---
title: C++基础语法
date: 2022-09-26 21:14:43
permalink: /pages/8498db/
categories:
  - C++
tags:
  - 类型 
---
## 基础类型

C++的基础数据类型有：

bool
char
int
float
double
wchar_t（宽字符型）：如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。
void

<!-- more -->
### 修饰符
除此外，还有类型修饰符：signed、unsigned、long 和 short 

可以被类型修饰符修饰的类型有：int char 和 double

其中：

int 可以被 signed、unsigned、long 和 short 修饰
char 可以被 signed、unsigned 修饰
double 可以被 long 修饰

如果只写：signed、unsigned、long 和 short
等价于： signed int、unsigned int、long int 和 short int

### 范围
不同的编译器，数据类型的大小不同
```c++
#include <iostream>
#include <limits>
using namespace std;
int main(int argc, char* argv[])
{
    cout << "bool:\t\t\t" << sizeof(bool) << "\t字节\t" << "范围:" << numeric_limits<bool>::min() << "~" << numeric_limits<bool>::max() << endl;
    cout << "char:\t\t\t" << sizeof(char) << "\t字节\t" << "范围:" << (int)numeric_limits<char>::min() << "~" << (int)numeric_limits<char>::max() << endl;
    cout << "signed char:\t\t" << sizeof(signed char) << "\t字节\t" << "范围:" << (int)numeric_limits<signed char>::min() << "~" << (int)numeric_limits<signed char>::max() << endl;
    cout << "unsigned char:\t\t" << sizeof(unsigned char) << "\t字节\t" << "范围:" << (int)numeric_limits<unsigned char>::min() << "~" << (int)numeric_limits<unsigned char>::max() << endl;
    cout << "int:\t\t\t" << sizeof(int) << "\t字节\t" << "范围:" << numeric_limits<int>::min() << "~" << numeric_limits<int>::max() << endl;
    cout << "signed int:\t\t" << sizeof(signed int) << "\t字节\t" << "范围:" << numeric_limits<signed int>::min() << "~" << numeric_limits<signed int>::max() << endl;
    cout << "signed:\t\t\t" << sizeof(signed) << "\t字节\t" << "范围:" << numeric_limits<signed>::min() << "~" << numeric_limits<signed>::max() << endl;
    cout << "unsigned int:\t\t" << sizeof(unsigned int) << "\t字节\t" << "范围:" << numeric_limits<unsigned int>::min() << "~" << numeric_limits<unsigned int>::max() << endl;
    cout << "unsigned:\t\t" << sizeof(unsigned) << "\t字节\t" << "范围:" << numeric_limits<unsigned>::min() << "~" << numeric_limits<unsigned>::max() << endl;
    cout << "short int:\t\t" << sizeof(short int) << "\t字节\t" << "范围:" << numeric_limits<short int>::min() << "~" << numeric_limits<short int>::max() << endl;
    cout << "short:\t\t\t" << sizeof(short) << "\t字节\t" << "范围:" << numeric_limits<short>::min() << "~" << numeric_limits<short>::max() << endl;
    cout << "signed short int:\t" << sizeof(signed short int) << "\t字节\t" << "范围:" << numeric_limits<signed short int>::min() << "~" << numeric_limits<signed short int>::max() << endl;
    cout << "unsigned short int:\t" << sizeof(unsigned short int) << "\t字节\t" << "范围:" << numeric_limits<unsigned short int>::min() << "~" << numeric_limits<unsigned short int>::max() << endl;
    cout << "long int:\t\t" << sizeof(long int) << "\t字节\t" << "范围:" << numeric_limits<long int>::min() << "~" << numeric_limits<long int>::max() << endl;
    cout << "long:\t\t\t" << sizeof(long) << "\t字节\t" << "范围:" << numeric_limits<long>::min() << "~" << numeric_limits<long>::max() << endl;
    cout << "signed long int:\t" << sizeof(signed long int) << "\t字节\t" << "范围:" << numeric_limits<signed long int>::min() << "~" << numeric_limits<unsigned long int>::max() << endl;
    cout << "unsigned long int:\t" << sizeof(unsigned long int) << "\t字节\t" << "范围:" << numeric_limits<unsigned long int>::min() << "~" << numeric_limits<unsigned long int>::max() << endl;
    cout << "float:\t\t\t" << sizeof(float) << "\t字节\t" << "范围:" << numeric_limits<float>::min() << "~" << numeric_limits<float>::max() << endl;
    cout << "double:\t\t\t" << sizeof(double) << "\t字节\t" << "范围:" << numeric_limits<double>::min() << "~" << numeric_limits<double>::max() << endl;
    cout << "long double:\t\t" << sizeof(long double) << "\t字节\t" << "范围:" << numeric_limits<long double>::min() << "~" << numeric_limits<long double>::max() << endl;
    cout << "wchar_t:\t\t" << sizeof(wchar_t) << "\t字节\t" << "范围:" << numeric_limits<wchar_t>::min() << "~" << numeric_limits<wchar_t>::max() << endl;
	return 0;
}
```

使用：Microsoft Visual C++ x86 
![x86](https://cdn.addai.cn/博客/202209272111396.png)

使用：Microsoft Visual C++ x64 
![x64 ](https://cdn.addai.cn/博客/202209272112878.png)

使用: Ubuntu GCC
![linux GCC](https://cdn.addai.cn/博客/202209272130447.png)

## 基础运算符

|优先权|	运算符|	说明|	结合性|
|:----:|:----:|:----|:----:|
|1	|()| 括号 |由左至右|
|2	|!、-、++、--	| 逻辑运算符NOT、算术运算符负号、递增、递减|	由右至左|
|3	|*、/、%| 算术运算符的乘法、除法、余数	|由左至右|
|4	|+、-	| 算术运算符加法、减法	|由左至右|
|5	|<<、>>、>>> | 位操作子左移、右移、无符号右移	|由左至右|
|6	| >、>=、<、<= | 关系运算符大于、大于等于、小于、小于等于	|由左至右|
|7	| ==、!=	|关系运算符等于、不等于	|由左至右|
|8	|&	| 位操作子AND |	由左至右|
|9	|^	| 位操作子XOR |	由左至右|
|10|	\| | 位操作子OR	|由左至右|
|11|	&&|	逻辑运算符AND	|由左至右|
|12|	\|\| | 逻辑运算符OR	|由左至右|
|13|	?:|	条件控制运算符	|由右至左|
|14|	=、op= | 指定运算符	|由右至左|
<!-- more -->
**op=** 这里指： += 、 -= 、 *= 、 \\= 、 %= 、 &= 、 ^= 、 |=

## 引用

**变量：** 


## 指针&指针初始化

指针（pointer）是 C++中的一个核心概念；是c++中常见的用来存在内存的一种工具。

理解指针有两个点：
1. 指针本身是一个大小等于int类型的变量。
2. 指针内存储着它指向的值的地址。

```c++
void test1()
{
	int a = 1;	// 声明并初始化 int 类型变量 a
	int* ptr;		// 声明int类型指针 ptr
	ptr = &a;		// 让指针ptr指向 变量a 的地址
	cout << ptr  << endl;	// 输出 指针指向的地址
	cout << *ptr << endl;	// 输出 指针指向的地址的值
	cout << &ptr << endl;	// 输出 指针的地址
}
```
结果：
> 0x7fffffffe46c
> 1
> 0x7fffffffe470

c++兼容c,所以这里我们可以使用 malloc,free 这两个关键字。
但在c++中又增加了两个新关键字 new , delete; 在c++程序中，我们以新的关键字为主。


### malloc & free

下面比较两者代码：

```c++
void test2()
{
	int* ptr;
	ptr = (int*)malloc(sizeof(int)); // 申请一个int大小的堆内存，并进行强制类型转换
	*ptr = 1; // 对ptr指向的位置赋值
	cout << *ptr << endl; // 输出
	free(ptr);
}
```
结果：
> 1

### new & delete

```c++

```

## 数组 
以int类型举例：

当声明一个int类型的变量a，是在内存中声明了一个int类型大小（4Byte，32Bit）的内存

当声明一个int类型的数组array，是在内存中声明了一组连续的int类型大小（4Byte，32Bit）的内存

### 基本操作（初始化和下标访问）

数据申明的基本形式：

```c++
类型  参数[数量]
```
访问数组时，使用数组下标，下标从0开始。

#### 初始化1
已知数组大小，和所有元素的值。
```c++
void demo()
{
  int array[2] = { 1, 2 };
  cout << array[0] << endl;
  cout << array[1] << endl;
}
```
结果为：
> 1
> 2

这种情况下也可以省略数组大小不写，结果等价。
```c++
void demo()
{
  int array[2] = { 1, 2 };
  cout << array[0] << endl;
  cout << array[1] << endl;
}
```


#### 初始化2
已知数组大小，和有元素的值，且值相同。
```c++
void demo()
{
  int array[2] = { 1 };
  cout << array[0] << endl;
  cout << array[1] << endl;
}
```
结果：
> 1
> 1


#### 初始化3
已知数组大小，值暂不清晰。
```c++
void demo()
{
  int array[2];
  array[0] = 0;
  array[1] = 1;
  cout << array[0] << endl;
  cout << array[1] << endl;
}
```

#### 未初始化
为初始化的数据为当前内存位置存的随机值。

存在两种为初始的情况：
1、数组刚声明，未赋值。
2、数组访问下标越界，虽然还是可以访问，但是值为随机值。

```c++
void demo()
{
  int array1[2];
  cout << array1[0] << endl;
  cout << array1[1] << endl;

  int array2[2] = {0};
  cout << array2[0] << endl;
  cout << array2[1] << endl;
  cout << array2[2] << endl;
}
```

结果：
```
-135408993
32767

0
0
-135408993
```


### 栈数组和堆数组（动态分配）

**栈数组：内容存储在栈中的数组。** 
上面的demo其实就是栈数组。
这样的数组有一个弊端，需要在写代码时，就定义好数组大小。

如果我们需要在运行时决定数组大小，就需要堆数组；对数组大小进行动态分配。

**堆数组：内容存储在堆中的数组。**
C++如果想把内存分配到堆上，


## 常用语句

C++ 常用语句有：

1、赋值语句

2、条件语句

3、循环语句

<!-- more -->

### 赋值语句

一般形式为：
``` c++
value = exp;
```
value 为变量，exp为可求值的表达式。


例：

``` c++

int a = 0;

a = 1 + 1;

```
第一句 初始一个int类型变量a，并赋值为0；
第二句 求1 + 1 的值，并赋给 a；



### 条件语句

#### if else

一般形式为：
```c++
if (exp)
{
  // 程序代码
}
else
{
  // 程序代码
}
```
exp 为求值为bool 类型的表达式。
程序代码中可以继续嵌套 if else 已完成复杂逻辑判断。


如果只有为true的条件需要特殊的程序代码：
```c++
if (exp)
{
  // 程序代码
}
```

如果有多个并列的不同条件：
```c++
if (exp1)
{
  // 程序代码
}
else if (exp2)
{
  // 程序代码
}
else
{
  // 程序代码
}
```


#### switch

如果我们存在大量使用多个并列的不同条件需要判断，也可以使用switch。

一般形式：
```c++
switch (exp) {
  case condition_exp1:
    // 程序代码1
    break;
  case condition_exp2:
    // 程序代码2
    break;
  case condition_exp3:
    // 程序代码3
    break;
  default:
    // 程序代码4
    break;
}
```
exp、condition_exp1、condition_exp2 ... 可 计算为 int类型，或者为 枚举类型。

逻辑为：exp求出的值，等于 哪一个 condition_exp；代码就跳转到那里执行，到break为止。

如果没有，就执行 default。

例1：
```c++
int a = 2;
switch (a)
{
case 1:
	cout << "case 1" << endl;
	break;
case 1 + 1 :
	cout << "case 2" << endl;
	break;
default:
	cout << "case default" << endl;
	break;
}
```

运行结果：
```
case 2
```

例2：
```c++
switch (1 + 1)
{
case 1+0:
	cout << "case 1" << endl;
case 2:
	cout << "case 2" << endl;
default:
	cout << "case default" << endl;
	break;
}
```

运行结果：
```
case 2
case default
```

### 循环语句

#### while

#### do... while

#### for
