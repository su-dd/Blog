(window.webpackJsonp=window.webpackJsonp||[]).push([[156],{499:function(v,t,_){"use strict";_.r(t);var r=_(1),s=Object(r.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"面向对象的核心概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#面向对象的核心概念"}},[v._v("#")]),v._v(" 面向对象的核心概念")]),v._v(" "),t("p",[v._v("抽象、对象，类、封装、继承、多态、接口、抽象类；这些组成了面向对象的基础，如果谈面向对象的程序设计；就要先了解它们。")]),v._v(" "),t("h2",{attrs:{id:"抽象、对象、类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象、对象、类"}},[v._v("#")]),v._v(" 抽象、对象、类")]),v._v(" "),t("p",[t("strong",[v._v("抽象")]),v._v(" 是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程，是编程的基础。编程的本质就是对世界的近似描述，抽象的方向维度取决于实现的目的。")]),v._v(" "),t("p",[t("strong",[v._v("对象")]),v._v(" 抽取一个特定事物的属性和行为的结果，就是一个对象。它携带者一个特定事物的特征抽象。")]),v._v(" "),t("p",[t("strong",[v._v("类")]),v._v(" 抽取一类事物的属性和行为的结果，就是一个类。它携带者这类事物的特征，对类特化（给具体值）就是形成一个对象。")]),v._v(" "),t("h2",{attrs:{id:"封装、继承、多态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#封装、继承、多态"}},[v._v("#")]),v._v(" 封装、继承、多态")]),v._v(" "),t("p",[t("strong",[v._v("封装")]),v._v(" 将抽象出的数据、行为进行有机结合；隐藏细节，指对外提供特定功能的接口；封装可以分级向外提供接口：public、protected、private。")]),v._v(" "),t("p",[t("strong",[v._v("继承")]),v._v(" 描述父子类的关系，子类继承于父类；子类就是父类的一种特例，子类拥有父类的所有信息。继承的方式一般有：public、protected、private。")]),v._v(" "),t("p",[t("strong",[v._v("多态")]),v._v("指为不同数据类型的实体提供统一接口，并表现出不同的行为。")]),v._v(" "),t("p",[v._v("可以分为：")]),v._v(" "),t("p",[v._v("变量多态：基础类型变量可以被赋值基础类型对象，也可以被赋值派生类型对象。")]),v._v(" "),t("p",[v._v("函数多态：给相同函数调用（函数名和实参数表），传递同一个对象，可以有不同的行为。行为有接受对象类型决定。")]),v._v(" "),t("p",[v._v("也可以分为：")]),v._v(" "),t("p",[v._v("动态多态：在运行期决定的多态，主要为通过虚继承的方式，实现父类，不同子类的实现不同；即override。")]),v._v(" "),t("p",[v._v("静态多态：在编译期决定的多态")]),v._v(" "),t("blockquote",[t("p",[v._v("静态多态分为：非参数化多态和参数化多态")]),v._v(" "),t("p",[t("strong",[v._v("非参数化多态")]),v._v("：函数重载，运算符重载；即overload。")]),v._v(" "),t("p",[t("strong",[v._v("参数化多态")]),v._v("：把类型做出参数的多态，泛型编程。")])]),v._v(" "),t("h2",{attrs:{id:"抽象类和接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象类和接口"}},[v._v("#")]),v._v(" 抽象类和接口")]),v._v(" "),t("p",[v._v("抽象类是用来捕捉子类的通用特性的，不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板；")]),v._v(" "),t("p",[v._v("接口则是抽象方法的集合，只是一种形式，接口自身不能做任何事情。")])])}),[],!1,null,null,null);t.default=s.exports}}]);