(window.webpackJsonp=window.webpackJsonp||[]).push([[129],{472:function(v,_,t){"use strict";t.r(_);var r=t(1),e=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("在1994年，由Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 "),_("strong",[v._v("Design Patterns - Elements of Reusable Object-Oriented Software")]),v._v("的书，这里就是设计模式的起源。")]),v._v(" "),_("p",[v._v("四位作者合成GOF（四人帮，Gang of Four），他们提出的设计模式主要基于面向对象设计原则。")]),v._v(" "),_("blockquote",[_("p",[v._v("对接口编程而不是对实现编程。")]),v._v(" "),_("p",[v._v("优先使用对象组合而不是继承。")])]),v._v(" "),_("p",[v._v("总结来说设计模式是前人总结的经验，用于解决开发过程中常见问题的解决公式。")]),v._v(" "),_("h2",{attrs:{id:"_7大基本原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7大基本原则"}},[v._v("#")]),v._v(" 7大基本原则")]),v._v(" "),_("ol",[_("li",[_("p",[_("strong",[v._v("开闭原则（OCP，Open Close Principle）")])]),v._v(" "),_("blockquote",[_("p",[v._v("对扩展开放，对修改关闭。")]),v._v(" "),_("p",[v._v("在程序需要进行拓展的时候，不能去修改原有的代码，而是实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用"),_("strong",[v._v("接口和抽象类")]),v._v("。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("单一职责原则（SRP，Single Responsibility Principle）")])]),v._v(" "),_("blockquote",[_("p",[v._v("就一个类而言,应该仅有一个引起它变化的原因；")]),v._v(" "),_("p",[v._v("控制类的粒度、将对象解耦、提高内聚性；注重职责，主要约束类（实现和细节）；")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("里氏替换原则（LSP，Liskov Substitution Principle）")])]),v._v(" "),_("blockquote",[_("p",[v._v("任何基类可以出现的地方，子类一定可以出现。")]),v._v(" "),_("p",[v._v("阐述继承复用的原则；开闭原则实现方式；子类继承父类时，尽量不要重写父类方法；（不要破坏继承关系）")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("依赖倒置原则（DIP，Dependence Inversion Principle）")])]),v._v(" "),_("blockquote",[_("p",[v._v("接口不应依赖于实现，实现应该依赖于接口。")]),v._v(" "),_("p",[v._v("原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("接口隔离原则（ISP，Interface Segregation Principle）")])]),v._v(" "),_("blockquote",[_("p",[v._v("从子类实现角度，一个子类实现只需要实现那些他需要的接口。")]),v._v(" "),_("p",[v._v("所以我们需要对接口进行分组，这样可以降低类之间的耦合度。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("迪米特法则（LoD， Law of Demeter）")])]),v._v(" "),_("blockquote",[_("p",[v._v("一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。")])])]),v._v(" "),_("li",[_("p",[_("strong",[v._v("合成复用原则（CRP，Composite Reuse Principle）")])]),v._v(" "),_("blockquote",[_("p",[v._v("尽量使用合成/聚合的方式，而不是使用继承。")])])])]),v._v(" "),_("h2",{attrs:{id:"设计模型分类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模型分类"}},[v._v("#")]),v._v(" 设计模型分类")]),v._v(" "),_("p",[_("strong",[v._v("创建型")]),v._v("：描述对象如何创建，是为了将对象的创建与使用分离。")]),v._v(" "),_("p",[v._v("包括6种：单例、原型、简单工厂、工厂方法、抽象工厂、建造者。")]),v._v(" "),_("p",[_("strong",[v._v("结构型")]),v._v("：描述类或对象如何组织成更大结构")]),v._v(" "),_("p",[v._v("包括7种：代理、适配器、桥接、装饰、外观、享元、组合。")]),v._v(" "),_("p",[_("strong",[v._v("行为型")]),v._v("：描述类或对象之间如何协作完成任务")]),v._v(" "),_("p",[v._v("包括11种：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。")]),v._v(" "),_("p",[v._v("共24中设计模式，也由把简单工厂摘出来，为23中设计模式。")]),v._v(" "),_("h2",{attrs:{id:"图解设计模式关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#图解设计模式关系"}},[v._v("#")]),v._v(" 图解设计模式关系")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%B3%E7%B3%BB%E5%9B%BE.webp",alt:"设计模式关系图"}})]),v._v(" "),_("h2",{attrs:{id:"语言选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#语言选择"}},[v._v("#")]),v._v(" 语言选择")]),v._v(" "),_("p",[v._v("作者为C++开发，所以暂定语言为C++。")]),v._v(" "),_("p",[v._v("在进入正题之前，需要先了解两个概念：接口和抽象类。")]),v._v(" "),_("p",[_("strong",[v._v("定义:")])]),v._v(" "),_("p",[v._v("抽象类：用来捕捉子类的通用特性的，不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板；")]),v._v(" "),_("p",[v._v("接口：抽象方法的集合，只是一种形式，接口自身不能做任何事情。")]),v._v(" "),_("p",[_("strong",[v._v("实现：")])]),v._v(" "),_("p",[v._v("C++语言中没有为这两个概念提供直接的关键字。但从实现的角度我们却更容易的知道他们的区别。")]),v._v(" "),_("p",[v._v("抽象类：存在纯虚函数的类。")]),v._v(" "),_("p",[v._v("接口：只存在纯虚函数的类。")]),v._v(" "),_("p",[v._v("C++的override关键字为"),_("strong",[v._v("virtual")]),v._v("；一个函数使用了"),_("strong",[v._v("virtual")]),v._v("代表可以被子类重写，但同时它也应该被实现；这样的函数称为"),_("strong",[v._v("虚函数")]),v._v("。")]),v._v(" "),_("p",[v._v("在"),_("strong",[v._v("虚函数")]),v._v("的末尾使用 "),_("strong",[v._v("‘=0’")]),v._v("，这个函数就变成的"),_("strong",[v._v("纯虚函数")]),v._v("，这时它就不能被实现，只能被子类重写。")])])}),[],!1,null,null,null);_.default=e.exports}}]);