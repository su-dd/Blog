(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],c=e[2],m=0,p=[];m<s.length;m++)o=s[m],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&p.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(d&&d(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"cff562a5",3:"531acd57",4:"917e5a2f",5:"323082ce",6:"fba4ebfe",7:"45101e24",8:"7397f135",9:"20fcb649",10:"2cd4b68b",11:"733d4ab2",12:"f5a70e82",13:"4d8c1284",14:"518510ed",15:"a266a355",16:"69ecfe5a",17:"a6a5e59d",18:"8c9e44cc",19:"2861a5bd",20:"dabdcc5e",21:"b8317130",22:"46e9b7da",23:"a4025da6",24:"c2fbd549",25:"30472c64",26:"442945fd",27:"4a086f9b",28:"edf89f24",29:"151226bf",30:"6c067212",31:"bb1540d1",32:"09f5cc25",33:"5261d5ea",34:"51c795e3",35:"12f7f988",36:"8327db33",37:"112f6c0b",38:"20191ba3",39:"e45a5efd",40:"238ee8ee",41:"be9bf62e",42:"3a4f56b4",43:"92f23c09",44:"e5053632",45:"52ab3b68",46:"c2589849",47:"102e88ad",48:"bf524334",49:"0f9ffe85",50:"43cb2571",51:"976889fe",52:"118f8b22",53:"06a3f5cd",54:"493670ce",55:"0a6a171b",56:"36041806",57:"3abb2bd6",58:"9c30f62c",59:"f5e92ffb",60:"14f8e778",61:"f555540c",62:"e596fc73",63:"0c349e67",64:"dd07a2e6",65:"315a6949",66:"1c5ded71",67:"494d92bb",68:"aef647d2",69:"45bd65a7",70:"06c91bba",71:"b8aece77",72:"7cf0f3d3",73:"f49fdd95",74:"5a806d23",75:"91f2b41a",76:"1db73a7f",77:"39aa2f0f",78:"dcd5cc8e",79:"df14cf99",80:"2b3b8b9f",81:"80345e8a",82:"ed95ca0d",83:"335e4184",84:"b219dc4b",85:"9d032788",86:"55f210e6",87:"a0db9e8f",88:"b3537c8a",89:"33570411",90:"941c4684",91:"be607e5a",92:"f0d5e953",93:"b8937166",94:"b252b8a4",95:"8af820f5",96:"9dcd0ab0",97:"9699c160",98:"e1d14407",99:"eb86b749",100:"60b800ef",101:"66701792",102:"c3b3591c",103:"92e4ddd8",104:"691282f2",105:"c5599995",106:"af3edb3d",107:"c25e9863",108:"1e3aeebe",109:"1b22a6eb",110:"d40a1bca",111:"c3ea7452",112:"d96e8508",113:"658cb11a",114:"381756eb",115:"41cc8435",116:"05139cac",117:"963900c8",118:"37965514",119:"823c0b39",120:"d3655be7",121:"7e3815cd",122:"dd04ca2c",123:"5eec9a72",124:"92a29444",125:"63e42c6a",126:"55a1d374",127:"1beb1614",128:"99051007",129:"beb99217",130:"329d962a",131:"59b74420",132:"fce7d641",133:"21a55328",134:"c43d0376",135:"ea174984",136:"be318aaa",137:"d84d5582",138:"4b34b72b",139:"df5ea758",140:"0d57d5ab",141:"4a719260",142:"6753af99",143:"ba256a59",144:"a7ebd62e",145:"a27410d5",146:"ca494a45",147:"6fdefa7e",148:"71fb2e90",149:"a8a7065d",150:"90099809",151:"71bb788d",152:"6ec0f3e3",153:"3790a3de",154:"152c7b24",155:"bfa10f50",156:"d3e6f6a6",157:"93423f96",158:"193f485f",159:"b1fe6678",160:"971bd865",161:"15f6e202",162:"fe071dc9",163:"da0876dc",164:"c6a447f0",165:"fc7a3304",166:"203d55bb"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;i.push([108,0]),t()}([function(n,e,t){var a=t(57),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var m=c.beforeCreate;c.beforeCreate=m?[].concat(m,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||this||Function("return this")()},function(n,e,t){var a=t(29),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var a=t(4);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(3),r=t(33),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(71),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){var a=t(0),r=t(57),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(167),r=t(170);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return m})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return u})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(17);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function m(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function p(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function u(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:m(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function g(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return h(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?h(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return u(t,e,a);if(Array.isArray(e))return Object.assign(u(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(u(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function h(n){const e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function f(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(5),r=t(66),i=t(102),o=t(28),s=t(56),l=TypeError,c=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=d(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(16),r=t(152),i=t(153),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(5),r=t(13),i=t(36);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(8).Symbol;n.exports=a},function(n,e,t){"use strict";var a=t(18),r=t(33),i=t(34),o=t(132),s=t(134);a({target:"Array",proto:!0,arity:1,forced:t(4)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=i(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var a=t(2),r=t(53).f,i=t(15),o=t(116),s=t(38),l=t(67),c=t(128);n.exports=function(n,e){var t,d,m,p,u,g=n.target,h=n.global,f=n.stat;if(t=h?a:f?a[g]||s(g,{}):(a[g]||{}).prototype)for(d in e){if(p=e[d],m=n.dontCallGetSet?(u=r(t,d))&&u.value:t[d],!c(h?d:g+(f?".":"#")+d,n.forced)&&void 0!==m){if(typeof p==typeof m)continue;l(p,m)}(n.sham||m&&m.sham)&&i(p,"sham",!0),o(t,d,p,n)}}},function(n,e,t){var a=t(3),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(2),r=t(63),i=t(7),o=t(65),s=t(61),l=t(60),c=a.Symbol,d=r("wks"),m=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(d,n)||(d[n]=s&&i(c,n)?c[n]:m("Symbol."+n)),d[n]}},function(n,e,t){var a=t(157),r=t(158),i=t(159),o=t(160),s=t(161);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(73);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(179);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(46);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),d=a.speed,m=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,d,m)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),d=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&p(r),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:m(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=m(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function d(n,e){var t,a=m(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function m(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/blogwriter/blogwriter","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(4);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(49),r=t(54);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(2),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0),r=t(114),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e,t){var a=t(54),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(126);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(29),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(2),r=t(38),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(2),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(151),r=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(8),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(171),r=t(178),i=t(180),o=t(181),s=t(182);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(6),r=t(46),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.r(e);var a={name:"LastReadingPopup",data:()=>({lastReading:null,show:!1}),computed:{popupConfig(){const n={"/":{message:"检测到您上一次阅读的位置，是否移至该位置？",sureButtonText:"确定",cancelButtonText:"取消"},"/zh/":{message:"检测到您上一次阅读的位置，是否移至该位置？",sureButtonText:"前往",cancelButtonText:"取消"}};return n[`/${this.$lang.split("-")[0]}/`]||n[this.$localePath]||n},message(){const n=this.popupConfig;return n&&n.message||n["/"].message},sureButtonText(){const n=this.popupConfig;return n&&n.sureButtonText||n["/"].sureButtonText},cancelButtonText(){const n=this.popupConfig;return n&&n.cancelButtonText||n["/"].cancelButtonText}},mounted(){window.ActiveXObject||"ActiveXObject"in window?setTimeout(()=>{window.addEventListener("load",this.init())},1e3):setTimeout(()=>{window.addEventListener("load",this.init)},1e3)},methods:{init(){this.lastReading=JSON.parse(localStorage.getItem("lastReading")),this.lastReading&&(this.$route.path===this.lastReading.path?this.goto():(this.show=!0,setTimeout(this.clean,1e4)))},goto(){this.$route.path!==this.lastReading.path?this.$router.replace(this.lastReading.path).then(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop,this.clean()}):this.$nextTick(()=>{document.documentElement.scrollTop=this.lastReading.scrollTop})},dontgoto(){this.clean()},clean(){this.show=!1,localStorage.removeItem("lastReading")}}},r=(t(245),t(1)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("transition",{attrs:{name:"sw-update-popup"}},[n.show?e("div",{staticClass:"sw-update-popup"},[n._v("\n    "+n._s(n.message)+"\n\n    "),e("br"),n._v(" "),e("button",{on:{click:n.goto}},[n._v("\n      "+n._s(n.sureButtonText)+"\n    ")]),n._v(" "),e("button",{on:{click:n.dontgoto}},[n._v("\n      "+n._s(n.cancelButtonText)+"\n    ")])]):n._e()])}),[],!1,null,"37dae447",null);e.default=i.exports},function(n,e,t){var a=t(3),r=t(4),i=t(19),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,m=Math.max,p=Math.min,u=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function h(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(k,e),d?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=i}function k(){var n=u();if(x(n))return w(n);s=setTimeout(k,function(n){var t=e-(n-l);return f?p(t,i-(n-c)):t}(n))}function w(n){return s=void 0,v&&a?b(n):(a=r=void 0,o)}function E(){var n=u(),t=x(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(k,e),b(l)}return void 0===s&&(s=setTimeout(k,e)),o}return e=h(e)||0,g(t)&&(d=!!t.leading,i=(f="maxWait"in t)?m(h(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),E.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},E.flush=function(){return void 0===s?o:w(u())},E}},function(n,e,t){var a=t(5),r=t(35),i=t(110),o=t(36),s=t(30),l=t(56),c=t(7),d=t(66),m=Object.getOwnPropertyDescriptor;e.f=a?m:function(n,e){if(n=s(n),e=l(e),d)try{return m(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){var a=t(55),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(111),r=t(58);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(31),r=t(0),i=t(59),o=t(60),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){var a=t(3);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(61);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(62),r=t(4),i=t(2).String;n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!i(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(2),o=t(112),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(r=(a=d.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(64),r=t(37);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.30.2",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.30.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(3),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(5),r=t(4),i=t(101);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(7),r=t(121),i=t(53),o=t(13);n.exports=function(n,e,t){for(var s=r(e),l=o.f,c=i.f,d=0;d<s.length;d++){var m=s[d];a(n,m)||t&&a(t,m)||l(n,m,c(e,m))}}},function(n,e,t){var a=t(125);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(137),r=t(28),i=t(138);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(21),r=t(162),i=t(163),o=t(164),s=t(165),l=t(166);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(14),r=t(41);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(183),r=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(78),r=t(186),i=t(79);n.exports=function(n,e,t,o,s,l){var c=1&t,d=n.length,m=e.length;if(d!=m&&!(c&&m>d))return!1;var p=l.get(n),u=l.get(e);if(p&&u)return p==e&&u==n;var g=-1,h=!0,f=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++g<d;){var v=n[g],b=e[g];if(o)var y=c?o(b,v,g,e,n,l):o(v,b,g,n,e,l);if(void 0!==y){if(y)continue;h=!1;break}if(f){if(!r(e,(function(n,e){if(!i(f,e)&&(v===n||s(v,n,t,o,l)))return f.push(e)}))){h=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){h=!1;break}}return l.delete(n),l.delete(e),h}},function(n,e,t){var a=t(42),r=t(184),i=t(185);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(196),r=t(202),i=t(84);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(8),r=t(198),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(51)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(199),r=t(200),i=t(201),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(74),r=t(44);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(8),"Set");n.exports=a},function(n,e,t){var a=t(41);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(89),r=t(25);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(6),r=t(45),i=t(213),o=t(216);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(149),r=t(154),i=t(225),o=t(233),s=t(242),l=t(107),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var a=t(252),r=t(253),i=t(254),o=!1,s=t(255).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),d=/^\uFEFF/;function m(n,t){var r,i,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),a.existsSync(i)&&(r=i)),r||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),a.existsSync(i)}))&&(r=i),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function p(n,t){var a,r=n.filename,i=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(a=e.cache.get(r))return a;i||(t=g(r).toString().replace(d,""))}else if(!i){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=g(r).toString().replace(d,"")}return a=e.compile(t,n),n.cache&&e.cache.set(r,a),a}function u(n,t,a){var r;if(!a){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,a){try{e(r=p(n)(t))}catch(n){a(n)}}));throw new Error("Please provide a callback function")}try{r=p(n)(t)}catch(n){return a(n)}a(null,r)}function g(n){return e.fileLoader(n)}function h(n,e,t,a,r){var i=e.split("\n"),o=Math.max(a-3,0),s=Math.min(i.length,a+3),l=r(t),c=i.slice(o,s).map((function(n,e){var t=e+o+1;return(t==a?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+a+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var a={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],a.client=t.client||!1,a.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,a.compileDebug=!1!==t.compileDebug,a.debug=!!t.debug,a.filename=t.filename,a.openDelimiter=t.openDelimiter||e.openDelimiter||"<",a.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",a.delimiter=t.delimiter||e.delimiter||"%",a.strict=t.strict||!1,a.context=t.context,a.cache=t.cache||!1,a.rmWhitespace=t.rmWhitespace,a.root=t.root,a.outputFunctionName=t.outputFunctionName,a.localsName=t.localsName||e.localsName||"locals",a.views=t.views,a.async=t.async,a.destructuredLocals=t.destructuredLocals,a.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,a.strict?a._with=!1:a._with=void 0===t._with||t._with,this.opts=a,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=a.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var a=r.dirname,i=r.extname,o=(0,r.resolve)(t?e:a(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var a=e||{},r=t||{};return 2==arguments.length&&i.shallowCopyFromList(r,a,l),p(r,n)(a)},e.renderFile=function(){var n,e,t,a=Array.prototype.slice.call(arguments),r=a.shift(),o={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=a.pop()),a.length?(e=a.shift(),a.length?i.shallowCopy(o,a.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,c)),o.filename=r):e={},u(o,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),a=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,a),new RegExp(n)},compile:function(){var n,e,t,a=this.opts,o="",s="",l=a.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',a.outputFunctionName&&(o+="  var "+a.outputFunctionName+" = __append;\n"),a.destructuredLocals&&a.destructuredLocals.length){for(var c="  var __locals = ("+a.localsName+" || {}),\n",d=0;d<a.destructuredLocals.length;d++){var u=a.destructuredLocals[d];d>0&&(c+=",\n  "),c+=u+" = __locals."+u}o+=c+";\n"}!1!==a._with&&(o+="  with ("+a.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=a.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(a.filename?JSON.stringify(a.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,a.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,a.compileDebug&&(n="rethrow = rethrow || "+h.toString()+";\n"+n)),a.strict&&(n='"use strict";\n'+n),a.debug&&console.log(n),a.compileDebug&&a.filename&&(n=n+"\n//# sourceURL="+a.filename+"\n");try{if(a.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(a.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(a.filename&&(n.message+=" in "+a.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",a.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var g=a.client?e:function(n){return e.apply(a.context,[n||{},l,function(e,t){var r=i.shallowCopy({},n);return t&&(r=i.shallowCopy(r,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=m(n,t),p(t)}(e,a)(r)},h])};if(g.dependencies=this.dependencies,a.filename&&"function"==typeof Object.defineProperty){var f=a.filename,v=r.basename(f,r.extname(f));try{Object.defineProperty(g,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return g},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,a=this.parseTemplateText(),r=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;a&&a.length&&a.forEach((function(l,c){var p,u,h,f,b,y;if(0===l.indexOf(o+r)&&0!==l.indexOf(o+r+r)&&(u=a[c+2])!=r+s&&u!="-"+r+s&&u!="_"+r+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(h=l.match(/^\s*include\s+(\S+)/))&&(p=a[c-1])&&(p==o+r||p==o+r+"-"||p==o+r+"_"))return f=i.shallowCopy({},t.opts),b=function(n,e){var t,a,r=i.shallowCopy({},e);a=g(t=m(n,r)).toString().replace(d,""),r.filename=t;var o=new v(a,r);return o.generateSource(),{source:o.source,filename:t,template:a}}(h[1],f),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(h[1],f.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,a=t.exec(e),r=[];a;)0!==(n=a.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(a[0]),e=e.slice(a[0].length),a=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,a=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case a+t:case a+t+"_":this.mode=v.modes.EVAL;break;case a+t+"=":this.mode=v.modes.ESCAPED;break;case a+t+"-":this.mode=v.modes.RAW;break;case a+t+"#":this.mode=v.modes.COMMENT;break;case a+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(a+t+t,a+t)+'")\n';break;case t+t+r:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(246),t(1)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(247),t(1)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(2),r=t(9),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(5),r=t(4);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(3),r=t(4),i=t(0),o=t(7),s=t(5),l=t(117).CONFIGURABLE,c=t(118),d=t(119),m=d.enforce,p=d.get,u=String,g=Object.defineProperty,h=a("".slice),f=a("".replace),v=a([].join),b=s&&!r((function(){return 8!==g((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===h(u(e),0,7)&&(e="["+f(u(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?g(n,"name",{value:e,configurable:!0}):n.name=e),b&&t&&o(t,"arity")&&n.length!==t.arity&&g(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&g(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=m(n);return o(a,"source")||(a.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return i(this)&&p(this).source||c(this)}),"toString")},function(n,e,t){var a=t(63),r=t(65),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(3),r=t(7),i=t(30),o=t(123).indexOf,s=t(50),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,d=[];for(t in a)!r(s,t)&&r(a,t)&&l(d,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(d,t)||l(d,t));return d}},function(n,e,t){var a=t(18),r=t(2),i=t(135),o=t(136),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(258)},function(n,e,t){"use strict";var a=t(18),r=t(129).left,i=t(130),o=t(62);a({target:"Array",proto:!0,forced:!t(131)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(35),r=t(9),i=t(58),o=t(113),s=t(115),l=t(20),c=TypeError,d=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,d);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var a=t(32),r=t(55);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(35),r=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(13),i=t(103),o=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(5),r=t(7),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(3),r=t(0),i=t(37),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var a,r,i,o=t(120),s=t(2),l=t(9),c=t(15),d=t(7),m=t(37),p=t(104),u=t(50),g=s.TypeError,h=s.WeakMap;if(o||m.state){var f=m.state||(m.state=new h);f.get=f.get,f.has=f.has,f.set=f.set,a=function(n,e){if(f.has(n))throw g("Object already initialized");return e.facade=n,f.set(n,e),e},r=function(n){return f.get(n)||{}},i=function(n){return f.has(n)}}else{var v=p("state");u[v]=!0,a=function(n,e){if(d(n,v))throw g("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return d(n,v)?n[v]:{}},i=function(n){return d(n,v)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(2),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(31),r=t(3),i=t(122),o=t(127),s=t(28),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(105),r=t(100).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(30),r=t(124),i=t(34),o=function(n){return function(e,t,o){var s,l=a(e),c=i(l),d=r(o,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(68),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(68),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(4),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==d||t!=c&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(32),r=t(33),i=t(49),o=t(34),s=TypeError,l=function(n){return function(e,t,l,c){a(t);var d=r(e),m=i(d),p=o(d),u=n?p-1:0,g=n?-1:1;if(l<2)for(;;){if(u in m){c=m[u],u+=g;break}if(u+=g,n?u<0:p<=u)throw s("Reduce of empty array with no initial value")}for(;n?u>=0:p>u;u+=g)u in m&&(c=t(c,m[u],u,d));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(4);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(19);n.exports="undefined"!=typeof process&&"process"==a(process)},function(n,e,t){"use strict";var a=t(5),r=t(133),i=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(19);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(29),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(31),r=t(7),i=t(15),o=t(59),s=t(69),l=t(67),c=t(139),d=t(140),m=t(141),p=t(145),u=t(146),g=t(5),h=t(64);n.exports=function(n,e,t,f){var v=f?2:1,b=n.split("."),y=b[b.length-1],x=a.apply(null,b);if(x){var k=x.prototype;if(!h&&r(k,"cause")&&delete k.cause,!t)return x;var w=a("Error"),E=e((function(n,e){var t=m(f?e:n,void 0),a=f?new x(n):new x;return void 0!==t&&i(a,"message",t),u(a,E,a.stack,2),this&&o(k,this)&&d(a,this,E),arguments.length>v&&p(a,arguments[v]),a}));if(E.prototype=k,"Error"!==y?s?s(E,w):l(E,w,{name:!0}):g&&"stackTraceLimit"in x&&(c(E,x,"stackTraceLimit"),c(E,x,"prepareStackTrace")),l(E,x),!h)try{k.name!==y&&i(k,"name",y),k.constructor=E}catch(n){}return E}}},function(n,e,t){var a=t(3),r=t(32);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(13).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),i=t(69);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var a=t(142);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(143),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(144),r=t(0),i=t(19),o=t(20)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(20)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(15);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(15),r=t(147),i=t(148),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){var a=t(3),r=Error,i=a("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var a=t(4),r=t(36);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(70),r=t(150);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=r),s||(s=[]);++l<c;){var d=e[l];t>0&&i(d)?t>1?n(d,t-1,i,o,s):a(s,d):o||(s[s.length]=d)}return s}},function(n,e,t){var a=t(16),r=t(39),i=t(6),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(16),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(155),r=t(211),i=t(47),o=t(6),s=t(222);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(156),r=t(210),i=t(87);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(72),r=t(76);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var d=(c=t[o])[0],m=n[d],p=c[1];if(l&&c[2]){if(void 0===m&&!(d in n))return!1}else{var u=new a;if(i)var g=i(m,p,d,n,e,u);if(!(void 0===g?r(p,m,3,i,u):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(22),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(22);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(22);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(22);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(21);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(21),r=t(40),i=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(74),r=t(168),i=t(41),o=t(75),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,m=c.hasOwnProperty,p=RegExp("^"+d.call(m).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?p:s).test(o(n))}},function(n,e,t){var a,r=t(169),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(8)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(172),r=t(21),i=t(40);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(173),r=t(174),i=t(175),o=t(176),s=t(177);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(23);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(23),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(23),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(23);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(24);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(24);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(24);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(24);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(72),r=t(77),i=t(187),o=t(190),s=t(206),l=t(6),c=t(81),d=t(83),m="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,u,g,h){var f=l(n),v=l(e),b=f?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(b="[object Arguments]"==b?m:b)==m,k=(y="[object Arguments]"==y?m:y)==m,w=b==y;if(w&&c(n)){if(!c(e))return!1;f=!0,x=!1}if(w&&!x)return h||(h=new a),f||d(n)?r(n,e,t,u,g,h):i(n,e,b,t,u,g,h);if(!(1&t)){var E=x&&p.call(n,"__wrapped__"),_=k&&p.call(e,"__wrapped__");if(E||_){var C=E?n.value():n,T=_?e.value():e;return h||(h=new a),g(C,T,t,u,h)}}return!!w&&(h||(h=new a),o(n,e,t,u,g,h))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(16),r=t(188),i=t(73),o=t(77),s=t(189),l=t(43),c=a?a.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,m,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!m(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var u=s;case"[object Set]":var g=1&a;if(u||(u=l),n.size!=e.size&&!g)return!1;var h=p.get(n);if(h)return h==e;a|=2,p.set(n,e);var f=o(u(n),u(e),a,c,m,p);return p.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var a=t(8).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(191),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=a(n),d=c.length;if(d!=a(e).length&&!l)return!1;for(var m=d;m--;){var p=c[m];if(!(l?p in e:r.call(e,p)))return!1}var u=s.get(n),g=s.get(e);if(u&&g)return u==e&&g==n;var h=!0;s.set(n,e),s.set(e,n);for(var f=l;++m<d;){var v=n[p=c[m]],b=e[p];if(i)var y=l?i(b,v,p,e,n,s):i(v,b,p,n,e,s);if(!(void 0===y?v===b||o(v,b,t,i,s):y)){h=!1;break}f||(f="constructor"==p)}if(h&&!f){var x=n.constructor,k=e.constructor;x==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof k&&k instanceof k||(h=!1)}return s.delete(n),s.delete(e),h}},function(n,e,t){var a=t(192),r=t(193),i=t(80);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(70),r=t(6);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(194),r=t(195),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(197),r=t(39),i=t(6),o=t(81),s=t(82),l=t(83),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&r(n),m=!t&&!d&&o(n),p=!t&&!d&&!m&&l(n),u=t||d||m||p,g=u?a(n.length,String):[],h=g.length;for(var f in n)!e&&!c.call(n,f)||u&&("length"==f||m&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,h))||g.push(f);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(14),r=t(44),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(71),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(51)(n))},function(n,e,t){var a=t(203),r=t(204),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(205)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(207),r=t(40),i=t(208),o=t(85),s=t(209),l=t(14),c=t(75),d=c(a),m=c(r),p=c(i),u=c(o),g=c(s),h=l;(a&&"[object DataView]"!=h(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=h(new r)||i&&"[object Promise]"!=h(i.resolve())||o&&"[object Set]"!=h(new o)||s&&"[object WeakMap]"!=h(new s))&&(h=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case d:return"[object DataView]";case m:return"[object Map]";case p:return"[object Promise]";case u:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=h},function(n,e,t){var a=t(10)(t(8),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(8),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(8),"WeakMap");n.exports=a},function(n,e,t){var a=t(86),r=t(80);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(76),r=t(212),i=t(219),o=t(45),s=t(86),l=t(87),c=t(25);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(88);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(214),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(215);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(42);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(217);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(16),r=t(218),i=t(6),o=t(46),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(220),r=t(221);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(89),r=t(39),i=t(6),o=t(82),s=t(44),l=t(25);n.exports=function(n,e,t){for(var c=-1,d=(e=a(e,n)).length,m=!1;++c<d;){var p=l(e[c]);if(!(m=null!=n&&t(n,p)))break;n=n[p]}return m||++c!=d?m:!!(d=null==n?0:n.length)&&s(d)&&o(p,d)&&(i(n)||r(n))}},function(n,e,t){var a=t(223),r=t(224),i=t(45),o=t(25);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(88);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(47),r=t(226),i=t(228);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(227),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(229),r=t(232)(a);n.exports=r},function(n,e,t){var a=t(230),r=t(231),i=t(47),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(78),r=t(234),i=t(239),o=t(79),s=t(240),l=t(43);n.exports=function(n,e,t){var c=-1,d=r,m=n.length,p=!0,u=[],g=u;if(t)p=!1,d=i;else if(m>=200){var h=e?null:s(n);if(h)return l(h);p=!1,d=o,g=new a}else g=e?[]:u;n:for(;++c<m;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,p&&v==v){for(var b=g.length;b--;)if(g[b]===v)continue n;e&&g.push(v),u.push(f)}else d(g,v,t)||(g!==u&&g.push(v),u.push(f))}return u}},function(n,e,t){var a=t(235);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(236),r=t(237),i=t(238);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(85),r=t(241),i=t(43),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(84),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(90)},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(18),r=t(2),i=t(251);a({global:!0},{Reflect:{}}),i(r.Reflect,"Reflect",!0)},function(n,e,t){var a=t(13).f,r=t(7),i=t(20)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,i)&&a(n,i,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,a=n.length-1;a>=0;a--){var r=n[a];"."===r?n.splice(a,1):".."===r?(n.splice(a,1),t++):t&&(n.splice(a,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function a(n,e){if(n.filter)return n.filter(e);for(var t=[],a=0;a<n.length;a++)e(n[a],a,n)&&t.push(n[a]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var i=r>=0?arguments[r]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(a(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===r(n,-1);return(n=t(a(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(a(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function a(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=a(n.split("/")),i=a(t.split("/")),o=Math.min(r.length,i.length),s=o,l=0;l<o;l++)if(r[l]!==i[l]){s=l;break}var c=[];for(l=s;l<r.length;l++)c.push("..");return(c=c.concat(i.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,a=-1,r=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!r){a=i;break}}else r=!1;return-1===a?t?"/":".":t&&1===a?"/":n.slice(0,a)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,a=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===a&&(r=!1,a=e+1);return-1===a?"":n.slice(t,a)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,a=-1,r=!0,i=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===a&&(r=!1,a=o+1),46===s?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!r){t=o+1;break}}return-1===e||-1===a||0===i||1===i&&e===a-1&&e===t+1?"":n.slice(e,a)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var a=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(a,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var a=0;a<t.length;a++){var r=t[a];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/blogwriter/blogwriter/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(93)},function(n,e,t){"use strict";t(94)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function d(n){return null!==n&&"object"==typeof n}var m=Object.prototype.toString;function p(n){return"[object Object]"===m.call(n)}function u(n){return"[object RegExp]"===m.call(n)}function g(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===m?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var k=Object.prototype.hasOwnProperty;function w(n,e){return k.call(n,e)}function E(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _=/-(\w)/g,C=E((function(n){return n.replace(_,(function(n,e){return e?e.toUpperCase():""}))})),T=E((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),A=/\B([A-Z])/g,S=E((function(n){return n.replace(A,"-$1").toLowerCase()}));var I=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function B(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function P(n,e){for(var t in e)n[t]=e[t];return n}function z(n){for(var e={},t=0;t<n.length;t++)n[t]&&P(e,n[t]);return e}function D(n,e,t){}var j=function(n,e,t){return!1},O=function(n){return n};function F(n,e){if(n===e)return!0;var t=d(n),a=d(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return F(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return F(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(F(n[t],e))return t;return-1}function $(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function L(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var R=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],G={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:j,isReservedAttr:j,isUnknownElement:j,getTagNamespace:D,parsePlatformTagName:O,mustUseProp:j,async:!0,_lifecycleHooks:U},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var V=new RegExp("[^".concat(q.source,".$_\\d]"));var J="__proto__"in{},Z="undefined"!=typeof window,X=Z&&window.navigator.userAgent.toLowerCase(),W=X&&/msie|trident/.test(X),Q=X&&X.indexOf("msie 9.0")>0,Y=X&&X.indexOf("edge/")>0;X&&X.indexOf("android");var K=X&&/iphone|ipad|ipod|ios/.test(X);X&&/chrome\/\d+/.test(X),X&&/phantomjs/.test(X);var nn,en=X&&X.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(Z)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!Z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=Z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var mn=null;function pn(n){void 0===n&&(n=null),n||mn&&mn._scope.off(),mn=n,n&&n._scope.on()}var un=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new un;return e.text=n,e.isComment=!0,e};function hn(n){return new un(void 0,void 0,void 0,String(n))}function fn(n){var e=new un(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,bn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,bn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function kn(n){xn.push(n),yn.target=n}function wn(){xn.pop(),yn.target=xn[xn.length-1]}var En=Array.prototype,_n=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];H(_n,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var Cn=Object.getOwnPropertyNames(_n),Tn={},An=!0;function Sn(n){An=n}var In={notify:D,depend:D,addSub:D,removeSub:D},Bn=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?In:new yn,this.vmCount=0,H(n,"__ob__",this),r(n)){if(!t)if(J)n.__proto__=_n;else for(var a=0,i=Cn.length;a<i;a++){H(n,s=Cn[a],_n[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;zn(n,s=o[a],Tn,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Pn(n[e],!1,this.mock)},n}();function Pn(n,e,t){return n&&w(n,"__ob__")&&n.__ob__ instanceof Bn?n.__ob__:!An||!t&&on()||!r(n)&&!p(n)||!Object.isExtensible(n)||n.__v_skip||Ln(n)||n instanceof un?void 0:new Bn(n,e,t)}function zn(n,e,t,a,i,o){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,d=l&&l.set;c&&!d||t!==Tn&&2!==arguments.length||(t=n[e]);var m=!i&&Pn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),m&&(m.dep.depend(),r(e)&&On(e))),Ln(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(L(a,e)){if(d)d.call(n,e);else{if(c)return;if(!i&&Ln(a)&&!Ln(e))return void(a.value=e);t=e}m=!i&&Pn(e,!1,o),s.notify()}}}),s}}function Dn(n,e,t){if(!$n(n)){var a=n.__ob__;return r(n)&&g(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&Pn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(zn(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function jn(n,e){if(r(n)&&g(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||$n(n)||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&On(e)}function Fn(n){return Mn(n,!0),H(n,"__v_isShallow",!0),n}function Mn(n,e){if(!$n(n)){Pn(n,e,on());0}}function $n(n){return!(!n||!n.__v_isReadonly)}function Ln(n){return!(!n||!0!==n.__v_isRef)}function Rn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(Ln(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];Ln(a)&&!Ln(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Gn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function qn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var Nn=E((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Ae(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Ae(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Vn(n,e,t,a,r,o){var l,c,d,m;for(l in n)c=n[l],d=e[l],m=Nn(l),i(c)||(i(d)?(i(c.fns)&&(c=n[l]=Hn(c,o)),s(m.once)&&(c=n[l]=r(m.name,c,m.capture)),t(m.name,c,m.capture,m.passive,m.params)):c!==d&&(d.fns=c,n[l]=d));for(l in e)i(n[l])&&a((m=Nn(l)).name,e[l],m.capture)}function Jn(n,e,t){var a;n instanceof un&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),x(a.fns,l)}i(r)?a=Hn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Hn([r,l]),a.merged=!0,n[e]=a}function Zn(n,e,t,a,r){if(o(e)){if(w(e,t))return n[t]=e[t],r||delete e[t],!0;if(w(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Xn(n){return l(n)?[hn(n)]:r(n)?function n(e,t){var a,c,d,m,p=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(d=p.length-1,m=p[d],r(c)?c.length>0&&(Wn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Wn(m)&&(p[d]=hn(m.text+c[0].text),c.shift()),p.push.apply(p,c)):l(c)?Wn(m)?p[d]=hn(m.text+c):""!==c&&p.push(hn(c)):Wn(c)&&Wn(m)?p[d]=hn(m.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),p.push(c)));return p}(n):void 0}function Wn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Qn(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(d(n))if(dn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),m=c.next();!m.done;)l.push(e(m.value,l.length)),m=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=P(P({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function Kn(n){return Bt(this.$options,"filters",n,!0)||O}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,r){var i=G.keyCodes[e]||t;return r&&a&&!G.keyCodes[e]?ne(r,a):i?ne(i,n):a?S(a)!==e:void 0===n}function te(n,e,t,a,i){if(t)if(d(t)){r(t)&&(t=z(t));var o=void 0,s=function(r){if("class"===r||"style"===r||y(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||G.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=C(r),c=S(r);l in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||ie(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function re(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&oe(n[a],"".concat(e,"_").concat(a),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(p(e)){var t=n.on=n.on?P({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function le(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function de(n,e){return"string"==typeof n?e+n:n}function me(n){n._o=re,n._n=v,n._s=f,n._l=Qn,n._t=Yn,n._q=F,n._i=M,n._m=ae,n._f=Kn,n._k=ee,n._b=te,n._v=hn,n._e=gn,n._u=le,n._g=se,n._d=ce,n._p=de}function pe(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(ue)&&delete t[c];return t}function ue(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function he(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=fe(n,t,c,e[c]))}else i={};for(var d in t)d in i||(i[d]=ve(t,d));return e&&Object.isExtensible(e)&&(e._normalized=i),H(i,"$stable",s),H(i,"$key",l),H(i,"$hasNormal",o),i}function fe(n,e,t,a){var i=function(){var e=mn;pn(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Xn(t))&&t[0];return pn(e),t&&(!i||1===t.length&&i.isComment&&!ge(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ve(n,e){return function(){return n[e]}}function be(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||ke(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:I(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Rn(n,e,t)}))}}}function ye(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,xe(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function xe(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function ke(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var we=null;function Ee(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function _e(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ge(t)))return t}}function Ce(n,e,t,a,m,p){return(r(t)||l(t))&&(m=a,a=t,t=void 0),s(p)&&(m=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return gn();o(t)&&o(t.is)&&(e=t.is);if(!e)return gn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Xn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var m,p;if("string"==typeof e){var u=void 0;p=n.$vnode&&n.$vnode.ns||G.getTagNamespace(e),m=G.isReservedTag(e)?new un(G.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(u=Bt(n.$options,"components",e))?new un(e,t,a,void 0,void 0,n):xt(u,t,n,a,e)}else m=xt(e,t,n,a);return r(m)?m:o(m)?(o(p)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(m,p),o(t)&&function(n){d(n.style)&&Ge(n.style);d(n.class)&&Ge(n.class)}(t),m):gn()}(n,e,t,a,m)}function Te(n,e,t){kn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Se(n,a,"errorCaptured hook")}}Se(n,e,t)}finally{wn()}}function Ae(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Te(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Te(n,a,r)}return i}function Se(n,e,t){if(G.errorHandler)try{return G.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Ie(e,null,"config.errorHandler")}Ie(n,e,t)}function Ie(n,e,t){if(!Z||"undefined"==typeof console)throw n;console.error(n)}var Be,Pe=!1,ze=[],De=!1;function je(){De=!1;var n=ze.slice(0);ze.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Oe=Promise.resolve();Be=function(){Oe.then(je),K&&setTimeout(D)},Pe=!0}else if(W||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Be="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(je)}:function(){setTimeout(je,0)};else{var Fe=1,Me=new MutationObserver(je),$e=document.createTextNode(String(Fe));Me.observe($e,{characterData:!0}),Be=function(){Fe=(Fe+1)%2,$e.data=String(Fe)},Pe=!0}function Le(n,e){var t;if(ze.push((function(){if(n)try{n.call(e)}catch(n){Te(n,e,"nextTick")}else t&&t(e)})),De||(De=!0,Be()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Re(n){return function(e,t){if(void 0===t&&(t=mn),t)return function(n,e,t){var a=n.$options;a[e]=Tt(a[e],t)}(t,n,e)}}Re("beforeMount"),Re("mounted"),Re("beforeUpdate"),Re("updated"),Re("beforeDestroy"),Re("destroyed"),Re("activated"),Re("deactivated"),Re("serverPrefetch"),Re("renderTracked"),Re("renderTriggered"),Re("errorCaptured");var Ue=new cn;function Ge(n){return function n(e,t){var a,i,o=r(e);if(!o&&!d(e)||e.__v_skip||Object.isFrozen(e)||e instanceof un)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(Ln(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ue),Ue.clear(),n}var qe,Ne=0,He=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Ne,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=D)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;kn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Te(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Ge(n),wn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():pt(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ae(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ve(n,e){qe.$on(n,e)}function Je(n,e){qe.$off(n,e)}function Ze(n,e){var t=qe;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Xe(n,e,t){qe=n,Vn(e,t||{},Ve,Je,Ze,n),qe=void 0}var We=null;function Qe(n){var e=We;return We=n,function(){We=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ke(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ke(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),kn();var r=mn;a&&pn(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Ae(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&pn(r),wn()}var et=[],tt=[],at={},rt=!1,it=!1,ot=0;var st=0,lt=Date.now;if(Z&&!W){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var dt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function mt(){var n,e;for(st=lt(),it=!0,et.sort(dt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();ot=et.length=tt.length=0,at={},rt=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ke(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<bn.length;n++){var e=bn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}bn.length=0}(),sn&&G.devtools&&sn.emit("flush")}function pt(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,it){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,Le(mt))}}function ut(n,e){if(n){for(var t=Object.create(null),a=dn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function gt(n,e,t,i,o){var l,c=this,d=o.options;w(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var m=s(d._compiled),p=!m;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=ut(d.inject,i),this.slots=function(){return c.$slots||he(i,n.scopedSlots,c.$slots=pe(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return he(i,n.scopedSlots,this.slots())}}),m&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=he(i,n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,a){var o=Ce(l,n,e,t,a,p);return o&&!r(o)&&(o.fnScopeId=d._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return Ce(l,n,e,t,a,p)}}function ht(n,e,t,a,r){var i=fn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ft(n,e){for(var t in e)n[C(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}me(gt.prototype);var bt={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;bt.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,We)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),d=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var m=r.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,m,d.data&&d.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=m,t=t||a;var p=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,p||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Xe(n,t,p),e&&n.$options.props){Sn(!1);for(var u=n._props,g=n.$options._propKeys||[],h=0;h<g.length;h++){var f=g[h],v=n.$options.props;u[f]=Pt(f,v,e,n)}Sn(!0),n.$options.propsData=e}c&&(n.$slots=pe(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ke(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(bt);function xt(n,e,t,l,c){if(!i(n)){var m=t.$options._base;if(d(n)&&(n=m.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=we;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(a,t)}));var m=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},p=$((function(t){n.resolved=Ee(t,e),r?a.length=0:m(!0)})),u=$((function(e){o(n.errorComp)&&(n.error=!0,m(!0))})),g=n(p,u);return d(g)&&(h(g)?i(n.resolved)&&g.then(p,u):h(g.component)&&(g.component.then(p,u),o(g.error)&&(n.errorComp=Ee(g.error,e)),o(g.loading)&&(n.loadingComp=Ee(g.loading,e),0===g.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,m(!1))}),g.delay||200)),o(g.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&u(null)}),g.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(p=n,m)))return function(n,e,t,a,r){var i=gn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(p,e,t,l,c);e=e||{},Ht(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var u=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in a){var d=S(c);Zn(r,l,c,d,!0)||Zn(r,s,c,d,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},d=l.props;if(o(d))for(var m in d)c[m]=Pt(m,d,e||a);else o(t.attrs)&&ft(c,t.attrs),o(t.props)&&ft(c,t.props);var p=new gt(t,c,s,i,n),u=l.render.call(null,p._c,p);if(u instanceof un)return ht(u,t,p.parent,l,p);if(r(u)){for(var g=Xn(u)||[],h=new Array(g.length),f=0;f<g.length;f++)h[f]=ht(g[f],t,p.parent,l,p);return h}}(n,u,e,t,l);var g=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var f=e.slot;e={},f&&(e.slot=f)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],r=e[a],i=bt[a];r===i||r&&r._merged||(e[a]=r?kt(i,r):i)}}(e);var v=vt(n.options)||c;return new un("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:g,tag:c,children:l},p)}}}function kt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var wt=D,Et=G.optionMergeStrategies;function _t(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,i,o=dn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(a=o[s])&&(r=n[a],i=e[a],t&&w(n,a)?r!==i&&p(r)&&p(i)&&_t(r,i):Dn(n,a,i));return n}function Ct(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?_t(a,r):r}:e?n?function(){return _t(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Tt(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function At(n,e,t,a){var r=Object.create(n||null);return e?P(r,e):r}Et.data=function(n,e,t){return t?Ct(n,e,t):e&&"function"!=typeof e?n:Ct(n,e)},U.forEach((function(n){Et[n]=Tt})),R.forEach((function(n){Et[n+"s"]=At})),Et.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in P(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},Et.props=Et.methods=Et.inject=Et.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return P(r,n),e&&P(r,e),r},Et.provide=function(n,e){return n?function(){var t=Object.create(null);return _t(t,c(n)?n.call(this):n),e&&_t(t,c(e)?e.call(this):e,!1),t}:e};var St=function(n,e){return void 0===e?n:e};function It(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[C(i)]={type:null});else if(p(t))for(var s in t)i=t[s],o[C(s)]=p(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(p(t))for(var o in t){var s=t[o];a[o]=p(s)?P({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=It(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=It(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)w(n,o)||l(o);function l(a){var r=Et[a]||St;s[a]=r(n[a],e[a],t,a)}return s}function Bt(n,e,t,a){if("string"==typeof t){var r=n[e];if(w(r,t))return r[t];var i=C(t);if(w(r,i))return r[i];var o=T(i);return w(r,o)?r[o]:r[t]||r[i]||r[o]}}function Pt(n,e,t,a){var r=e[n],i=!w(t,n),o=t[n],s=Ot(Boolean,r.type);if(s>-1)if(i&&!w(r,"default"))o=!1;else if(""===o||o===S(n)){var l=Ot(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Dt(e.type)?a.call(n):a}(a,r,n);var d=An;Sn(!0),Pn(o),Sn(d)}return o}var zt=/^\s*function (\w+)/;function Dt(n){var e=n&&n.toString().match(zt);return e?e[1]:""}function jt(n,e){return Dt(n)===Dt(e)}function Ot(n,e){if(!r(e))return jt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(jt(e[t],n))return t;return-1}var Ft={enumerable:!0,configurable:!0,get:D,set:D};function Mt(n,e,t){Ft.get=function(){return this[e][t]},Ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Ft)}function $t(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Fn({}),r=n.$options._propKeys=[];n.$parent&&Sn(!1);var i=function(i){r.push(i);var o=Pt(i,e,t,n);zn(a,i,o),i in n||Mt(n,"_props",i)};for(var o in e)i(o);Sn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=be(n);pn(n),kn();var r=Ae(t,null,[n._props||Fn({}),a],n,"setup");if(wn(),pn(),c(r))e.render=r;else if(d(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Rn(i,r,o)}else for(var o in r)N(o)||Rn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?D:I(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;p(e=n._data=c(e)?function(n,e){kn();try{return n.call(e,e)}catch(n){return Te(n,e,"data()"),{}}finally{wn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&w(a,i)||N(i)||Mt(n,"_data",i)}var o=Pn(e);o&&o.vmCount++}(n);else{var t=Pn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new He(n,o||D,D,Lt)),r in n||Rt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)qt(n,t,a[i]);else qt(n,t,a)}}(n,e.watch)}var Lt={lazy:!0};function Rt(n,e,t){var a=!on();c(t)?(Ft.get=a?Ut(e):Gt(t),Ft.set=D):(Ft.get=t.get?a&&!1!==t.cache?Ut(e):Gt(t.get):D,Ft.set=t.set||D),Object.defineProperty(n,e,Ft)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Gt(n){return function(){return n.call(this,this)}}function qt(n,e,t,a){return p(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var Nt=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&P(n.extendOptions,a),(e=n.options=It(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Vt(n){this._init(n)}function Jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=vt(n)||vt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=It(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Mt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Rt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=P({},o.options),r[a]=o,o}}function Zt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Xt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Wt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Qt(t,i,a,r)}}}function Qt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Nt++,e._isVue=!0,e.__v_skip=!0,e._scope=new Gn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=It(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=pe(e._renderChildren,r),n.$scopedSlots=t?he(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Ce(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Ce(n,e,t,a,r,!0)};var i=t&&t.data;zn(n,"$attrs",i&&i.attrs||a,null,!0),zn(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=ut(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),Sn(!0))}(e),$t(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!d(t))return;for(var a=qn(n),r=dn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Vt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Dn,n.prototype.$delete=jn,n.prototype.$watch=function(n,e,t){if(p(e))return qt(this,n,e,t);(t=t||{}).user=!0;var a=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');kn(),Ae(e,this,[a.value],this,r),wn()}return function(){a.teardown()}}}(Vt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?B(t):t;for(var a=B(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ae(t[i],e,a,e,r)}return e}}(Vt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Qe(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Vt),function(n){me(n.prototype),n.prototype.$nextTick=function(n){return Le(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=he(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&ke(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{pn(e),we=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Te(t,e,"render"),n=e._vnode}finally{we=null,pn()}return r(n)&&1===n.length&&(n=n[0]),n instanceof un||(n=gn()),n.parent=i,n}}(Vt);var Yt=[String,RegExp,Array],Kt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Zt(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Qt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Qt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Wt(n,(function(n){return Xt(e,n)}))})),this.$watch("exclude",(function(e){Wt(n,(function(n){return!Xt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=_e(n),t=e&&e.componentOptions;if(t){var a=Zt(t),r=this.include,i=this.exclude;if(r&&(!a||!Xt(r,a))||i&&a&&Xt(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return G}};Object.defineProperty(n,"config",e),n.util={warn:wt,extend:P,mergeOptions:It,defineReactive:zn},n.set=Dn,n.delete=jn,n.nextTick=Le,n.observable=function(n){return Pn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,P(n.options.components,Kt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=B(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=It(this.options,n),this}}(n),Jt(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Vt),Object.defineProperty(Vt.prototype,"$isServer",{get:on}),Object.defineProperty(Vt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Vt,"FunctionalRenderContext",{value:gt}),Vt.version="2.7.14";var na=b("style,class"),ea=b("input,textarea,option,select,progress"),ta=b("contenteditable,draggable,spellcheck"),aa=b("events,caret,typing,plaintext-only"),ra=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",oa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sa=function(n){return oa(n)?n.slice(6,n.length):""},la=function(n){return null==n||!1===n};function ca(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=da(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=da(e,t.data));return function(n,e){if(o(n)||o(e))return ma(n,pa(e));return""}(e.staticClass,e.class)}function da(n,e){return{staticClass:ma(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function ma(n,e){return n?e?n+" "+e:n:e||""}function pa(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=pa(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ua={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ga=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ha=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),fa=function(n){return ga(n)||ha(n)};var va=Object.create(null);var ba=b("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ua[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xa={create:function(n,e){ka(e)},update:function(n,e){n.data.ref!==e.data.ref&&(ka(n,!0),ka(e))},destroy:function(n){ka(n,!0)}};function ka(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Ae(t,a,[s],a,"template ref function");else{var d=n.data.refInFor,m="string"==typeof t||"number"==typeof t,p=Ln(t),u=a.$refs;if(m||p)if(d){var g=m?u[t]:t.value;e?r(g)&&x(g,i):r(g)?g.includes(i)||g.push(i):m?(u[t]=[i],wa(a,t,u[t])):t.value=[i]}else if(m){if(e&&u[t]!==i)return;u[t]=l,wa(a,t,s)}else if(p){if(e&&t.value!==i)return;t.value=s}else 0}}}function wa(n,e,t){var a=n._setupState;a&&w(a,e)&&(Ln(a[e])?a[e].value=t:a[e]=t)}var Ea=new un("",{},[]),_a=["create","activate","update","remove","destroy"];function Ca(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||ba(a)&&ba(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Ta(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Aa={create:Sa,update:Sa,destroy:function(n){Sa(n,Ea)}};function Sa(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===Ea,o=e===Ea,s=Ba(n.data.directives,n.context),l=Ba(e.data.directives,e.context),c=[],d=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,za(r,"update",e,n),r.def&&r.def.componentUpdated&&d.push(r)):(za(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var m=function(){for(var t=0;t<c.length;t++)za(c[t],"inserted",e,n)};i?Jn(e,"insert",m):m()}d.length&&Jn(e,"postpatch",(function(){for(var t=0;t<d.length;t++)za(d[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||za(s[t],"unbind",n,n,o)}(n,e)}var Ia=Object.create(null);function Ba(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=Ia),r[Pa(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||Bt(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||Bt(e.$options,"directives",a.name)}return r}function Pa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function za(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Te(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Da=[xa,Aa];function ja(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},d=e.data.attrs||{};for(a in(o(d.__ob__)||s(d._v_attr_proxy))&&(d=e.data.attrs=P({},d)),d)r=d[a],c[a]!==r&&Oa(l,a,r,e.data.pre);for(a in(W||Y)&&d.value!==c.value&&Oa(l,"value",d.value),c)i(d[a])&&(oa(a)?l.removeAttributeNS(ia,sa(a)):ta(a)||l.removeAttribute(a))}}function Oa(n,e,t,a){a||n.tagName.indexOf("-")>-1?Fa(n,e,t):ra(e)?la(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return la(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):oa(e)?la(t)?n.removeAttributeNS(ia,sa(e)):n.setAttributeNS(ia,e,t):Fa(n,e,t)}function Fa(n,e,t){if(la(t))n.removeAttribute(e);else{if(W&&!Q&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Ma={create:ja,update:ja};function $a(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=ca(e),l=t._transitionClasses;o(l)&&(s=ma(s,pa(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var La,Ra={create:$a,update:$a};function Ua(n,e,t){var a=La;return function r(){var i=e.apply(null,arguments);null!==i&&Na(n,r,t,a)}}var Ga=Pe&&!(en&&Number(en[1])<=53);function qa(n,e,t,a){if(Ga){var r=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}La.addEventListener(n,e,an?{capture:t,passive:a}:t)}function Na(n,e,t,a){(a||La).removeEventListener(n,e._wrapper||e,t)}function Ha(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};La=e.elm||n.elm,function(n){if(o(n.__r)){var e=W?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Vn(t,a,qa,Na,Ua,e.context),La=void 0}}var Va,Ja={create:Ha,update:Ha,destroy:function(n){return Ha(n,Ea)}};function Za(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=P({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var d=i(a)?"":String(a);Xa(r,d)&&(r.value=d)}else if("innerHTML"===t&&ha(r.tagName)&&i(r.innerHTML)){(Va=Va||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var m=Va.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;m.firstChild;)r.appendChild(m.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Xa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Wa={create:Za,update:Za},Qa=E((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ya(n){var e=Ka(n.style);return n.staticStyle?P(n.staticStyle,e):e}function Ka(n){return Array.isArray(n)?z(n):"string"==typeof n?Qa(n):n}var nr,er=/^--/,tr=/\s*!important$/,ar=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(S(e),t.replace(tr,""),"important");else{var a=ir(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},rr=["Webkit","Moz","ms"],ir=E((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=C(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var a=rr[t]+e;if(a in nr)return a}}));function or(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,c=a.staticStyle,d=a.normalizedStyle||a.style||{},m=c||d,p=Ka(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?P({},p):p;var u=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ya(r.data))&&P(a,t);(t=Ya(n.data))&&P(a,t);for(var i=n;i=i.parent;)i.data&&(t=Ya(i.data))&&P(a,t);return a}(e,!0);for(s in m)i(u[s])&&ar(l,s,"");for(s in u)(r=u[s])!==m[s]&&ar(l,s,null==r?"":r)}}var sr={create:or,update:or},lr=/\s+/;function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function mr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&P(e,pr(n.name||"v")),P(e,n),e}return"string"==typeof n?pr(n):void 0}}var pr=E((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),ur=Z&&!Q,gr="transition",hr="transitionend",fr="animation",vr="animationend";ur&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(gr="WebkitTransition",hr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(fr="WebkitAnimation",vr="webkitAnimationEnd"));var br=Z?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yr(n){br((function(){br(n)}))}function xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),cr(n,e))}function kr(n,e){n._transitionClasses&&x(n._transitionClasses,e),dr(n,e)}function wr(n,e,t){var a=_r(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?hr:vr,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,d)}var Er=/\b(transform|all)(,|$)/;function _r(n,e){var t,a=window.getComputedStyle(n),r=(a[gr+"Delay"]||"").split(", "),i=(a[gr+"Duration"]||"").split(", "),o=Cr(r,i),s=(a[fr+"Delay"]||"").split(", "),l=(a[fr+"Duration"]||"").split(", "),c=Cr(s,l),d=0,m=0;return"transition"===e?o>0&&(t="transition",d=o,m=i.length):"animation"===e?c>0&&(t="animation",d=c,m=l.length):m=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:d,propCount:m,hasTransform:"transition"===t&&Er.test(a[gr+"Property"])}}function Cr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Tr(e)+Tr(n[t])})))}function Tr(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ar(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=mr(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,m=a.enterToClass,p=a.enterActiveClass,u=a.appearClass,g=a.appearToClass,h=a.appearActiveClass,f=a.beforeEnter,b=a.enter,y=a.afterEnter,x=a.enterCancelled,k=a.beforeAppear,w=a.appear,E=a.afterAppear,_=a.appearCancelled,C=a.duration,T=We,A=We.$vnode;A&&A.parent;)T=A.context,A=A.parent;var S=!T._isMounted||!n.isRootInsert;if(!S||w||""===w){var I=S&&u?u:l,B=S&&h?h:p,P=S&&g?g:m,z=S&&k||f,D=S&&c(w)?w:b,j=S&&E||y,O=S&&_||x,F=v(d(C)?C.enter:C);0;var M=!1!==r&&!Q,L=Br(D),R=t._enterCb=$((function(){M&&(kr(t,P),kr(t,B)),R.cancelled?(M&&kr(t,I),O&&O(t)):j&&j(t),t._enterCb=null}));n.data.show||Jn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),D&&D(t,R)})),z&&z(t),M&&(xr(t,I),xr(t,B),yr((function(){kr(t,I),R.cancelled||(xr(t,P),L||(Ir(F)?setTimeout(R,F):wr(t,s,R)))}))),n.data.show&&(e&&e(),D&&D(t,R)),M||L||R()}}}function Sr(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=mr(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,m=a.leaveActiveClass,p=a.beforeLeave,u=a.leave,g=a.afterLeave,h=a.leaveCancelled,f=a.delayLeave,b=a.duration,y=!1!==r&&!Q,x=Br(u),k=v(d(b)?b.leave:b);0;var w=t._leaveCb=$((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(kr(t,c),kr(t,m)),w.cancelled?(y&&kr(t,l),h&&h(t)):(e(),g&&g(t)),t._leaveCb=null}));f?f(E):E()}function E(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(xr(t,l),xr(t,m),yr((function(){kr(t,l),w.cancelled||(xr(t,c),x||(Ir(k)?setTimeout(w,k):wr(t,s,w)))}))),u&&u(t,w),y||x||w())}}function Ir(n){return"number"==typeof n&&!isNaN(n)}function Br(n){if(i(n))return!1;var e=n.fns;return o(e)?Br(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function Pr(n,e){!0!==e.data.show&&Ar(e)}var zr=function(n){var e,t,a={},c=n.modules,d=n.nodeOps;for(e=0;e<_a.length;++e)for(a[_a[e]]=[],t=0;t<c.length;++t)o(c[t][_a[e]])&&a[_a[e]].push(c[t][_a[e]]);function m(n){var e=d.parentNode(n);o(e)&&d.removeChild(e,n)}function p(n,e,t,r,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=fn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return u(n,e),g(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](Ea,s);e.push(s);break}g(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var m=n.data,p=n.children,f=n.tag;o(f)?(n.elm=n.ns?d.createElementNS(n.ns,f):d.createElement(f,n),y(n),h(n,p,e),o(m)&&v(n,e),g(t,n.elm,r)):s(n.isComment)?(n.elm=d.createComment(n.text),g(t,n.elm,r)):(n.elm=d.createTextNode(n.text),g(t,n.elm,r))}}function u(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(v(n,e),y(n)):(ka(n),e.push(n))}function g(n,e,t){o(n)&&(o(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function h(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)p(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var r=0;r<a.create.length;++r)a.create[r](Ea,n);o(e=n.data.hook)&&(o(e.create)&&e.create(Ea,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;o(e=We)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function x(n,e,t,a,r,i){for(;a<=r;++a)p(t[a],i,n,e,!1,t,a)}function k(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)k(n.children[t])}function w(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(E(a),k(a)):m(a.elm))}}function E(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&m(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&E(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else m(n.elm)}function _(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&Ca(n,i))return r}}function C(n,e,t,r,l,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=fn(e));var m=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?S(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var u,g=e.data;o(g)&&o(u=g.hook)&&o(u=u.prepatch)&&u(n,e);var h=n.children,v=e.children;if(o(g)&&f(e)){for(u=0;u<a.update.length;++u)a.update[u](n,e);o(u=g.hook)&&o(u=u.update)&&u(n,e)}i(e.text)?o(h)&&o(v)?h!==v&&function(n,e,t,a,r){var s,l,c,m=0,u=0,g=e.length-1,h=e[0],f=e[g],v=t.length-1,b=t[0],y=t[v],k=!r;for(0;m<=g&&u<=v;)i(h)?h=e[++m]:i(f)?f=e[--g]:Ca(h,b)?(C(h,b,a,t,u),h=e[++m],b=t[++u]):Ca(f,y)?(C(f,y,a,t,v),f=e[--g],y=t[--v]):Ca(h,y)?(C(h,y,a,t,v),k&&d.insertBefore(n,h.elm,d.nextSibling(f.elm)),h=e[++m],y=t[--v]):Ca(f,b)?(C(f,b,a,t,u),k&&d.insertBefore(n,f.elm,h.elm),f=e[--g],b=t[++u]):(i(s)&&(s=Ta(e,m,g)),i(l=o(b.key)?s[b.key]:_(b,e,m,g))?p(b,a,n,h.elm,!1,t,u):Ca(c=e[l],b)?(C(c,b,a,t,u),e[l]=void 0,k&&d.insertBefore(n,c.elm,h.elm)):p(b,a,n,h.elm,!1,t,u),b=t[++u]);m>g?x(n,i(t[v+1])?null:t[v+1].elm,t,u,v,a):u>v&&w(e,m,g)}(m,h,v,t,c):o(v)?(o(n.text)&&d.setTextContent(m,""),x(m,null,v,0,v.length-1,t)):o(h)?w(h,0,h.length-1):o(n.text)&&d.setTextContent(m,""):n.text!==e.text&&d.setTextContent(m,e.text),o(g)&&o(u=g.hook)&&o(u=u.postpatch)&&u(n,e)}}}function T(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var A=b("attrs,class,staticClass,staticStyle,key");function S(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return u(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var d=!0,m=n.firstChild,p=0;p<c.length;p++){if(!m||!S(m,c[p],t,a)){d=!1;break}m=m.nextSibling}if(!d||m)return!1}else h(e,c,t);if(o(l)){var g=!1;for(var f in l)if(!A(f)){g=!0,v(e,t);break}!g&&l.class&&Ge(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,m=[];if(i(n))c=!0,p(e,m);else{var u=o(n.nodeType);if(!u&&Ca(n,e))C(n,e,m,null,null,r);else{if(u){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&S(n,e,m))return T(e,m,!0),n;l=n,n=new un(d.tagName(l).toLowerCase(),{},[],void 0,l)}var g=n.elm,h=d.parentNode(g);if(p(e,m,g._leaveCb?null:h,d.nextSibling(g)),o(e.parent))for(var v=e.parent,b=f(e);v;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](v);if(v.elm=e.elm,b){for(var x=0;x<a.create.length;++x)a.create[x](Ea,v);var E=v.data.hook.insert;if(E.merged)for(var _=1;_<E.fns.length;_++)E.fns[_]()}else ka(v);v=v.parent}o(h)?w([n],0,0):o(n.tag)&&k(n)}}return T(e,m,c),e.elm}o(n)&&k(n)}}({nodeOps:ya,modules:[Ma,Ra,Ja,Wa,sr,Z?{create:Pr,activate:Pr,remove:function(n,e){!0!==n.data.show?Sr(n,e):e()}}:{}].concat(Da)});Q&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Rr(n,"input")}));var Dr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Jn(t,"postpatch",(function(){Dr.componentUpdated(n,e,t)})):jr(n,e,t.context),n._vOptions=[].map.call(n.options,Mr)):("textarea"===t.tag||ba(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",$r),n.addEventListener("compositionend",Lr),n.addEventListener("change",Lr),Q&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){jr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Mr);if(r.some((function(n,e){return!F(n,a[e])})))(n.multiple?e.value.some((function(n){return Fr(n,r)})):e.value!==e.oldValue&&Fr(e.value,r))&&Rr(n,"change")}}};function jr(n,e,t){Or(n,e,t),(W||Y)&&setTimeout((function(){Or(n,e,t)}),0)}function Or(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=M(a,Mr(o))>-1,o.selected!==i&&(o.selected=i);else if(F(Mr(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Fr(n,e){return e.every((function(e){return!F(e,n)}))}function Mr(n){return"_value"in n?n._value:n.value}function $r(n){n.target.composing=!0}function Lr(n){n.target.composing&&(n.target.composing=!1,Rr(n.target,"input"))}function Rr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var Gr={model:Dr,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Ar(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?Ar(t,(function(){n.style.display=n.__vOriginalDisplay})):Sr(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},qr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Nr(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Nr(_e(e.children)):n}function Hr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[C(a)]=r[a];return e}function Vr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Jr=function(n){return n.tag||ge(n)},Zr=function(n){return"show"===n.name},Xr={name:"transition",props:qr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Jr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=Nr(r);if(!i)return r;if(this._leaving)return Vr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Hr(this),c=this._vnode,d=Nr(c);if(i.data.directives&&i.data.directives.some(Zr)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!ge(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var m=d.data.transition=P({},s);if("out-in"===a)return this._leaving=!0,Jn(m,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Vr(n,r);if("in-out"===a){if(ge(i))return c;var p,u=function(){p()};Jn(s,"afterEnter",u),Jn(s,"enterCancelled",u),Jn(m,"delayLeave",(function(n){p=n}))}}return r}}},Wr=P({tag:String,moveClass:String},qr);function Qr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Kr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Wr.mode;var ni={Transition:Xr,TransitionGroup:{props:Wr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Hr(this),s=0;s<r.length;s++){if((d=r[s]).tag)if(null!=d.key&&0!==String(d.key).indexOf("__vlist"))i.push(d),t[d.key]=d,(d.data||(d.data={})).transition=o;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var d;(d=a[s]).data.transition=o,d.data.pos=d.elm.getBoundingClientRect(),t[d.key]?l.push(d):c.push(d)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Qr),n.forEach(Yr),n.forEach(Kr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;xr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(hr,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(hr,n),t._moveCb=null,kr(t,e))})}})))},methods:{hasMove:function(n,e){if(!ur)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){dr(t,n)})),cr(t,e),t.style.display="none",this.$el.appendChild(t);var a=_r(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Vt.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Vt.config.isReservedTag=fa,Vt.config.isReservedAttr=na,Vt.config.getTagNamespace=function(n){return ha(n)?"svg":"math"===n?"math":void 0},Vt.config.isUnknownElement=function(n){if(!Z)return!0;if(fa(n))return!1;if(n=n.toLowerCase(),null!=va[n])return va[n];var e=document.createElement(n);return n.indexOf("-")>-1?va[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:va[n]=/HTMLUnknownElement/.test(e.toString())},P(Vt.options.directives,Gr),P(Vt.options.components,ni),Vt.prototype.__patch__=Z?zr:D,Vt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=gn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new He(n,a,D,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&Z?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},Z&&setTimeout((function(){G.devtools&&sn&&sn.emit("init",Vt)}),0);var ti=/[!'()*]/g,ai=function(n){return"%"+n.charCodeAt(0).toString(16)},ri=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,ai).replace(ri,",")};function oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function li(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=oi(t.shift()),r=t.length>0?oi(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function ci(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(ii(e)):a.push(ii(e)+"="+ii(n)))})),a.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var di=/\/?$/;function mi(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=pi(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:hi(e,r),matched:n?gi(n):[]};return t&&(o.redirectedFrom=hi(t,r)),Object.freeze(o)}function pi(n){if(Array.isArray(n))return n.map(pi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=pi(n[t]);return e}return n}var ui=mi(null,{path:"/"});function gi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function hi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||ci)(a)+r}function fi(n,e,t){return e===ui?n===e:!!e&&(n.path&&e.path?n.path.replace(di,"")===e.path.replace(di,"")&&(t||n.hash===e.hash&&vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vi(n.query,e.query)&&vi(n.params,e.params))))}function vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?vi(i,o):String(i)===String(o)}))}function bi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var yi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),d=0,m=!1;r&&r._routerRoot!==r;){var p=r.$vnode?r.$vnode.data:{};p.routerView&&d++,p.keepAlive&&r._directInactive&&r._inactive&&(m=!0),r=r.$parent}if(i.routerViewDepth=d,m){var u=c[s],g=u&&u.component;return g?(u.configProps&&xi(g,i,u.route,u.configProps),o(g,i,a)):o()}var h=l.matched[d],f=h&&h.components[s];if(!h||!f)return c[s]=null,o();c[s]={component:f},i.registerRouteInstance=function(n,e){var t=h.instances[s];(e&&t!==n||!e&&t===n)&&(h.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){h.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==h.instances[s]&&(h.instances[s]=n.componentInstance),bi(l)};var v=h.props&&h.props[s];return v&&(ei(c[s],{route:l,configProps:v}),xi(f,i,l,v)),o(f,i,a)}};function xi(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ei({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function ki(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function wi(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var Ei=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},_i=$i,Ci=Bi,Ti=function(n,e){return zi(Bi(n,e),e)},Ai=zi,Si=Mi,Ii=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Bi(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=Ii.exec(n));){var l=t[0],c=t[1],d=t.index;if(o+=n.slice(i,d),i=d+l.length,c)o+=c[1];else{var m=n[i],p=t[2],u=t[3],g=t[4],h=t[5],f=t[6],v=t[7];o&&(a.push(o),o="");var b=null!=p&&null!=m&&m!==p,y="+"===f||"*"===f,x="?"===f||"*"===f,k=t[2]||s,w=g||h;a.push({name:u||r++,prefix:p||"",delimiter:k,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:w?ji(w):v?".*":"[^"+Di(k)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function Pi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function zi(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Fi(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?Pi:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=i[l.name];if(null==d){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(Ei(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var m=0;m<d.length;m++){if(c=o(d[m]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===m?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Di(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ji(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Oi(n,e){return n.keys=e,n}function Fi(n){return n&&n.sensitive?"":"i"}function Mi(n,e,t){Ei(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Di(s);else{var l=Di(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=Di(t.delimiter||"/"),m=i.slice(-d.length)===d;return a||(i=(m?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=r?"$":a&&m?"":"(?="+d+"|$)",Oi(new RegExp("^"+i,Fi(t)),e)}function $i(n,e,t){return Ei(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Oi(n,e)}(n,e):Ei(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push($i(n[r],e,t).source);return Oi(new RegExp("(?:"+a.join("|")+")",Fi(t)),e)}(n,e,t):function(n,e,t){return Mi(Bi(n,t),e,t)}(n,e,t)}_i.parse=Ci,_i.compile=Ti,_i.tokensToFunction=Ai,_i.tokensToRegExp=Si;var Li=Object.create(null);function Ri(n,e,t){e=e||{};try{var a=Li[n]||(Li[n]=_i.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ei({},n)).params;return i&&"object"==typeof i&&(r.params=ei({},i)),r}if(!r.path&&r.params&&e){(r=ei({},r))._normalized=!0;var o=ei(ei({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Ri(s,o,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",d=l.path?ki(l.path,c,t||r.append):c,m=function(n,e,t){void 0===e&&(e={});var a,r=t||li;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(si):si(o)}return a}(l.query,r.query,a&&a.options.parseQuery),p=r.hash||l.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:m,hash:p}}var Gi,qi=function(){},Ni={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,s=r.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,m=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,u=null==this.activeClass?m:this.activeClass,g=null==this.exactActiveClass?p:this.exactActiveClass,h=o.redirectedFrom?mi(null,Ui(o.redirectedFrom),null,t):o;l[g]=fi(a,h,this.exactPath),l[u]=this.exact||this.exactPath?l[g]:function(n,e){return 0===n.path.replace(di,"/").indexOf(e.path.replace(di,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,h);var f=l[g]?this.ariaCurrentValue:null,v=function(n){Hi(n)&&(e.replace?t.replace(i,qi):t.push(i,qi))},b={click:Hi};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[u],isExactActive:l[g]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":f};else{var k=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var w=k.data=ei({},k.data);for(var E in w.on=w.on||{},w.on){var _=w.on[E];E in b&&(w.on[E]=Array.isArray(_)?_:[_])}for(var C in b)C in w.on?w.on[C].push(b[C]):w.on[C]=v;var T=k.data.attrs=ei({},k.data.attrs);T.href=s,T["aria-current"]=f}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Hi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Vi="undefined"!=typeof window;function Ji(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return wi(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var m={path:d,regex:Zi(d,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?wi(o+"/"+r.path):void 0;n(e,t,a,r,m,i)}));t[m.path]||(e.push(m.path),t[m.path]=m);if(void 0!==r.alias)for(var p=Array.isArray(r.alias)?r.alias:[r.alias],u=0;u<p.length;++u){0;var g={path:p[u],children:r.children};n(e,t,a,g,i,m.path||"/")}l&&(a[l]||(a[l]=m))}(i,o,s,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Zi(n,e){return _i(n,[],e)}function Xi(n,e){var t=Ji(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Ui(n,t,!1,e),c=s.name;if(c){var d=i[c];if(!d)return l(null,s);var m=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&m.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=Ri(d.path,s.params),l(d,s,o)}if(s.path){s.params={};for(var u=0;u<a.length;u++){var g=a[u],h=r[g];if(Wi(h.regex,s.path,s.params))return l(h,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(mi(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,d=s.path,m=t.query,p=t.hash,u=t.params;if(m=s.hasOwnProperty("query")?s.query:m,p=s.hasOwnProperty("hash")?s.hash:p,u=s.hasOwnProperty("params")?s.params:u,c){i[c];return o({_normalized:!0,name:c,query:m,hash:p,params:u},void 0,t)}if(d){var g=function(n,e){return ki(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:Ri(g,u),query:m,hash:p},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Ri(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):mi(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Ji([e||n],a,r,i,t),t&&t.alias.length&&Ji(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Ji(n,a,r,i)}}}function Wi(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?oi(a[r]):a[r])}return!0}var Qi=Vi&&window.performance&&window.performance.now?window.performance:Date;function Yi(){return Qi.now().toFixed(3)}var Ki=Yi();function no(){return Ki}function eo(n){return Ki=n}var to=Object.create(null);function ao(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function ro(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=no();if(n)return to[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){po(n,i)})).catch((function(n){0})):po(o,i))}))}}function io(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){io(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return co(n.x)||co(n.y)}function lo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var mo=/^#\d/;function po(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=mo.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else so(n)&&(e=lo(n))}else a&&so(n)&&(e=lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var uo,go=Vi&&((-1===(uo=window.navigator.userAgent).indexOf("Android 2.")&&-1===uo.indexOf("Android 4.0")||-1===uo.indexOf("Mobile Safari")||-1!==uo.indexOf("Chrome")||-1!==uo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ho(n,e){io();var t=window.history;try{if(e){var a=ei({},t.state);a.key=no(),t.replaceState(a,"",n)}else t.pushState({key:eo(Yi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function fo(n){ho(n,!0)}var vo={redirected:2,aborted:4,cancelled:8,duplicated:16};function bo(n,e){return xo(n,e,vo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ko.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return xo(n,e,vo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xo(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var ko=["params","query","hash"];function wo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function Eo(n,e){return wo(n)&&n._isRouter&&(null==e||n.type===e)}function _o(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function Co(n){return function(e,t,a){var r=!1,i=0,o=null;To(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=Io((function(e){var r;((r=e).__esModule||So&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Gi.extend(e),t.components[s]=e,--i<=0&&a()})),d=Io((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=wo(n)?n:new Error(e),a(o))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var m=l.component;m&&"function"==typeof m.then&&m.then(c,d)}}})),r||a()}}function To(n,e){return Ao(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Ao(n){return Array.prototype.concat.apply([],n)}var So="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Io(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Bo=function(n,e){this.router=n,this.base=function(n){if(!n)if(Vi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=ui,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Po(n,e,t,a){var r=To(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=Gi.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return Ao(a?r.reverse():r)}function zo(n,e){if(e)return function(){return n.apply(e,arguments)}}Bo.prototype.listen=function(n){this.cb=n},Bo.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Bo.prototype.onError=function(n){this.errorCbs.push(n)},Bo.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(Eo(n,vo.redirected)&&i===ui||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Bo.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,s=function(n){!Eo(n)&&wo(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(fi(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&ro(this.router,r,n,!1),s(((o=xo(i=r,n,vo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),m=d.updated,p=d.deactivated,u=d.activated,g=[].concat(function(n){return Po(n,"beforeRouteLeave",zo,!0)}(p),this.router.beforeHooks,function(n){return Po(n,"beforeRouteUpdate",zo)}(m),u.map((function(n){return n.beforeEnter})),Co(u)),h=function(e,t){if(a.pending!==n)return s(yo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return xo(n,e,vo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):wo(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(bo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};_o(g,h,(function(){_o(function(n){return Po(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(u).concat(a.router.resolveHooks),h,(function(){if(a.pending!==n)return s(yo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){bi(n)}))}))}))},Bo.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Bo.prototype.setupListeners=function(){},Bo.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=ui,this.pending=null};var Do=function(n){function e(e,t){n.call(this,e,t),this._startLocation=jo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=go&&t;a&&this.listeners.push(ao());var r=function(){var t=n.current,r=jo(n.base);n.current===ui&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ro(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){ho(wi(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){fo(wi(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(jo(this.base)!==this.current.fullPath){var e=wi(this.base+this.current.fullPath);n?ho(e):fo(e)}},e.prototype.getCurrentLocation=function(){return jo(this.base)},e}(Bo);function jo(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(wi(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Oo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=jo(n);if(!/^\/#/.test(e))return window.location.replace(wi(n+"/#"+e)),!0}(this.base)||Fo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=go&&e;t&&this.listeners.push(ao());var a=function(){var e=n.current;Fo()&&n.transitionTo(Mo(),(function(a){t&&ro(n.router,a,e,!0),go||Ro(a.fullPath)}))},r=go?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Lo(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){Ro(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Mo()!==e&&(n?Lo(e):Ro(e))},e.prototype.getCurrentLocation=function(){return Mo()},e}(Bo);function Fo(){var n=Mo();return"/"===n.charAt(0)||(Ro("/"+n),!1)}function Mo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function $o(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Lo(n){go?ho($o(n)):window.location.hash=n}function Ro(n){go?fo($o(n)):window.location.replace($o(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){Eo(n,vo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Bo),Go=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Xi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!go&&!1!==n.fallback,this.fallback&&(e="hash"),Vi||(e="abstract"),this.mode=e,e){case"history":this.history=new Do(this,n.base);break;case"hash":this.history=new Oo(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},qo={currentRoute:{configurable:!0}};Go.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},qo.currentRoute.get=function(){return this.history&&this.history.current},Go.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Do||t instanceof Oo){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;go&&r&&"fullPath"in n&&ro(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Go.prototype.beforeEach=function(n){return Ho(this.beforeHooks,n)},Go.prototype.beforeResolve=function(n){return Ho(this.resolveHooks,n)},Go.prototype.afterEach=function(n){return Ho(this.afterHooks,n)},Go.prototype.onReady=function(n,e){this.history.onReady(n,e)},Go.prototype.onError=function(n){this.history.onError(n)},Go.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Go.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Go.prototype.go=function(n){this.history.go(n)},Go.prototype.back=function(){this.go(-1)},Go.prototype.forward=function(){this.go(1)},Go.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Go.prototype.resolve=function(n,e,t){var a=Ui(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?wi(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},Go.prototype.getRoutes=function(){return this.matcher.getRoutes()},Go.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==ui&&this.history.transitionTo(this.history.getCurrentLocation())},Go.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==ui&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Go.prototype,qo);var No=Go;function Ho(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Go.install=function n(e){if(!n.installed||Gi!==e){n.installed=!0,Gi=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yi),e.component("RouterLink",Ni);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Go.version="3.6.5",Go.isNavigationFailure=Eo,Go.NavigationFailureType=vo,Go.START_LOCATION=ui,Vi&&window.Vue&&window.Vue.use(Go);t(109);t(17),t(106);var Vo={NotFound:()=>Promise.all([t.e(0),t.e(7)]).then(t.bind(null,352)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,350))},Jo={"v-61b8cb42":()=>t.e(10).then(t.bind(null,357)),"v-4de845b7":()=>t.e(11).then(t.bind(null,358)),"v-5d5fac8c":()=>t.e(12).then(t.bind(null,359)),"v-757b99ea":()=>t.e(13).then(t.bind(null,360)),"v-460ef113":()=>t.e(14).then(t.bind(null,361)),"v-f40d089a":()=>t.e(15).then(t.bind(null,362)),"v-9cb9f502":()=>t.e(16).then(t.bind(null,363)),"v-1426ab32":()=>t.e(17).then(t.bind(null,364)),"v-794e1f68":()=>t.e(18).then(t.bind(null,365)),"v-7bcac0e6":()=>t.e(19).then(t.bind(null,366)),"v-005bcd95":()=>t.e(20).then(t.bind(null,367)),"v-3fce6aba":()=>t.e(21).then(t.bind(null,368)),"v-b585bbb4":()=>t.e(22).then(t.bind(null,369)),"v-3bd78159":()=>t.e(23).then(t.bind(null,370)),"v-0b80f274":()=>t.e(24).then(t.bind(null,371)),"v-2332c1f2":()=>t.e(25).then(t.bind(null,372)),"v-aabe0666":()=>t.e(26).then(t.bind(null,373)),"v-7f914f28":()=>t.e(27).then(t.bind(null,374)),"v-5beff70c":()=>t.e(28).then(t.bind(null,375)),"v-2c360072":()=>t.e(29).then(t.bind(null,376)),"v-bd3e73d6":()=>t.e(30).then(t.bind(null,377)),"v-7d723798":()=>t.e(31).then(t.bind(null,378)),"v-50308c98":()=>t.e(32).then(t.bind(null,379)),"v-1c24e404":()=>t.e(33).then(t.bind(null,380)),"v-8b018710":()=>t.e(34).then(t.bind(null,381)),"v-77df4576":()=>t.e(35).then(t.bind(null,382)),"v-18534ad1":()=>t.e(36).then(t.bind(null,383)),"v-cc5927b4":()=>t.e(37).then(t.bind(null,384)),"v-e25aa456":()=>t.e(38).then(t.bind(null,385)),"v-00c545c2":()=>t.e(39).then(t.bind(null,386)),"v-70aac31b":()=>t.e(40).then(t.bind(null,387)),"v-0589c0f2":()=>t.e(41).then(t.bind(null,388)),"v-48484eb8":()=>t.e(42).then(t.bind(null,389)),"v-58d11274":()=>t.e(43).then(t.bind(null,390)),"v-082fdfae":()=>t.e(44).then(t.bind(null,353)),"v-3bf0cc6a":()=>t.e(45).then(t.bind(null,391)),"v-481f7a8e":()=>t.e(46).then(t.bind(null,392)),"v-31f8ea53":()=>t.e(47).then(t.bind(null,393)),"v-6c1991f0":()=>t.e(48).then(t.bind(null,394)),"v-6873a6ea":()=>t.e(49).then(t.bind(null,395)),"v-0576fcbb":()=>t.e(50).then(t.bind(null,396)),"v-6887f1e5":()=>t.e(51).then(t.bind(null,397)),"v-83b82806":()=>t.e(52).then(t.bind(null,398)),"v-3168fb0a":()=>t.e(53).then(t.bind(null,399)),"v-0ce44bc7":()=>t.e(54).then(t.bind(null,400)),"v-680b8ef6":()=>t.e(55).then(t.bind(null,401)),"v-24155794":()=>t.e(56).then(t.bind(null,402)),"v-1fe008ed":()=>t.e(57).then(t.bind(null,403)),"v-20c337c8":()=>t.e(58).then(t.bind(null,404)),"v-10a5e49a":()=>t.e(59).then(t.bind(null,405)),"v-f4316aea":()=>t.e(60).then(t.bind(null,406)),"v-65e9a99b":()=>t.e(61).then(t.bind(null,407)),"v-1bd16c74":()=>t.e(62).then(t.bind(null,408)),"v-771f9586":()=>t.e(63).then(t.bind(null,409)),"v-4616cb7c":()=>t.e(64).then(t.bind(null,410)),"v-1d501bea":()=>t.e(65).then(t.bind(null,411)),"v-aeda6256":()=>t.e(66).then(t.bind(null,412)),"v-6dea94dd":()=>t.e(67).then(t.bind(null,413)),"v-58f7ed24":()=>t.e(68).then(t.bind(null,414)),"v-edcbc950":()=>t.e(69).then(t.bind(null,415)),"v-f6fe71b6":()=>t.e(70).then(t.bind(null,416)),"v-b1641af6":()=>t.e(71).then(t.bind(null,417)),"v-442bcca5":()=>t.e(72).then(t.bind(null,418)),"v-44635ae9":()=>t.e(73).then(t.bind(null,419)),"v-6b5259f3":()=>t.e(74).then(t.bind(null,420)),"v-c2f13d5e":()=>t.e(75).then(t.bind(null,421)),"v-2b03f108":()=>t.e(76).then(t.bind(null,422)),"v-37304324":()=>t.e(77).then(t.bind(null,423)),"v-feca9b46":()=>t.e(78).then(t.bind(null,424)),"v-7dfce7ab":()=>t.e(79).then(t.bind(null,425)),"v-59c4f32d":()=>t.e(80).then(t.bind(null,426)),"v-1a24ff19":()=>t.e(81).then(t.bind(null,427)),"v-fa7509dc":()=>t.e(82).then(t.bind(null,428)),"v-1aa23326":()=>t.e(83).then(t.bind(null,429)),"v-7d93fff2":()=>t.e(84).then(t.bind(null,430)),"v-0ccea3d1":()=>t.e(85).then(t.bind(null,431)),"v-21aac14b":()=>t.e(86).then(t.bind(null,432)),"v-4640f53e":()=>t.e(87).then(t.bind(null,433)),"v-0200859b":()=>t.e(88).then(t.bind(null,434)),"v-2d62fca3":()=>t.e(89).then(t.bind(null,435)),"v-4b2407b4":()=>t.e(90).then(t.bind(null,436)),"v-7881fa56":()=>t.e(91).then(t.bind(null,437)),"v-ecf90178":()=>t.e(92).then(t.bind(null,438)),"v-a48cd908":()=>t.e(93).then(t.bind(null,439)),"v-57d84b4a":()=>t.e(94).then(t.bind(null,440)),"v-5d8f37ec":()=>t.e(95).then(t.bind(null,441)),"v-784843da":()=>t.e(96).then(t.bind(null,442)),"v-4f15d4c2":()=>t.e(97).then(t.bind(null,443)),"v-9821a518":()=>t.e(98).then(t.bind(null,444)),"v-5db5a612":()=>t.e(99).then(t.bind(null,445)),"v-72640f06":()=>t.e(100).then(t.bind(null,446)),"v-2752c5bd":()=>t.e(101).then(t.bind(null,447)),"v-630da19d":()=>t.e(102).then(t.bind(null,448)),"v-727129f0":()=>t.e(103).then(t.bind(null,449)),"v-d712169e":()=>t.e(104).then(t.bind(null,450)),"v-1fc9e54e":()=>t.e(105).then(t.bind(null,451)),"v-0195be44":()=>t.e(106).then(t.bind(null,452)),"v-336f3fe8":()=>t.e(107).then(t.bind(null,453)),"v-69e80c93":()=>t.e(108).then(t.bind(null,454)),"v-1211eca2":()=>t.e(109).then(t.bind(null,455)),"v-c70d9778":()=>t.e(110).then(t.bind(null,456)),"v-47e65f80":()=>t.e(111).then(t.bind(null,457)),"v-3ec0a222":()=>t.e(112).then(t.bind(null,458)),"v-f9ea29ee":()=>t.e(113).then(t.bind(null,459)),"v-b4f8fe5e":()=>t.e(114).then(t.bind(null,460)),"v-0af76612":()=>t.e(115).then(t.bind(null,461)),"v-08a4d6f6":()=>t.e(119).then(t.bind(null,462)),"v-517f137a":()=>t.e(120).then(t.bind(null,463)),"v-49e7087f":()=>t.e(121).then(t.bind(null,464)),"v-0bc371cd":()=>t.e(122).then(t.bind(null,465)),"v-e04d8192":()=>t.e(123).then(t.bind(null,466)),"v-265cccf6":()=>t.e(124).then(t.bind(null,467)),"v-3318fa93":()=>t.e(125).then(t.bind(null,468)),"v-42e1da52":()=>t.e(126).then(t.bind(null,469)),"v-728b9a42":()=>t.e(127).then(t.bind(null,470)),"v-26c1e7e5":()=>t.e(128).then(t.bind(null,471)),"v-65fef59e":()=>t.e(129).then(t.bind(null,472)),"v-bc657dee":()=>t.e(130).then(t.bind(null,473)),"v-f74da980":()=>t.e(131).then(t.bind(null,474)),"v-249801bc":()=>t.e(132).then(t.bind(null,475)),"v-2683afea":()=>t.e(133).then(t.bind(null,476)),"v-5a67b37d":()=>t.e(134).then(t.bind(null,477)),"v-74346634":()=>t.e(135).then(t.bind(null,478)),"v-13ace923":()=>t.e(136).then(t.bind(null,479)),"v-21d1e650":()=>t.e(137).then(t.bind(null,480)),"v-75466e3a":()=>t.e(138).then(t.bind(null,481)),"v-3edde552":()=>t.e(139).then(t.bind(null,482)),"v-f8a4b682":()=>t.e(140).then(t.bind(null,483)),"v-38966624":()=>t.e(141).then(t.bind(null,484)),"v-75d595a3":()=>t.e(142).then(t.bind(null,485)),"v-7b8e7334":()=>t.e(143).then(t.bind(null,486)),"v-009cee4b":()=>t.e(144).then(t.bind(null,487)),"v-7614b482":()=>t.e(145).then(t.bind(null,488)),"v-0d84c87d":()=>t.e(146).then(t.bind(null,489)),"v-50e76cbf":()=>t.e(147).then(t.bind(null,490)),"v-8bdb2f3e":()=>t.e(148).then(t.bind(null,491)),"v-2aed201f":()=>t.e(149).then(t.bind(null,492)),"v-2cdcd46d":()=>t.e(150).then(t.bind(null,493)),"v-3bc566a8":()=>t.e(151).then(t.bind(null,494)),"v-8650f030":()=>t.e(152).then(t.bind(null,495)),"v-9418c160":()=>t.e(153).then(t.bind(null,496)),"v-00827dda":()=>t.e(154).then(t.bind(null,497)),"v-f8b33396":()=>t.e(155).then(t.bind(null,498)),"v-b1388684":()=>t.e(156).then(t.bind(null,499)),"v-594dd699":()=>t.e(157).then(t.bind(null,500)),"v-bb5e48a0":()=>t.e(158).then(t.bind(null,501)),"v-1df84aee":()=>t.e(159).then(t.bind(null,502)),"v-69d20cf3":()=>t.e(160).then(t.bind(null,503)),"v-5d4c8520":()=>t.e(161).then(t.bind(null,504)),"v-4c7328ea":()=>t.e(162).then(t.bind(null,505)),"v-0624a254":()=>t.e(163).then(t.bind(null,506)),"v-4b089667":()=>t.e(116).then(t.bind(null,507)),"v-cb850cc6":()=>t.e(9).then(t.bind(null,508)),"v-07521cf9":()=>t.e(118).then(t.bind(null,509)),"v-7f5075af":()=>t.e(117).then(t.bind(null,510))};function Zo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Xo=/-(\w)/g,Wo=Zo(n=>n.replace(Xo,(n,e)=>e?e.toUpperCase():"")),Qo=/\B([A-Z])/g,Yo=Zo(n=>n.replace(Qo,"-$1").toLowerCase()),Ko=Zo(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Ko(Wo(e))):n(Ko(e))||n(Yo(e))}const es=Object.assign({},Vo,Jo),ts=n=>es[n],as=n=>Jo[n],rs=n=>Vo[n],is=n=>Vt.component(n);function os(n){return ns(as,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(is,n)}function ds(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Vt.component(n,e.default)}}))}function ms(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var ps=t(95),us=t.n(ps),gs=t(96),hs=t.n(gs),fs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${hs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=bs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return us()([{name:"description",content:this.$description}],n,this.siteMeta,xs)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",bs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function bs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ks=t(52),ws={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ks)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},Es=t(26),_s=t.n(Es),Cs={mounted(){_s.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Vt.component(n.name)||_s.a.start(),t()}),this.$router.afterEach(()=>{_s.a.done(),this.isSidebarOpen=!1})}};t(243),t(244);class Ts{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var As={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Ts).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ss={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Is={},Bs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},Ps=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Ss[n]},zs=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},Ds=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},js=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=Bs(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(s.js,s.html);var l=Ps("vue");return s.jsLib.unshift(l),s},Os=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Fs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ms(){var n=Ds(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ds(n,"vuepress-plugin-demo-block__code"),t=Ds(n,"vuepress-plugin-demo-block__display"),a=Ds(n,"vuepress-plugin-demo-block__footer"),r=Ds(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Fs(n),htmlTpl:Bs("")},o=Ps("react"),s=Ps("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Os(i,o):js(i,o),d=zs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(d),d.addEventListener("click",$s.bind(null,d,l,e,a)),Ps("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(Ps("cssLib")).concat(Ps("jsLib")).join(",");return zs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),Ps("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(Ps("jsLib")).join(";"),css_external:i.concat(Ps("cssLib")).join(";"),layout:Ps("codepenLayout"),js_pre_processor:Ps("codepenJsProcessor"),editors:Ps("codepenEditors")});return zs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:Ps("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var m=e.firstChild.cloneNode(!0);m.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(m)}if(c.css&&function(n){if(!Is[n]){var e=zs("style",{innerHTML:n});document.body.appendChild(e),Is[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var p=(new(Vue.extend(c.script))).$mount();r.appendChild(p.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ms()}),300)}function $s(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var Ls={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ms()},updated:function(){Ms()}},Rs="auto",Us="zoom-in",Gs="zoom-out",qs="grab",Ns="move";function Hs(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Vs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Js(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Zs(n,e,t){!function(n){var e=Xs,t=Ws;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Xs="transition",Ws="transform",Qs="transform",Ys="transitionend";var Ks=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Ks,onClose:Ks,onGrab:Ks,onMove:Ks,onRelease:Ks,onBeforeOpen:Ks,onBeforeClose:Ks,onBeforeGrab:Ks,onBeforeRelease:Ks,onImageLoading:Ks,onImageLoaded:Ks},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),al(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!al(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!al(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function al(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Zs(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Zs(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},il="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ol=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Js(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?qs:Gs,transition:Qs+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Zs(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Zs(this.el,{transform:"none"})},grab:function(n,e,t){var a=cl(),r=a.x-n,i=a.y-e;Zs(this.el,{cursor:Ns,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=cl(),r=a.x-n,i=a.y-e;Zs(this.el,{transition:Qs,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Zs(this.el,this.styleClose)},restoreOpenStyle:function(){Zs(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":il(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-o,y:l.y-s},d=c.x/o,m=c.y/s,p=i+Math.min(d,m);if(r&&"string"==typeof r){var u=t||this.el.naturalWidth,g=e||this.el.naturalHeight,h=parseFloat(r)*u/(100*this.rect.width),f=parseFloat(r)*g/(100*this.rect.height);if(p>h||p>f)return{x:h,y:f}}return{x:p,y:p}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function dl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Hs(n,a,e[a],t)}))}var ml=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return ol(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,Hs(n,"click",this.handler.click),this.options.preloadImage&&Vs(Js(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Vs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var i=function n(){Hs(a,Ys,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&dl(document,e.handler,!0),t(a)};return Hs(a,Ys,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Rs,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Hs(t,Ys,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&dl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Ys,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Hs(r,Ys,n,!1),a(r)};return Hs(r,Ys,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Ns,this.target.move(n,e,t);var r=this.target.el,i=function n(){Hs(r,Ys,n,!1),a(r)};return Hs(r,Ys,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Rs,this.target.restoreOpenStyle();var a=function a(){Hs(t,Ys,a,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Ys,a),this}}}]),n}();const pl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ul=Number("500");class gl{constructor(){this.instance=new ml(pl)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ul){setTimeout(()=>this.update(n),e)}}var hl=[fs,ws,Cs,As,Ls,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new gl,this.$vuepress.zooming.updateDelay()}}],fl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ms("layout",n),Vt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(1),bl=Object(vl.a)(fl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(bl,"mixins",hl);const yl=[{name:"v-61b8cb42",path:"/design/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-61b8cb42").then(t)}},{path:"/design/index.html",redirect:"/design/"},{path:"/00.目录/20.软件设计.html",redirect:"/design/"},{name:"v-4de845b7",path:"/frame/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4de845b7").then(t)}},{path:"/frame/index.html",redirect:"/frame/"},{path:"/00.目录/40.常用框架.html",redirect:"/frame/"},{name:"v-5d5fac8c",path:"/tools/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5d5fac8c").then(t)}},{path:"/tools/index.html",redirect:"/tools/"},{path:"/00.目录/50.常用工具.html",redirect:"/tools/"},{name:"v-757b99ea",path:"/language/c++/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-757b99ea").then(t)}},{path:"/language/c++/index.html",redirect:"/language/c++/"},{path:"/10.编程语言/10.C++.html",redirect:"/language/c++/"},{name:"v-460ef113",path:"/language/java/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-460ef113").then(t)}},{path:"/language/java/index.html",redirect:"/language/java/"},{path:"/10.编程语言/20.JAVA.html",redirect:"/language/java/"},{name:"v-f40d089a",path:"/language/go/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f40d089a").then(t)}},{path:"/language/go/index.html",redirect:"/language/go/"},{path:"/10.编程语言/30.Go.html",redirect:"/language/go/"},{name:"v-9cb9f502",path:"/pages/21eaf0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-9cb9f502").then(t)}},{path:"/pages/21eaf0/index.html",redirect:"/pages/21eaf0/"},{path:"/11.算法/1.名词收集.html",redirect:"/pages/21eaf0/"},{name:"v-1426ab32",path:"/pages/e184a5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1426ab32").then(t)}},{path:"/pages/e184a5/index.html",redirect:"/pages/e184a5/"},{path:"/12.操作系统/10.系统的概念.html",redirect:"/pages/e184a5/"},{name:"v-794e1f68",path:"/pages/360dfa/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-794e1f68").then(t)}},{path:"/pages/360dfa/index.html",redirect:"/pages/360dfa/"},{path:"/12.操作系统/20.系统的进程.html",redirect:"/pages/360dfa/"},{name:"v-7bcac0e6",path:"/pages/aac1ac/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7bcac0e6").then(t)}},{path:"/pages/aac1ac/index.html",redirect:"/pages/aac1ac/"},{path:"/12.操作系统/30.系统的线程.html",redirect:"/pages/aac1ac/"},{name:"v-005bcd95",path:"/pages/295c69/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-005bcd95").then(t)}},{path:"/pages/295c69/index.html",redirect:"/pages/295c69/"},{path:"/12.操作系统/40.存储.html",redirect:"/pages/295c69/"},{name:"v-3fce6aba",path:"/design/oo/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3fce6aba").then(t)}},{path:"/design/oo/index.html",redirect:"/design/oo/"},{path:"/20.软件设计/10.面向对象.html",redirect:"/design/oo/"},{name:"v-b585bbb4",path:"/design/GoF/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b585bbb4").then(t)}},{path:"/design/GoF/index.html",redirect:"/design/GoF/"},{path:"/20.软件设计/20.设计模式.html",redirect:"/design/GoF/"},{name:"v-3bd78159",path:"/design/ddd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3bd78159").then(t)}},{path:"/design/ddd/index.html",redirect:"/design/ddd/"},{path:"/20.软件设计/30.领域驱动设计.html",redirect:"/design/ddd/"},{name:"v-0b80f274",path:"/frame/spring/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0b80f274").then(t)}},{path:"/frame/spring/index.html",redirect:"/frame/spring/"},{path:"/40.常用框架/10.后端框架/10.Spring.html",redirect:"/frame/spring/"},{name:"v-2332c1f2",path:"/pages/8292d8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2332c1f2").then(t)}},{path:"/pages/8292d8/index.html",redirect:"/pages/8292d8/"},{path:"/50.常用工具/10.Git/10.手册/00.常用Git命令清单.html",redirect:"/pages/8292d8/"},{name:"v-aabe0666",path:"/pages/c10281/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-aabe0666").then(t)}},{path:"/pages/c10281/index.html",redirect:"/pages/c10281/"},{path:"/50.常用工具/10.Git/10.手册/03.Git变基合并.html",redirect:"/pages/c10281/"},{name:"v-7f914f28",path:"/pages/4cbc21/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7f914f28").then(t)}},{path:"/pages/4cbc21/index.html",redirect:"/pages/4cbc21/"},{path:"/50.常用工具/10.Git/10.手册/06.Git命令思维导图.html",redirect:"/pages/4cbc21/"},{name:"v-5beff70c",path:"/pages/635088/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5beff70c").then(t)}},{path:"/pages/635088/index.html",redirect:"/pages/635088/"},{path:"/50.常用工具/10.Git/20.文档笔记/10.Git基础与命令.html",redirect:"/pages/635088/"},{name:"v-2c360072",path:"/pages/1832fe/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2c360072").then(t)}},{path:"/pages/1832fe/index.html",redirect:"/pages/1832fe/"},{path:"/50.常用工具/10.Git/20.文档笔记/100.Git工具-重写历史.html",redirect:"/pages/1832fe/"},{name:"v-bd3e73d6",path:"/pages/d9e9c6/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-bd3e73d6").then(t)}},{path:"/pages/d9e9c6/index.html",redirect:"/pages/d9e9c6/"},{path:"/50.常用工具/10.Git/20.文档笔记/110.Git工具-重置揭密.html",redirect:"/pages/d9e9c6/"},{name:"v-7d723798",path:"/pages/4bef1a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7d723798").then(t)}},{path:"/pages/4bef1a/index.html",redirect:"/pages/4bef1a/"},{path:"/50.常用工具/10.Git/20.文档笔记/20.Git分支-分支原理.html",redirect:"/pages/4bef1a/"},{name:"v-50308c98",path:"/pages/ea5a8c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-50308c98").then(t)}},{path:"/pages/ea5a8c/index.html",redirect:"/pages/ea5a8c/"},{path:"/50.常用工具/10.Git/20.文档笔记/30.Git分支的新建与合并-分支操作.html",redirect:"/pages/ea5a8c/"},{name:"v-1c24e404",path:"/pages/a399b3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1c24e404").then(t)}},{path:"/pages/a399b3/index.html",redirect:"/pages/a399b3/"},{path:"/50.常用工具/10.Git/20.文档笔记/40.Git分支管理-查看分支.html",redirect:"/pages/a399b3/"},{name:"v-8b018710",path:"/pages/49ee30/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8b018710").then(t)}},{path:"/pages/49ee30/index.html",redirect:"/pages/49ee30/"},{path:"/50.常用工具/10.Git/20.文档笔记/50.Git分支开发工作流.html",redirect:"/pages/49ee30/"},{name:"v-77df4576",path:"/pages/574d62/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-77df4576").then(t)}},{path:"/pages/574d62/index.html",redirect:"/pages/574d62/"},{path:"/50.常用工具/10.Git/20.文档笔记/60.Git分支-远程分支.html",redirect:"/pages/574d62/"},{name:"v-18534ad1",path:"/pages/3a3247/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-18534ad1").then(t)}},{path:"/pages/3a3247/index.html",redirect:"/pages/3a3247/"},{path:"/50.常用工具/10.Git/20.文档笔记/70.Git分支-变基.html",redirect:"/pages/3a3247/"},{name:"v-cc5927b4",path:"/pages/c984d1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-cc5927b4").then(t)}},{path:"/pages/c984d1/index.html",redirect:"/pages/c984d1/"},{path:"/50.常用工具/10.Git/20.文档笔记/80.Git工具-查看修订版本.html",redirect:"/pages/c984d1/"},{name:"v-e25aa456",path:"/pages/76d859/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e25aa456").then(t)}},{path:"/pages/76d859/index.html",redirect:"/pages/76d859/"},{path:"/50.常用工具/10.Git/20.文档笔记/90.Git工具-交互式暂存.html",redirect:"/pages/76d859/"},{name:"v-00c545c2",path:"/pages/6a3b4c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-00c545c2").then(t)}},{path:"/pages/6a3b4c/index.html",redirect:"/pages/6a3b4c/"},{path:"/50.常用工具/20.CMake/1.CMake简述.html",redirect:"/pages/6a3b4c/"},{name:"v-70aac31b",path:"/pages/44f8a2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-70aac31b").then(t)}},{path:"/pages/44f8a2/index.html",redirect:"/pages/44f8a2/"},{path:"/50.常用工具/20.CMake/2.CMake详解.html",redirect:"/pages/44f8a2/"},{name:"v-0589c0f2",path:"/pages/a038dc/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0589c0f2").then(t)}},{path:"/pages/a038dc/index.html",redirect:"/pages/a038dc/"},{path:"/50.常用工具/30.NVM/1.NVM使用.html",redirect:"/pages/a038dc/"},{name:"v-48484eb8",path:"/pages/dafb6a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-48484eb8").then(t)}},{path:"/pages/dafb6a/index.html",redirect:"/pages/dafb6a/"},{path:"/50.常用工具/60.部署/10.认知nginx.html",redirect:"/pages/dafb6a/"},{name:"v-58d11274",path:"/pages/e8f440/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-58d11274").then(t)}},{path:"/pages/e8f440/index.html",redirect:"/pages/e8f440/"},{path:"/50.常用工具/60.部署/20.阿里云存储容器选择.html",redirect:"/pages/e8f440/"},{name:"v-082fdfae",path:"/about/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-082fdfae").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/60.关于/1.介绍.html",redirect:"/about/"},{name:"v-3bf0cc6a",path:"/pages/a2f161/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3bf0cc6a").then(t)}},{path:"/pages/a2f161/index.html",redirect:"/pages/a2f161/"},{path:"/60.关于/10.指南/01.指南/02.介绍.html",redirect:"/pages/a2f161/"},{name:"v-481f7a8e",path:"/pages/793dcb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-481f7a8e").then(t)}},{path:"/pages/793dcb/index.html",redirect:"/pages/793dcb/"},{path:"/60.关于/10.指南/01.指南/03.快速上手.html",redirect:"/pages/793dcb/"},{name:"v-31f8ea53",path:"/pages/2f674a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-31f8ea53").then(t)}},{path:"/pages/2f674a/index.html",redirect:"/pages/2f674a/"},{path:"/60.关于/10.指南/01.指南/04.目录结构.html",redirect:"/pages/2f674a/"},{name:"v-6c1991f0",path:"/pages/33d574/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6c1991f0").then(t)}},{path:"/pages/33d574/index.html",redirect:"/pages/33d574/"},{path:"/60.关于/10.指南/01.指南/05.核心配置和约定.html",redirect:"/pages/33d574/"},{name:"v-6873a6ea",path:"/pages/088c16/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6873a6ea").then(t)}},{path:"/pages/088c16/index.html",redirect:"/pages/088c16/"},{path:"/60.关于/10.指南/01.指南/06.自动生成front matter.html",redirect:"/pages/088c16/"},{name:"v-0576fcbb",path:"/pages/d0d7eb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0576fcbb").then(t)}},{path:"/pages/d0d7eb/index.html",redirect:"/pages/d0d7eb/"},{path:"/60.关于/10.指南/01.指南/07.Markdown 容器.html",redirect:"/pages/d0d7eb/"},{name:"v-6887f1e5",path:"/pages/197691/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6887f1e5").then(t)}},{path:"/pages/197691/index.html",redirect:"/pages/197691/"},{path:"/60.关于/10.指南/01.指南/08.Markdown 中使用组件.html",redirect:"/pages/197691/"},{name:"v-83b82806",path:"/pages/8dfab5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-83b82806").then(t)}},{path:"/pages/8dfab5/index.html",redirect:"/pages/8dfab5/"},{path:"/60.关于/10.指南/02.相关文章/03.使目录栏支持h2~h6标题.html",redirect:"/pages/8dfab5/"},{name:"v-3168fb0a",path:"/pages/dd027d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3168fb0a").then(t)}},{path:"/pages/dd027d/index.html",redirect:"/pages/dd027d/"},{path:"/60.关于/10.指南/02.相关文章/06.如何让你的笔记更有表现力.html",redirect:"/pages/dd027d/"},{name:"v-0ce44bc7",path:"/pages/2b8e22/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0ce44bc7").then(t)}},{path:"/pages/2b8e22/index.html",redirect:"/pages/2b8e22/"},{path:"/60.关于/10.指南/02.相关文章/07.批量操作front matter工具.html",redirect:"/pages/2b8e22/"},{name:"v-680b8ef6",path:"/pages/0fc1d2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-680b8ef6").then(t)}},{path:"/pages/0fc1d2/index.html",redirect:"/pages/0fc1d2/"},{path:"/60.关于/10.指南/02.相关文章/08.部署.html",redirect:"/pages/0fc1d2/"},{name:"v-24155794",path:"/pages/9ae0bd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-24155794").then(t)}},{path:"/pages/9ae0bd/index.html",redirect:"/pages/9ae0bd/"},{path:"/60.关于/10.指南/02.相关文章/09.关于写文章和一级标题.html",redirect:"/pages/9ae0bd/"},{name:"v-1fe008ed",path:"/pages/26997d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1fe008ed").then(t)}},{path:"/pages/26997d/index.html",redirect:"/pages/26997d/"},{path:"/60.关于/10.指南/02.相关文章/10.关于博客搭建与管理.html",redirect:"/pages/26997d/"},{name:"v-20c337c8",path:"/pages/c5a54d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-20c337c8").then(t)}},{path:"/pages/c5a54d/index.html",redirect:"/pages/c5a54d/"},{path:"/60.关于/10.指南/02.相关文章/11.在线编辑和新增文章的方法.html",redirect:"/pages/c5a54d/"},{name:"v-10a5e49a",path:"/pages/83ed2b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-10a5e49a").then(t)}},{path:"/pages/83ed2b/index.html",redirect:"/pages/83ed2b/"},{path:"/60.关于/2.列表.html",redirect:"/pages/83ed2b/"},{name:"v-f4316aea",path:"/pages/a20ce8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f4316aea").then(t)}},{path:"/pages/a20ce8/index.html",redirect:"/pages/a20ce8/"},{path:"/60.关于/20.配置/01.配置/01.主题配置.html",redirect:"/pages/a20ce8/"},{name:"v-65e9a99b",path:"/pages/f14bdb/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-65e9a99b").then(t)}},{path:"/pages/f14bdb/index.html",redirect:"/pages/f14bdb/"},{path:"/60.关于/20.配置/01.配置/02.首页配置.html",redirect:"/pages/f14bdb/"},{name:"v-1bd16c74",path:"/pages/3216b0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1bd16c74").then(t)}},{path:"/pages/3216b0/index.html",redirect:"/pages/3216b0/"},{path:"/60.关于/20.配置/01.配置/03.front matter配置.html",redirect:"/pages/3216b0/"},{name:"v-771f9586",path:"/pages/54651a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-771f9586").then(t)}},{path:"/pages/54651a/index.html",redirect:"/pages/54651a/"},{path:"/60.关于/20.配置/01.配置/04.目录页配置.html",redirect:"/pages/54651a/"},{name:"v-4616cb7c",path:"/pages/1cc523/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4616cb7c").then(t)}},{path:"/pages/1cc523/index.html",redirect:"/pages/1cc523/"},{path:"/60.关于/20.配置/01.配置/05.添加摘要.html",redirect:"/pages/1cc523/"},{name:"v-1d501bea",path:"/pages/f51918/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1d501bea").then(t)}},{path:"/pages/f51918/index.html",redirect:"/pages/f51918/"},{path:"/60.关于/20.配置/01.配置/06.修改主题颜色和样式.html",redirect:"/pages/f51918/"},{name:"v-aeda6256",path:"/pages/ce175c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-aeda6256").then(t)}},{path:"/pages/ce175c/index.html",redirect:"/pages/ce175c/"},{path:"/60.关于/20.配置/01.配置/07.评论栏.html",redirect:"/pages/ce175c/"},{name:"v-6dea94dd",path:"/pages/0a2075/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6dea94dd").then(t)}},{path:"/pages/0a2075/index.html",redirect:"/pages/0a2075/"},{path:"/60.关于/3.资料收集.html",redirect:"/pages/0a2075/"},{name:"v-58f7ed24",path:"/pages/beb6c0bd8a66cea6/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-58f7ed24").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/70.收藏/01.网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-edcbc950",path:"/pages/47cf96/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-edcbc950").then(t)}},{path:"/pages/47cf96/index.html",redirect:"/pages/47cf96/"},{path:"/70.收藏/02.常用的前端轮子.html",redirect:"/pages/47cf96/"},{name:"v-f6fe71b6",path:"/archives/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f6fe71b6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-b1641af6",path:"/categories/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b1641af6").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-442bcca5",path:"/tags/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-442bcca5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-44635ae9",path:"/pages/560a28/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-44635ae9").then(t)}},{path:"/pages/560a28/index.html",redirect:"/pages/560a28/"},{path:"/_posts/随笔/1.水平扩展和垂直扩展.html",redirect:"/pages/560a28/"},{name:"v-6b5259f3",path:"/pages/7cdb84/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-6b5259f3").then(t)}},{path:"/pages/7cdb84/index.html",redirect:"/pages/7cdb84/"},{path:"/_posts/随笔/10.后向纠错.html",redirect:"/pages/7cdb84/"},{name:"v-c2f13d5e",path:"/pages/5ce909/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c2f13d5e").then(t)}},{path:"/pages/5ce909/index.html",redirect:"/pages/5ce909/"},{path:"/_posts/随笔/100.教育的意义.html",redirect:"/pages/5ce909/"},{name:"v-2b03f108",path:"/pages/f96e78/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2b03f108").then(t)}},{path:"/pages/f96e78/index.html",redirect:"/pages/f96e78/"},{path:"/_posts/随笔/11.HelloWord的执行过程.html",redirect:"/pages/f96e78/"},{name:"v-37304324",path:"/pages/876d21/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-37304324").then(t)}},{path:"/pages/876d21/index.html",redirect:"/pages/876d21/"},{path:"/_posts/随笔/12.DNS是怎么工作的.html",redirect:"/pages/876d21/"},{name:"v-feca9b46",path:"/pages/6a8491/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-feca9b46").then(t)}},{path:"/pages/6a8491/index.html",redirect:"/pages/6a8491/"},{path:"/_posts/随笔/13.http和https有什么区别.html",redirect:"/pages/6a8491/"},{name:"v-7dfce7ab",path:"/pages/0ad58c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7dfce7ab").then(t)}},{path:"/pages/0ad58c/index.html",redirect:"/pages/0ad58c/"},{path:"/_posts/随笔/14.ipv4和ipv6有什么区别.html",redirect:"/pages/0ad58c/"},{name:"v-59c4f32d",path:"/pages/fe33e1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-59c4f32d").then(t)}},{path:"/pages/fe33e1/index.html",redirect:"/pages/fe33e1/"},{path:"/_posts/随笔/20.一个网页的执行过程.html",redirect:"/pages/fe33e1/"},{name:"v-1a24ff19",path:"/pages/71575b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1a24ff19").then(t)}},{path:"/pages/71575b/index.html",redirect:"/pages/71575b/"},{path:"/_posts/随笔/30.如何稳定占用一半的CPU.html",redirect:"/pages/71575b/"},{name:"v-fa7509dc",path:"/pages/b9419f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-fa7509dc").then(t)}},{path:"/pages/b9419f/index.html",redirect:"/pages/b9419f/"},{path:"/_posts/随笔/40.如何稳定的占用一半的内存.html",redirect:"/pages/b9419f/"},{name:"v-1aa23326",path:"/pages/2e9782/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1aa23326").then(t)}},{path:"/pages/2e9782/index.html",redirect:"/pages/2e9782/"},{path:"/_posts/随笔/50.如何使用udp做一个安全的传输.html",redirect:"/pages/2e9782/"},{name:"v-7d93fff2",path:"/pages/35cb80/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7d93fff2").then(t)}},{path:"/pages/35cb80/index.html",redirect:"/pages/35cb80/"},{path:"/_posts/随笔/70.TCP下载一个大文件的过程.html",redirect:"/pages/35cb80/"},{name:"v-0ccea3d1",path:"/pages/1eec76/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0ccea3d1").then(t)}},{path:"/pages/1eec76/index.html",redirect:"/pages/1eec76/"},{path:"/_posts/随笔/71.Qt原子操作.html",redirect:"/pages/1eec76/"},{name:"v-21aac14b",path:"/pages/7d6e5c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-21aac14b").then(t)}},{path:"/pages/7d6e5c/index.html",redirect:"/pages/7d6e5c/"},{path:"/_posts/随笔/9.前向纠错.html",redirect:"/pages/7d6e5c/"},{name:"v-4640f53e",path:"/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4640f53e").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-0200859b",path:"/pages/185350/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0200859b").then(t)}},{path:"/pages/185350/index.html",redirect:"/pages/185350/"},{path:"/后端框架--Spring/10.spring_restful注解.html",redirect:"/pages/185350/"},{name:"v-2d62fca3",path:"/pages/a5092c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2d62fca3").then(t)}},{path:"/pages/a5092c/index.html",redirect:"/pages/a5092c/"},{path:"/后端框架--Spring/20.Spring定时任务.html",redirect:"/pages/a5092c/"},{name:"v-4b2407b4",path:"/pages/ab0f00/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4b2407b4").then(t)}},{path:"/pages/ab0f00/index.html",redirect:"/pages/ab0f00/"},{path:"/后端框架--Spring/30.Spring动态定时任务.html",redirect:"/pages/ab0f00/"},{name:"v-7881fa56",path:"/pages/0c8435/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7881fa56").then(t)}},{path:"/pages/0c8435/index.html",redirect:"/pages/0c8435/"},{path:"/后端框架--Spring/40.Spring注册失败.html",redirect:"/pages/0c8435/"},{name:"v-ecf90178",path:"/pages/d62e19/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-ecf90178").then(t)}},{path:"/pages/d62e19/index.html",redirect:"/pages/d62e19/"},{path:"/后端框架--Spring/5.Spring基础/10.Spring初识.html",redirect:"/pages/d62e19/"},{name:"v-a48cd908",path:"/pages/2c89d0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-a48cd908").then(t)}},{path:"/pages/2c89d0/index.html",redirect:"/pages/2c89d0/"},{path:"/后端框架--Spring/5.Spring基础/20.Spring_Xml配置.html",redirect:"/pages/2c89d0/"},{name:"v-57d84b4a",path:"/pages/c35ea5/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-57d84b4a").then(t)}},{path:"/pages/c35ea5/index.html",redirect:"/pages/c35ea5/"},{path:"/后端框架--Spring/5.Spring基础/30.Spring_IOC的XML实现.html",redirect:"/pages/c35ea5/"},{name:"v-5d8f37ec",path:"/pages/af24c9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5d8f37ec").then(t)}},{path:"/pages/af24c9/index.html",redirect:"/pages/af24c9/"},{path:"/后端框架--Spring/5.Spring基础/40.Spring_AOP的XML实现.html",redirect:"/pages/af24c9/"},{name:"v-784843da",path:"/pages/4ea055/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-784843da").then(t)}},{path:"/pages/4ea055/index.html",redirect:"/pages/4ea055/"},{path:"/后端框架--Spring/5.Spring基础/50.Spring_IOC的注解实现.html",redirect:"/pages/4ea055/"},{name:"v-4f15d4c2",path:"/pages/4ea056/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4f15d4c2").then(t)}},{path:"/pages/4ea056/index.html",redirect:"/pages/4ea056/"},{path:"/后端框架--Spring/5.Spring基础/60.Spring_AOP的注解实现.html",redirect:"/pages/4ea056/"},{name:"v-9821a518",path:"/pages/30c07c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-9821a518").then(t)}},{path:"/pages/30c07c/index.html",redirect:"/pages/30c07c/"},{path:"/后端框架--Spring/50.SpringAPI文档knife4j.html",redirect:"/pages/30c07c/"},{name:"v-5db5a612",path:"/pages/08040d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5db5a612").then(t)}},{path:"/pages/08040d/index.html",redirect:"/pages/08040d/"},{path:"/数据库-MySQL/10.SQL基本语法.html",redirect:"/pages/08040d/"},{name:"v-72640f06",path:"/pages/74c8e0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-72640f06").then(t)}},{path:"/pages/74c8e0/index.html",redirect:"/pages/74c8e0/"},{path:"/编程语言--C++/10.基础/1.C++简介.html",redirect:"/pages/74c8e0/"},{name:"v-2752c5bd",path:"/pages/5805d0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2752c5bd").then(t)}},{path:"/pages/5805d0/index.html",redirect:"/pages/5805d0/"},{path:"/编程语言--C++/10.基础/2.HelloWorld.html",redirect:"/pages/5805d0/"},{name:"v-630da19d",path:"/pages/29b4c6/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-630da19d").then(t)}},{path:"/pages/29b4c6/index.html",redirect:"/pages/29b4c6/"},{path:"/编程语言--C++/10.基础/3.C++基础概念.html",redirect:"/pages/29b4c6/"},{name:"v-727129f0",path:"/pages/8498db/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-727129f0").then(t)}},{path:"/pages/8498db/index.html",redirect:"/pages/8498db/"},{path:"/编程语言--C++/10.基础/4.C++基础语法.html",redirect:"/pages/8498db/"},{name:"v-d712169e",path:"/pages/25293e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-d712169e").then(t)}},{path:"/pages/25293e/index.html",redirect:"/pages/25293e/"},{path:"/编程语言--C++/10.基础/5.C++结构体联合体.html",redirect:"/pages/25293e/"},{name:"v-1fc9e54e",path:"/pages/a8b12f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1fc9e54e").then(t)}},{path:"/pages/a8b12f/index.html",redirect:"/pages/a8b12f/"},{path:"/编程语言--C++/10.基础/6.C++类基础概念.html",redirect:"/pages/a8b12f/"},{name:"v-0195be44",path:"/pages/269843/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0195be44").then(t)}},{path:"/pages/269843/index.html",redirect:"/pages/269843/"},{path:"/编程语言--C++/10.基础/7.C++抽象类接口.html",redirect:"/pages/269843/"},{name:"v-336f3fe8",path:"/pages/a79d76/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-336f3fe8").then(t)}},{path:"/pages/a79d76/index.html",redirect:"/pages/a79d76/"},{path:"/编程语言--C++/10.基础/8.C++头文件.html",redirect:"/pages/a79d76/"},{name:"v-69e80c93",path:"/pages/8d1751/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-69e80c93").then(t)}},{path:"/pages/8d1751/index.html",redirect:"/pages/8d1751/"},{path:"/编程语言--C++/10.基础/9.C++枚举和枚举类.html",redirect:"/pages/8d1751/"},{name:"v-1211eca2",path:"/pages/f2ea1e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1211eca2").then(t)}},{path:"/pages/f2ea1e/index.html",redirect:"/pages/f2ea1e/"},{path:"/编程语言--C++/20.深入理解/10.详解：C++内存分配.html",redirect:"/pages/f2ea1e/"},{name:"v-c70d9778",path:"/pages/f95db2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-c70d9778").then(t)}},{path:"/pages/f95db2/index.html",redirect:"/pages/f95db2/"},{path:"/编程语言--C++/20.深入理解/20.详解：变量、引用、指针.html",redirect:"/pages/f95db2/"},{name:"v-47e65f80",path:"/pages/f2ea1f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-47e65f80").then(t)}},{path:"/pages/f2ea1f/index.html",redirect:"/pages/f2ea1f/"},{path:"/编程语言--C++/20.深入理解/30.详解：C++类的默认函数.html",redirect:"/pages/f2ea1f/"},{name:"v-3ec0a222",path:"/pages/9516e1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3ec0a222").then(t)}},{path:"/pages/9516e1/index.html",redirect:"/pages/9516e1/"},{path:"/编程语言--C++/20.深入理解/50.详解：继承和虚表.html",redirect:"/pages/9516e1/"},{name:"v-f9ea29ee",path:"/pages/740f83/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f9ea29ee").then(t)}},{path:"/pages/740f83/index.html",redirect:"/pages/740f83/"},{path:"/编程语言--Java/10.Java基础.html",redirect:"/pages/740f83/"},{name:"v-b4f8fe5e",path:"/pages/e5b6fe/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b4f8fe5e").then(t)}},{path:"/pages/e5b6fe/index.html",redirect:"/pages/e5b6fe/"},{path:"/编程语言--Java/15.JavaBean.html",redirect:"/pages/e5b6fe/"},{name:"v-0af76612",path:"/pages/9a5df1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0af76612").then(t)}},{path:"/pages/9a5df1/index.html",redirect:"/pages/9a5df1/"},{path:"/编程语言--Java/20.Java容器.html",redirect:"/pages/9a5df1/"},{name:"v-08a4d6f6",path:"/pages/5fcd9c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-08a4d6f6").then(t)}},{path:"/pages/5fcd9c/index.html",redirect:"/pages/5fcd9c/"},{path:"/编程语言--Java/30.泛型和数据结构.html",redirect:"/pages/5fcd9c/"},{name:"v-517f137a",path:"/pages/e9f877/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-517f137a").then(t)}},{path:"/pages/e9f877/index.html",redirect:"/pages/e9f877/"},{path:"/编程语言--Java/40.JAVA反射.html",redirect:"/pages/e9f877/"},{name:"v-49e7087f",path:"/pages/be8065/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-49e7087f").then(t)}},{path:"/pages/be8065/index.html",redirect:"/pages/be8065/"},{path:"/编程语言--Java/50.JUnit单元测试.html",redirect:"/pages/be8065/"},{name:"v-0bc371cd",path:"/pages/8388fc/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0bc371cd").then(t)}},{path:"/pages/8388fc/index.html",redirect:"/pages/8388fc/"},{path:"/编程语言--Java/60.JAVA内存.html",redirect:"/pages/8388fc/"},{name:"v-e04d8192",path:"/pages/72b069/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-e04d8192").then(t)}},{path:"/pages/72b069/index.html",redirect:"/pages/72b069/"},{path:"/编程语言--golang/1.HelloWorld.html",redirect:"/pages/72b069/"},{name:"v-265cccf6",path:"/pages/10f9a7/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-265cccf6").then(t)}},{path:"/pages/10f9a7/index.html",redirect:"/pages/10f9a7/"},{path:"/编程语言--golang/2.基础.html",redirect:"/pages/10f9a7/"},{name:"v-3318fa93",path:"/pages/7f78ce/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3318fa93").then(t)}},{path:"/pages/7f78ce/index.html",redirect:"/pages/7f78ce/"},{path:"/编程语言--golang/3.控制流.html",redirect:"/pages/7f78ce/"},{name:"v-42e1da52",path:"/pages/600b2c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-42e1da52").then(t)}},{path:"/pages/600b2c/index.html",redirect:"/pages/600b2c/"},{path:"/编程语言--golang/4.更多类型.html",redirect:"/pages/600b2c/"},{name:"v-728b9a42",path:"/pages/7a5364/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-728b9a42").then(t)}},{path:"/pages/7a5364/index.html",redirect:"/pages/7a5364/"},{path:"/编程语言--golang/5.方法.html",redirect:"/pages/7a5364/"},{name:"v-26c1e7e5",path:"/pages/0466ae/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-26c1e7e5").then(t)}},{path:"/pages/0466ae/index.html",redirect:"/pages/0466ae/"},{path:"/编程语言--golang/6.并发.html",redirect:"/pages/0466ae/"},{name:"v-65fef59e",path:"/pages/eb366e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-65fef59e").then(t)}},{path:"/pages/eb366e/index.html",redirect:"/pages/eb366e/"},{path:"/软件设计--设计模式/0.设计模式总览.html",redirect:"/pages/eb366e/"},{name:"v-bc657dee",path:"/pages/715e9b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-bc657dee").then(t)}},{path:"/pages/715e9b/index.html",redirect:"/pages/715e9b/"},{path:"/软件设计--设计模式/1.简单工厂模式.html",redirect:"/pages/715e9b/"},{name:"v-f74da980",path:"/pages/c938fe/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f74da980").then(t)}},{path:"/pages/c938fe/index.html",redirect:"/pages/c938fe/"},{path:"/软件设计--设计模式/10.装饰模式.html",redirect:"/pages/c938fe/"},{name:"v-249801bc",path:"/pages/4d70d2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-249801bc").then(t)}},{path:"/pages/4d70d2/index.html",redirect:"/pages/4d70d2/"},{path:"/软件设计--设计模式/11.代理模式.html",redirect:"/pages/4d70d2/"},{name:"v-2683afea",path:"/pages/51f3ea/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2683afea").then(t)}},{path:"/pages/51f3ea/index.html",redirect:"/pages/51f3ea/"},{path:"/软件设计--设计模式/12.桥模式.html",redirect:"/pages/51f3ea/"},{name:"v-5a67b37d",path:"/pages/54282c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5a67b37d").then(t)}},{path:"/pages/54282c/index.html",redirect:"/pages/54282c/"},{path:"/软件设计--设计模式/13.适配器模式.html",redirect:"/pages/54282c/"},{name:"v-74346634",path:"/pages/d6c716/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-74346634").then(t)}},{path:"/pages/d6c716/index.html",redirect:"/pages/d6c716/"},{path:"/软件设计--设计模式/14.迭代器模式.html",redirect:"/pages/d6c716/"},{name:"v-13ace923",path:"/pages/918f6b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-13ace923").then(t)}},{path:"/pages/918f6b/index.html",redirect:"/pages/918f6b/"},{path:"/软件设计--设计模式/15.备忘录模式.html",redirect:"/pages/918f6b/"},{name:"v-21d1e650",path:"/pages/b2b690/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-21d1e650").then(t)}},{path:"/pages/b2b690/index.html",redirect:"/pages/b2b690/"},{path:"/软件设计--设计模式/16.命令模式.html",redirect:"/pages/b2b690/"},{name:"v-75466e3a",path:"/pages/135e7e/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-75466e3a").then(t)}},{path:"/pages/135e7e/index.html",redirect:"/pages/135e7e/"},{path:"/软件设计--设计模式/17.组合模式.html",redirect:"/pages/135e7e/"},{name:"v-3edde552",path:"/pages/88b3b0/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3edde552").then(t)}},{path:"/pages/88b3b0/index.html",redirect:"/pages/88b3b0/"},{path:"/软件设计--设计模式/18.职责链模式.html",redirect:"/pages/88b3b0/"},{name:"v-f8a4b682",path:"/pages/d342b4/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f8a4b682").then(t)}},{path:"/pages/d342b4/index.html",redirect:"/pages/d342b4/"},{path:"/软件设计--设计模式/19.访问者模式.html",redirect:"/pages/d342b4/"},{name:"v-38966624",path:"/pages/3726e2/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-38966624").then(t)}},{path:"/pages/3726e2/index.html",redirect:"/pages/3726e2/"},{path:"/软件设计--设计模式/2.工厂模式.html",redirect:"/pages/3726e2/"},{name:"v-75d595a3",path:"/pages/ff0ba9/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-75d595a3").then(t)}},{path:"/pages/ff0ba9/index.html",redirect:"/pages/ff0ba9/"},{path:"/软件设计--设计模式/20.解释器模式.html",redirect:"/pages/ff0ba9/"},{name:"v-7b8e7334",path:"/pages/37df0f/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7b8e7334").then(t)}},{path:"/pages/37df0f/index.html",redirect:"/pages/37df0f/"},{path:"/软件设计--设计模式/21.中介者模式.html",redirect:"/pages/37df0f/"},{name:"v-009cee4b",path:"/pages/7cdad8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-009cee4b").then(t)}},{path:"/pages/7cdad8/index.html",redirect:"/pages/7cdad8/"},{path:"/软件设计--设计模式/22.观察者模式.html",redirect:"/pages/7cdad8/"},{name:"v-7614b482",path:"/pages/d841b1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7614b482").then(t)}},{path:"/pages/d841b1/index.html",redirect:"/pages/d841b1/"},{path:"/软件设计--设计模式/23.状态模式.html",redirect:"/pages/d841b1/"},{name:"v-0d84c87d",path:"/pages/d741b1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0d84c87d").then(t)}},{path:"/pages/d741b1/index.html",redirect:"/pages/d741b1/"},{path:"/软件设计--设计模式/24.建造者模式.html",redirect:"/pages/d741b1/"},{name:"v-50e76cbf",path:"/pages/d731b1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-50e76cbf").then(t)}},{path:"/pages/d731b1/index.html",redirect:"/pages/d731b1/"},{path:"/软件设计--设计模式/25.设计模式回顾.html",redirect:"/pages/d731b1/"},{name:"v-8bdb2f3e",path:"/pages/8f3579/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8bdb2f3e").then(t)}},{path:"/pages/8f3579/index.html",redirect:"/pages/8f3579/"},{path:"/软件设计--设计模式/3.外观（面板）模式.html",redirect:"/pages/8f3579/"},{name:"v-2aed201f",path:"/pages/8bab8c/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2aed201f").then(t)}},{path:"/pages/8bab8c/index.html",redirect:"/pages/8bab8c/"},{path:"/软件设计--设计模式/4.单例模式.html",redirect:"/pages/8bab8c/"},{name:"v-2cdcd46d",path:"/pages/e4eef8/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-2cdcd46d").then(t)}},{path:"/pages/e4eef8/index.html",redirect:"/pages/e4eef8/"},{path:"/软件设计--设计模式/5.原型模式.html",redirect:"/pages/e4eef8/"},{name:"v-3bc566a8",path:"/pages/b0b3d1/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-3bc566a8").then(t)}},{path:"/pages/b0b3d1/index.html",redirect:"/pages/b0b3d1/"},{path:"/软件设计--设计模式/6.抽象工厂模式.html",redirect:"/pages/b0b3d1/"},{name:"v-8650f030",path:"/pages/dfc73d/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-8650f030").then(t)}},{path:"/pages/dfc73d/index.html",redirect:"/pages/dfc73d/"},{path:"/软件设计--设计模式/7.模板方法模式.html",redirect:"/pages/dfc73d/"},{name:"v-9418c160",path:"/pages/37ea50/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-9418c160").then(t)}},{path:"/pages/37ea50/index.html",redirect:"/pages/37ea50/"},{path:"/软件设计--设计模式/8.策略模式.html",redirect:"/pages/37ea50/"},{name:"v-00827dda",path:"/pages/fc67c3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-00827dda").then(t)}},{path:"/pages/fc67c3/index.html",redirect:"/pages/fc67c3/"},{path:"/软件设计--设计模式/9.享元模式.html",redirect:"/pages/fc67c3/"},{name:"v-f8b33396",path:"/pages/3ea3c4/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-f8b33396").then(t)}},{path:"/pages/3ea3c4/index.html",redirect:"/pages/3ea3c4/"},{path:"/软件设计--面向对象/1.OO的世界.html",redirect:"/pages/3ea3c4/"},{name:"v-b1388684",path:"/pages/9ac8f7/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-b1388684").then(t)}},{path:"/pages/9ac8f7/index.html",redirect:"/pages/9ac8f7/"},{path:"/软件设计--面向对象/2.面向对象的核心概念.html",redirect:"/pages/9ac8f7/"},{name:"v-594dd699",path:"/pages/34e57a/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-594dd699").then(t)}},{path:"/pages/34e57a/index.html",redirect:"/pages/34e57a/"},{path:"/软件设计--领域驱动设计/10.初识DDD.html",redirect:"/pages/34e57a/"},{name:"v-bb5e48a0",path:"/pages/210a5b/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-bb5e48a0").then(t)}},{path:"/pages/210a5b/index.html",redirect:"/pages/210a5b/"},{path:"/软件设计--领域驱动设计/20.DDD概览.html",redirect:"/pages/210a5b/"},{name:"v-1df84aee",path:"/pages/e880da/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-1df84aee").then(t)}},{path:"/pages/e880da/index.html",redirect:"/pages/e880da/"},{path:"/软件设计--领域驱动设计/30.值对象、DP.html",redirect:"/pages/e880da/"},{name:"v-69d20cf3",path:"/pages/e88Odc/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-69d20cf3").then(t)}},{path:"/pages/e88Odc/index.html",redirect:"/pages/e88Odc/"},{path:"/软件设计--领域驱动设计/40.实体、领域服务、应用服务.html",redirect:"/pages/e88Odc/"},{name:"v-5d4c8520",path:"/pages/e880df/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-5d4c8520").then(t)}},{path:"/pages/e880df/index.html",redirect:"/pages/e880df/"},{path:"/软件设计--领域驱动设计/50.基于Cola的初步实践.html",redirect:"/pages/e880df/"},{name:"v-4c7328ea",path:"/pages/e880db/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4c7328ea").then(t)}},{path:"/pages/e880db/index.html",redirect:"/pages/e880db/"},{path:"/软件设计--领域驱动设计/60.贫血模型和充血模型.html",redirect:"/pages/e880db/"},{name:"v-0624a254",path:"/pages/e880dd/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-0624a254").then(t)}},{path:"/pages/e880dd/index.html",redirect:"/pages/e880dd/"},{path:"/软件设计--领域驱动设计/70.统一语言.html",redirect:"/pages/e880dd/"},{name:"v-4b089667",path:"/pages/311ce3/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-4b089667").then(t)}},{path:"/pages/311ce3/index.html",redirect:"/pages/311ce3/"},{path:"/编程语言--Java/21.容器类型/1.List.html",redirect:"/pages/311ce3/"},{name:"v-cb850cc6",path:"/language/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-cb850cc6").then(t)}},{path:"/language/index.html",redirect:"/language/"},{path:"/00.目录/10.编程语言.html",redirect:"/language/"},{name:"v-07521cf9",path:"/pages/9e1298/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-07521cf9").then(t)}},{path:"/pages/9e1298/index.html",redirect:"/pages/9e1298/"},{path:"/编程语言--Java/21.容器类型/3.map.html",redirect:"/pages/9e1298/"},{name:"v-7f5075af",path:"/pages/df5401/",component:bl,beforeEnter:(n,e,t)=>{ds("Layout","v-7f5075af").then(t)}},{path:"/pages/df5401/index.html",redirect:"/pages/df5401/"},{path:"/编程语言--Java/21.容器类型/2.set.html",redirect:"/pages/df5401/"},{path:"*",component:bl}],xl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["link",{rel:"stylesheet",href:"https://at.alicdn.com/t/font_3077305_pt8umhrn4k9.css"}],["meta",{name:"referrer",content:"no-referrer-when-downgrade"}],["meta",{name:"keywords",content:"su-dd,苏呆呆,苏呆呆的博客,呆呆的博客,个人技术博客,技术文档,c++基础,c++提高,c11,c++新特性,c++,java,spring,ddd,面向对象,设计模式,汇编,git,springcloud,面试,git,github,markdown,md文档,vdoing,demo"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"baidu_union_verify",content:"0c4ba741a75f427faa8dd9c724a81b73"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["script",{},'var _hmt = _hmt || [];\n      (function() {\n        var hm = document.createElement("script");\n        hm.src = "https://hm.baidu.com/hm.js?3d63e1b0aa607833cafb451888226547";\n        var s = document.getElementsByTagName("script")[0]; \n        s.parentNode.insertBefore(hm, s);\n      })();'],["script",{async:"async",src:"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","data-ad-client":"ca-pub-2770102725717150",crossorigin:"anonymous"}]],pages:[{title:"软件设计",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"20.软件设计",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"软件设计相关知识的收集、学习、整理"}},title:"软件设计",date:"2022-05-01T22:58:59.000Z",permalink:"/design",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95/20.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1.html",relativePath:"00.目录/20.软件设计.md",key:"v-61b8cb42",path:"/design/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"常用框架",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"40.常用框架",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"常用框架"}},title:"常用框架",date:"2022-06--7 23:03:25",permalink:"/frame",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95/40.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6.html",relativePath:"00.目录/40.常用框架.md",key:"v-4de845b7",path:"/frame/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"常用工具",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"50.常用工具",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"工具使用方式记录"}},title:"常用工具",date:"2022-05-01T23:03:25.000Z",permalink:"/tools",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7.html",relativePath:"00.目录/50.常用工具.md",key:"v-5d5fac8c",path:"/tools/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"C++",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"编程语言--C++",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"C++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程范式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。"}},title:"C++",date:"2022-05-15T22:09:17.000Z",permalink:"/language/c++",article:!1,comment:!1,editLink:!1},regularPath:"/10.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/10.C++.html",relativePath:"10.编程语言/10.C++.md",key:"v-757b99ea",path:"/language/c++/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Java",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"编程语言--Java",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对Java相关内容的收集和记录"}},title:"Java",date:"2022-05-15T22:09:17.000Z",permalink:"/language/java",article:!1,comment:!1,editLink:!1},regularPath:"/10.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/20.JAVA.html",relativePath:"10.编程语言/20.JAVA.md",key:"v-460ef113",path:"/language/java/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Go",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"编程语言--golang",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"目前所有内容来着：https://tour.go-zh.org/"}},title:"Go",date:"2022-05-15T22:09:17.000Z",permalink:"/language/go",article:!1,comment:!1,editLink:!1},regularPath:"/10.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/30.Go.html",relativePath:"10.编程语言/30.Go.md",key:"v-f40d089a",path:"/language/go/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"名词收集",frontmatter:{title:"名词收集",date:"2022-06-10T23:36:34.000Z",permalink:"/pages/21eaf0/",categories:["知识积累","常见知识"],tags:[null]},regularPath:"/11.%E7%AE%97%E6%B3%95/1.%E5%90%8D%E8%AF%8D%E6%94%B6%E9%9B%86.html",relativePath:"11.算法/1.名词收集.md",key:"v-9cb9f502",path:"/pages/21eaf0/",headersStr:null,content:"算法思想： 1、枚举（穷举） 2、递推 3、递归 4、分治 5、概率算法 6、回溯（试探） 7、贪心 8、迭代（辗转） 9、模拟 10、动态规划 11、分支界限 12、近似\n\n贪心算法 动态规划 遗传算法 模拟退火算法 蚁群算法\n\n算法： 1、排序算法 2、B+树 3、LSM-Tree 4、布隆过滤 5、Tire树 6、红黑树 7、雷达树 8、Quad-Tree",normalizedContent:"算法思想： 1、枚举（穷举） 2、递推 3、递归 4、分治 5、概率算法 6、回溯（试探） 7、贪心 8、迭代（辗转） 9、模拟 10、动态规划 11、分支界限 12、近似\n\n贪心算法 动态规划 遗传算法 模拟退火算法 蚁群算法\n\n算法： 1、排序算法 2、b+树 3、lsm-tree 4、布隆过滤 5、tire树 6、红黑树 7、雷达树 8、quad-tree",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"系统的概念",frontmatter:{title:"系统的概念",date:"2022-06-10T23:46:02.000Z",permalink:"/pages/e184a5/",categories:["知识积累","系统"],tags:[null]},regularPath:"/12.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/10.%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5.html",relativePath:"12.操作系统/10.系统的概念.md",key:"v-1426ab32",path:"/pages/e184a5/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"进程",frontmatter:{title:"进程",date:"2022-06-10T23:46:49.000Z",permalink:"/pages/360dfa/",categories:["知识积累","系统"],tags:[null]},regularPath:"/12.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20.%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B.html",relativePath:"12.操作系统/20.系统的进程.md",key:"v-794e1f68",path:"/pages/360dfa/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"线程",frontmatter:{title:"线程",date:"2022-06-10T23:47:16.000Z",permalink:"/pages/aac1ac/",categories:["知识积累","系统"],tags:[null]},regularPath:"/12.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/30.%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B.html",relativePath:"12.操作系统/30.系统的线程.md",key:"v-7bcac0e6",path:"/pages/aac1ac/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"内存",frontmatter:{title:"内存",date:"2022-06-10T23:47:45.000Z",permalink:"/pages/295c69/",categories:["知识积累","系统"],tags:[null]},regularPath:"/12.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/40.%E5%AD%98%E5%82%A8.html",relativePath:"12.操作系统/40.存储.md",key:"v-005bcd95",path:"/pages/295c69/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"面向对象",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"软件设计--面向对象",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对《面向对象》相关内容的收集和记录"}},title:"面向对象",date:"2022-05-15T22:09:17.000Z",permalink:"/design/oo",article:!1,comment:!1,editLink:!1},regularPath:"/20.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/10.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"20.软件设计/10.面向对象.md",key:"v-3fce6aba",path:"/design/oo/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"设计模式",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"软件设计--设计模式",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对《设计模式》相关内容的收集和记录"}},title:"设计模式",date:"2022-05-15T22:09:17.000Z",permalink:"/design/GoF",article:!1,comment:!1,editLink:!1},regularPath:"/20.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/20.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"20.软件设计/20.设计模式.md",key:"v-b585bbb4",path:"/design/GoF/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"领域驱动设计",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"软件设计--领域驱动设计",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对《领域驱动设计》相关内容的收集和记录；文章从面向对象，代码优化入手，同大家一起了解DDD。"}},title:"领域驱动设计",date:"2022-05-15T22:09:17.000Z",permalink:"/design/ddd",article:!1,comment:!1,editLink:!1},regularPath:"/20.%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/30.%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.html",relativePath:"20.软件设计/30.领域驱动设计.md",key:"v-3bd78159",path:"/design/ddd/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Spring相关",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"后端框架--Spring",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对Spring相关内容的收集和记录"}},title:"Spring相关",date:"2022-05-15T22:09:17.000Z",permalink:"/frame/spring",article:!1,comment:!1,editLink:!1},regularPath:"/40.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/10.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/10.Spring.html",relativePath:"40.常用框架/10.后端框架/10.Spring.md",key:"v-0b80f274",path:"/frame/spring/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"常用Git命令清单",frontmatter:{title:"常用Git命令清单",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/8292d8/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html",relativePath:"50.常用工具/10.Git/10.手册/00.常用Git命令清单.md",key:"v-2332c1f2",path:"/pages/8292d8/",headers:[{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:187},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:334},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:605},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:1005},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1406},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2199},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2616},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3725},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4147},{level:2,title:"十、常用操作组合",slug:"十、常用操作组合",normalizedTitle:"十、常用操作组合",charIndex:4799},{level:3,title:"1. 修改本地分支名和远程分支名",slug:"_1-修改本地分支名和远程分支名",normalizedTitle:"1. 修改本地分支名和远程分支名",charIndex:4812}],headersStr:"一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、常用操作组合 1. 修改本地分支名和远程分支名",content:'# 常用Git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n>  * Workspace：工作区\n>  * Index / Stage：暂存区\n>  * Repository：仓库区（或本地仓库）\n>  * Remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n1\n2\n3\n\n\n相关文章：\n\n《如何撤销 Git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',normalizedContent:'# 常用git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 git 命令清单。几个专用名词的译名如下。\n\n>  * workspace：工作区\n>  * index / stage：暂存区\n>  * repository：仓库区（或本地仓库）\n>  * remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n1\n2\n3\n\n\n相关文章：\n\n《如何撤销 git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Git变基合并",frontmatter:{title:"Git变基合并",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c10281/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/10.%E6%89%8B%E5%86%8C/03.Git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6.html",relativePath:"50.常用工具/10.Git/10.手册/03.Git变基合并.md",key:"v-aabe0666",path:"/pages/c10281/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:17},{level:3,title:"变基要遵守的准则",slug:"变基要遵守的准则",normalizedTitle:"变基要遵守的准则",charIndex:750},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:815},{level:2,title:"后悔药",slug:"后悔药",normalizedTitle:"后悔药",charIndex:531},{level:2,title:"开发期间的rebase操作",slug:"开发期间的rebase操作",normalizedTitle:"开发期间的rebase操作",charIndex:1887},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:1905},{level:3,title:"操作步骤",slug:"操作步骤",normalizedTitle:"操作步骤",charIndex:2159},{level:3,title:"git cherry-pick",slug:"git-cherry-pick",normalizedTitle:"git cherry-pick",charIndex:2524},{level:4,title:"基本应用",slug:"基本应用",normalizedTitle:"基本应用",charIndex:2595},{level:4,title:"转移多个提交",slug:"转移多个提交",normalizedTitle:"转移多个提交",charIndex:2777}],headersStr:"说明 变基要遵守的准则 变基的实质 后悔药 开发期间的rebase操作 背景 操作步骤 git cherry-pick 基本应用 转移多个提交",content:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (HEAD -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看HEAD指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (HEAD -> v2, master) HEAD@{0}: checkout: moving from master to v2\n07c398f (HEAD -> v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master\n07c398f (HEAD -> v2, master) HEAD@{2}: rebase (start): checkout v2\n15a97d8 HEAD@{3}: reset: moving to 15a97d8\n07c398f (HEAD -> v2, master) HEAD@{4}: merge v2: Fast-forward\n15a97d8 HEAD@{5}: checkout: moving from v2 to master\n07c398f (HEAD -> v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (HEAD -> v2, master) HEAD@{7}: rebase (pick): C\n15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase\nd278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 HEAD@{10}: commit: D\n\n# 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9}\ngit reset --hard d278ecd  # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\n1\n2\n\n\n2.4-dev 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n1\n2\n3\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n1\n2\n3\n4\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit ID 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n    \n    1\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n    \n    1\n    2\n    3\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n# 基本应用\n\ngit cherry-pick <commitHash> # 将commitHash应用于当前分支\n\n\n1\n\n\n上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n# 转移多个提交\n\nCherry pick 支持一次转移多个提交。\n\ngit cherry-pick <HashA> <HashB> # A和B提交\n\n\n1\n\n\n上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick A..B # A到B提交，不包含A\n\n\n1\n\n\n上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\n\ngit cherry-pick A^..B # A到B提交，包含A\n\n\n1\n",normalizedContent:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (head -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看head指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (head -> v2, master) head@{0}: checkout: moving from master to v2\n07c398f (head -> v2, master) head@{1}: rebase (finish): returning to refs/heads/master\n07c398f (head -> v2, master) head@{2}: rebase (start): checkout v2\n15a97d8 head@{3}: reset: moving to 15a97d8\n07c398f (head -> v2, master) head@{4}: merge v2: fast-forward\n15a97d8 head@{5}: checkout: moving from v2 to master\n07c398f (head -> v2, master) head@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (head -> v2, master) head@{7}: rebase (pick): c\n15a97d8 head@{8}: rebase (start): checkout master # 首次rebase\nd278ecd head@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 head@{10}: commit: d\n\n# 可见，示例中最初的 rebase 操作是 head@{8}，想回退到变基前的状态需让指针指向 head@{9}\ngit reset --hard d278ecd  # 重置当前分支的head为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\n1\n2\n\n\n2.4-dev 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n1\n2\n3\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n1\n2\n3\n4\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit id 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n    \n    1\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n    \n    1\n    2\n    3\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n# 基本应用\n\ngit cherry-pick <commithash> # 将commithash应用于当前分支\n\n\n1\n\n\n上面命令就会将指定的提交commithash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n# 转移多个提交\n\ncherry pick 支持一次转移多个提交。\n\ngit cherry-pick <hasha> <hashb> # a和b提交\n\n\n1\n\n\n上面的命令将 a 和 b 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick a..b # a到b提交，不包含a\n\n\n1\n\n\n上面的命令可以转移从 a 到 b 的所有提交。它们必须按照正确的顺序放置：提交 a 必须早于提交 b，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 a 将不会包含在 cherry pick 中。如果要包含提交 a，可以使用下面的语法。\n\ngit cherry-pick a^..b # a到b提交，包含a\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git命令思维导图",frontmatter:{title:"Git命令思维导图",date:"2020-11-18T17:46:22.000Z",permalink:"/pages/4cbc21/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/10.%E6%89%8B%E5%86%8C/06.Git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"50.常用工具/10.Git/10.手册/06.Git命令思维导图.md",key:"v-7f914f28",path:"/pages/4cbc21/",headersStr:null,content:"文档来源：数据不是我归纳的，下次标注下。",normalizedContent:"文档来源：数据不是我归纳的，下次标注下。",charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Git基础与命令",frontmatter:{title:"Git基础与命令",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/635088/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10.Git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4.html",relativePath:"50.常用工具/10.Git/20.文档笔记/10.Git基础与命令.md",key:"v-5beff70c",path:"/pages/635088/",headers:[{level:2,title:"Git基础",slug:"git基础",normalizedTitle:"git基础",charIndex:2},{level:3,title:"全局配置",slug:"全局配置",normalizedTitle:"全局配置",charIndex:93},{level:3,title:"检查配置信息",slug:"检查配置信息",normalizedTitle:"检查配置信息",charIndex:202},{level:3,title:"获取帮助",slug:"获取帮助",normalizedTitle:"获取帮助",charIndex:237},{level:3,title:"初始化仓库",slug:"初始化仓库",normalizedTitle:"初始化仓库",charIndex:398},{level:3,title:"克隆远程仓库",slug:"克隆远程仓库",normalizedTitle:"克隆远程仓库",charIndex:474},{level:3,title:"检查文件状态",slug:"检查文件状态",normalizedTitle:"检查文件状态",charIndex:623},{level:3,title:"加入暂存区 (跟踪文件)",slug:"加入暂存区-跟踪文件",normalizedTitle:"加入暂存区 (跟踪文件)",charIndex:950},{level:3,title:"忽略文件",slug:"忽略文件",normalizedTitle:"忽略文件",charIndex:1119},{level:3,title:"查看修改的具体内容",slug:"查看修改的具体内容",normalizedTitle:"查看修改的具体内容",charIndex:2105},{level:3,title:"提交更新",slug:"提交更新",normalizedTitle:"提交更新",charIndex:2263},{level:3,title:"跳过使用暂存区域",slug:"跳过使用暂存区域",normalizedTitle:"跳过使用暂存区域",charIndex:2406},{level:2,title:"Git 基础 - 查看提交历史",slug:"git-基础-查看提交历史",normalizedTitle:"git 基础 - 查看提交历史",charIndex:2506},{level:2,title:"Git 基础 - 撤消操作",slug:"git-基础-撤消操作",normalizedTitle:"git 基础 - 撤消操作",charIndex:4022},{level:2,title:"Git 基础 - 远程仓库的使用",slug:"git-基础-远程仓库的使用",normalizedTitle:"git 基础 - 远程仓库的使用",charIndex:4228},{level:3,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:4249},{level:3,title:"添加远程仓库",slug:"添加远程仓库",normalizedTitle:"添加远程仓库",charIndex:4323},{level:3,title:"从远程仓库中抓取与拉取",slug:"从远程仓库中抓取与拉取",normalizedTitle:"从远程仓库中抓取与拉取",charIndex:4370},{level:3,title:"推送到远程仓库",slug:"推送到远程仓库",normalizedTitle:"推送到远程仓库",charIndex:1106},{level:3,title:"查看某个远程仓库",slug:"查看某个远程仓库",normalizedTitle:"查看某个远程仓库",charIndex:4825},{level:3,title:"远程仓库的重命名与移除",slug:"远程仓库的重命名与移除",normalizedTitle:"远程仓库的重命名与移除",charIndex:4951},{level:2,title:"Git 基础 - 打标签",slug:"git-基础-打标签",normalizedTitle:"git 基础 - 打标签",charIndex:5049},{level:3,title:"列出标签",slug:"列出标签",normalizedTitle:"列出标签",charIndex:5066},{level:3,title:"创建标签",slug:"创建标签",normalizedTitle:"创建标签",charIndex:5164},{level:3,title:"附注标签",slug:"附注标签",normalizedTitle:"附注标签",charIndex:5199},{level:3,title:"轻量标签",slug:"轻量标签",normalizedTitle:"轻量标签",charIndex:5181},{level:3,title:"后期打标签",slug:"后期打标签",normalizedTitle:"后期打标签",charIndex:5893},{level:3,title:"共享标签",slug:"共享标签",normalizedTitle:"共享标签",charIndex:6294},{level:3,title:"删除标签",slug:"删除标签",normalizedTitle:"删除标签",charIndex:6527},{level:3,title:"检出标签",slug:"检出标签",normalizedTitle:"检出标签",charIndex:7014},{level:2,title:"Git 命令别名",slug:"git-命令别名",normalizedTitle:"git 命令别名",charIndex:8135}],headersStr:"Git基础 全局配置 检查配置信息 获取帮助 初始化仓库 克隆远程仓库 检查文件状态 加入暂存区 (跟踪文件) 忽略文件 查看修改的具体内容 提交更新 跳过使用暂存区域 Git 基础 - 查看提交历史 Git 基础 - 撤消操作 Git 基础 - 远程仓库的使用 查看远程仓库 添加远程仓库 从远程仓库中抓取与拉取 推送到远程仓库 查看某个远程仓库 远程仓库的重命名与移除 Git 基础 - 打标签 列出标签 创建标签 附注标签 轻量标签 后期打标签 共享标签 删除标签 检出标签 Git 命令别名",content:"# Git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# Git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n1\n2\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n1\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n1\n2\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n1\n2\n3\n4\n5\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n M README # 已修改，但未暂存 （M的位置靠右，红色）\nMM Rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\nA  lib/git.rb # 新添加到暂存区，未提交\nM  lib/simplegit.rb # 已修改，已暂存 （M的位置靠左，绿色）\n?? LICENSE.txt # 新添加，未跟踪\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\n1\n2\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n1\n2\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 Git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\n1\n2\n3\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n1\n2\n3\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n1\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# Git 基础 - 查看提交历史\n\ngit log\n\n\n1\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 SHA-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n1\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n1\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n1\n2\n3\n4\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - Scott Chacon, 6 years ago : changed the version number\n085bb3b - Scott Chacon, 6 years ago : removed unnecessary test\na11bef0 - Scott Chacon, 6 years ago : first commit\n\n\n1\n2\n3\n4\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from SIGCHLD on trap\n*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 Added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e Merge branch 'defunkt' into local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n1\n2\n3\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# Git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n1\n2\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n1\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n1\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n1\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n1\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n1\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n1\n2\n\n\n\n# Git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n1\n2\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\nGit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n1\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n1\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n1\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n\n1\n2\n3\n4\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n1\n2\n3\n4\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n1\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n1\n2\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\nDeleted tag 'v1.4-lw' (was e7d5add)\n\n\n1\n2\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nTo /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n1\n2\n3\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n1\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nNote: checking out '2.0.0'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch>\n\nHEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nPrevious HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final\nHEAD is now at df3f601... add atlas.json and cover image\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n\n\n1\n2\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# Git 命令别名\n\nGit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n1\n2\n3\n4\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset HEAD --'\n\n\n1\n\n\n这会使下面的两个命令等价：\n\n$ git unstage fileA\n$ git reset HEAD -- fileA\n\n\n1\n2\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 HEAD'\n\n\n1\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nAuthor: Josh Goebel <dreamer3@example.com>\nDate:   Tue Aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    Signed-off-by: Scott Chacon <schacon@example.com>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n\n\n1\n",normalizedContent:"# git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n1\n2\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n1\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n1\n2\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n1\n2\n3\n4\n5\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n m readme # 已修改，但未暂存 （m的位置靠右，红色）\nmm rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\na  lib/git.rb # 新添加到暂存区，未提交\nm  lib/simplegit.rb # 已修改，已暂存 （m的位置靠左，绿色）\n?? license.txt # 新添加，未跟踪\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\n1\n2\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n1\n2\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 todo 文件，而不忽略 subdir/todo\n/todo\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ngithub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\n1\n2\n3\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n1\n2\n3\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n1\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# git 基础 - 查看提交历史\n\ngit log\n\n\n1\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 sha-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n1\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n1\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n1\n2\n3\n4\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - scott chacon, 6 years ago : changed the version number\n085bb3b - scott chacon, 6 years ago : removed unnecessary test\na11bef0 - scott chacon, 6 years ago : first commit\n\n\n1\n2\n3\n4\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ascii 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from sigchld on trap\n*  5e3ee11 merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e merge branch 'defunkt' into local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n1\n2\n3\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n1\n2\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n1\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n1\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n1\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n1\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n1\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n1\n2\n\n\n\n# git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n1\n2\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\ngit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 gnu privacy guard （gpg）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n1\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n1\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n1\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nauthor: scott chacon <schacon@gee-mail.com>\ndate:   mon mar 17 21:52:11 2008 -0700\n\n\n1\n2\n3\n4\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n1\n2\n3\n4\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n1\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n1\n2\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\ndeleted tag 'v1.4-lw' (was e7d5add)\n\n\n1\n2\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nto /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n1\n2\n3\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n1\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached head）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nnote: checking out '2.0.0'.\n\nyou are in 'detached head' state. you can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nif you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. example:\n\n  git checkout -b <new-branch>\n\nhead is now at 99ada87... merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nprevious head position was 99ada87... merge pull request #89 from schacon/appendix-final\nhead is now at df3f601... add atlas.json and cover image\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nswitched to a new branch 'version2'\n\n\n1\n2\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# git 命令别名\n\ngit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n1\n2\n3\n4\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset head --'\n\n\n1\n\n\n这会使下面的两个命令等价：\n\n$ git unstage filea\n$ git reset head -- filea\n\n\n1\n2\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 head'\n\n\n1\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nauthor: josh goebel <dreamer3@example.com>\ndate:   tue aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    signed-off-by: scott chacon <schacon@example.com>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出，git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git工具-重写历史",frontmatter:{title:"Git工具-重写历史",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/1832fe/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2.html",relativePath:"50.常用工具/10.Git/20.文档笔记/100.Git工具-重写历史.md",key:"v-2c360072",path:"/pages/1832fe/",headers:[{level:2,title:"修改最后一次提交",slug:"修改最后一次提交",normalizedTitle:"修改最后一次提交",charIndex:453},{level:3,title:"修改提交信息",slug:"修改提交信息",normalizedTitle:"修改提交信息",charIndex:519},{level:3,title:"修改实际内容",slug:"修改实际内容",normalizedTitle:"修改实际内容",charIndex:700},{level:2,title:"修改多个提交信息",slug:"修改多个提交信息",normalizedTitle:"修改多个提交信息",charIndex:1113},{level:2,title:"重新排序提交",slug:"重新排序提交",normalizedTitle:"重新排序提交",charIndex:4034},{level:2,title:"压缩提交",slug:"压缩提交",normalizedTitle:"压缩提交",charIndex:4460},{level:2,title:"拆分提交",slug:"拆分提交",normalizedTitle:"拆分提交",charIndex:6218},{level:2,title:"核武器级选项：filter-branch",slug:"核武器级选项-filter-branch",normalizedTitle:"核武器级选项：filter-branch",charIndex:7244},{level:3,title:"从每一个提交中移除一个文件",slug:"从每一个提交中移除一个文件",normalizedTitle:"从每一个提交中移除一个文件",charIndex:7318},{level:3,title:"使一个子目录做为新的根目录",slug:"使一个子目录做为新的根目录",normalizedTitle:"使一个子目录做为新的根目录",charIndex:8358},{level:3,title:"全局修改邮箱地址",slug:"全局修改邮箱地址",normalizedTitle:"全局修改邮箱地址",charIndex:8684}],headersStr:"修改最后一次提交 修改提交信息 修改实际内容 修改多个提交信息 重新排序提交 压缩提交 拆分提交 核武器级选项：filter-branch 从每一个提交中移除一个文件 使一个子目录做为新的根目录 全局修改邮箱地址",content:"# Git 工具 - 重写历史\n\n许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nNOTE   在满意之前不要推送你的工作GIT 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n1\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\nTIP   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ GIT\n      COMMIT --AMEND --NO-EDIT\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 HEAD~2^ 或 HEAD~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i HEAD~3\n\n\n1\n\n\n再次记住这是一个变基命令——在 HEAD~3..HEAD 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\na5f4a0d added cat-file\n310154e updated README formatting and added blame\nf7f3f6d changed my name a bit\n\n\n1\n2\n3\n4\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i HEAD~3\nStopped at f7f3f6d... changed my name a bit\nYou can amend the commit now, with\n\n       git commit --amend\n\nOnce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n1\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n1\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n改为这样：\n\npick 310154e updated README formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n1\n2\n\n\n当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated README formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# This is a combination of 3 commits.\n# The first commit's message is:\nchanged my name a bit\n\n# This is the 2nd commit message:\n\nupdated README formatting and added blame\n\n# This is the 3rd commit message:\n\nadded cat-file\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset HEAD^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset HEAD^\n$ git add README\n$ git commit -m 'updated README formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n\n\nGit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated README formatting\nf3cc40e changed my name a bit\n\n\n1\n2\n3\n4\n5\n\n\n再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\nCAUTION   GIT FILTER-BRANCH 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          GIT-FILTER-REPO，它是一个 PYTHON 脚本，相比大多数使用 FILTER-BRANCH\n          的应用来说，它做得要更好。它的文档和源码可访问\n          HTTPS://GITHUB.COM/NEWREN/GIT-FILTER-REPO 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\nRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nRef 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' HEAD 的命令。\n\n最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk HEAD\nRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nRef 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n        then\n                GIT_AUTHOR_NAME=\"Scott Chacon\";\n                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' HEAD\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",normalizedContent:"# git 工具 - 重写历史\n\n许多时候，在使用 git 时，你可能想要修订提交历史。 git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nnote   在满意之前不要推送你的工作git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n1\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 sha-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\ntip   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ git\n      commit --amend --no-edit\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 head 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 head~2^ 或 head~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i head~3\n\n\n1\n\n\n再次记住这是一个变基命令——在 head~3..head 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n# rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" head~3..head\na5f4a0d added cat-file\n310154e updated readme formatting and added blame\nf7f3f6d changed my name a bit\n\n\n1\n2\n3\n4\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（head~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i head~3\nstopped at f7f3f6d... changed my name a bit\nyou can amend the commit now, with\n\n       git commit --amend\n\nonce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n1\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n1\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n改为这样：\n\npick 310154e updated readme formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n1\n2\n\n\n当保存并退出编辑器时，git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated readme formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# this is a combination of 3 commits.\n# the first commit's message is:\nchanged my name a bit\n\n# this is the 2nd commit message:\n\nupdated readme formatting and added blame\n\n# this is the 3rd commit message:\n\nadded cat-file\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated readme formatting”，第二个 “added blame” 来代替原来的 “updated readme formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset head^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset head^\n$ git add readme\n$ git commit -m 'updated readme formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n\n\ngit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated readme formatting\nf3cc40e changed my name a bit\n\n\n1\n2\n3\n4\n5\n\n\n再次强调，这些改动了所有在列表中的提交的 sha-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\ncaution   git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          git-filter-repo，它是一个 python 脚本，相比大多数使用 filter-branch\n          的应用来说，它做得要更好。它的文档和源码可访问\n          https://github.com/newren/git-filter-repo 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' head\nrewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nref 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' head 的命令。\n\n最后将可以看到 git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk head\nrewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nref 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n现在新项目根目录是 trunk 子目录了。 git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$git_author_email\" = \"schacon@localhost\" ];\n        then\n                git_author_name=\"scott chacon\";\n                git_author_email=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 sha-1 校验和，这个命令会修改你的历史中的每一个提交的 sha-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git工具-重置揭密",frontmatter:{title:"Git工具-重置揭密",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/d9e9c6/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86.html",relativePath:"50.常用工具/10.Git/20.文档笔记/110.Git工具-重置揭密.md",key:"v-bd3e73d6",path:"/pages/d9e9c6/",headers:[{level:2,title:"三棵树",slug:"三棵树",normalizedTitle:"三棵树",charIndex:147},{level:3,title:"HEAD",slug:"head",normalizedTitle:"head",charIndex:348},{level:3,title:"索引",slug:"索引",normalizedTitle:"索引",charIndex:257},{level:3,title:"工作目录",slug:"工作目录",normalizedTitle:"工作目录",charIndex:1116},{level:2,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:1764},{level:2,title:"重置的作用",slug:"重置的作用",normalizedTitle:"重置的作用",charIndex:2573},{level:3,title:"第 1 步：移动 HEAD",slug:"第-1-步-移动-head",normalizedTitle:"第 1 步：移动 head",charIndex:2720},{level:3,title:"第 2 步：更新索引（--mixed）",slug:"第-2-步-更新索引-mixed",normalizedTitle:"第 2 步：更新索引（--mixed）",charIndex:3207},{level:3,title:"第 3 步：更新工作目录（--hard）",slug:"第-3-步-更新工作目录-hard",normalizedTitle:"第 3 步：更新工作目录（--hard）",charIndex:3507},{level:3,title:"回顾",slug:"回顾",normalizedTitle:"回顾",charIndex:3867},{level:2,title:"通过路径来重置",slug:"通过路径来重置",normalizedTitle:"通过路径来重置",charIndex:4002},{level:2,title:"压缩",slug:"压缩",normalizedTitle:"压缩",charIndex:4855},{level:2,title:"检出",slug:"检出",normalizedTitle:"检出",charIndex:1113},{level:3,title:"不带路径",slug:"不带路径",normalizedTitle:"不带路径",charIndex:5428},{level:3,title:"带路径",slug:"带路径",normalizedTitle:"带路径",charIndex:5429},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6348}],headersStr:"三棵树 HEAD 索引 工作目录 工作流程 重置的作用 第 1 步：移动 HEAD 第 2 步：更新索引（--mixed） 第 3 步：更新工作目录（--hard） 回顾 通过路径来重置 压缩 检出 不带路径 带路径 总结",content:"# Git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 Git 的 reset 和 checkout 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\nGit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nHEAD                上一次提交的快照，下一次提交的父结点\nIndex               预期的下一次提交的快照\nWorking Directory   沙盒\n\n\n# HEAD\n\nHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：\n\n$ git cat-file -p HEAD\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor Scott Chacon  1301511835 -0700\ncommitter Scott Chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r HEAD\n100644 blob a906cb2a4a904a152...   README\n100644 blob 8f94139338f9404f2...   Rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nGit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。\n\nGit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n1\n2\n3\n4\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── README\n├── Rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 工作流程\n\n经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 HEAD\n\nreset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 HEAD （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 HEAD 分支的指向 （已跳过）\n 2. 让索引看起来像 HEAD （到此处停止）\n\n所以它本质上只是将 file.txt 从 HEAD 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。\n\n                            HEAD   INDEX   WORKDIR   WD SAFE?\nCommit Level                                         \nreset --soft [commit]       REF    NO      NO        YES\nreset [commit]              REF    YES     NO        YES\nreset --hard [commit]       REF    YES     YES       NO\ncheckout <commit>           HEAD   YES     YES       YES\nFile Level                                           \nreset [commit] <paths>      NO     YES     NO        YES\ncheckout [commit] <paths>   NO     YES     YES       NO",normalizedContent:"# git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 git 的 reset 和 checkout 命令。 在初遇的 git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\ngit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nhead                上一次提交的快照，下一次提交的父结点\nindex               预期的下一次提交的快照\nworking directory   沙盒\n\n\n# head\n\nhead 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 head 将是下一次提交的父结点。 通常，理解 head 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 head 快照实际的目录列表，以及其中每个文件的 sha-1 校验和：\n\n$ git cat-file -p head\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor scott chacon  1301511835 -0700\ncommitter scott chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r head\n100644 blob a906cb2a4a904a152...   readme\n100644 blob 8f94139338f9404f2...   rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ngit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 git 的“暂存区”，这就是当你运行 git commit 时 git 看起来的样子。\n\ngit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\treadme\n100644 8f94139338f9404f26296befa88755fc2598c289 0\trakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n1\n2\n3\n4\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── readme\n├── rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 工作流程\n\n经典的 git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 git 仓库，其中的 head 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 head 不同，若运行 git status 的话就会看到 “changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 head 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 head\n\nreset 做的第一件事是移动 head 的指向。 这与改变 head 自身不同（checkout 所做的）；reset 移动 head 指向的分支。 这意味着如果 head 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，git 会创建一个新的提交，并移动 head 所指向的分支来使其指向该提交。 当你将它 reset 回 head~（head 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 head 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 head 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset head~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 head 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 head （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 head 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed head file.txt 的简写形式，因为你既没有指定一个提交的 sha-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 head 分支的指向 （已跳过）\n 2. 让索引看起来像 head （到此处停止）\n\n所以它本质上只是将 file.txt 从 head 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 git 从 head 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“wip” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft head~2 来将 head 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 head。 reset 会移动 head 分支的指向，而 checkout 只会移动 head 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 head 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，head 自身会移动。 现在 head 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 head 使其指向了提交 a，但_做法_是非常不同的。 reset 会移动 head 分支的指向，而 checkout 则移动 head 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 head。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 head。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “head” 一列中的 “ref” 表示该命令移动了 head 指向的分支引用，而 “head” 则表示只移动了 head 自身。 特别注意 wd safe? 一列——如果它标记为 no，那么运行该命令之前请考虑一下。\n\n                            head   index   workdir   wd safe?\ncommit level                                         \nreset --soft [commit]       ref    no      no        yes\nreset [commit]              ref    yes     no        yes\nreset --hard [commit]       ref    yes     yes       no\ncheckout <commit>           head   yes     yes       yes\nfile level                                           \nreset [commit] <paths>      no     yes     no        yes\ncheckout [commit] <paths>   no     yes     yes       no",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git分支-分支原理",frontmatter:{title:"Git分支-分支原理",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/4bef1a/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html",relativePath:"50.常用工具/10.Git/20.文档笔记/20.Git分支-分支原理.md",key:"v-7d723798",path:"/pages/4bef1a/",headers:[{level:3,title:"首次提交",slug:"首次提交",normalizedTitle:"首次提交",charIndex:130},{level:4,title:"小结：",slug:"小结",normalizedTitle:"小结：",charIndex:684},{level:3,title:"再次提交",slug:"再次提交",normalizedTitle:"再次提交",charIndex:823},{level:3,title:"Git 的分支",slug:"git-的分支",normalizedTitle:"git 的分支",charIndex:896},{level:3,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:1088},{level:3,title:"当前分支的指针",slug:"当前分支的指针",normalizedTitle:"当前分支的指针",charIndex:1252},{level:3,title:"查看当前所在分支",slug:"查看当前所在分支",normalizedTitle:"查看当前所在分支",charIndex:1432},{level:3,title:"分支切换",slug:"分支切换",normalizedTitle:"分支切换",charIndex:1771},{level:3,title:"创建分支同时切换",slug:"创建分支同时切换",normalizedTitle:"创建分支同时切换",charIndex:3223}],headersStr:"首次提交 小结： 再次提交 Git 的分支 创建分支 当前分支的指针 查看当前所在分支 分支切换 创建分支同时切换",content:"# Git分支-分支原理\n\nGit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\n\n现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# Git 的分支\n\nGit 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\nGit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\nGit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. HEAD 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -> master分支，testing 分支)\n34ac2 Fixed bug # 34ac2 提交对象\n98ca9 The initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 HEAD 就指向 testing 分支了。\n\n\n\n图6. HEAD 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. HEAD 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 HEAD 随之移动 ▲\n\n这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n\n\n1\n",normalizedContent:"# git分支-分支原理\n\ngit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 sha-1 哈希算法），然后会把当前版本的文件快照保存到 git 仓库中 （git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add readme test.rb license\n$ git commit -m 'the initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 git 仓库中这些校验和保存为树对象。随后，git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，git 就可以在需要的时候重现此次保存的快照。\n\n现在，git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# git 的分支\n\ngit 的分支，其实本质上仅仅是指向提交对象的可变指针。 git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\ngit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\ngit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 head 的特殊指针，指向当前所在的本地分支（译注：将 head 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. head 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (head -> master, testing) add feature # f30ab提交对象 (head当前所在分支 -> master分支，testing 分支)\n34ac2 fixed bug # 34ac2 提交对象\n98ca9 the initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 head 就指向 testing 分支了。\n\n\n\n图6. head 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. head 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 head 随之移动 ▲\n\n这条命令做了两件事。 一是使 head 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (head, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 git 的分支实质上仅是包含所指对象校验和（长度为 40 的 sha-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git分支的新建与合并-分支操作",frontmatter:{title:"Git分支的新建与合并-分支操作",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/ea5a8c/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30.Git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C.html",relativePath:"50.常用工具/10.Git/20.文档笔记/30.Git分支的新建与合并-分支操作.md",key:"v-50308c98",path:"/pages/ea5a8c/",headers:[{level:3,title:"创建分支并切换",slug:"创建分支并切换",normalizedTitle:"创建分支并切换",charIndex:45},{level:3,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:187},{level:3,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:575},{level:3,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:666},{level:3,title:"多次提交之后合并分支",slug:"多次提交之后合并分支",normalizedTitle:"多次提交之后合并分支",charIndex:781},{level:3,title:"遇到冲突时的分支合并",slug:"遇到冲突时的分支合并",normalizedTitle:"遇到冲突时的分支合并",charIndex:1123}],headersStr:"创建分支并切换 切换分支 合并分支 删除分支 多次提交之后合并分支 遇到冲突时的分支合并",content:"# Git分支的新建与合并-分支操作\n\n文档：Git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n1\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n1\n2\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n1\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支Git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n1\n2\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n1\n2\n3\n4\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n1\n2\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现CONFLICT提升，表示有冲突\n\n$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n\n\n1\n2\n3\n4\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< HEAD:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",normalizedContent:"# git分支的新建与合并-分支操作\n\n文档：git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n1\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n1\n2\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n1\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n1\n2\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n1\n2\n3\n4\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n1\n2\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，git 不得不做一些额外的工作。 出现这种情况的时候，git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现conflict提升，表示有冲突\n\n$ git merge iss53\nauto-merging index.html\nconflict (content): merge conflict in index.html\nautomatic merge failed; fix conflicts and then commit the result.\n\n\n1\n2\n3\n4\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< head:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git分支管理-查看分支",frontmatter:{title:"Git分支管理-查看分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/a399b3/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40.Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF.html",relativePath:"50.常用工具/10.Git/20.文档笔记/40.Git分支管理-查看分支.md",key:"v-1c24e404",path:"/pages/a399b3/",headers:[{level:3,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:10},{level:3,title:"查看每个分支的最后提交",slug:"查看每个分支的最后提交",normalizedTitle:"查看每个分支的最后提交",charIndex:152},{level:3,title:"查看已(未)合并的分支",slug:"查看已-未-合并的分支",normalizedTitle:"查看已(未)合并的分支",charIndex:297},{level:4,title:"查看指定分支的已(未)合并的分支",slug:"查看指定分支的已-未-合并的分支",normalizedTitle:"查看指定分支的已(未)合并的分支",charIndex:765}],headersStr:"查看分支 查看每个分支的最后提交 查看已(未)合并的分支 查看指定分支的已(未)合并的分支",content:"# Git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\n1\n2\n3\n4\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 test\n\n\n1\n2\n3\n4\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n1\n2\n3\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n1\n2\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n\n\n1\n2\n3\n\n\n强制删除未合并的分支:\n\n$ git branch -D testing\n\n\n1\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topicA\n  featureB\n\n\n1\n2\n3\n",normalizedContent:"# git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\n1\n2\n3\n4\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 merge branch 'iss53'\n  testing 782fd34 test\n\n\n1\n2\n3\n4\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n1\n2\n3\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n1\n2\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: the branch 'testing' is not fully merged.\nif you are sure you want to delete it, run 'git branch -d testing'.\n\n\n1\n2\n3\n\n\n强制删除未合并的分支:\n\n$ git branch -d testing\n\n\n1\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topica\n  featureb\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git分支开发工作流",frontmatter:{title:"Git分支开发工作流",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/49ee30/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50.Git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html",relativePath:"50.常用工具/10.Git/20.文档笔记/50.Git分支开发工作流.md",key:"v-8b018710",path:"/pages/49ee30/",headers:[{level:3,title:"长期分支",slug:"长期分支",normalizedTitle:"长期分支",charIndex:32},{level:3,title:"主题分支 (短期分支)",slug:"主题分支-短期分支",normalizedTitle:"主题分支 (短期分支)",charIndex:625}],headersStr:"长期分支 主题分支 (短期分支)",content:"# Git分支开发工作流\n\n文档：Git分支开发工作流\n\n\n# 长期分支\n\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。",normalizedContent:"# git分支开发工作流\n\n文档：git分支开发工作流\n\n\n# 长期分支\n\n因为 git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 c1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 c4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 c10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 c5 和 c6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 git 版本库中 —— 没有与服务器发生交互。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git分支-远程分支",frontmatter:{title:"Git分支-远程分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/574d62/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60.Git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF.html",relativePath:"50.常用工具/10.Git/20.文档笔记/60.Git分支-远程分支.md",key:"v-77df4576",path:"/pages/574d62/",headers:[{level:3,title:"查看远程引用列表与信息",slug:"查看远程引用列表与信息",normalizedTitle:"查看远程引用列表与信息",charIndex:71},{level:3,title:"远程跟踪分支",slug:"远程跟踪分支",normalizedTitle:"远程跟踪分支",charIndex:184},{level:3,title:"推送",slug:"推送",normalizedTitle:"推送",charIndex:432},{level:4,title:"重命名远程仓库上的分支名",slug:"重命名远程仓库上的分支名",normalizedTitle:"重命名远程仓库上的分支名",charIndex:2723},{level:3,title:"跟踪分支",slug:"跟踪分支",normalizedTitle:"跟踪分支",charIndex:186},{level:3,title:"查看跟踪分支",slug:"查看跟踪分支",normalizedTitle:"查看跟踪分支",charIndex:5263},{level:3,title:"拉取",slug:"拉取",normalizedTitle:"拉取",charIndex:605},{level:3,title:"删除远程分支",slug:"删除远程分支",normalizedTitle:"删除远程分支",charIndex:6361}],headersStr:"查看远程引用列表与信息 远程跟踪分支 推送 重命名远程仓库上的分支名 跟踪分支 查看跟踪分支 拉取 删除远程分支",content:"# Git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n1\n2\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 URL 的缩写。远程仓库名本质上是远程URL的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nNOTE   如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，GIT 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “CREDENTIAL CACHE”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 GIT CONFIG\n       --GLOBAL CREDENTIAL.HELPER CACHE 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nBranch sf set up to track remote branch serverfix from origin.\nSwitched to a new branch 'sf'\n\n\n1\n2\n3\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\n\n\n1\n2\n\n\nNOTE   上游快捷方式当设置好跟踪分支后，可以通过简写 @{UPSTREAM} 或 @{U} 来引用它的上游分支。 所以在\n       MASTER 分支时并且它正在跟踪 ORIGIN/MASTER 时，如果愿意的话可以使用 GIT MERGE @{U}\n       来取代 GIT MERGE ORIGIN/MASTER。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n1\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n1\n2\n3\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",normalizedContent:"# git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n1\n2\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 git 服务器。 如果你从这里克隆，git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 url 的缩写。远程仓库名本质上是远程url的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\ncounting objects: 24, done.\ndelta compression using up to 8 threads.\ncompressing objects: 100% (15/15), done.\nwriting objects: 100% (24/24), 1.91 kib | 0 bytes/s, done.\ntotal 24 (delta 2), reused 0 (delta 0)\nto https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里有些工作被简化了。 git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nnote   如何避免每次输入密码如果你正在使用 https url 来推送，git 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config\n       --global credential.helper cache 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: counting objects: 7, done.\nremote: compressing objects: 100% (2/2), done.\nremote: total 3 (delta 0), reused 3 (delta 0)\nunpacking objects: 100% (3/3), done.\nfrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nbranch sf set up to track remote branch serverfix from origin.\nswitched to a new branch 'sf'\n\n\n1\n2\n3\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\n\n\n1\n2\n\n\nnote   上游快捷方式当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在\n       master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u}\n       来取代 git merge origin/master。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n1\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nto https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n1\n2\n3\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git分支-变基",frontmatter:{title:"Git分支-变基",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/3a3247/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70.Git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA.html",relativePath:"50.常用工具/10.Git/20.文档笔记/70.Git分支-变基.md",key:"v-18534ad1",path:"/pages/3a3247/",headers:[{level:2,title:"变基的基本操作",slug:"变基的基本操作",normalizedTitle:"变基的基本操作",charIndex:117},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:312},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:728},{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:1138},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:1701},{level:2,title:"更有趣的变基例子",slug:"更有趣的变基例子",normalizedTitle:"更有趣的变基例子",charIndex:1727},{level:3,title:"更有趣的变基例子",slug:"更有趣的变基例子-2",normalizedTitle:"更有趣的变基例子",charIndex:1727},{level:3,title:"--onto选项",slug:"onto选项",normalizedTitle:"--onto选项",charIndex:2530},{level:3,title:"省去先切换到源分支的步骤",slug:"省去先切换到源分支的步骤",normalizedTitle:"省去先切换到源分支的步骤",charIndex:2762},{level:2,title:"变基的风险",slug:"变基的风险",normalizedTitle:"变基的风险",charIndex:3415},{level:3,title:"金科玉律",slug:"金科玉律",normalizedTitle:"金科玉律",charIndex:3425},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:3615},{level:2,title:"用变基解决变基",slug:"用变基解决变基",normalizedTitle:"用变基解决变基",charIndex:4412},{level:2,title:"变基 vs. 合并",slug:"变基-vs-合并",normalizedTitle:"变基 vs. 合并",charIndex:5550}],headersStr:"变基的基本操作 概念 原理 步骤 优点 更有趣的变基例子 更有趣的变基例子 --onto选项 省去先切换到源分支的步骤 变基的风险 金科玉律 变基的实质 用变基解决变基 变基 vs. 合并",content:"# Git分支-变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n\n\n1\n2\n3\n4\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 C4 中的修改变基到 C3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n1\n2\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n4\n5\n\n\n此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n1\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中C分支中的但不在B分支里的修改，应用到A分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n1\n2\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n1\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n1\n2\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n1\n2\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会：\n\n * 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\n * 检查其中哪些提交不是合并操作的结果（C2，C3，C4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",normalizedContent:"# git分支-变基\n\n在 git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（c3 和 c4）以及二者最近的共同祖先（c2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 c4 中引入的补丁和修改，然后在 c3 的基础上应用一次。 在 git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nfirst, rewinding head to replay your work on top of it...\napplying: added staged command\n\n\n1\n2\n3\n4\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 c2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 c3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 c4 中的修改变基到 c3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n1\n2\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n4\n5\n\n\n此时，c4' 指向的快照就和 the merge example 中 c5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 c8 和 c9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n1\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中c分支中的但不在b分支里的修改，应用到a分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n1\n2\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n1\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n1\n2\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n1\n2\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 c4 和 c6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，git 除了对整个提交计算 sha-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, git 将会：\n\n * 检查哪些提交是我们的分支上独有的（c2，c3，c4，c6，c7）\n * 检查其中哪些提交不是合并操作的结果（c2，c3，c4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 c2 和 c3，因为 c4 其实就是 c4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 c4' 和 c4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 c4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git工具-查看修订版本",frontmatter:{title:"Git工具-查看修订版本",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c984d1/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80.Git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC.html",relativePath:"50.常用工具/10.Git/20.文档笔记/80.Git工具-查看修订版本.md",key:"v-cc5927b4",path:"/pages/c984d1/",headers:[{level:2,title:"单个修订版本",slug:"单个修订版本",normalizedTitle:"单个修订版本",charIndex:91},{level:2,title:"简短的 SHA-1",slug:"简短的-sha-1",normalizedTitle:"简短的 sha-1",charIndex:181},{level:3,title:"查看给定SHA-1值的提交",slug:"查看给定sha-1值的提交",normalizedTitle:"查看给定sha-1值的提交",charIndex:956},{level:2,title:"分支引用",slug:"分支引用",normalizedTitle:"分支引用",charIndex:2177},{level:3,title:"查看最后一次提交",slug:"查看最后一次提交",normalizedTitle:"查看最后一次提交",charIndex:2252},{level:2,title:"引用日志",slug:"引用日志",normalizedTitle:"引用日志",charIndex:2696},{level:3,title:"HEAD的指向历史",slug:"head的指向历史",normalizedTitle:"head的指向历史",charIndex:2705},{level:2,title:"祖先引用",slug:"祖先引用",normalizedTitle:"祖先引用",charIndex:4613},{level:2,title:"提交区间",slug:"提交区间",normalizedTitle:"提交区间",charIndex:6634},{level:3,title:"双点",slug:"双点",normalizedTitle:"双点",charIndex:6735},{level:4,title:"查看即将推送到远端的内容",slug:"查看即将推送到远端的内容",normalizedTitle:"查看即将推送到远端的内容",charIndex:7262},{level:3,title:"多点",slug:"多点",normalizedTitle:"多点",charIndex:7606},{level:3,title:"三点",slug:"三点",normalizedTitle:"三点",charIndex:8032}],headersStr:"单个修订版本 简短的 SHA-1 查看给定SHA-1值的提交 分支引用 查看最后一次提交 引用日志 HEAD的指向历史 祖先引用 提交区间 双点 查看即将推送到远端的内容 多点 三点",content:"# Git工具-查看修订版本\n\nGit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 SHA-1\n\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 查看给定SHA-1值的提交\n\n在本例中，假设你想要的提交其 SHA-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\n1\n2\n3\n\n\nGit 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n1\n2\n3\n4\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nNOTE   关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 SHA-1 值相同， GIT\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 P =\n       (N(N-1)/2) * (1/2^160)) ）。 2^80 是 1.2 X\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 LINUX 内核历史（650 万个 GIT\n       对象）的代码， 并将之提交到一个巨大的 GIT 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n1\n2\n\n\n如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n1\n2\n\n\n\n# 引用日志\n\n\n# HEAD的指向历史\n\n当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.\n1c002dd HEAD@{2}: commit: added some blame and merge stuff\n1c36188 HEAD@{3}: rebase -i (squash): updating HEAD\n95df984 HEAD@{4}: commit: # This is a combination of two commits.\n1c36188 HEAD@{5}: rebase -i (squash): updating HEAD\n7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show HEAD@{5}\n\n\n1\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n1\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nReflog: master@{0} (Scott Chacon <schacon@gmail.com>)\nReflog message: commit: fixed refs handling, added gc auto, updated\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nReflog: master@{1} (Scott Chacon <schacon@gmail.com>)\nReflog message: merge phedders/rdocs: Merge made by recursive.\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\nTIP   将引用日志想作 GIT 版的 SHELL 历史记录如果你有 UNIX 或者 LINUX 的背景，不妨将引用日志想作\n      GIT 版的 SHELL 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 Merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b Some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n你可以使用 HEAD^ 来查看上一个提交，也就是 “HEAD 的父提交”：\n\n$ git show HEAD^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNOTE   在 WINDOWS 上转义脱字符在 WINDOWS 的 CMD.EXE 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ GIT SHOW HEAD^ # 在 WINDOWS 上无法工作 $ GIT\n       SHOW HEAD^^ # 可以 $ GIT SHOW \"HEAD^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nAuthor: Paul Hedderly <paul+git@mjr.org>\nDate:   Wed Dec 10 22:22:03 2008 +0000\n\n    Some rdoc changes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的。 而区别在于你在后面加数字的时候。 HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，HEAD~3 就是\n\n$ git show HEAD~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以写成 HEAD~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show HEAD~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n你也可以组合使用这两个语法——你可以通过 HEAD~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.\n\n\n\nFigure 137. Example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nD\nC\n\n\n1\n2\n3\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nF\nE\n\n\n1\n2\n3\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..HEAD\n\n\n1\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..HEAD 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 HEAD。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refA..refB\n$ git log ^refA refB\n$ git log refB --not refA\n\n\n1\n2\n3\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refA refB ^refC\n$ git log refA refB --not refC\n\n\n1\n2\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nF\nE\nD\nC\n\n\n1\n2\n3\n4\n5\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< F\n< E\n> D\n> C\n\n\n1\n2\n3\n4\n5\n\n\n有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。",normalizedContent:"# git工具-查看修订版本\n\ngit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 sha-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 sha-1\n\ngit 十分智能，你只需要提供 sha-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 sha-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 sha-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 查看给定sha-1值的提交\n\n在本例中，假设你想要的提交其 sha-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\n1\n2\n3\n\n\ngit 可以为 sha-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 sha-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n1\n2\n3\n4\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 sha-1 的歧义。 例如，到 2019 年 2 月为止，linux 内核这个相当大的 git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nnote   关于 sha-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 sha-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 sha-1 值相同， git\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 sha-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 p =\n       (n(n-1)/2) * (1/2^160)) ）。 2^80 是 1.2 x\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 sha-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 linux 内核历史（650 万个 git\n       对象）的代码， 并将之提交到一个巨大的 git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 sha-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n1\n2\n\n\n如果你想知道某个分支指向哪个特定的 sha-1，或者想看任何一个例子中被简写的 sha-1， 你可以使用一个叫做 rev-parse 的 git 探测工具。 你可以在 git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n1\n2\n\n\n\n# 引用日志\n\n\n# head的指向历史\n\n当你在工作时， git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 head 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b head@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 head@{1}: merge phedders/rdocs: merge made by the 'recursive' strategy.\n1c002dd head@{2}: commit: added some blame and merge stuff\n1c36188 head@{3}: rebase -i (squash): updating head\n95df984 head@{4}: commit: # this is a combination of two commits.\n1c36188 head@{5}: rebase -i (squash): updating head\n7e05da5 head@{6}: rebase -i (pick): updating head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每当你的 head 所指向的位置发生了变化，git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 head 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show head@{5}\n\n\n1\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n1\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nreflog: master@{0} (scott chacon <schacon@gmail.com>)\nreflog message: commit: fixed refs handling, added gc auto, updated\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nreflog: master@{1} (scott chacon <schacon@gmail.com>)\nreflog message: merge phedders/rdocs: merge made by recursive.\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show head@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\ntip   将引用日志想作 git 版的 shell 历史记录如果你有 unix 或者 linux 的背景，不妨将引用日志想作\n      git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n你可以使用 head^ 来查看上一个提交，也就是 “head 的父提交”：\n\n$ git show head^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote   在 windows 上转义脱字符在 windows 的 cmd.exe 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ git show head^ # 在 windows 上无法工作 $ git\n       show head^^ # 可以 $ git show \"head^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nauthor: paul hedderly <paul+git@mjr.org>\ndate:   wed dec 10 22:22:03 2008 +0000\n\n    some rdoc changes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 head~ 和 head^ 是等价的。 而区别在于你在后面加数字的时候。 head~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，head~3 就是\n\n$ git show head~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以写成 head~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show head~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n你也可以组合使用这两个语法——你可以通过 head~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 example history for range selection.\n\n\n\nfigure 137. example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nd\nc\n\n\n1\n2\n3\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nf\ne\n\n\n1\n2\n3\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..head\n\n\n1\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..head 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， git 会默认为 head。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— git 使用 head 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refa..refb\n$ git log ^refa refb\n$ git log refb --not refa\n\n\n1\n2\n3\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refa 或 refb 包含的但是不被 refc 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refa refb ^refc\n$ git log refa refb --not refc\n\n\n1\n2\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nf\ne\nd\nc\n\n\n1\n2\n3\n4\n5\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< f\n< e\n> d\n> c\n\n\n1\n2\n3\n4\n5\n\n\n有了这些工具，你就可以十分方便地查看你 git 仓库中的提交。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Git工具-交互式暂存",frontmatter:{title:"Git工具-交互式暂存",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/76d859/",categories:["《Git》学习笔记"],tags:["Git"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/10.Git/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90.Git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98.html",relativePath:"50.常用工具/10.Git/20.文档笔记/90.Git工具-交互式暂存.md",key:"v-e25aa456",path:"/pages/76d859/",headers:[{level:2,title:"暂存与取消暂存文件",slug:"暂存与取消暂存文件",normalizedTitle:"暂存与取消暂存文件",charIndex:751},{level:2,title:"暂存补丁",slug:"暂存补丁",normalizedTitle:"暂存补丁",charIndex:3468}],headersStr:"暂存与取消暂存文件 暂存补丁",content:'# Git工具-交互式暂存\n\n本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 What now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nWhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n要暂存 TODO 和 index.html 文件，可以输入数字：\n\nUpdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 TODO\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update>> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：\n\nUpdate>>\nupdated 2 paths\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 r 或 3（撤消）选项：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> [enter]\nreverted one path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nReview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ Date Finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\nGit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class SimpleGit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nStage this hunk [y,n,a,d,/,j,J,g,e,?]?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nStage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nWhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',normalizedContent:'# git工具-交互式暂存\n\n本节中的几个交互式 git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 what now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nwhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n要暂存 todo 和 index.html 文件，可以输入数字：\n\nupdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 todo\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 update>> 提示符后不输入任何东西并直接按回车，git 将会暂存之前选择的文件：\n\nupdate>>\nupdated 2 paths\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在可以看到 todo 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 todo 文件，使用 r 或 3（撤消）选项：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> [enter]\nreverted one path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次查看 git 状态，可以看到已经取消暂存 todo 文件：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nreview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ date finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\ngit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class simplegit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nstage this hunk [y,n,a,d,/,j,j,g,e,?]?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nstage this hunk [y,n,a,d,/,j,j,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nj - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nk - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nwhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"CMake简述",frontmatter:{title:"CMake简述",date:"2023-04-03T22:29:57.000Z",permalink:"/pages/6a3b4c/",categories:["常用工具","CMake"],tags:["CMake"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/20.CMake/1.CMake%E7%AE%80%E8%BF%B0.html",relativePath:"50.常用工具/20.CMake/1.CMake简述.md",key:"v-00c545c2",path:"/pages/6a3b4c/",headers:[{level:2,title:"CMake",slug:"cmake",normalizedTitle:"cmake",charIndex:2},{level:3,title:"定义变量",slug:"定义变量",normalizedTitle:"定义变量",charIndex:134},{level:3,title:"添加头文件搜索路径",slug:"添加头文件搜索路径",normalizedTitle:"添加头文件搜索路径",charIndex:254},{level:3,title:"添加库文件搜索路径",slug:"添加库文件搜索路径",normalizedTitle:"添加库文件搜索路径",charIndex:399},{level:3,title:"添加可执行文件",slug:"添加可执行文件",normalizedTitle:"添加可执行文件",charIndex:525},{level:3,title:"添加库文件",slug:"添加库文件",normalizedTitle:"添加库文件",charIndex:399},{level:3,title:"链接库文件",slug:"链接库文件",normalizedTitle:"链接库文件",charIndex:939},{level:3,title:"控制流语句",slug:"控制流语句",normalizedTitle:"控制流语句",charIndex:1125},{level:3,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:1206},{level:3,title:"自定义命令",slug:"自定义命令",normalizedTitle:"自定义命令",charIndex:1270},{level:3,title:"安装规则",slug:"安装规则",normalizedTitle:"安装规则",charIndex:1369}],headersStr:"CMake 定义变量 添加头文件搜索路径 添加库文件搜索路径 添加可执行文件 添加库文件 链接库文件 控制流语句 循环语句 自定义命令 安装规则",content:"# CMake\n\nCMake 是一个跨平台的构建系统，可以用于自动生成各种不同平台编译器的构建文件。 CMake 使用一种类似于脚本的语言来描述项目的构建过程，并生成相应的 Makefile 或其他构建工具所需的配置文件。\n\n下面是一些常见的CMake语法：\n\n\n# 定义变量\n\n使用 set() 命令来定义一个变量，如 set(SOURCE_FILES main.cpp)。\n\n其中，SOURCE_FILES 是变量名，main.cpp 是变量值。在CMake中，变量可以是字符串、列表或布尔值。\n\n\n# 添加头文件搜索路径\n\n使用 include_directories() 命令来添加头文件搜索路径，如 include_directories(include)。\n\n其中，include 是需要添加的头文件路径。该命令用于指定包含C/C++头文件的目录列表，以便编译器能够找到它们。\n\n\n# 添加库文件搜索路径\n\n使用 link_directories() 命令来添加库文件搜索路径，如 link_directories(lib)。\n\n其中，lib 是需要添加的库文件路径。该命令用于指定包含库文件的目录列表，以便链接器能够找到它们。\n\n\n# 添加可执行文件\n\n使用 add_executable() 命令来添加可执行文件，如 add_executable(my_executable \\${SOURCE_FILES})。\n\n其中，my_executable 是可执行文件的名称，\\${SOURCE_FILES} 是需要编译的源代码文件。该命令用于指定要生成的可执行文件的名称以及源代码文件的列表。\n\n\n# 添加库文件\n\n使用 add_library() 命令来添加库文件，如 add_library(my_library STATIC \\${SOURCE_FILES})（静态库）或者 add_library(my_library SHARED \\${SOURCE_FILES})（动态库）。\n\n其中，my_library 是库文件的名称，\\${SOURCE_FILES} 是需要编译的源代码文件。该命令用于指定要生成的库文件的名称、类型以及源代码文件的列表。\n\n\n# 链接库文件\n\n使用 target_link_libraries() 命令来将库文件链接到目标文件中，如 target_link_libraries(my_executable my_library)。\n\n其中，my_executable 是可执行文件的名称，my_library 是需要链接的库文件名称。该命令用于指定要链接到可执行文件或库文件中的库文件的列表。\n\n\n# 控制流语句\n\nCMake支持一些基本的控制流语句，如 if()、else()、elseif()和endif()，可用于根据条件设置变量或执行特定的操作。\n\n\n# 循环语句\n\nCMake也支持循环语句，如 foreach() 和 while()，可用于遍历列表或实现特定的循环操作。\n\n\n# 自定义命令\n\nCMake允许使用 add_custom_command() 和 add_custom_target() 命令来定义自定义构建步骤或目标，这些步骤或目标可以在构建过程中执行。\n\n\n# 安装规则\n\nCMake 提供了 install() 命令用于描述安装规则，包括将可执行文件、库文件和其他资源复制到指定位置等操作。\n\n以上是 CMake 中的一些常见语法，但并不限于此， CMake 还有许多高级特性，如宏、函数、模块化编程等，这些特性可以帮助开发者更方便地管理和构建项目。",normalizedContent:"# cmake\n\ncmake 是一个跨平台的构建系统，可以用于自动生成各种不同平台编译器的构建文件。 cmake 使用一种类似于脚本的语言来描述项目的构建过程，并生成相应的 makefile 或其他构建工具所需的配置文件。\n\n下面是一些常见的cmake语法：\n\n\n# 定义变量\n\n使用 set() 命令来定义一个变量，如 set(source_files main.cpp)。\n\n其中，source_files 是变量名，main.cpp 是变量值。在cmake中，变量可以是字符串、列表或布尔值。\n\n\n# 添加头文件搜索路径\n\n使用 include_directories() 命令来添加头文件搜索路径，如 include_directories(include)。\n\n其中，include 是需要添加的头文件路径。该命令用于指定包含c/c++头文件的目录列表，以便编译器能够找到它们。\n\n\n# 添加库文件搜索路径\n\n使用 link_directories() 命令来添加库文件搜索路径，如 link_directories(lib)。\n\n其中，lib 是需要添加的库文件路径。该命令用于指定包含库文件的目录列表，以便链接器能够找到它们。\n\n\n# 添加可执行文件\n\n使用 add_executable() 命令来添加可执行文件，如 add_executable(my_executable \\${source_files})。\n\n其中，my_executable 是可执行文件的名称，\\${source_files} 是需要编译的源代码文件。该命令用于指定要生成的可执行文件的名称以及源代码文件的列表。\n\n\n# 添加库文件\n\n使用 add_library() 命令来添加库文件，如 add_library(my_library static \\${source_files})（静态库）或者 add_library(my_library shared \\${source_files})（动态库）。\n\n其中，my_library 是库文件的名称，\\${source_files} 是需要编译的源代码文件。该命令用于指定要生成的库文件的名称、类型以及源代码文件的列表。\n\n\n# 链接库文件\n\n使用 target_link_libraries() 命令来将库文件链接到目标文件中，如 target_link_libraries(my_executable my_library)。\n\n其中，my_executable 是可执行文件的名称，my_library 是需要链接的库文件名称。该命令用于指定要链接到可执行文件或库文件中的库文件的列表。\n\n\n# 控制流语句\n\ncmake支持一些基本的控制流语句，如 if()、else()、elseif()和endif()，可用于根据条件设置变量或执行特定的操作。\n\n\n# 循环语句\n\ncmake也支持循环语句，如 foreach() 和 while()，可用于遍历列表或实现特定的循环操作。\n\n\n# 自定义命令\n\ncmake允许使用 add_custom_command() 和 add_custom_target() 命令来定义自定义构建步骤或目标，这些步骤或目标可以在构建过程中执行。\n\n\n# 安装规则\n\ncmake 提供了 install() 命令用于描述安装规则，包括将可执行文件、库文件和其他资源复制到指定位置等操作。\n\n以上是 cmake 中的一些常见语法，但并不限于此， cmake 还有许多高级特性，如宏、函数、模块化编程等，这些特性可以帮助开发者更方便地管理和构建项目。",charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:34:25",lastUpdatedTimestamp:1680708865e3},{title:"CMake详解",frontmatter:{title:"CMake详解",date:"2023-04-03T22:52:32.000Z",permalink:"/pages/44f8a2/",categories:["常用工具","CMake"],tags:["CMake"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/20.CMake/2.CMake%E8%AF%A6%E8%A7%A3.html",relativePath:"50.常用工具/20.CMake/2.CMake详解.md",key:"v-70aac31b",path:"/pages/44f8a2/",headers:[{level:2,title:"什么是 CMake?",slug:"什么是-cmake",normalizedTitle:"什么是 cmake?",charIndex:2},{level:2,title:"入门案例：单个源文件",slug:"入门案例-单个源文件",normalizedTitle:"入门案例：单个源文件",charIndex:716},{level:3,title:"编写 CMakeLists.txt",slug:"编写-cmakelists-txt",normalizedTitle:"编写 cmakelists.txt",charIndex:1728},{level:3,title:"编译项目",slug:"编译项目",normalizedTitle:"编译项目",charIndex:2211},{level:2,title:"多个源文件",slug:"多个源文件",normalizedTitle:"多个源文件",charIndex:3260},{level:3,title:"同一目录，多个源文件",slug:"同一目录-多个源文件",normalizedTitle:"同一目录，多个源文件",charIndex:3270},{level:2,title:"多个目录，多个源文件",slug:"多个目录-多个源文件",normalizedTitle:"多个目录，多个源文件",charIndex:4281},{level:2,title:"自定义编译选项",slug:"自定义编译选项",normalizedTitle:"自定义编译选项",charIndex:5433},{level:3,title:"修改 CMakeLists 文件",slug:"修改-cmakelists-文件",normalizedTitle:"修改 cmakelists 文件",charIndex:5636},{level:3,title:"修改 main.cc 文件",slug:"修改-main-cc-文件",normalizedTitle:"修改 main.cc 文件",charIndex:6635},{level:3,title:"编写 config.h.in 文件",slug:"编写-config-h-in-文件",normalizedTitle:"编写 config.h.in 文件",charIndex:7446},{level:3,title:"编译项目",slug:"编译项目-2",normalizedTitle:"编译项目",charIndex:2211},{level:3,title:"USE_MYMATH 为 ON",slug:"use-mymath-为-on",normalizedTitle:"use_mymath 为 on",charIndex:7976},{level:3,title:"USE_MYMATH 为 OFF",slug:"use-mymath-为-off",normalizedTitle:"use_mymath 为 off",charIndex:8197},{level:2,title:"安装和测试",slug:"安装和测试",normalizedTitle:"安装和测试",charIndex:8415},{level:3,title:"定制安装规则",slug:"定制安装规则",normalizedTitle:"定制安装规则",charIndex:8665},{level:3,title:"为工程添加测试",slug:"为工程添加测试",normalizedTitle:"为工程添加测试",charIndex:9782},{level:2,title:"支持 gdb",slug:"支持-gdb",normalizedTitle:"支持 gdb",charIndex:11719},{level:2,title:"添加环境检查",slug:"添加环境检查",normalizedTitle:"添加环境检查",charIndex:11963},{level:3,title:"添加 CheckFunctionExists 宏",slug:"添加-checkfunctionexists-宏",normalizedTitle:"添加 checkfunctionexists 宏",charIndex:12141},{level:3,title:"预定义相关宏变量",slug:"预定义相关宏变量",normalizedTitle:"预定义相关宏变量",charIndex:12429},{level:3,title:"在代码中使用宏和函数",slug:"在代码中使用宏和函数",normalizedTitle:"在代码中使用宏和函数",charIndex:12548},{level:2,title:"添加版本号",slug:"添加版本号",normalizedTitle:"添加版本号",charIndex:12826},{level:2,title:"生成安装包",slug:"生成安装包",normalizedTitle:"生成安装包",charIndex:14183},{level:2,title:"项目迁移",slug:"项目迁移",normalizedTitle:"项目迁移",charIndex:18170},{level:3,title:"autotools",slug:"autotools",normalizedTitle:"autotools",charIndex:18291},{level:3,title:"qmake",slug:"qmake",normalizedTitle:"qmake",charIndex:49},{level:3,title:"Visual Studio",slug:"visual-studio",normalizedTitle:"visual studio",charIndex:367},{level:3,title:"CMakeLists.txt 自动推导",slug:"cmakelists-txt-自动推导",normalizedTitle:"cmakelists.txt 自动推导",charIndex:18783},{level:2,title:"类似工具",slug:"类似工具",normalizedTitle:"类似工具",charIndex:18920}],headersStr:"什么是 CMake? 入门案例：单个源文件 编写 CMakeLists.txt 编译项目 多个源文件 同一目录，多个源文件 多个目录，多个源文件 自定义编译选项 修改 CMakeLists 文件 修改 main.cc 文件 编写 config.h.in 文件 编译项目 USE_MYMATH 为 ON USE_MYMATH 为 OFF 安装和测试 定制安装规则 为工程添加测试 支持 gdb 添加环境检查 添加 CheckFunctionExists 宏 预定义相关宏变量 在代码中使用宏和函数 添加版本号 生成安装包 项目迁移 autotools qmake Visual Studio CMakeLists.txt 自动推导 类似工具",content:'# 什么是 CMake?\n\n你或许听过好几种 Make 工具，例如 GNU Make ，QT 的 qmake ，微软的 MS nmake，BSD Make（pmake），Makepp，等等。\n\n这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。\n\nCMake 就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。\n\n从而做到 “Write once, run everywhere”。\n\n显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等 [1]。在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：\n\n写 CMake 配置文件 CMakeLists.txt 。 执行命令 cmake PATH 或者 ccmake PATH 生成 Makefile（ccmake和 cmake 的区别在于前者提供了一个交互式的界面）。其中， PATH 是 CMakeLists.txt 所在的目录。 使用 make 命令进行编译。\n\n\n# 入门案例：单个源文件\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo1\n\n对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * power - Calculate the power of number.\n * @param base: Base value.\n * @param exponent: Exponent value.\n *\n * @return base raised to the power exponent.\n */\ndouble power(double base, int exponent)\n{\n    int result = base;\n    int i;\n    \n    if (exponent == 0) {\n        return 1;\n    }\n    \n    for(i = 1; i < exponent; ++i){\n        result = result * base;\n    }\n\n    return result;\n}\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3){\n        printf("Usage: %s base exponent \\n", argv[0]);\n        return 1;\n    }\n    double base = atof(argv[1]);\n    int exponent = atoi(argv[2]);\n    double result = power(base, exponent);\n    printf("%g ^ %d is %g\\n", base, exponent, result);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 编写 CMakeLists.txt\n\n首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下：\n\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n\n# 项目信息\nproject (Demo1)\n\n# 指定生成目标\nadd_executable(Demo main.cc)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nCMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。\n\n符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。\n\n对于上面的 CMakeLists.txt 文件，依次出现了几个命令：\n\ncmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本； project：参数值是 Demo1，该命令表示项目的名称是 Demo1 。 add_executable：将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件。\n\n\n# 编译项目\n\n之后，在当前目录执行 cmake . ，得到 Makefile 后再使用 make 命令编译得到 Demo1 可执行文件。\n\n[ehome@xman Demo1]$ cmake .\n-- The C compiler identification is GNU 4.8.2\n-- The CXX compiler identification is GNU 4.8.2\n-- Check for working C compiler: /usr/sbin/cc\n-- Check for working C compiler: /usr/sbin/cc -- works\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Check for working CXX compiler: /usr/sbin/c++\n-- Check for working CXX compiler: /usr/sbin/c++ -- works\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/ehome/Documents/programming/C/power/Demo1\n[ehome@xman Demo1]$ make\nScanning dependencies of target Demo\n[100%] Building C object CMakeFiles/Demo.dir/main.cc.o\nLinking C executable Demo\n[100%] Built target Demo\n[ehome@xman Demo1]$ ./Demo 5 4\n5 ^ 4 is 625\n[ehome@xman Demo1]$ ./Demo 7 3\n7 ^ 3 is 343\n[ehome@xman Demo1]$ ./Demo 2 10\n2 ^ 10 is 1024\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 多个源文件\n\n\n# 同一目录，多个源文件\n\n本小节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo2\n\n上面的例子只有单个源文件。现在假如把 power 函数单独写进一个名为 MathFunctions.c 的源文件里，使得这个工程变成如下的形式：\n\n./Demo2\n    |\n    +--- main.cc\n    |\n    +--- MathFunctions.cc\n    |\n    +--- MathFunctions.h\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个时候，CMakeLists.txt 可以改成如下的形式：\n\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n\n# 项目信息\nproject (Demo2)\n\n# 指定生成目标\nadd_executable(Demo main.cc MathFunctions.cc)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n唯一的改动只是在 add_executable 命令中增加了一个 MathFunctions.cc 源文件。\n\n这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：\n\naux_source_directory(<dir> <variable>)\n\n\n1\n\n\n因此，可以修改 CMakeLists.txt 如下：\n\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n\n# 项目信息\nproject (Demo2)\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 DIR_SRCS 变量\naux_source_directory(. DIR_SRCS)\n\n# 指定生成目标\nadd_executable(Demo ${DIR_SRCS})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样，CMake 会将当前目录所有源文件的文件名赋值给变量 DIR_SRCS ，再指示变量 DIR_SRCS 中的源文件需要编译成一个名称为 Demo 的可执行文件。\n\n\n# 多个目录，多个源文件\n\n本小节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo3\n\n现在进一步将 MathFunctions.h 和 MathFunctions.cc 文件移动到 math 目录下。\n\n./Demo3\n    |\n    +--- main.cc\n    |\n    +--- math/\n          |\n          +--- MathFunctions.cc\n          |\n          +--- MathFunctions.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt文件。\n\n为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。\n\n根目录中的 CMakeLists.txt ：\n\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n\n# 项目信息\nproject (Demo3)\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 DIR_SRCS 变量\naux_source_directory(. DIR_SRCS)\n\n# 添加 math 子目录\nadd_subdirectory(math)\n\n# 指定生成目标 \nadd_executable(Demo main.cc)\n\n# 添加链接库\ntarget_link_libraries(Demo MathFunctions)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n该文件添加了下面的内容: 第3行，使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。\n\n第6行，使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。\n\n子目录中的 CMakeLists.txt：\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 DIR_LIB_SRCS 变量\naux_source_directory(. DIR_LIB_SRCS)\n\n# 生成链接库\nadd_library (MathFunctions ${DIR_LIB_SRCS})\n\n\n1\n2\n3\n4\n5\n6\n\n\n在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。\n\n\n# 自定义编译选项\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo4\n\nCMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 ON ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。\n\n\n# 修改 CMakeLists 文件\n\n我们要做的第一步是在顶层的 CMakeLists.txt 文件中添加该选项：\n\n# CMake 最低版本号要求\ncmake_minimum_required (VERSION 2.8)\n\n# 项目信息\nproject (Demo4)\n\n# 加入一个配置头文件，用于处理 CMake 对源码的设置\nconfigure_file (\n  "${PROJECT_SOURCE_DIR}/config.h.in"\n  "${PROJECT_BINARY_DIR}/config.h"\n  )\n\n# 是否使用自己的 MathFunctions 库\noption (USE_MYMATH\n       "Use provided math implementation" ON)\n\n# 是否加入 MathFunctions 库\nif (USE_MYMATH)\n  include_directories ("${PROJECT_SOURCE_DIR}/math")\n  add_subdirectory (math)  \n  set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions)\nendif (USE_MYMATH)\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 DIR_SRCS 变量\naux_source_directory(. DIR_SRCS)\n\n# 指定生成目标\nadd_executable(Demo ${DIR_SRCS})\ntarget_link_libraries (Demo  ${EXTRA_LIBS})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n其中：\n\n第7行的 configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。 第13行的 option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。 第17行根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。\n\n\n# 修改 main.cc 文件\n\n之后修改 main.cc 文件，让其根据 USE_MYMATH 的预定义值来决定是否调用标准库还是 MathFunctions 库：\n\n#include <stdio.h>\n#include <stdlib.h>\n#include "config.h"\n\n#ifdef USE_MYMATH\n  #include "math/MathFunctions.h"\n#else\n  #include <math.h>\n#endif\n\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3){\n        printf("Usage: %s base exponent \\n", argv[0]);\n        return 1;\n    }\n    double base = atof(argv[1]);\n    int exponent = atoi(argv[2]);\n    \n#ifdef USE_MYMATH\n    printf("Now we use our own Math library. \\n");\n    double result = power(base, exponent);\n#else\n    printf("Now we use the standard library. \\n");\n    double result = pow(base, exponent);\n#endif\n    printf("%g ^ %d is %g\\n", base, exponent, result);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 编写 config.h.in 文件\n\n上面的程序值得注意的是第2行，这里引用了一个 config.h 文件，这个文件预定义了 USE_MYMATH 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：\n\n#cmakedefine USE_MYMATH\n\n\n1\n\n\n这样 CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。\n\n\n# 编译项目\n\n现在编译一下这个项目，为了便于交互式的选择该变量的值，可以使用 ccmake 命令（也可以使用 cmake -i 命令，该命令会提供一个会话式的交互式配置界面）：\n\n\n\nCMake的交互式配置界面 CMake的交互式配置界面从中可以找到刚刚定义的 USE_MYMATH 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 enter 键可以修改该选项。修改完成后可以按下 c 选项完成配置，之后再按 g 键确认生成 Makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。我们可以试试分别将 USE_MYMATH 设为 ON 和 OFF 得到的结果：\n\n\n# USE_MYMATH 为 ON\n\n运行结果：\n\n[ehome@xman Demo4]$ ./Demo\nNow we use our own MathFunctions library. \n 7 ^ 3 = 343.000000\n 10 ^ 5 = 100000.000000\n 2 ^ 10 = 1024.000000\n\n\n1\n2\n3\n4\n5\n\n\n此时 config.h 的内容为：\n\n#define USE_MYMATH\n\n\n1\n\n\n\n# USE_MYMATH 为 OFF\n\n运行结果：\n\n[ehome@xman Demo4]$ ./Demo\nNow we use the standard library. \n 7 ^ 3 = 343.000000\n 10 ^ 5 = 100000.000000\n 2 ^ 10 = 1024.000000\n\n\n1\n2\n3\n4\n5\n\n\n此时 config.h 的内容为：\n\n/* #undef USE_MYMATH */\n\n\n1\n\n\n\n# 安装和测试\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo5\n\nCMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 make install 和 make test 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 install 和 test 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。\n\n\n# 定制安装规则\n\n首先先在math/CMakeLists.txt 文件里添加下面两行：\n\n# 指定 MathFunctions 库的安装路径\ninstall (TARGETS MathFunctions DESTINATION bin)\ninstall (FILES MathFunctions.h DESTINATION include)\n\n\n1\n2\n3\n\n\n指明 MathFunctions 库的安装路径。之后同样修改根目录的 CMakeLists 文件，在末尾添加下面几行：\n\n# 指定安装路径\ninstall (TARGETS Demo DESTINATION bin)\ninstall (FILES "${PROJECT_BINARY_DIR}/config.h"\n         DESTINATION include)\n\n\n1\n2\n3\n4\n\n\n通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 /usr/local/bin 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 /usr/local/include 中。\n\n我们可以验证一下（顺带一提的是，这里的 /usr/local/ 是默认安装到的根目录，可以通过修改 CMAKE_INSTALL_PREFIX 变量的值来指定这些文件应该拷贝到哪个根目录）：\n\n[ehome@xman Demo5]$ sudo make install\n[ 50%] Built target MathFunctions\n[100%] Built target Demo\nInstall the project...\n-- Install configuration: ""\n-- Installing: /usr/local/bin/Demo\n-- Installing: /usr/local/include/config.h\n-- Installing: /usr/local/bin/libMathFunctions.a\n-- Up-to-date: /usr/local/include/MathFunctions.h\n[ehome@xman Demo5]$ ls /usr/local/bin\nDemo  libMathFunctions.a\n[ehome@xman Demo5]$ ls /usr/local/include\nconfig.h  MathFunctions.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 为工程添加测试\n\n添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 add_test 命令。\n\n# 启用测试\nenable_testing()\n\n# 测试程序是否成功运行\nadd_test (test_run Demo 5 2)\n\n# 测试帮助信息是否可以正常提示\nadd_test (test_usage Demo)\nset_tests_properties (test_usage\n  PROPERTIES PASS_REGULAR_EXPRESSION "Usage: .* base exponent")\n\n# 测试 5 的平方\nadd_test (test_5_2 Demo 5 2)\nset_tests_properties (test_5_2\n PROPERTIES PASS_REGULAR_EXPRESSION "is 25")\n\n# 测试 10 的 5 次方\nadd_test (test_10_5 Demo 10 5)\nset_tests_properties (test_10_5\n PROPERTIES PASS_REGULAR_EXPRESSION "is 100000")\n\n# 测试 2 的 10 次方\nadd_test (test_2_10 Demo 2 10)\nset_tests_properties (test_2_10\n PROPERTIES PASS_REGULAR_EXPRESSION "is 1024")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面的代码包含了四个测试。第一个测试 test_run 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 PASS_REGULAR_EXPRESSION 用来测试输出是否包含后面跟着的字符串。让我们看看测试的结果：\n\n[ehome@xman Demo5]$ make test\nRunning tests...\nTest project /home/ehome/Documents/programming/C/power/Demo5\n    Start 1: test_run\n1/4 Test #1: test_run .........................   Passed    0.00 sec\n    Start 2: test_5_2\n2/4 Test #2: test_5_2 .........................   Passed    0.00 sec\n    Start 3: test_10_5\n3/4 Test #3: test_10_5 ........................   Passed    0.00 sec\n    Start 4: test_2_10\n4/4 Test #4: test_2_10 ........................   Passed    0.00 sec\n\n100% tests passed, 0 tests failed out of 4\n\nTotal Test time (real) =   0.01 sec\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果要测试更多的输入数据，像上面那样一个个写测试用例未免太繁琐。这时可以通过编写宏来实现：\n\n# 定义一个宏，用来简化测试工作\nmacro (do_test arg1 arg2 result)\n  add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2})\n  set_tests_properties (test_${arg1}_${arg2}\n    PROPERTIES PASS_REGULAR_EXPRESSION ${result})\nendmacro (do_test)\n \n# 使用该宏进行一系列的数据测试\ndo_test (5 2 "is 25")\ndo_test (10 5 "is 100000")\ndo_test (2 10 "is 1024")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n关于 CTest 的更详细的用法可以通过 man 1 ctest 参考 CTest 的文档。\n\n\n# 支持 gdb\n\n让 CMake 支持 gdb 的设置也很容易，只需要指定 Debug 模式下开启 -g 选项：\n\nset(CMAKE_BUILD_TYPE "Debug")\nset(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")\nset(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -O3 -Wall")\n\n\n1\n2\n3\n\n\n之后可以直接对生成的程序使用 gdb 来调试。\n\n\n# 添加环境检查\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo6\n\n有时候可能要对系统环境做点检查，例如要使用一个平台相关的特性的时候。在这个例子中，我们检查系统是否自带 pow 函数。如果带有 pow 函数，就使用它；否则使用我们定义的 power 函数。\n\n\n# 添加 CheckFunctionExists 宏\n\n首先在顶层 CMakeLists 文件中添加 CheckFunctionExists.cmake 宏，并调用 check_function_exists 命令测试链接器是否能够在链接阶段找到 pow 函数。\n\n# 检查系统是否支持 pow 函数\ninclude (${CMAKE_ROOT}/Modules/CheckFunctionExists.cmake)\ncheck_function_exists (pow HAVE_POW)\n\n\n1\n2\n3\n\n\n将上面这段代码放在 configure_file 命令前。\n\n\n# 预定义相关宏变量\n\n接下来修改 config.h.in 文件，预定义相关的宏变量。\n\n// does the platform provide pow function?\n#cmakedefine HAVE_POW\n\n\n1\n2\n\n\n\n# 在代码中使用宏和函数\n\n最后一步是修改 main.cc ，在代码中使用宏和函数：\n\n#ifdef HAVE_POW\n    printf("Now we use the standard library. \\n");\n    double result = pow(base, exponent);\n#else\n    printf("Now we use our own Math library. \\n");\n    double result = power(base, exponent);\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 添加版本号\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo7\n\n给项目添加和维护版本号是一个好习惯，这样有利于用户了解每个版本的维护情况，并及时了解当前所用的版本是否过时，或是否可能出现不兼容的情况。首先修改顶层 CMakeLists 文件，在 project 命令之后加入如下两行：\n\nset (Demo_VERSION_MAJOR 1)\nset (Demo_VERSION_MINOR 0)\n\n\n1\n2\n\n\n分别指定当前的项目的主版本号和副版本号。之后，为了在代码中获取版本信息，我们可以修改 config.h.in 文件，添加两个预定义变量：\n\n// the configured options and settings for Tutorial\n#define Demo_VERSION_MAJOR @Demo_VERSION_MAJOR@\n#define Demo_VERSION_MINOR @Demo_VERSION_MINOR@\n\n\n1\n2\n3\n\n\n这样就可以直接在代码中打印版本信息了：\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include "config.h"\n#include "math/MathFunctions.h"\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3){\n        // print version info\n        printf("%s Version %d.%d\\n",\n            argv[0],\n            Demo_VERSION_MAJOR,\n            Demo_VERSION_MINOR);\n        printf("Usage: %s base exponent \\n", argv[0]);\n        return 1;\n    }\n    double base = atof(argv[1]);\n    int exponent = atoi(argv[2]);\n    \n#if defined (HAVE_POW)\n    printf("Now we use the standard library. \\n");\n    double result = pow(base, exponent);\n#else\n    printf("Now we use our own Math library. \\n");\n    double result = power(base, exponent);\n#endif\n    \n    printf("%g ^ %d is %g\\n", base, exponent, result);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 生成安装包\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/Demo8\n\n本节将学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。首先在顶层的 CMakeLists.txt 文件尾部添加下面几行：\n\n# 构建一个 CPack 安装包\ninclude (InstallRequiredSystemLibraries)\nset (CPACK_RESOURCE_FILE_LICENSE\n  "${CMAKE_CURRENT_SOURCE_DIR}/License.txt")\nset (CPACK_PACKAGE_VERSION_MAJOR "${Demo_VERSION_MAJOR}")\nset (CPACK_PACKAGE_VERSION_MINOR "${Demo_VERSION_MINOR}")\ninclude (CPack)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的代码做了以下几个工作：\n\n导入 InstallRequiredSystemLibraries 模块，以便之后导入 CPack 模块； 设置一些 CPack 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号； 导入 CPack 模块。 接下来的工作是像往常一样构建工程，并执行 cpack 命令。\n\n生成二进制安装包：\n\n> cpack -C CPackConfig.cmake\n\n生成源码安装包\n\n> cpack -C CPackSourceConfig.cmake\n\n我们可以试一下。在生成项目后，执行 cpack -C CPackConfig.cmake 命令：\n\n[ehome@xman Demo8]$ cpack -C CPackSourceConfig.cmake\nCPack: Create package using STGZ\nCPack: Install projects\nCPack: - Run preinstall target for: Demo8\nCPack: - Install project: Demo8\nCPack: Create package\nCPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux.sh generated.\nCPack: Create package using TGZ\nCPack: Install projects\nCPack: - Run preinstall target for: Demo8\nCPack: - Install project: Demo8\nCPack: Create package\nCPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux.tar.gz generated.\nCPack: Create package using TZ\nCPack: Install projects\nCPack: - Run preinstall target for: Demo8\nCPack: - Install project: Demo8\nCPack: Create package\nCPack: - package: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux.tar.Z generated.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n此时会在该目录下创建 3 个不同格式的二进制包文件：\n\n[ehome@xman Demo8]$ ls Demo8-*\nDemo8-1.0.1-Linux.sh  Demo8-1.0.1-Linux.tar.gz  Demo8-1.0.1-Linux.tar.Z\n\n\n1\n2\n\n\n这 3 个二进制包文件所包含的内容是完全相同的。我们可以执行其中一个。此时会出现一个由 CPack 自动生成的交互式安装界面：\n\n[ehome@xman Demo8]$ sh Demo8-1.0.1-Linux.sh \nDemo8 Installer Version: 1.0.1, Copyright (c) Humanity\nThis is a self-extracting archive.\nThe archive will be extracted to: /home/ehome/Documents/programming/C/power/Demo8\n\nIf you want to stop extracting, please press <ctrl-C>.\nThe MIT License (MIT)\n\nCopyright (c) 2013 Joseph Pan(http://hahack.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the "Software"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nDo you accept the license? [yN]: \ny\nBy default the Demo8 will be installed in:\n  "/home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux"\nDo you want to include the subdirectory Demo8-1.0.1-Linux?\nSaying no will install in: "/home/ehome/Documents/programming/C/power/Demo8" [Yn]: \ny\n\nUsing target directory: /home/ehome/Documents/programming/C/power/Demo8/Demo8-1.0.1-Linux\nExtracting, please wait...\n\nUnpacking finished successfully\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n完成后提示安装到了 Demo8-1.0.1-Linux 子目录中，我们可以进去执行该程序：\n\n[ehome@xman Demo8]$ ./Demo8-1.0.1-Linux/bin/Demo 5 2\nNow we use our own Math library. \n5 ^ 2 is 25\n\n\n1\n2\n3\n\n\n关于 CPack 的更详细的用法可以通过 man 1 cpack 参考 CPack 的文档。\n\n\n# 项目迁移\n\nCMake 可以很轻松地构建出在适合各个平台执行的工程环境。而如果当前的工程环境不是 CMake ，而是基于某个特定的平台，是否可以迁移到 CMake 呢？答案是可能的。下面针对几个常用的平台，列出了它们对应的迁移方案。\n\n\n# autotools\n\n * am2cmake 可以将 autotools 系的项目转换到 CMake，这个工具的一个成功案例是 KDE 。\n * Alternative Automake2CMake 可以转换使用 automake 的 KDevelop 工程项目。\n * Converting autoconf tests\n\n\n# qmake\n\n * qmake converter 可以转换使用 QT 的 qmake 的工程。\n\n\n# Visual Studio\n\n * vcproj2cmake.rb 可以根据 Visual Studio 的工程文件（后缀名是 .vcproj 或 .vcxproj）生成 CMakeLists.txt 文件。\n * vcproj2cmake.ps1 vcproj2cmake 的 PowerShell 版本。\n * folders4cmake 根据 Visual Studio 项目文件生成相应的 “source_group” 信息，这些信息可以很方便的在 CMake 脚本中使用。支持 Visual Studio 9/10 工程文件。\n\n\n# CMakeLists.txt 自动推导\n\n * gencmake 根据现有文件推导 CMakeLists.txt 文件。\n * CMakeListGenerator 应用一套文件和目录分析创建出完整的 CMakeLists.txt 文件。仅支持 Win32 平台。\n\n\n# 类似工具\n\n * SCons：Eric S. Raymond、Timothee Besset、Zed A. Shaw 等大神力荐的项目架构工具。和 CMake 的最大区别是使用 Python 作为执行脚本',normalizedContent:'# 什么是 cmake?\n\n你或许听过好几种 make 工具，例如 gnu make ，qt 的 qmake ，微软的 ms nmake，bsd make（pmake），makepp，等等。\n\n这些 make 工具遵循着不同的规范和标准，所执行的 makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 make 工具，就得为每一种标准写一次 makefile ，这将是一件让人抓狂的工作。\n\ncmake 就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 cmakelist.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 makefile 和工程文件，如 unix 的 makefile 或 windows 的 visual studio 工程。\n\n从而做到 “write once, run everywhere”。\n\n显然，cmake 是一个比上述几种 make 更高级的编译配置工具。一些使用 cmake 作为项目架构系统的知名开源项目有 vtk、itk、kde、opencv、osg 等 [1]。在 linux 平台下使用 cmake 生成 makefile 并编译的流程如下：\n\n写 cmake 配置文件 cmakelists.txt 。 执行命令 cmake path 或者 ccmake path 生成 makefile（ccmake和 cmake 的区别在于前者提供了一个交互式的界面）。其中， path 是 cmakelists.txt 所在的目录。 使用 make 命令进行编译。\n\n\n# 入门案例：单个源文件\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo1\n\n对于简单的项目，只需要写几行代码就可以了。例如，假设现在我们的项目中只有一个源文件 main.cc ，该程序的用途是计算一个数的指数幂。\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/**\n * power - calculate the power of number.\n * @param base: base value.\n * @param exponent: exponent value.\n *\n * @return base raised to the power exponent.\n */\ndouble power(double base, int exponent)\n{\n    int result = base;\n    int i;\n    \n    if (exponent == 0) {\n        return 1;\n    }\n    \n    for(i = 1; i < exponent; ++i){\n        result = result * base;\n    }\n\n    return result;\n}\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3){\n        printf("usage: %s base exponent \\n", argv[0]);\n        return 1;\n    }\n    double base = atof(argv[1]);\n    int exponent = atoi(argv[2]);\n    double result = power(base, exponent);\n    printf("%g ^ %d is %g\\n", base, exponent, result);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 编写 cmakelists.txt\n\n首先编写 cmakelists.txt 文件，并保存在与 main.cc 源文件同个目录下：\n\n# cmake 最低版本号要求\ncmake_minimum_required (version 2.8)\n\n# 项目信息\nproject (demo1)\n\n# 指定生成目标\nadd_executable(demo main.cc)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\ncmakelists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。\n\n符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。\n\n对于上面的 cmakelists.txt 文件，依次出现了几个命令：\n\ncmake_minimum_required：指定运行此配置文件所需的 cmake 的最低版本； project：参数值是 demo1，该命令表示项目的名称是 demo1 。 add_executable：将名为 main.cc 的源文件编译成一个名称为 demo 的可执行文件。\n\n\n# 编译项目\n\n之后，在当前目录执行 cmake . ，得到 makefile 后再使用 make 命令编译得到 demo1 可执行文件。\n\n[ehome@xman demo1]$ cmake .\n-- the c compiler identification is gnu 4.8.2\n-- the cxx compiler identification is gnu 4.8.2\n-- check for working c compiler: /usr/sbin/cc\n-- check for working c compiler: /usr/sbin/cc -- works\n-- detecting c compiler abi info\n-- detecting c compiler abi info - done\n-- check for working cxx compiler: /usr/sbin/c++\n-- check for working cxx compiler: /usr/sbin/c++ -- works\n-- detecting cxx compiler abi info\n-- detecting cxx compiler abi info - done\n-- configuring done\n-- generating done\n-- build files have been written to: /home/ehome/documents/programming/c/power/demo1\n[ehome@xman demo1]$ make\nscanning dependencies of target demo\n[100%] building c object cmakefiles/demo.dir/main.cc.o\nlinking c executable demo\n[100%] built target demo\n[ehome@xman demo1]$ ./demo 5 4\n5 ^ 4 is 625\n[ehome@xman demo1]$ ./demo 7 3\n7 ^ 3 is 343\n[ehome@xman demo1]$ ./demo 2 10\n2 ^ 10 is 1024\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 多个源文件\n\n\n# 同一目录，多个源文件\n\n本小节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo2\n\n上面的例子只有单个源文件。现在假如把 power 函数单独写进一个名为 mathfunctions.c 的源文件里，使得这个工程变成如下的形式：\n\n./demo2\n    |\n    +--- main.cc\n    |\n    +--- mathfunctions.cc\n    |\n    +--- mathfunctions.h\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这个时候，cmakelists.txt 可以改成如下的形式：\n\n# cmake 最低版本号要求\ncmake_minimum_required (version 2.8)\n\n# 项目信息\nproject (demo2)\n\n# 指定生成目标\nadd_executable(demo main.cc mathfunctions.cc)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n唯一的改动只是在 add_executable 命令中增加了一个 mathfunctions.cc 源文件。\n\n这样写当然没什么问题，但是如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。更省事的方法是使用 aux_source_directory 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：\n\naux_source_directory(<dir> <variable>)\n\n\n1\n\n\n因此，可以修改 cmakelists.txt 如下：\n\n# cmake 最低版本号要求\ncmake_minimum_required (version 2.8)\n\n# 项目信息\nproject (demo2)\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 dir_srcs 变量\naux_source_directory(. dir_srcs)\n\n# 指定生成目标\nadd_executable(demo ${dir_srcs})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这样，cmake 会将当前目录所有源文件的文件名赋值给变量 dir_srcs ，再指示变量 dir_srcs 中的源文件需要编译成一个名称为 demo 的可执行文件。\n\n\n# 多个目录，多个源文件\n\n本小节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo3\n\n现在进一步将 mathfunctions.h 和 mathfunctions.cc 文件移动到 math 目录下。\n\n./demo3\n    |\n    +--- main.cc\n    |\n    +--- math/\n          |\n          +--- mathfunctions.cc\n          |\n          +--- mathfunctions.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对于这种情况，需要分别在项目根目录 demo3 和 math 目录里各编写一个 cmakelists.txt文件。\n\n为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。\n\n根目录中的 cmakelists.txt ：\n\n# cmake 最低版本号要求\ncmake_minimum_required (version 2.8)\n\n# 项目信息\nproject (demo3)\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 dir_srcs 变量\naux_source_directory(. dir_srcs)\n\n# 添加 math 子目录\nadd_subdirectory(math)\n\n# 指定生成目标 \nadd_executable(demo main.cc)\n\n# 添加链接库\ntarget_link_libraries(demo mathfunctions)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n该文件添加了下面的内容: 第3行，使用命令 add_subdirectory 指明本项目包含一个子目录 math，这样 math 目录下的 cmakelists.txt 文件和源代码也会被处理 。\n\n第6行，使用命令 target_link_libraries 指明可执行文件 main 需要连接一个名为 mathfunctions 的链接库 。\n\n子目录中的 cmakelists.txt：\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 dir_lib_srcs 变量\naux_source_directory(. dir_lib_srcs)\n\n# 生成链接库\nadd_library (mathfunctions ${dir_lib_srcs})\n\n\n1\n2\n3\n4\n5\n6\n\n\n在该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。\n\n\n# 自定义编译选项\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo4\n\ncmake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。例如，可以将 mathfunctions 库设为一个可选的库，如果该选项为 on ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。\n\n\n# 修改 cmakelists 文件\n\n我们要做的第一步是在顶层的 cmakelists.txt 文件中添加该选项：\n\n# cmake 最低版本号要求\ncmake_minimum_required (version 2.8)\n\n# 项目信息\nproject (demo4)\n\n# 加入一个配置头文件，用于处理 cmake 对源码的设置\nconfigure_file (\n  "${project_source_dir}/config.h.in"\n  "${project_binary_dir}/config.h"\n  )\n\n# 是否使用自己的 mathfunctions 库\noption (use_mymath\n       "use provided math implementation" on)\n\n# 是否加入 mathfunctions 库\nif (use_mymath)\n  include_directories ("${project_source_dir}/math")\n  add_subdirectory (math)  \n  set (extra_libs ${extra_libs} mathfunctions)\nendif (use_mymath)\n\n# 查找当前目录下的所有源文件\n# 并将名称保存到 dir_srcs 变量\naux_source_directory(. dir_srcs)\n\n# 指定生成目标\nadd_executable(demo ${dir_srcs})\ntarget_link_libraries (demo  ${extra_libs})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n其中：\n\n第7行的 configure_file 命令用于加入一个配置头文件 config.h ，这个文件由 cmake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。 第13行的 option 命令添加了一个 use_mymath 选项，并且默认值为 on 。 第17行根据 use_mymath 变量的值来决定是否使用我们自己编写的 mathfunctions 库。\n\n\n# 修改 main.cc 文件\n\n之后修改 main.cc 文件，让其根据 use_mymath 的预定义值来决定是否调用标准库还是 mathfunctions 库：\n\n#include <stdio.h>\n#include <stdlib.h>\n#include "config.h"\n\n#ifdef use_mymath\n  #include "math/mathfunctions.h"\n#else\n  #include <math.h>\n#endif\n\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3){\n        printf("usage: %s base exponent \\n", argv[0]);\n        return 1;\n    }\n    double base = atof(argv[1]);\n    int exponent = atoi(argv[2]);\n    \n#ifdef use_mymath\n    printf("now we use our own math library. \\n");\n    double result = power(base, exponent);\n#else\n    printf("now we use the standard library. \\n");\n    double result = pow(base, exponent);\n#endif\n    printf("%g ^ %d is %g\\n", base, exponent, result);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 编写 config.h.in 文件\n\n上面的程序值得注意的是第2行，这里引用了一个 config.h 文件，这个文件预定义了 use_mymath 的值。但我们并不直接编写这个文件，为了方便从 cmakelists.txt 中导入配置，我们编写一个 config.h.in 文件，内容如下：\n\n#cmakedefine use_mymath\n\n\n1\n\n\n这样 cmake 会自动根据 cmakelists 配置文件中的设置自动生成 config.h 文件。\n\n\n# 编译项目\n\n现在编译一下这个项目，为了便于交互式的选择该变量的值，可以使用 ccmake 命令（也可以使用 cmake -i 命令，该命令会提供一个会话式的交互式配置界面）：\n\n\n\ncmake的交互式配置界面 cmake的交互式配置界面从中可以找到刚刚定义的 use_mymath 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 enter 键可以修改该选项。修改完成后可以按下 c 选项完成配置，之后再按 g 键确认生成 makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。我们可以试试分别将 use_mymath 设为 on 和 off 得到的结果：\n\n\n# use_mymath 为 on\n\n运行结果：\n\n[ehome@xman demo4]$ ./demo\nnow we use our own mathfunctions library. \n 7 ^ 3 = 343.000000\n 10 ^ 5 = 100000.000000\n 2 ^ 10 = 1024.000000\n\n\n1\n2\n3\n4\n5\n\n\n此时 config.h 的内容为：\n\n#define use_mymath\n\n\n1\n\n\n\n# use_mymath 为 off\n\n运行结果：\n\n[ehome@xman demo4]$ ./demo\nnow we use the standard library. \n 7 ^ 3 = 343.000000\n 10 ^ 5 = 100000.000000\n 2 ^ 10 = 1024.000000\n\n\n1\n2\n3\n4\n5\n\n\n此时 config.h 的内容为：\n\n/* #undef use_mymath */\n\n\n1\n\n\n\n# 安装和测试\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo5\n\ncmake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 makefile 后使用 make install 和 make test 来执行。在以前的 gnu makefile 里，你可能需要为此编写 install 和 test 两个伪目标和相应的规则，但在 cmake 里，这样的工作同样只需要简单的调用几条命令。\n\n\n# 定制安装规则\n\n首先先在math/cmakelists.txt 文件里添加下面两行：\n\n# 指定 mathfunctions 库的安装路径\ninstall (targets mathfunctions destination bin)\ninstall (files mathfunctions.h destination include)\n\n\n1\n2\n3\n\n\n指明 mathfunctions 库的安装路径。之后同样修改根目录的 cmakelists 文件，在末尾添加下面几行：\n\n# 指定安装路径\ninstall (targets demo destination bin)\ninstall (files "${project_binary_dir}/config.h"\n         destination include)\n\n\n1\n2\n3\n4\n\n\n通过上面的定制，生成的 demo 文件和 mathfunctions 函数库 libmathfunctions.o 文件将会被复制到 /usr/local/bin 中，而 mathfunctions.h 和生成的 config.h 文件则会被复制到 /usr/local/include 中。\n\n我们可以验证一下（顺带一提的是，这里的 /usr/local/ 是默认安装到的根目录，可以通过修改 cmake_install_prefix 变量的值来指定这些文件应该拷贝到哪个根目录）：\n\n[ehome@xman demo5]$ sudo make install\n[ 50%] built target mathfunctions\n[100%] built target demo\ninstall the project...\n-- install configuration: ""\n-- installing: /usr/local/bin/demo\n-- installing: /usr/local/include/config.h\n-- installing: /usr/local/bin/libmathfunctions.a\n-- up-to-date: /usr/local/include/mathfunctions.h\n[ehome@xman demo5]$ ls /usr/local/bin\ndemo  libmathfunctions.a\n[ehome@xman demo5]$ ls /usr/local/include\nconfig.h  mathfunctions.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 为工程添加测试\n\n添加测试同样很简单。cmake 提供了一个称为 ctest 的测试工具。我们要做的只是在项目根目录的 cmakelists 文件中调用一系列的 add_test 命令。\n\n# 启用测试\nenable_testing()\n\n# 测试程序是否成功运行\nadd_test (test_run demo 5 2)\n\n# 测试帮助信息是否可以正常提示\nadd_test (test_usage demo)\nset_tests_properties (test_usage\n  properties pass_regular_expression "usage: .* base exponent")\n\n# 测试 5 的平方\nadd_test (test_5_2 demo 5 2)\nset_tests_properties (test_5_2\n properties pass_regular_expression "is 25")\n\n# 测试 10 的 5 次方\nadd_test (test_10_5 demo 10 5)\nset_tests_properties (test_10_5\n properties pass_regular_expression "is 100000")\n\n# 测试 2 的 10 次方\nadd_test (test_2_10 demo 2 10)\nset_tests_properties (test_2_10\n properties pass_regular_expression "is 1024")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面的代码包含了四个测试。第一个测试 test_run 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 pass_regular_expression 用来测试输出是否包含后面跟着的字符串。让我们看看测试的结果：\n\n[ehome@xman demo5]$ make test\nrunning tests...\ntest project /home/ehome/documents/programming/c/power/demo5\n    start 1: test_run\n1/4 test #1: test_run .........................   passed    0.00 sec\n    start 2: test_5_2\n2/4 test #2: test_5_2 .........................   passed    0.00 sec\n    start 3: test_10_5\n3/4 test #3: test_10_5 ........................   passed    0.00 sec\n    start 4: test_2_10\n4/4 test #4: test_2_10 ........................   passed    0.00 sec\n\n100% tests passed, 0 tests failed out of 4\n\ntotal test time (real) =   0.01 sec\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果要测试更多的输入数据，像上面那样一个个写测试用例未免太繁琐。这时可以通过编写宏来实现：\n\n# 定义一个宏，用来简化测试工作\nmacro (do_test arg1 arg2 result)\n  add_test (test_${arg1}_${arg2} demo ${arg1} ${arg2})\n  set_tests_properties (test_${arg1}_${arg2}\n    properties pass_regular_expression ${result})\nendmacro (do_test)\n \n# 使用该宏进行一系列的数据测试\ndo_test (5 2 "is 25")\ndo_test (10 5 "is 100000")\ndo_test (2 10 "is 1024")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n关于 ctest 的更详细的用法可以通过 man 1 ctest 参考 ctest 的文档。\n\n\n# 支持 gdb\n\n让 cmake 支持 gdb 的设置也很容易，只需要指定 debug 模式下开启 -g 选项：\n\nset(cmake_build_type "debug")\nset(cmake_cxx_flags_debug "$env{cxxflags} -o0 -wall -g -ggdb")\nset(cmake_cxx_flags_release "$env{cxxflags} -o3 -wall")\n\n\n1\n2\n3\n\n\n之后可以直接对生成的程序使用 gdb 来调试。\n\n\n# 添加环境检查\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo6\n\n有时候可能要对系统环境做点检查，例如要使用一个平台相关的特性的时候。在这个例子中，我们检查系统是否自带 pow 函数。如果带有 pow 函数，就使用它；否则使用我们定义的 power 函数。\n\n\n# 添加 checkfunctionexists 宏\n\n首先在顶层 cmakelists 文件中添加 checkfunctionexists.cmake 宏，并调用 check_function_exists 命令测试链接器是否能够在链接阶段找到 pow 函数。\n\n# 检查系统是否支持 pow 函数\ninclude (${cmake_root}/modules/checkfunctionexists.cmake)\ncheck_function_exists (pow have_pow)\n\n\n1\n2\n3\n\n\n将上面这段代码放在 configure_file 命令前。\n\n\n# 预定义相关宏变量\n\n接下来修改 config.h.in 文件，预定义相关的宏变量。\n\n// does the platform provide pow function?\n#cmakedefine have_pow\n\n\n1\n2\n\n\n\n# 在代码中使用宏和函数\n\n最后一步是修改 main.cc ，在代码中使用宏和函数：\n\n#ifdef have_pow\n    printf("now we use the standard library. \\n");\n    double result = pow(base, exponent);\n#else\n    printf("now we use our own math library. \\n");\n    double result = power(base, exponent);\n#endif\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 添加版本号\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo7\n\n给项目添加和维护版本号是一个好习惯，这样有利于用户了解每个版本的维护情况，并及时了解当前所用的版本是否过时，或是否可能出现不兼容的情况。首先修改顶层 cmakelists 文件，在 project 命令之后加入如下两行：\n\nset (demo_version_major 1)\nset (demo_version_minor 0)\n\n\n1\n2\n\n\n分别指定当前的项目的主版本号和副版本号。之后，为了在代码中获取版本信息，我们可以修改 config.h.in 文件，添加两个预定义变量：\n\n// the configured options and settings for tutorial\n#define demo_version_major @demo_version_major@\n#define demo_version_minor @demo_version_minor@\n\n\n1\n2\n3\n\n\n这样就可以直接在代码中打印版本信息了：\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include "config.h"\n#include "math/mathfunctions.h"\n\nint main(int argc, char *argv[])\n{\n    if (argc < 3){\n        // print version info\n        printf("%s version %d.%d\\n",\n            argv[0],\n            demo_version_major,\n            demo_version_minor);\n        printf("usage: %s base exponent \\n", argv[0]);\n        return 1;\n    }\n    double base = atof(argv[1]);\n    int exponent = atoi(argv[2]);\n    \n#if defined (have_pow)\n    printf("now we use the standard library. \\n");\n    double result = pow(base, exponent);\n#else\n    printf("now we use our own math library. \\n");\n    double result = power(base, exponent);\n#endif\n    \n    printf("%g ^ %d is %g\\n", base, exponent, result);\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 生成安装包\n\n本节对应的源代码所在目录：\n\nhttps://github.com/wzpan/cmake-demo/tree/master/demo8\n\n本节将学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 cpack ，它同样也是由 cmake 提供的一个工具，专门用于打包。首先在顶层的 cmakelists.txt 文件尾部添加下面几行：\n\n# 构建一个 cpack 安装包\ninclude (installrequiredsystemlibraries)\nset (cpack_resource_file_license\n  "${cmake_current_source_dir}/license.txt")\nset (cpack_package_version_major "${demo_version_major}")\nset (cpack_package_version_minor "${demo_version_minor}")\ninclude (cpack)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面的代码做了以下几个工作：\n\n导入 installrequiredsystemlibraries 模块，以便之后导入 cpack 模块； 设置一些 cpack 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号； 导入 cpack 模块。 接下来的工作是像往常一样构建工程，并执行 cpack 命令。\n\n生成二进制安装包：\n\n> cpack -c cpackconfig.cmake\n\n生成源码安装包\n\n> cpack -c cpacksourceconfig.cmake\n\n我们可以试一下。在生成项目后，执行 cpack -c cpackconfig.cmake 命令：\n\n[ehome@xman demo8]$ cpack -c cpacksourceconfig.cmake\ncpack: create package using stgz\ncpack: install projects\ncpack: - run preinstall target for: demo8\ncpack: - install project: demo8\ncpack: create package\ncpack: - package: /home/ehome/documents/programming/c/power/demo8/demo8-1.0.1-linux.sh generated.\ncpack: create package using tgz\ncpack: install projects\ncpack: - run preinstall target for: demo8\ncpack: - install project: demo8\ncpack: create package\ncpack: - package: /home/ehome/documents/programming/c/power/demo8/demo8-1.0.1-linux.tar.gz generated.\ncpack: create package using tz\ncpack: install projects\ncpack: - run preinstall target for: demo8\ncpack: - install project: demo8\ncpack: create package\ncpack: - package: /home/ehome/documents/programming/c/power/demo8/demo8-1.0.1-linux.tar.z generated.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n此时会在该目录下创建 3 个不同格式的二进制包文件：\n\n[ehome@xman demo8]$ ls demo8-*\ndemo8-1.0.1-linux.sh  demo8-1.0.1-linux.tar.gz  demo8-1.0.1-linux.tar.z\n\n\n1\n2\n\n\n这 3 个二进制包文件所包含的内容是完全相同的。我们可以执行其中一个。此时会出现一个由 cpack 自动生成的交互式安装界面：\n\n[ehome@xman demo8]$ sh demo8-1.0.1-linux.sh \ndemo8 installer version: 1.0.1, copyright (c) humanity\nthis is a self-extracting archive.\nthe archive will be extracted to: /home/ehome/documents/programming/c/power/demo8\n\nif you want to stop extracting, please press <ctrl-c>.\nthe mit license (mit)\n\ncopyright (c) 2013 joseph pan(http://hahack.com)\n\npermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the "software"), to deal in\nthe software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe software, and to permit persons to whom the software is furnished to do so,\nsubject to the following conditions:\n\nthe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the software.\n\nthe software is provided "as is", without warranty of any kind, express or\nimplied, including but not limited to the warranties of merchantability, fitness\nfor a particular purpose and noninfringement. in no event shall the authors or\ncopyright holders be liable for any claim, damages or other liability, whether\nin an action of contract, tort or otherwise, arising from, out of or in\nconnection with the software or the use or other dealings in the software.\n\n\ndo you accept the license? [yn]: \ny\nby default the demo8 will be installed in:\n  "/home/ehome/documents/programming/c/power/demo8/demo8-1.0.1-linux"\ndo you want to include the subdirectory demo8-1.0.1-linux?\nsaying no will install in: "/home/ehome/documents/programming/c/power/demo8" [yn]: \ny\n\nusing target directory: /home/ehome/documents/programming/c/power/demo8/demo8-1.0.1-linux\nextracting, please wait...\n\nunpacking finished successfully\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n完成后提示安装到了 demo8-1.0.1-linux 子目录中，我们可以进去执行该程序：\n\n[ehome@xman demo8]$ ./demo8-1.0.1-linux/bin/demo 5 2\nnow we use our own math library. \n5 ^ 2 is 25\n\n\n1\n2\n3\n\n\n关于 cpack 的更详细的用法可以通过 man 1 cpack 参考 cpack 的文档。\n\n\n# 项目迁移\n\ncmake 可以很轻松地构建出在适合各个平台执行的工程环境。而如果当前的工程环境不是 cmake ，而是基于某个特定的平台，是否可以迁移到 cmake 呢？答案是可能的。下面针对几个常用的平台，列出了它们对应的迁移方案。\n\n\n# autotools\n\n * am2cmake 可以将 autotools 系的项目转换到 cmake，这个工具的一个成功案例是 kde 。\n * alternative automake2cmake 可以转换使用 automake 的 kdevelop 工程项目。\n * converting autoconf tests\n\n\n# qmake\n\n * qmake converter 可以转换使用 qt 的 qmake 的工程。\n\n\n# visual studio\n\n * vcproj2cmake.rb 可以根据 visual studio 的工程文件（后缀名是 .vcproj 或 .vcxproj）生成 cmakelists.txt 文件。\n * vcproj2cmake.ps1 vcproj2cmake 的 powershell 版本。\n * folders4cmake 根据 visual studio 项目文件生成相应的 “source_group” 信息，这些信息可以很方便的在 cmake 脚本中使用。支持 visual studio 9/10 工程文件。\n\n\n# cmakelists.txt 自动推导\n\n * gencmake 根据现有文件推导 cmakelists.txt 文件。\n * cmakelistgenerator 应用一套文件和目录分析创建出完整的 cmakelists.txt 文件。仅支持 win32 平台。\n\n\n# 类似工具\n\n * scons：eric s. raymond、timothee besset、zed a. shaw 等大神力荐的项目架构工具。和 cmake 的最大区别是使用 python 作为执行脚本',charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:49:51",lastUpdatedTimestamp:1680709791e3},{title:"NVM使用",frontmatter:{title:"NVM使用",date:"2023-04-03T23:57:10.000Z",permalink:"/pages/a038dc/",categories:["常用工具","NVM"],tags:["NVM"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/30.NVM/1.NVM%E4%BD%BF%E7%94%A8.html",relativePath:"50.常用工具/30.NVM/1.NVM使用.md",key:"v-0589c0f2",path:"/pages/a038dc/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:2},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:78},{level:2,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:687}],headersStr:"介绍 安装 语法",content:"# 介绍\n\nNode Version Manager 的缩写，是一个用于在单个计算机上管理和切换多个 Node.js 版本的工具。使用 nvm，您可以轻松地安装、卸载和更改所需的 Node.js 版本，而不必手动更改系统环境变量。\n\n\n# 安装\n\n1、文件下载路径: release\n\n2、国内源配置：nvm安装路径下 settings.txt 文件增加\n\nnode_mirror: https://npm.taobao.org/mirrors/node/\n\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n\n\n1\n2\n3\n\n\n3、安装node\n\nnvm install node版本号  // 安装对应版本的node\nnvm list                 // 用于查看已安装的node版本列表\nnvm use node版本号     // 切换到对应版本的nodejs\n \n \n如：\nnvm install 16.13.1  // 安装16.13.1版本的nodejs\nnvm use 16.13.1   // 使用16.13.1版本的nodejs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n4、环境变量配置：\n\n安装nvm时会自动生成：NVM_HOME 和 NVM_SYMLINK ,并添加到 Path 中，所以无需特殊处理。\n\n以我的电脑举例：\n\nNVM_HOME : C:\\environment\\nvm\n\nNVM_SYMLINK : C:\\environment\\nodejs\n\n\n1\n2\n3\n\n\n\n# 语法\n\nnvm list：查看当前本机使用 nvm 已安装的nodejs的版本列表\n\nnvm arch：查看当前本机是 32 bit 还是 64 bit\n\nnvm install node@版本号：安装指定版本的 nodejs\n\nnvm install latest：安装最新版本的 nodejs\n\nnvm install 14.15.1：安装 14.15.1 版本的 nodejs\n\nnvm uninstall node@版本号：卸载指定版本的 nodejs\n\nnvm uninstall 14.15.1：卸载 14.15.1 版本的 nodejs\n\nnvm use node@版本号：使用指定版本的 nodejs(该版本是已经安装过后的)\n\nnvm use 14.15.1：使用已安装的 14.15.1 版本的 nodejs\n\nnvm root：查看本机安装的 nvm 的安装目录地址\n\n使用管理员身份打开cmd，然后使用 nvm use 14.15.1使用指定版本的node",normalizedContent:"# 介绍\n\nnode version manager 的缩写，是一个用于在单个计算机上管理和切换多个 node.js 版本的工具。使用 nvm，您可以轻松地安装、卸载和更改所需的 node.js 版本，而不必手动更改系统环境变量。\n\n\n# 安装\n\n1、文件下载路径: release\n\n2、国内源配置：nvm安装路径下 settings.txt 文件增加\n\nnode_mirror: https://npm.taobao.org/mirrors/node/\n\nnpm_mirror: https://npm.taobao.org/mirrors/npm/\n\n\n1\n2\n3\n\n\n3、安装node\n\nnvm install node版本号  // 安装对应版本的node\nnvm list                 // 用于查看已安装的node版本列表\nnvm use node版本号     // 切换到对应版本的nodejs\n \n \n如：\nnvm install 16.13.1  // 安装16.13.1版本的nodejs\nnvm use 16.13.1   // 使用16.13.1版本的nodejs\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n4、环境变量配置：\n\n安装nvm时会自动生成：nvm_home 和 nvm_symlink ,并添加到 path 中，所以无需特殊处理。\n\n以我的电脑举例：\n\nnvm_home : c:\\environment\\nvm\n\nnvm_symlink : c:\\environment\\nodejs\n\n\n1\n2\n3\n\n\n\n# 语法\n\nnvm list：查看当前本机使用 nvm 已安装的nodejs的版本列表\n\nnvm arch：查看当前本机是 32 bit 还是 64 bit\n\nnvm install node@版本号：安装指定版本的 nodejs\n\nnvm install latest：安装最新版本的 nodejs\n\nnvm install 14.15.1：安装 14.15.1 版本的 nodejs\n\nnvm uninstall node@版本号：卸载指定版本的 nodejs\n\nnvm uninstall 14.15.1：卸载 14.15.1 版本的 nodejs\n\nnvm use node@版本号：使用指定版本的 nodejs(该版本是已经安装过后的)\n\nnvm use 14.15.1：使用已安装的 14.15.1 版本的 nodejs\n\nnvm root：查看本机安装的 nvm 的安装目录地址\n\n使用管理员身份打开cmd，然后使用 nvm use 14.15.1使用指定版本的node",charsets:{cjk:!0},lastUpdated:"2023/06/08, 22:51:50",lastUpdatedTimestamp:168623591e4},{title:"认知nginx",frontmatter:{title:"认知nginx",date:"2022-05-13T14:47:29.000Z",permalink:"/pages/dafb6a/",categories:["知识积累","部署和运维相关"],tags:["nginx"]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/60.%E9%83%A8%E7%BD%B2/10.%E8%AE%A4%E7%9F%A5nginx.html",relativePath:"50.常用工具/60.部署/10.认知nginx.md",key:"v-48484eb8",path:"/pages/dafb6a/",headers:[{level:2,title:"基础认知",slug:"基础认知",normalizedTitle:"基础认知",charIndex:2},{level:2,title:"用途介绍",slug:"用途介绍",normalizedTitle:"用途介绍",charIndex:11},{level:2,title:"基本命令",slug:"基本命令",normalizedTitle:"基本命令",charIndex:20},{level:2,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:92}],headersStr:"基础认知 用途介绍 基本命令 配置",content:"# 基础认知\n\n\n# 用途介绍\n\n\n# 基本命令\n\n启动：nginx\n\n版本：nginx -v\n\n关闭：nginx -s stop\n\n安全退出: nginx -s quit\n\n重新加载配置文件：nginx -s reload\n\n检查配置文件语法：nginx -t\n\n查看 nginx进程ps -aux | grep nginx\n\n执行nginx启动后就可以在主机地址上看到Nginx默认页面了。\n\n\n# 配置",normalizedContent:"# 基础认知\n\n\n# 用途介绍\n\n\n# 基本命令\n\n启动：nginx\n\n版本：nginx -v\n\n关闭：nginx -s stop\n\n安全退出: nginx -s quit\n\n重新加载配置文件：nginx -s reload\n\n检查配置文件语法：nginx -t\n\n查看 nginx进程ps -aux | grep nginx\n\n执行nginx启动后就可以在主机地址上看到nginx默认页面了。\n\n\n# 配置",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"存储容器选择",frontmatter:{title:"存储容器选择",date:"2022-06-02T10:51:11.000Z",permalink:"/pages/e8f440/",categories:["知识积累","部署"],tags:[null]},regularPath:"/50.%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/60.%E9%83%A8%E7%BD%B2/20.%E9%98%BF%E9%87%8C%E4%BA%91%E5%AD%98%E5%82%A8%E5%AE%B9%E5%99%A8%E9%80%89%E6%8B%A9.html",relativePath:"50.常用工具/60.部署/20.阿里云存储容器选择.md",key:"v-58d11274",path:"/pages/e8f440/",headersStr:null,content:"如何选用NAS、OSS和EBS？\n\n本文介绍阿里云文件存储NAS与阿里云对象存储OSS、阿里云块存储EBS的区别，帮助您更好地选用阿里云文件存储NAS。\n\n文件存储NAS提供简单、可伸缩弹性的共享文件存储，配合云服务器ECS弹性计算服务构建业务系统。 当您选择使用文件存储NAS、对象存储OSS或块存储EBS部署应用程序时，需要考虑诸多因素。\n\n本文介绍文件存储NAS与对象存储OSS、块存储EBS的区别，帮助您更好地进行选择。\n\n架构图\n\n\n\n文件存储NAS和对象存储OSS有什么不同？\n\n文件存储NAS和对象存储OSS的主要区别：您无需修改应用，即可直接像访问本地文件系统一样访问文件存储NAS。文件存储NAS提供高吞吐和高IOPS的同时支持文件的随机读写和在线修改。\n\n对象存储OSS是比较新的存储类型，相对于文件存储目录树的组织形式，对象存储OSS采用扁平的文件组织形式，采用RESTFul API接口访问，不支持文件随机读写，主要适用于互联网架构的海量数据的上传下载和分发。\n\n文件存储NAS和块存储EBS有什么不同？\n\n文件存储NAS相对于块存储EBS的主要区别：文件存储NAS可以同时支持上千个ECS客户端同时共享访问，提供高吞吐量。\n\n块存储EBS是裸磁盘，挂载到ECS后不能被操作系统应用直接访问，需要格式化成文件系统（ext3、ext4、NTFS等）后才能被访问。块存储EBS的优势是性能高、时延低，适合于OLTP数据库、NoSQL数据库等IO密集型的高性能、低时延应用工作负载。但是块存储EBS无法实现容量弹性扩展，单盘最大容量为32TB，并且对共享访问的支持有限，需要配合类Oracle RAC、WSFC Windows故障转移集群等集群管理软件才能进行共享访问。因此，块存储EBS主要还是针对单ECS的高性能，低时延的存储产品。\n\n访问比较：\n\n存储产品      时延            吞吐       访问模式\n文件存储NAS   低时延（毫秒级）      数百Gbps   上千个ECS通过POSIX接口并发访问，随机读写。\n对象存储OSS   较低时延（几十毫秒级）   数百Gbps   数百万客户端通过Web并发，追加写。\n块存储EBS    极低时延（微秒级）     数十Gbps   单ECS通过POSIX接口访问，随机读写。\n\n存储比较：\n\n       文件存储NAS                   对象存储OSS                   块存储云盘\n共享访问   上千台ECS同时挂载，并发访问同一个文件系统    百万台客户端向同一个存储空间并发上传下载文件    单台ECS访问\n协议接口   POSIX / NFS / SMB / MPI   RESTful API / SDK / 客户端   格式化后支持POSIX协议\n读写模式   随机读写                      顺序读写                      随机读写\n存储结构   目录树                       扁平结构                      格式化后支持目录树\n最大容量   10PiB                     无限                        32TiB",normalizedContent:"如何选用nas、oss和ebs？\n\n本文介绍阿里云文件存储nas与阿里云对象存储oss、阿里云块存储ebs的区别，帮助您更好地选用阿里云文件存储nas。\n\n文件存储nas提供简单、可伸缩弹性的共享文件存储，配合云服务器ecs弹性计算服务构建业务系统。 当您选择使用文件存储nas、对象存储oss或块存储ebs部署应用程序时，需要考虑诸多因素。\n\n本文介绍文件存储nas与对象存储oss、块存储ebs的区别，帮助您更好地进行选择。\n\n架构图\n\n\n\n文件存储nas和对象存储oss有什么不同？\n\n文件存储nas和对象存储oss的主要区别：您无需修改应用，即可直接像访问本地文件系统一样访问文件存储nas。文件存储nas提供高吞吐和高iops的同时支持文件的随机读写和在线修改。\n\n对象存储oss是比较新的存储类型，相对于文件存储目录树的组织形式，对象存储oss采用扁平的文件组织形式，采用restful api接口访问，不支持文件随机读写，主要适用于互联网架构的海量数据的上传下载和分发。\n\n文件存储nas和块存储ebs有什么不同？\n\n文件存储nas相对于块存储ebs的主要区别：文件存储nas可以同时支持上千个ecs客户端同时共享访问，提供高吞吐量。\n\n块存储ebs是裸磁盘，挂载到ecs后不能被操作系统应用直接访问，需要格式化成文件系统（ext3、ext4、ntfs等）后才能被访问。块存储ebs的优势是性能高、时延低，适合于oltp数据库、nosql数据库等io密集型的高性能、低时延应用工作负载。但是块存储ebs无法实现容量弹性扩展，单盘最大容量为32tb，并且对共享访问的支持有限，需要配合类oracle rac、wsfc windows故障转移集群等集群管理软件才能进行共享访问。因此，块存储ebs主要还是针对单ecs的高性能，低时延的存储产品。\n\n访问比较：\n\n存储产品      时延            吞吐       访问模式\n文件存储nas   低时延（毫秒级）      数百gbps   上千个ecs通过posix接口并发访问，随机读写。\n对象存储oss   较低时延（几十毫秒级）   数百gbps   数百万客户端通过web并发，追加写。\n块存储ebs    极低时延（微秒级）     数十gbps   单ecs通过posix接口访问，随机读写。\n\n存储比较：\n\n       文件存储nas                   对象存储oss                   块存储云盘\n共享访问   上千台ecs同时挂载，并发访问同一个文件系统    百万台客户端向同一个存储空间并发上传下载文件    单台ecs访问\n协议接口   posix / nfs / smb / mpi   restful api / sdk / 客户端   格式化后支持posix协议\n读写模式   随机读写                      顺序读写                      随机读写\n存储结构   目录树                       扁平结构                      格式化后支持目录树\n最大容量   10pib                     无限                        32tib",charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"介绍",frontmatter:{title:"介绍",date:"2022-05-01T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/1.%E4%BB%8B%E7%BB%8D.html",relativePath:"60.关于/1.介绍.md",key:"v-082fdfae",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:75},{level:3,title:"技能",slug:"技能",normalizedTitle:"技能",charIndex:101},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:232}],headersStr:"📚Blog 🐼Me 技能 ✉️ 联系",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站。\n\n提示\n\n文章内容仅是我个人的小总结，如有误还请指正。\n\n更新日志\n\n\n# 🐼Me\n\n开发一位，一直在渴望美好生活。\n\n\n# 技能\n\n * 熟悉 C++、Qt、Java、Spring、Python、JavaScript、Vue、React 的拼写\n * 了解 Linux、windows 的开关机\n * 精通 Git 的 pull 和 push\n * 惯于 同 测试、产品 扯皮\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 987380454@qq.com\n * GitHub: https://github.com/su-dd",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站。\n\n提示\n\n文章内容仅是我个人的小总结，如有误还请指正。\n\n更新日志\n\n\n# 🐼me\n\n开发一位，一直在渴望美好生活。\n\n\n# 技能\n\n * 熟悉 c++、qt、java、spring、python、javascript、vue、react 的拼写\n * 了解 linux、windows 的开关机\n * 精通 git 的 pull 和 push\n * 惯于 同 测试、产品 扯皮\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 987380454@qq.com\n * github: https://github.com/su-dd",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"介绍",frontmatter:{title:"介绍",date:"2020-05-11T13:54:03.000Z",permalink:"/pages/a2f161",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/02.%E4%BB%8B%E7%BB%8D.html",relativePath:"60.关于/10.指南/01.指南/02.介绍.md",key:"v-3bf0cc6a",path:"/pages/a2f161/",headers:[{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:269},{level:2,title:"扩展功能",slug:"扩展功能",normalizedTitle:"扩展功能",charIndex:543},{level:2,title:"安利",slug:"安利",normalizedTitle:"安利",charIndex:867}],headersStr:"特性 扩展功能 安利",content:"Vdoing是VuePress v1.x的一个主题，是在默认主题基础上做的修改和扩展，很多配置仍然沿用官方配置。使用本主题可以很方便的搭建一个结构化的知识库或博客。\n\n这个主题的初衷是打造一个好用的、面向程序员的知识管理工具： 主题初衷与诞生。\n\n注意\n\n 1. Node请使用v14.17.x或以上版本\n 2. 在使用本主题前，要求你至少会VuePress v1.x的基本使用和默认主题的基本配置，然后再查看本文档。\n 3. 本文档仅负责介绍Vdoing主题对默认主题的扩展部分，更多配置请移步 VuePress v1.x文档\n\n\n# 特性\n\n * 知识管理\n\n包含三种典型的知识管理形态：结构化、碎片化、体系化。轻松打造属于你自己的知识管理平台。\n\n * 结构化\n\n自动生成侧边栏、目录页、索引页、面包屑等，轻松构建一个结构化知识库。\n\n * 碎片化&个性化\n\n博客功能提供一种知识的碎片化形态，并提供个性化的博客配置。\n\n * 简洁高效\n\n以 Markdown 为中心的项目结构，内置自动化工具，以更少的配置完成更多的事。配合多维索引快速定位每个知识点。\n\n * 沉浸式阅读体验\n\n专为阅读设计的UI，配合多种颜色模式、可关闭的侧边栏和导航栏，带给你一种沉浸式阅读体验。\n\n\n# 扩展功能\n\n相较于默认主题，添加的功能内容主要有：\n\n * 添加方便管理学习笔记和技术文档的自动生成结构化侧边栏、自动生成front matter、目录页、扩展的搜索框插件、面包屑、快捷翻页按钮 等，让你快速定位到任何你想要找的内容。\n\n * 添加博客相关的 文章信息栏（作者与创建时间）、最近更新栏 、博主信息栏、页脚版权栏、分类功能+分类页、标签功能+标签页、归档页、评论插件等。\n\n * 方便好用的 Markdown 容器。\n\n * 首页文章列表、个性化配置和样式美化等。\n\n * 多种颜色模式供用户选择：跟随系统、浅色模式、深色模式、阅读模式\n\n * 提高搬砖效率的辅助工具： 批量操作front matter工具\n\n * ...\n\n\n# 安利\n\n * 拥有它你就同时拥有了一个专属你个人的在线知识库(云笔记)、博客、文档库、Demo库、一站式技术搜索工具，内容全部采用Markdown编写，简单高效，各种代码随便贴。\n\n * 你可以在.md文件中写html、css、js、甚至是vue组件代码，markdown天然的就支持vue组件，魔改页面什么的不要太简单。\n\n * 相当多的程序员喜欢深色模式，还有的视力也不太好(🤓)，我们有浅色、深色和阅读模式，更有跟随系统自动响应深浅色模式功能，想怎么换就怎么换。\n   \n   > 点击右下角换肤按钮\n\n * 当你习惯用vdoing主题后，在别处看文档发现是markdown编写的，但所在站点的目录、导航、主题等某个地方用起来不是很爽，你都可以把文档拷贝或把整个专栏下载(如支持下载的话)下来放到vdoing主题，vdoing的自动化工具助你生成一个结构清晰的、拥有目录、页面导航的，而且有多种颜色模式的文档站。让你更专注于内容的学习。\n   \n   > 参考我博客中的文档专栏\n\n * 如果你想和更多的人分享你的文章，那么这款seo友好的主题是一个很不错的选择，更有为了加快百度收录而定制的每天定时百度推送程序。\n   \n   > 参考我的博客收录情况。\n\n别犹豫了，赶快上手吧",normalizedContent:"vdoing是vuepress v1.x的一个主题，是在默认主题基础上做的修改和扩展，很多配置仍然沿用官方配置。使用本主题可以很方便的搭建一个结构化的知识库或博客。\n\n这个主题的初衷是打造一个好用的、面向程序员的知识管理工具： 主题初衷与诞生。\n\n注意\n\n 1. node请使用v14.17.x或以上版本\n 2. 在使用本主题前，要求你至少会vuepress v1.x的基本使用和默认主题的基本配置，然后再查看本文档。\n 3. 本文档仅负责介绍vdoing主题对默认主题的扩展部分，更多配置请移步 vuepress v1.x文档\n\n\n# 特性\n\n * 知识管理\n\n包含三种典型的知识管理形态：结构化、碎片化、体系化。轻松打造属于你自己的知识管理平台。\n\n * 结构化\n\n自动生成侧边栏、目录页、索引页、面包屑等，轻松构建一个结构化知识库。\n\n * 碎片化&个性化\n\n博客功能提供一种知识的碎片化形态，并提供个性化的博客配置。\n\n * 简洁高效\n\n以 markdown 为中心的项目结构，内置自动化工具，以更少的配置完成更多的事。配合多维索引快速定位每个知识点。\n\n * 沉浸式阅读体验\n\n专为阅读设计的ui，配合多种颜色模式、可关闭的侧边栏和导航栏，带给你一种沉浸式阅读体验。\n\n\n# 扩展功能\n\n相较于默认主题，添加的功能内容主要有：\n\n * 添加方便管理学习笔记和技术文档的自动生成结构化侧边栏、自动生成front matter、目录页、扩展的搜索框插件、面包屑、快捷翻页按钮 等，让你快速定位到任何你想要找的内容。\n\n * 添加博客相关的 文章信息栏（作者与创建时间）、最近更新栏 、博主信息栏、页脚版权栏、分类功能+分类页、标签功能+标签页、归档页、评论插件等。\n\n * 方便好用的 markdown 容器。\n\n * 首页文章列表、个性化配置和样式美化等。\n\n * 多种颜色模式供用户选择：跟随系统、浅色模式、深色模式、阅读模式\n\n * 提高搬砖效率的辅助工具： 批量操作front matter工具\n\n * ...\n\n\n# 安利\n\n * 拥有它你就同时拥有了一个专属你个人的在线知识库(云笔记)、博客、文档库、demo库、一站式技术搜索工具，内容全部采用markdown编写，简单高效，各种代码随便贴。\n\n * 你可以在.md文件中写html、css、js、甚至是vue组件代码，markdown天然的就支持vue组件，魔改页面什么的不要太简单。\n\n * 相当多的程序员喜欢深色模式，还有的视力也不太好(🤓)，我们有浅色、深色和阅读模式，更有跟随系统自动响应深浅色模式功能，想怎么换就怎么换。\n   \n   > 点击右下角换肤按钮\n\n * 当你习惯用vdoing主题后，在别处看文档发现是markdown编写的，但所在站点的目录、导航、主题等某个地方用起来不是很爽，你都可以把文档拷贝或把整个专栏下载(如支持下载的话)下来放到vdoing主题，vdoing的自动化工具助你生成一个结构清晰的、拥有目录、页面导航的，而且有多种颜色模式的文档站。让你更专注于内容的学习。\n   \n   > 参考我博客中的文档专栏\n\n * 如果你想和更多的人分享你的文章，那么这款seo友好的主题是一个很不错的选择，更有为了加快百度收录而定制的每天定时百度推送程序。\n   \n   > 参考我的博客收录情况。\n\n别犹豫了，赶快上手吧",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"快速上手",frontmatter:{title:"快速上手",date:"2020-05-11T13:54:40.000Z",permalink:"/pages/793dcb",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/03.%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html",relativePath:"60.关于/10.指南/01.指南/03.快速上手.md",key:"v-481f7a8e",path:"/pages/793dcb/",headers:[{level:2,title:"安装和启动",slug:"安装和启动",normalizedTitle:"安装和启动",charIndex:2},{level:2,title:"使用Vdoing主题",slug:"使用vdoing主题",normalizedTitle:"使用vdoing主题",charIndex:1006},{level:2,title:"版本升级",slug:"版本升级",normalizedTitle:"版本升级",charIndex:1302}],headersStr:"安装和启动 使用Vdoing主题 版本升级",content:"# 安装和启动\n\n# clone the project\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing.git\n\n# enter the project directory\ncd vuepress-theme-vdoing\n\n# install dependency 注意：如安装不成功请关闭淘宝源。\nnpm install # or yarn install\n\n# develop\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# clone the project\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing-doc.git\n\n# enter the project directory\ncd vuepress-theme-vdoing-doc\n\n# install dependency 注意：如安装不成功请关闭淘宝源。\nnpm install # or yarn install\n\n# develop\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 仓库地址： https://github.com/xugaoyi/vuepress-theme-vdoing-doc\n\n# clone the project\ngit clone https://github.com/u2sb/vuepress-theme-vdoing-template.git\n\n# enter the project directory\ncd vuepress-theme-vdoing-template\n\n# install dependency 注意：如安装不成功请关闭淘宝源。\nnpm install # or yarn install\n\n# develop\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 仓库地址： https://github.com/u2sb/vuepress-theme-vdoing-template\n\n注意\n\nNode请使用v14.17.x或以上版本\n\n\n# 使用Vdoing主题\n\n 1. 安装最新的Vdoing主题包：\n\nnpm install vuepress-theme-vdoing -D\n\n\n1\n\n 2. 在.vuepress/config.js中配置使用主题：\n\n// config.js\nmodule.exports = {\n  theme: 'vdoing'\n}\n\n\n1\n2\n3\n4\n\n\n提示\n\n 1. 不建议在原默认vuepress项目上单独安装使用本主题包，而是clone我的整个项目再替换你自己的内容即可。\n 2. 修改config.js配置后需要重新启动项目才会生效。\n 3. 更多关于项目上手的问题，请查阅 问答。\n\n\n# 版本升级\n\n主题的版本会不定期更新，你只需更新npm主题包即可：\n\nnpm update vuepress-theme-vdoing\n\n\n1\n\n\n提示\n\n 1. 如更新后没起作用或报错，尝试把node_modules文件夹删除再npm i重新安装。\n 2. 在.vuepress/config.js中，设置theme: 'vdoing'才是使用npm主题依赖包:\n\n// config.js\nmodule.exports = {\n  theme: 'vdoing', // npm主题依赖包\n  // theme: require.resolve('../../vdoing'), // 使用本地主题包\n}\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 安装和启动\n\n# clone the project\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing.git\n\n# enter the project directory\ncd vuepress-theme-vdoing\n\n# install dependency 注意：如安装不成功请关闭淘宝源。\nnpm install # or yarn install\n\n# develop\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# clone the project\ngit clone https://github.com/xugaoyi/vuepress-theme-vdoing-doc.git\n\n# enter the project directory\ncd vuepress-theme-vdoing-doc\n\n# install dependency 注意：如安装不成功请关闭淘宝源。\nnpm install # or yarn install\n\n# develop\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 仓库地址： https://github.com/xugaoyi/vuepress-theme-vdoing-doc\n\n# clone the project\ngit clone https://github.com/u2sb/vuepress-theme-vdoing-template.git\n\n# enter the project directory\ncd vuepress-theme-vdoing-template\n\n# install dependency 注意：如安装不成功请关闭淘宝源。\nnpm install # or yarn install\n\n# develop\nnpm run dev # or yarn dev\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 仓库地址： https://github.com/u2sb/vuepress-theme-vdoing-template\n\n注意\n\nnode请使用v14.17.x或以上版本\n\n\n# 使用vdoing主题\n\n 1. 安装最新的vdoing主题包：\n\nnpm install vuepress-theme-vdoing -d\n\n\n1\n\n 2. 在.vuepress/config.js中配置使用主题：\n\n// config.js\nmodule.exports = {\n  theme: 'vdoing'\n}\n\n\n1\n2\n3\n4\n\n\n提示\n\n 1. 不建议在原默认vuepress项目上单独安装使用本主题包，而是clone我的整个项目再替换你自己的内容即可。\n 2. 修改config.js配置后需要重新启动项目才会生效。\n 3. 更多关于项目上手的问题，请查阅 问答。\n\n\n# 版本升级\n\n主题的版本会不定期更新，你只需更新npm主题包即可：\n\nnpm update vuepress-theme-vdoing\n\n\n1\n\n\n提示\n\n 1. 如更新后没起作用或报错，尝试把node_modules文件夹删除再npm i重新安装。\n 2. 在.vuepress/config.js中，设置theme: 'vdoing'才是使用npm主题依赖包:\n\n// config.js\nmodule.exports = {\n  theme: 'vdoing', // npm主题依赖包\n  // theme: require.resolve('../../vdoing'), // 使用本地主题包\n}\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"目录结构",frontmatter:{title:"目录结构",date:"2020-05-11T13:54:56.000Z",permalink:"/pages/2f674a",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/04.%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.html",relativePath:"60.关于/10.指南/01.指南/04.目录结构.md",key:"v-31f8ea53",path:"/pages/2f674a/",headersStr:null,content:".\n├── .github   (可选，GitHub 相关文件)\n│   ├── workflows\n│   │   ├── baiduPush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editFrontmatter.js (可选，批量操作front matter工具)\n├── baiduPush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n * docs 文件夹名称请不要修改\n\n * docs/.vuepress 用于存放全局的配置、样式、静态资源等，同官方，查看 详情\n\n * docs/@pages 此文件夹是自动生成的，存放分类页、标签页、归档页对应的.md文件，一般不需要改动\n\n * docs/_posts 专门用于存放碎片化博客文章，里面的.md文件不需要遵循命名约定，不会生成结构化侧边栏和目录页。\n\n * docs/<结构化目录> 请查看《构建结构化站点的核心配置和约定》。\n\n * docs/index.md 首页\n\n * vdoing 存放在本地的vdoing主题文件，如果你想深度的修改主题，首先要在docs/.vuepress/config.js中配置使用的主题指向这个文件。\n\n  module.exports = {\n    // theme: 'vdoing', // npm主题依赖包\n    theme: require.resolve('../../vdoing'), // 使用本地主题包\n  }\n\n\n1\n2\n3\n4\n\n\n  import { resolve } from 'path'\n  import { defineConfig4CustomTheme } from 'vuepress/config'\n  import { VdoingThemeConfig } from 'vuepress-theme-vdoing/types'\n  export default defineConfig4CustomTheme<VdoingThemeConfig>({\n    // theme: 'vdoing', // 使用npm主题包\n    theme: resolve(__dirname, '../../vdoing'), // 使用本地主题包\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意：主题的后续维护升级只对npm主题包负责，就是说你使用本地主题就等于放弃了后续的升级服务。因此，建议能在docs/.vuepress/内配置和修改的，就尽量不要改动主题内部代码。\n\n----------------------------------------\n\n提示\n\n为了方便您更快的学习和使用本主题，我在代码当中添加了比较多的注释说明。",normalizedContent:".\n├── .github   (可选，github 相关文件)\n│   ├── workflows\n│   │   ├── baidupush.yml (可选，百度定时自动推送)\n│   │   └── ci.yml (可选，自动部署)\n├── docs (必须，不要修改文件夹名称)\n│   ├── .vuepress （同官方，查看：https://vuepress.vuejs.org/zh/guide/directory-structure.html#目录结构）\n│   ├── @pages (可选，自动生成的文件夹，存放分类页、标签页、归档页)\n│   ├── _posts (可选，专门存放碎片化博客文章的文件夹)\n│   ├── <结构化目录>\n│   └── index.md (首页)\n├── vdoing (可选，本地的vdoing主题)\n├── utils  (可选，vdoing主题使用的node工具)\n│   ├── modules\n│   ├── config.yml (可选，批量操作front matter配置)\n│   ├── editfrontmatter.js (可选，批量操作front matter工具)\n├── baidupush.sh (可选，百度推送命令脚本)\n├── deploy.sh (可选，部署命令脚本)\n│\n└── package.json\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n * docs 文件夹名称请不要修改\n\n * docs/.vuepress 用于存放全局的配置、样式、静态资源等，同官方，查看 详情\n\n * docs/@pages 此文件夹是自动生成的，存放分类页、标签页、归档页对应的.md文件，一般不需要改动\n\n * docs/_posts 专门用于存放碎片化博客文章，里面的.md文件不需要遵循命名约定，不会生成结构化侧边栏和目录页。\n\n * docs/<结构化目录> 请查看《构建结构化站点的核心配置和约定》。\n\n * docs/index.md 首页\n\n * vdoing 存放在本地的vdoing主题文件，如果你想深度的修改主题，首先要在docs/.vuepress/config.js中配置使用的主题指向这个文件。\n\n  module.exports = {\n    // theme: 'vdoing', // npm主题依赖包\n    theme: require.resolve('../../vdoing'), // 使用本地主题包\n  }\n\n\n1\n2\n3\n4\n\n\n  import { resolve } from 'path'\n  import { defineconfig4customtheme } from 'vuepress/config'\n  import { vdoingthemeconfig } from 'vuepress-theme-vdoing/types'\n  export default defineconfig4customtheme<vdoingthemeconfig>({\n    // theme: 'vdoing', // 使用npm主题包\n    theme: resolve(__dirname, '../../vdoing'), // 使用本地主题包\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意：主题的后续维护升级只对npm主题包负责，就是说你使用本地主题就等于放弃了后续的升级服务。因此，建议能在docs/.vuepress/内配置和修改的，就尽量不要改动主题内部代码。\n\n----------------------------------------\n\n提示\n\n为了方便您更快的学习和使用本主题，我在代码当中添加了比较多的注释说明。",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"构建结构化站点的核心配置和约定",frontmatter:{title:"构建结构化站点的核心配置和约定",date:"2020-05-12T11:01:21.000Z",permalink:"/pages/33d574",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/05.%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E5%92%8C%E7%BA%A6%E5%AE%9A.html",relativePath:"60.关于/10.指南/01.指南/05.核心配置和约定.md",key:"v-6c1991f0",path:"/pages/33d574/",headers:[{level:3,title:"命名约定",slug:"命名约定",normalizedTitle:"命名约定",charIndex:456},{level:3,title:"级别说明",slug:"级别说明",normalizedTitle:"级别说明",charIndex:708},{level:3,title:"目录结构例子",slug:"目录结构例子",normalizedTitle:"目录结构例子",charIndex:1030},{level:3,title:"如何知道侧边栏数据有没有正确生成？",slug:"如何知道侧边栏数据有没有正确生成",normalizedTitle:"如何知道侧边栏数据有没有正确生成？",charIndex:1971}],headersStr:"命名约定 级别说明 目录结构例子 如何知道侧边栏数据有没有正确生成？",content:"本主题遵循“约定优于配置”原则，如果你想构建一个结构化的站点，需要遵循下面这些约定，约定可以为你省去很多配置，轻松拥有一个结构清晰的站点。\n\n你需要在config.js中有如下配置：\n\n// config.js\nmodule.exports = {\n  themeConfig: {\n     sidebar: 'structuring' //  'structuring' | { mode: 'structuring', collapsable: Boolean} | 'auto' | 自定义\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在运行开发服务npm run dev或打包npm run build时主题内部将会按照目录约定自动生成一个结构化的侧边栏、目录页、面包屑等数据。\n\n在源目录（一般是docs）文件夹中，除了.vuepress、@pages、_posts、index.md 或 README.md之外的文件夹将会为其生成对应的侧边栏。生成的顺序取自序号，标题取自文件（夹）名称。\n\n\n# 命名约定\n\n * 无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md，我们将会按照序号的顺序来决定其在侧边栏当中的顺序。\n * 同一级别目录别内即使只有一个文件或文件夹也要为其加上序号。\n\n提示\n\n序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15。\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多只能到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 README.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子中的其他）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录\n    1. 该级别下只能放.md文件。\n    2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\n\n# 目录结构例子\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── _posts\n│   ├── index.md\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《JavaScript教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.JavaScript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 如何知道侧边栏数据有没有正确生成？\n\n在运行开发服务时(npm run dev)，在命令行查看打印记录，如果正确生成会有这样的绿色提示记录：\n\ntip: add sidebar data. 侧边栏数据添加成功。\n\n\n1\n\n\n如果有未按约定的文件，会有黄色警告记录，如：\n\nwarning:  该文件'xxx'序号出错，请填写正确的序号。\n\n\n1\n",normalizedContent:"本主题遵循“约定优于配置”原则，如果你想构建一个结构化的站点，需要遵循下面这些约定，约定可以为你省去很多配置，轻松拥有一个结构清晰的站点。\n\n你需要在config.js中有如下配置：\n\n// config.js\nmodule.exports = {\n  themeconfig: {\n     sidebar: 'structuring' //  'structuring' | { mode: 'structuring', collapsable: boolean} | 'auto' | 自定义\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在运行开发服务npm run dev或打包npm run build时主题内部将会按照目录约定自动生成一个结构化的侧边栏、目录页、面包屑等数据。\n\n在源目录（一般是docs）文件夹中，除了.vuepress、@pages、_posts、index.md 或 readme.md之外的文件夹将会为其生成对应的侧边栏。生成的顺序取自序号，标题取自文件（夹）名称。\n\n\n# 命名约定\n\n * 无论是文件还是文件夹，请为其名称添加上正确的正整数序号和.，从00或01开始累计，如01.文件夹、02.文件.md，我们将会按照序号的顺序来决定其在侧边栏当中的顺序。\n * 同一级别目录别内即使只有一个文件或文件夹也要为其加上序号。\n\n提示\n\n序号只是用于决定先后顺序，并不一定需要连着，如01、02、03...，实际工作中可能会在两个文章中间插入一篇新的文章，因此为了方便可以采用间隔序号10、20、30...，后面如果需要在10和20中间插入一篇新文章，可以给定序号15。\n\n\n# 级别说明\n\n源目录（一般是docs）底下的级别现在我们称之为一级目录，一级目录的下一级为二级目录，以此类推，最多只能到四级目录。\n\n * 一级目录\n   1. .vuepress、@pages、_posts、index.md 或 readme.md 这些文件(文件夹)不参与数据生成。\n   2. 序号非必须。（如一些专栏，可以不用序号)\n * 二级目录\n   1. 该级别下可以同时放文件夹和.md文件，但是两者序号要连贯（参考下面的例子中的其他）。\n   2. 必须有序号\n * 三级目录\n   * (同上)\n * 四级目录\n    1. 该级别下只能放.md文件。\n    2. 必须有序号\n\n所有级别内至少有一个文件或文件夹。\n\n\n# 目录结构例子\n\n.\n├── docs\n│   │  (不参与数据生成)\n│   ├── .vuepress\n│   ├── @pages\n│   ├── _posts\n│   ├── index.md\n│   │\n│   │ (以下部分参与数据生成)\n│   ├── 《javascript教程》专栏 (一级目录)\n│   │   ├── 01.章节1 (二级目录)\n│   │   |   ├── 01.js1.md (三级目录-文件)\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.章节2 (二级目录)\n│   │   |   ├── 01.jsa.md\n│   │   |   ├── 02.小节 (三级目录)\n│   │   |   |   └── 01.jsxx.md (四级目录-文件)\n│   ├── 01.前端\n│   │   ├── 01.javascript\n│   │   |   ├── 01.js1.md\n│   │   |   ├── 02.js2.md\n│   │   |   └── 03.js3.md\n│   │   └── 02.vue\n│   │   |   ├── 01.vue1.md\n│   │   |   └── 02.vue2.md\n│   ├── 02.其他\n│   │   ├── 01.学习\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 02.学习笔记\n│   │   |   ├── 01.xxa.md\n│   │   |   └── 02.xxb.md\n│   │   ├── 03.文件x.md\n│   │   └── 04.文件xx.md\n│   └── 03.关于我\n│   │   └── 01.关于我.md\n.   .\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 如何知道侧边栏数据有没有正确生成？\n\n在运行开发服务时(npm run dev)，在命令行查看打印记录，如果正确生成会有这样的绿色提示记录：\n\ntip: add sidebar data. 侧边栏数据添加成功。\n\n\n1\n\n\n如果有未按约定的文件，会有黄色警告记录，如：\n\nwarning:  该文件'xxx'序号出错，请填写正确的序号。\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"自动生成front matter",frontmatter:{title:"自动生成front matter",date:"2020-05-12T11:46:37.000Z",permalink:"/pages/088c16",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/06.%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90front%20matter.html",relativePath:"60.关于/10.指南/01.指南/06.自动生成front matter.md",key:"v-6873a6ea",path:"/pages/088c16/",headers:[{level:3,title:"生成示例",slug:"生成示例",normalizedTitle:"生成示例",charIndex:203},{level:3,title:"title",slug:"title",normalizedTitle:"title",charIndex:28},{level:3,title:"date",slug:"date",normalizedTitle:"date",charIndex:38},{level:3,title:"permalink",slug:"permalink",normalizedTitle:"permalink",charIndex:49},{level:3,title:"categories",slug:"categories",normalizedTitle:"categories",charIndex:63},{level:3,title:"tags",slug:"tags",normalizedTitle:"tags",charIndex:78},{level:3,title:"扩展自动生成front matter",slug:"扩展自动生成front-matter",normalizedTitle:"扩展自动生成front matter",charIndex:1149},{level:3,title:"碎片化文章‘分类’的自动生成规则",slug:"碎片化文章-分类-的自动生成规则",normalizedTitle:"碎片化文章‘分类’的自动生成规则",charIndex:1255}],headersStr:"生成示例 title date permalink categories tags 扩展自动生成front matter 碎片化文章‘分类’的自动生成规则",content:"当你没有给.md文件的front matter指定标题(title)、时间(date)、永久链接(permalink)、分类(categories)、标签(tags)、主题配置中extendFrontmatter配置的字段时，在运行开发服务npm run dev或打包npm run build时将自动为你生成这些数据，你也可以自己手动设置这些数据，当你手动设置之后，相应的数据就不会再自动生成。\n\n\n# 生成示例\n\n---\ntitle: 《JavaScript教程》笔记\ndate: 2020-01-12 11:51:53\npermalink: /pages/d8cae9\ncategories:\n  - 前端\n  - JavaScript\ntags:\n  -\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# title\n\n * 类型: string\n\n * 默认：.md文件的名称\n\n当前页面的标题\n\n\n# date\n\n * 类型: string\n * 格式：YYYY-MM-DD HH:MM:SS\n * 默认：.md文件在系统中创建的时间\n\n当前页面的创建时间，如需手动添加或修改该字段时请按照格式添加或修改\n\n\n# permalink\n\n * 类型: string\n * 默认：/pages/+ 6位字母加数字的随机码\n\n当前页面的永久链接\n\n> Q：自动生成front matter为什么要包含永久链接？\n> \n> A：使用永久链接是出于以下几点考虑:\n> \n>  * 在config.js配置nav时使用永久链接，就不会因为文件的路径或名称的改变而改变。\n>  * 对于博客而言，当别人收藏了你的文章，在未来的时间里都可以通过永久链接来访问到。\n>  * 主题中的目录页需要通过永久链接来访问文章。\n\n\n# categories\n\n * 类型: array\n * 默认：\n   * .md所在的文件夹名称。\n   * 如果.md文件所在的目录是三级目录，则会有两个分类值，分别是二级目录和一级目录的文件夹名称。如果在四级目录，则再多一个三级目录的文件夹名称分类。（级别说明）\n   * 如果.md文件所在的目录是_posts，则默认值是随笔，这个默认值可以在config.js中修改，参考：config.js配置\n * 如果在 config.js配置 设置了category: false 将不会自动生成该字段\n\n当前页面的分类\n\n\n# tags\n\n * 类型: array\n * 默认：空数组\n * 如果在 config.js配置 设置了tag: false 将不会自动生成该字段\n\n当前页面的标签，默认值是空数组，自动生成该字段只是为了方便后面添加标签值。\n\n\n# 扩展自动生成front matter\n\n当在主题配置中配置了extendFrontmatter时，将在自动生成front matter时添加相应配置的字段和数据。详见：extendFrontmatter\n\n\n# 碎片化文章‘分类’的自动生成规则\n\n> 碎片化文章即放在_posts文件夹的文章，里面的.md文件不需要遵循命名约定，不会生成结构化侧边栏和目录页。\n\n当文章在_posts根目录时，分类获取 themeConfig.categoryText 的值，如_posts/foo.md ，则foo.md文件的分类会生成为：\n\ncategories:\n  - 随笔\n\n\n1\n2\n\n\n> categoryText的默认值是‘随笔’，可在themeConfig修改，详见categorytext。\n\n当文章在非_posts根目录时，获取父文件夹的名称作为分类，如\n\n_posts/想法/奇思妙想/foo.md ，则foo.md文件的分类会生成为：\n\ncategories:\n  - 想法\n  - 奇思妙想\n\n\n1\n2\n3\n",normalizedContent:"当你没有给.md文件的front matter指定标题(title)、时间(date)、永久链接(permalink)、分类(categories)、标签(tags)、主题配置中extendfrontmatter配置的字段时，在运行开发服务npm run dev或打包npm run build时将自动为你生成这些数据，你也可以自己手动设置这些数据，当你手动设置之后，相应的数据就不会再自动生成。\n\n\n# 生成示例\n\n---\ntitle: 《javascript教程》笔记\ndate: 2020-01-12 11:51:53\npermalink: /pages/d8cae9\ncategories:\n  - 前端\n  - javascript\ntags:\n  -\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# title\n\n * 类型: string\n\n * 默认：.md文件的名称\n\n当前页面的标题\n\n\n# date\n\n * 类型: string\n * 格式：yyyy-mm-dd hh:mm:ss\n * 默认：.md文件在系统中创建的时间\n\n当前页面的创建时间，如需手动添加或修改该字段时请按照格式添加或修改\n\n\n# permalink\n\n * 类型: string\n * 默认：/pages/+ 6位字母加数字的随机码\n\n当前页面的永久链接\n\n> q：自动生成front matter为什么要包含永久链接？\n> \n> a：使用永久链接是出于以下几点考虑:\n> \n>  * 在config.js配置nav时使用永久链接，就不会因为文件的路径或名称的改变而改变。\n>  * 对于博客而言，当别人收藏了你的文章，在未来的时间里都可以通过永久链接来访问到。\n>  * 主题中的目录页需要通过永久链接来访问文章。\n\n\n# categories\n\n * 类型: array\n * 默认：\n   * .md所在的文件夹名称。\n   * 如果.md文件所在的目录是三级目录，则会有两个分类值，分别是二级目录和一级目录的文件夹名称。如果在四级目录，则再多一个三级目录的文件夹名称分类。（级别说明）\n   * 如果.md文件所在的目录是_posts，则默认值是随笔，这个默认值可以在config.js中修改，参考：config.js配置\n * 如果在 config.js配置 设置了category: false 将不会自动生成该字段\n\n当前页面的分类\n\n\n# tags\n\n * 类型: array\n * 默认：空数组\n * 如果在 config.js配置 设置了tag: false 将不会自动生成该字段\n\n当前页面的标签，默认值是空数组，自动生成该字段只是为了方便后面添加标签值。\n\n\n# 扩展自动生成front matter\n\n当在主题配置中配置了extendfrontmatter时，将在自动生成front matter时添加相应配置的字段和数据。详见：extendfrontmatter\n\n\n# 碎片化文章‘分类’的自动生成规则\n\n> 碎片化文章即放在_posts文件夹的文章，里面的.md文件不需要遵循命名约定，不会生成结构化侧边栏和目录页。\n\n当文章在_posts根目录时，分类获取 themeconfig.categorytext 的值，如_posts/foo.md ，则foo.md文件的分类会生成为：\n\ncategories:\n  - 随笔\n\n\n1\n2\n\n\n> categorytext的默认值是‘随笔’，可在themeconfig修改，详见categorytext。\n\n当文章在非_posts根目录时，获取父文件夹的名称作为分类，如\n\n_posts/想法/奇思妙想/foo.md ，则foo.md文件的分类会生成为：\n\ncategories:\n  - 想法\n  - 奇思妙想\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"Markdown 容器",frontmatter:{title:"Markdown 容器",date:"2020-05-29T11:16:18.000Z",permalink:"/pages/d0d7eb/",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/07.Markdown%20%E5%AE%B9%E5%99%A8.html",relativePath:"60.关于/10.指南/01.指南/07.Markdown 容器.md",key:"v-0576fcbb",path:"/pages/d0d7eb/",headers:[{level:2,title:"信息框容器",slug:"信息框容器",normalizedTitle:"信息框容器",charIndex:92},{level:2,title:"布局容器",slug:"布局容器",normalizedTitle:"布局容器",charIndex:403},{level:3,title:"我是居中的内容",slug:"我是居中的内容",normalizedTitle:"我是居中的内容",charIndex:430},{level:2,title:"普通卡片列表",slug:"普通卡片列表",normalizedTitle:"普通卡片列表",charIndex:1085},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:23},{level:2,title:"图文卡片列表",slug:"图文卡片列表",normalizedTitle:"图文卡片列表",charIndex:3803},{level:3,title:"语法",slug:"语法-2",normalizedTitle:"语法",charIndex:23},{level:2,title:"增强配置",slug:"增强配置",normalizedTitle:"增强配置",charIndex:6203},{level:3,title:"1. 普通卡片和图文卡片容器",slug:"_1-普通卡片和图文卡片容器",normalizedTitle:"1. 普通卡片和图文卡片容器",charIndex:6256},{level:4,title:"target",slug:"target",normalizedTitle:"target",charIndex:6274},{level:3,title:"2. 图文卡片容器",slug:"_2-图文卡片容器",normalizedTitle:"2. 图文卡片容器",charIndex:6348},{level:4,title:"imgHeight",slug:"imgheight",normalizedTitle:"imgheight",charIndex:6361},{level:4,title:"objectFit",slug:"objectfit",normalizedTitle:"objectfit",charIndex:6406},{level:4,title:"lineClamp",slug:"lineclamp",normalizedTitle:"lineclamp",charIndex:6591},{level:3,title:"3. 配置示例：",slug:"_3-配置示例",normalizedTitle:"3. 配置示例：",charIndex:6630}],headersStr:"信息框容器 布局容器 我是居中的内容 普通卡片列表 语法 图文卡片列表 语法 增强配置 1. 普通卡片和图文卡片容器 target 2. 图文卡片容器 imgHeight objectFit lineClamp 3. 配置示例：",content:"Markdown 容器是对 Markdown 语法的一个扩展，使用简单的语法就可以在页面中呈现丰富的效果。\n\n除了原默认主题自带的容器外，本主题还新增了一些好用的自定义容器。\n\n\n# 信息框容器\n\n输入\n\n::: tip\n这是一条提示\n:::\n\n::: warning\n这是一条注意\n:::\n\n::: danger\n这是一条警告\n:::\n\n::: note\n这是笔记容器，在 <Badge text=\"v1.5.0 +\" /> 版本才支持哦~\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出\n\n提示\n\n这是一条提示\n\n注意\n\n这是一条注意\n\n警告\n\n这是一条警告\n\n笔记\n\n这是笔记容器，在 以上版本才支持哦~\n\n以上容器均可自定义标题，如：\n\n::: tip 我的提示\n自定义标题的提示框\n:::\n\n\n1\n2\n3\n\n\n我的提示\n\n自定义标题的提示框\n\n\n# 布局容器\n\n输入\n\n::: center\n  ### 我是居中的内容\n  （可用于标题、图片等的居中）\n:::\n\n::: right\n  [我是右浮动的内容](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\n:::\n\n::: details\n这是一个详情块，在 IE / Edge 中不生效\n```js\nconsole.log('这是一个详情块')\n```\n:::\n\n::: theorem 牛顿第一定律\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n::: right\n来自 [维基百科](https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E8%BF%90%E5%8A%A8%E5%AE%9A%E5%BE%8B)\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n输出\n\n\n# 我是居中的内容\n\n（可用于标题、图片等的居中）\n\n我是右浮动的内容\n\n点击查看\n\n这是一个详情块，在 IE / Edge 中不生效\n\nconsole.log('这是一个详情块')\n\n\n1\n\n\n牛顿第一定律\n\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n\n来自 维基百科\n\n> 注意：right、details、theorem这三个容器在v1.3.0 +版本才支持。center容器在v1.3.3 +版本才支持。\n\n\n# 普通卡片列表\n\n普通卡片列表容器，可用于友情链接、项目推荐、诗词展示等。\n\n先来看看效果：\n\n输出\n\n麋鹿鲁哟\n\n大道至简，知易行难\n\nXAOXUU\n\n#IOS #Volantis主题作者\n\n平凡的你我\n\n理想成为大牛的小陈同学\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: '#IOS #Volantis主题作者'\n  avatar: https://fastly.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: '#718971'\n  textColor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面效果在Markdown中的代码是这样的：\n\n输入\n\n::: cardList\n```yaml\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: '#IOS #Volantis主题作者'\n  avatar: https://fastly.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: '#718971'\n  textColor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgColor: '#FCDBA0'\n  textColor: '#A05F2C'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 语法\n\n::: cardList <每行显示数量>\n``` yaml\n- name: 名称\n  desc: 描述\n  avatar: https://xxx.jpg # 头像，可选\n  link: https://xxx/ # 链接，可选\n  bgColor: '#CBEAFA' # 背景色，可选，默认var(--bodyBg)。颜色值有#号时请添加引号\n  textColor: '#6854A1' # 文本色，可选，默认var(--textColor)\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * name名称\n   * desc描述\n   * avatar头像，可选\n   * link链接，可选\n   * bgColor背景色，可选，默认var(--bodyBg)。颜色值有#号时请添加引号\n   * textColor文本色，可选，默认var(--textColor)\n\n下面再来看另外一个示例：\n\n输入\n\n::: cardList 2\n```yaml\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n输出\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nVdoing\n\n🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgColor: '#F0DFB1'\n  textColor: '#242A38'\n- name: Vdoing\n  desc: 🚀一款简洁高效的VuePress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgColor: '#DFEEE7'\n  textColor: '#2A3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 图文卡片列表\n\n图文卡片列表容器，可用于项目展示、产品展示等。\n\n先看效果：\n\n输出\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nEvan Xu\n\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Evan Xu # 作者，可选\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输入\n\n::: cardImgList\n```yaml\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: Evan Xu # 作者，可选\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: Evan Xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 语法\n\n::: cardImgList <每行显示数量>\n``` yaml\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: 标题\n  desc: 描述 # 可选\n  author: 作者名称 # 可选\n  avatar: https://xxx.jpg # 作者头像，可选\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * img图片地址\n   * link链接地址\n   * name标题\n   * desc描述，可选\n   * author作者名称，可选\n   * avatar作者头像，可选\n\n\n# 增强配置\n\n为了适应更多需求场景，v1.9.0+版本的普通卡片和图文卡片容器添加了一些新的配置：\n\n\n# 1. 普通卡片和图文卡片容器\n\n# target\n\n * 链接的打开方式，默认_blank\n   \n   * _self 当前页面\n   \n   * _blank 新窗口打开\n\n\n# 2. 图文卡片容器\n\n# imgHeight\n\n * 设置图片高度，默认 auto\n   \n   * 带单位\n\n# objectFit\n\n * 设置图片的填充方式(object-fit)，默认 cover\n   \n   * fill 拉伸 (会改变宽高比)\n   * contain 缩放 (保持宽高比，会留空)\n   * cover 填充 (会裁剪)\n   * none 保持原有尺寸 (会留空或裁剪)\n   * scale-down 保证显示完整图片 (保持宽高比，会留空)\n\n# lineClamp\n\n * 描述文本超出多少行显示省略号，默认1\n\n\n\n\n# 3. 配置示例：\n\n::: cardImgList\n``` yaml\nconfig:\n    target: _blank\n    imgHeight: auto\n    objectFit: cover\n    lineClamp: 1\n\ndata:\n  - img: https://xxx.jpg\n    link: https://xugaoyi.com/\n    name: 标题\n    desc: 描述内容\n    author: Evan Xu\n    avatar: https://xxx.jpg\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",normalizedContent:"markdown 容器是对 markdown 语法的一个扩展，使用简单的语法就可以在页面中呈现丰富的效果。\n\n除了原默认主题自带的容器外，本主题还新增了一些好用的自定义容器。\n\n\n# 信息框容器\n\n输入\n\n::: tip\n这是一条提示\n:::\n\n::: warning\n这是一条注意\n:::\n\n::: danger\n这是一条警告\n:::\n\n::: note\n这是笔记容器，在 <badge text=\"v1.5.0 +\" /> 版本才支持哦~\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n输出\n\n提示\n\n这是一条提示\n\n注意\n\n这是一条注意\n\n警告\n\n这是一条警告\n\n笔记\n\n这是笔记容器，在 以上版本才支持哦~\n\n以上容器均可自定义标题，如：\n\n::: tip 我的提示\n自定义标题的提示框\n:::\n\n\n1\n2\n3\n\n\n我的提示\n\n自定义标题的提示框\n\n\n# 布局容器\n\n输入\n\n::: center\n  ### 我是居中的内容\n  （可用于标题、图片等的居中）\n:::\n\n::: right\n  [我是右浮动的内容](https://zh.wikipedia.org/wiki/%e7%89%9b%e9%a1%bf%e8%bf%90%e5%8a%a8%e5%ae%9a%e5%be%8b)\n:::\n\n::: details\n这是一个详情块，在 ie / edge 中不生效\n```js\nconsole.log('这是一个详情块')\n```\n:::\n\n::: theorem 牛顿第一定律\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n::: right\n来自 [维基百科](https://zh.wikipedia.org/wiki/%e7%89%9b%e9%a1%bf%e8%bf%90%e5%8a%a8%e5%ae%9a%e5%be%8b)\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n输出\n\n\n# 我是居中的内容\n\n（可用于标题、图片等的居中）\n\n我是右浮动的内容\n\n点击查看\n\n这是一个详情块，在 ie / edge 中不生效\n\nconsole.log('这是一个详情块')\n\n\n1\n\n\n牛顿第一定律\n\n假若施加于某物体的外力为零，则该物体的运动速度不变。\n\n来自 维基百科\n\n> 注意：right、details、theorem这三个容器在v1.3.0 +版本才支持。center容器在v1.3.3 +版本才支持。\n\n\n# 普通卡片列表\n\n普通卡片列表容器，可用于友情链接、项目推荐、诗词展示等。\n\n先来看看效果：\n\n输出\n\n麋鹿鲁哟\n\n大道至简，知易行难\n\nxaoxuu\n\n#ios #volantis主题作者\n\n平凡的你我\n\n理想成为大牛的小陈同学\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: '#ios #volantis主题作者'\n  avatar: https://fastly.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: '#718971'\n  textcolor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面效果在markdown中的代码是这样的：\n\n输入\n\n::: cardlist\n```yaml\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: '#ios #volantis主题作者'\n  avatar: https://fastly.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: '#718971'\n  textcolor: '#fff'\n- name: 平凡的你我\n  desc: 理想成为大牛的小陈同学\n  avatar: https://reinness.com/avatar.png\n  link: https://reinness.com\n  bgcolor: '#fcdba0'\n  textcolor: '#a05f2c'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 语法\n\n::: cardlist <每行显示数量>\n``` yaml\n- name: 名称\n  desc: 描述\n  avatar: https://xxx.jpg # 头像，可选\n  link: https://xxx/ # 链接，可选\n  bgcolor: '#cbeafa' # 背景色，可选，默认var(--bodybg)。颜色值有#号时请添加引号\n  textcolor: '#6854a1' # 文本色，可选，默认var(--textcolor)\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * name名称\n   * desc描述\n   * avatar头像，可选\n   * link链接，可选\n   * bgcolor背景色，可选，默认var(--bodybg)。颜色值有#号时请添加引号\n   * textcolor文本色，可选，默认var(--textcolor)\n\n下面再来看另外一个示例：\n\n输入\n\n::: cardlist 2\n```yaml\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n输出\n\n《静夜思》\n\n床前明月光，疑是地上霜。举头望明月，低头思故乡。\n\nvdoing\n\n🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n\n- name: 《静夜思》\n  desc: 床前明月光，疑是地上霜。举头望明月，低头思故乡。\n  bgcolor: '#f0dfb1'\n  textcolor: '#242a38'\n- name: vdoing\n  desc: 🚀一款简洁高效的vuepress 知识管理&博客(blog) 主题\n  link: https://github.com/xugaoyi/vuepress-theme-vdoing\n  bgcolor: '#dfeee7'\n  textcolor: '#2a3344'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 图文卡片列表\n\n图文卡片列表容器，可用于项目展示、产品展示等。\n\n先看效果：\n\n输出\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n标题\n\n描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n\nevan xu\n\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: evan xu # 作者，可选\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n输入\n\n::: cardimglist\n```yaml\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200529162253.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容 # 描述，可选\n  author: evan xu # 作者，可选\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像，可选\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100256.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n- img: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200530100257.jpg\n  link: https://xugaoyi.com/\n  name: 标题\n  desc: 描述内容描述内容描述内容描述内容描述内容描述内容描述内容描述内容\n  author: evan xu\n  avatar: https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 语法\n\n::: cardimglist <每行显示数量>\n``` yaml\n- img: https://xxx.jpg # 图片地址\n  link: https://xxx.com # 链接地址\n  name: 标题\n  desc: 描述 # 可选\n  author: 作者名称 # 可选\n  avatar: https://xxx.jpg # 作者头像，可选\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n * <每行显示数量> 数字，表示每行最多显示多少个，选值范围1~4，默认3。在小屏时会根据屏幕宽度减少每行显示数量。\n * 代码块需指定语言为yaml\n * 代码块内是一个yaml格式的数组列表\n * 数组成员的属性有：\n   * img图片地址\n   * link链接地址\n   * name标题\n   * desc描述，可选\n   * author作者名称，可选\n   * avatar作者头像，可选\n\n\n# 增强配置\n\n为了适应更多需求场景，v1.9.0+版本的普通卡片和图文卡片容器添加了一些新的配置：\n\n\n# 1. 普通卡片和图文卡片容器\n\n# target\n\n * 链接的打开方式，默认_blank\n   \n   * _self 当前页面\n   \n   * _blank 新窗口打开\n\n\n# 2. 图文卡片容器\n\n# imgheight\n\n * 设置图片高度，默认 auto\n   \n   * 带单位\n\n# objectfit\n\n * 设置图片的填充方式(object-fit)，默认 cover\n   \n   * fill 拉伸 (会改变宽高比)\n   * contain 缩放 (保持宽高比，会留空)\n   * cover 填充 (会裁剪)\n   * none 保持原有尺寸 (会留空或裁剪)\n   * scale-down 保证显示完整图片 (保持宽高比，会留空)\n\n# lineclamp\n\n * 描述文本超出多少行显示省略号，默认1\n\n\n\n\n# 3. 配置示例：\n\n::: cardimglist\n``` yaml\nconfig:\n    target: _blank\n    imgheight: auto\n    objectfit: cover\n    lineclamp: 1\n\ndata:\n  - img: https://xxx.jpg\n    link: https://xugaoyi.com/\n    name: 标题\n    desc: 描述内容\n    author: evan xu\n    avatar: https://xxx.jpg\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"Markdown 中使用组件",frontmatter:{title:"Markdown 中使用组件",date:"2020-11-10T18:56:22.000Z",permalink:"/pages/197691/",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/08.Markdown%20%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BB%84%E4%BB%B6.html",relativePath:"60.关于/10.指南/01.指南/08.Markdown 中使用组件.md",key:"v-6887f1e5",path:"/pages/197691/",headers:[{level:2,title:"标记",slug:"标记",normalizedTitle:"标记",charIndex:43},{level:4,title:"《沁园春·雪》",slug:"《沁园春·雪》",normalizedTitle:"《沁园春·雪》",charIndex:220},{level:2,title:"代码块选项卡",slug:"代码块选项卡",normalizedTitle:"代码块选项卡",charIndex:416}],headersStr:"标记 《沁园春·雪》 代码块选项卡",content:'主题的内置组件可以直接在Markdown文件中以类似html标签的方式使用。\n\n\n# 标记\n\n * Props:\n   \n   * text- string\n   * type - string, 可选值： tip | warning | error，默认： tip\n   * vertical - string, 可选值： top | middle，默认： top\n\n * Usage:\n\n你可以在标题或其他内容中使用标记：\n\n#### 《沁园春·雪》 <Badge text="摘"/>\n北国风光<Badge text="注释" type="warning"/>，千里冰封，万里雪飘。\n\n> <Badge text="译文" type="error" vertical="middle"/>: 北方的风光。\n\n\n1\n2\n3\n4\n\n\n效果：\n\n# 《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。\n\n\n# 代码块选项卡\n\n在<code-group>中嵌套<code-block>来配合使用。在<code-block>标签添加title来指定tab标题，active指定当前tab：\n\n<code-group>\n  <code-block title="YARN" active>\n  ```bash\n  yarn add vuepress-theme-vdoing -D\n  ```\n  </code-block>\n\n  <code-block title="NPM">\n  ```bash\n  npm install vuepress-theme-vdoing -D\n  ```\n  </code-block>\n</code-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n效果：\n\nyarn add vuepress-theme-vdoing -D\n\n\n1\n\n\nnpm install vuepress-theme-vdoing -D\n\n\n1\n\n\n注意\n\n * 请在<code-group>标签与markdown内容之间使用空行隔开，否则可能会解析不出来。\n * 该组件只适用于放置代码块，放其他内容在体验上并不友好。如您确实需要放置其他内容的选项卡，推荐使用vuepress-plugin-tabs插件。',normalizedContent:'主题的内置组件可以直接在markdown文件中以类似html标签的方式使用。\n\n\n# 标记\n\n * props:\n   \n   * text- string\n   * type - string, 可选值： tip | warning | error，默认： tip\n   * vertical - string, 可选值： top | middle，默认： top\n\n * usage:\n\n你可以在标题或其他内容中使用标记：\n\n#### 《沁园春·雪》 <badge text="摘"/>\n北国风光<badge text="注释" type="warning"/>，千里冰封，万里雪飘。\n\n> <badge text="译文" type="error" vertical="middle"/>: 北方的风光。\n\n\n1\n2\n3\n4\n\n\n效果：\n\n# 《沁园春·雪》\n\n北国风光，千里冰封，万里雪飘。\n\n> : 北方的风光。\n\n\n# 代码块选项卡\n\n在<code-group>中嵌套<code-block>来配合使用。在<code-block>标签添加title来指定tab标题，active指定当前tab：\n\n<code-group>\n  <code-block title="yarn" active>\n  ```bash\n  yarn add vuepress-theme-vdoing -d\n  ```\n  </code-block>\n\n  <code-block title="npm">\n  ```bash\n  npm install vuepress-theme-vdoing -d\n  ```\n  </code-block>\n</code-group>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n效果：\n\nyarn add vuepress-theme-vdoing -d\n\n\n1\n\n\nnpm install vuepress-theme-vdoing -d\n\n\n1\n\n\n注意\n\n * 请在<code-group>标签与markdown内容之间使用空行隔开，否则可能会解析不出来。\n * 该组件只适用于放置代码块，放其他内容在体验上并不友好。如您确实需要放置其他内容的选项卡，推荐使用vuepress-plugin-tabs插件。',charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"使目录栏支持h2~h6标题",frontmatter:{title:"使目录栏支持h2~h6标题",date:"2022-03-18T15:02:52.000Z",permalink:"/pages/8dfab5/",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/03.%E4%BD%BF%E7%9B%AE%E5%BD%95%E6%A0%8F%E6%94%AF%E6%8C%81h2~h6%E6%A0%87%E9%A2%98.html",relativePath:"60.关于/10.指南/02.相关文章/03.使目录栏支持h2~h6标题.md",key:"v-83b82806",path:"/pages/8dfab5/",headers:[{level:2,title:"markdown.extractHeaders",slug:"markdown-extractheaders",normalizedTitle:"markdown.extractheaders",charIndex:70}],headersStr:"markdown.extractHeaders",content:"在.vuepress/config.js添加如下配置即可使 VuePress 提取相应标题级别的数据，并应用到主题的右侧目录栏中。\n\n\n# markdown.extractHeaders\n\n * 类型: Array\n * 默认: ['h2', 'h3']\n\nMarkdown 文件的 headers (标题 & 小标题) 会在准备阶段被提取出来，并存储在 this.$page.headers 中。默认情况下，VuePress 会提取 h2 和 h3 标题。你可以通过这个选项来修改提取出的标题级别。\n\nmodule.exports = {\n  markdown: {\n    extractHeaders: [ 'h2', 'h3', 'h4', 'h5', 'h6' ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n注：此配置来自 VuePress官方文档",normalizedContent:"在.vuepress/config.js添加如下配置即可使 vuepress 提取相应标题级别的数据，并应用到主题的右侧目录栏中。\n\n\n# markdown.extractheaders\n\n * 类型: array\n * 默认: ['h2', 'h3']\n\nmarkdown 文件的 headers (标题 & 小标题) 会在准备阶段被提取出来，并存储在 this.$page.headers 中。默认情况下，vuepress 会提取 h2 和 h3 标题。你可以通过这个选项来修改提取出的标题级别。\n\nmodule.exports = {\n  markdown: {\n    extractheaders: [ 'h2', 'h3', 'h4', 'h5', 'h6' ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n注：此配置来自 vuepress官方文档",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"如何让你的笔记更有表现力",frontmatter:{title:"如何让你的笔记更有表现力",date:"2020-09-26T21:13:59.000Z",permalink:"/pages/dd027d/",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/06.%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9B%B4%E6%9C%89%E8%A1%A8%E7%8E%B0%E5%8A%9B.html",relativePath:"60.关于/10.指南/02.相关文章/06.如何让你的笔记更有表现力.md",key:"v-3168fb0a",path:"/pages/dd027d/",headers:[{level:2,title:"1. 文本高亮",slug:"_1-文本高亮",normalizedTitle:"1. 文本高亮",charIndex:126},{level:2,title:"2. 标记",slug:"_2-标记",normalizedTitle:"2. 标记",charIndex:237},{level:3,title:"内置标记",slug:"内置标记",normalizedTitle:"内置标记",charIndex:247},{level:3,title:"外部标记",slug:"外部标记",normalizedTitle:"外部标记",charIndex:358},{level:2,title:"3. 折叠列表",slug:"_3-折叠列表",normalizedTitle:"3. 折叠列表",charIndex:562},{level:2,title:"4. 思维导图 & 流程图",slug:"_4-思维导图-流程图",normalizedTitle:"4. 思维导图 &amp; 流程图",charIndex:null},{level:3,title:"方法一：",slug:"方法一",normalizedTitle:"方法一：",charIndex:754},{level:3,title:"方法二：",slug:"方法二",normalizedTitle:"方法二：",charIndex:1009},{level:3,title:"方法三：",slug:"方法三",normalizedTitle:"方法三：",charIndex:1235},{level:2,title:"5.Demo演示框",slug:"_5-demo演示框",normalizedTitle:"5.demo演示框",charIndex:1313},{level:3,title:"方法一：",slug:"方法一-2",normalizedTitle:"方法一：",charIndex:754},{level:3,title:"方法二：",slug:"方法二-2",normalizedTitle:"方法二：",charIndex:1009}],headersStr:"1. 文本高亮 2. 标记 内置标记 外部标记 3. 折叠列表 4. 思维导图 & 流程图 方法一： 方法二： 方法三： 5.Demo演示框 方法一： 方法二：",content:'你的知识笔记枯燥无味没有重点？基于本主题，配合各种骚操作，让你的知识笔记表现力爆棚~~\n\n笔记\n\nMarkdown的基本语法就不再重复啦 (对Markdown不了解的可以看 这里), 下面将介绍一些可以在本主题Markdown中使用的骚操作~\n\n\n# 1. 文本高亮\n\n使用<mark>标签让文本高亮\n\nVdoing是一款简洁高效的 &lt;mark>知识管理&amp;博客&lt;/mark> 主题\n\n\n1\n\n\nVdoing是一款简洁高效的 知识管理&博客 主题\n\n\n# 2. 标记\n\n\n# 内置标记\n\n主题内置的Badge组件，直接在 Markdown 文件中使用\n\n<Badge text="beta" type="warning"/>\n<Badge text="Vdoing主题"/>\n\n\n1\n2\n\n\n\n# 外部标记\n\n使用 shields 生成标记，在Markdown中使用\n\n![npm](https://img.shields.io/npm/v/vuepress-theme-vdoing)\n![star](https://img.shields.io/github/stars/xugaoyi/vuepress-theme-vdoing)\n\n\n1\n2\n\n\n\n\n> 这类标记图标可以生成动态统计数据。\n\n\n# 3. 折叠列表\n\n主题内置的容器，直接在 Markdown 文件中使用\n\n::: details\n这是一个详情块\n```js\nconsole.log(\'这是一个详情块\')\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n\n点击查看\n\n这是一个详情块\n\nconsole.log(\'这是一个详情块\')\n\n\n1\n\n\n> 更多：Markdown 容器\n\n\n# 4. 思维导图 & 流程图\n\n\n# 方法一：\n\n 1. 使用Markmap生成思维导图html文件\n 2. 将html文件放在docs/.vuepress/public/markmap/\n 3. 通过<iframe>插入到Markdown\n\n  <iframe :src="$withBase(\'/markmap/01.html\')" width="100%" height="400" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>\n\n\n1\n\n\n\n# 方法二：\n\n通过<iframe>标签引入processon或其他在线作图工具生成的链接。\n\n<iframe src="https://www.processon.com/view/link/5e718942e4b015182028682c" width="100%" height="500" frameborder="0" scrolling="No" leftmargin="0" topmargin="0"></iframe>\n\n\n1\n\n\n\n# 方法三：\n\n使用流程图插件：\n\n * vuepress-plugin-flowchart\n * vuepress-plugin-mermaidjs\n\n\n# 5.Demo演示框\n\n\n# 方法一：\n\n 1. 安装 vuepress-plugin-demo-block或其他同类插件，使用方法看插件文档\n 2. 在.vuepress/config.js配置插件\n 3. Markdown中使用\n\n> 同类插件：vuepress-plugin-demo-container\n\n<html>\n  <div class="animationBox">\n    <div class="rotate">旋转动画1</div>\n    <div class="play">\n      <div class="img">旋转动画2</div>\n      <span><p class="p2"></p></span>\n      <span><p></p></span>\n      <span><p></p></span>\n      <span><p class="p2"></p></span>\n    </div>\n    <div class="elasticity">弹性动画</div>\n    <div class="elasticity2">曲线弹性</div>\n  </div>\n</html>\n\n<style>\n  .animationBox{overflow: hidden;}\n  .animationBox>div{\n    width: 100px;height: 100px;background: #eee;border-radius: 50%;text-align: center;line-height: 100px;margin: 30px;float:left;\n  }\n  .rotate{\n    animation: rotate 5s linear infinite\n  }\n  .rotate:hover{ animation-play-state: paused}\n  @keyframes rotate {\n    0%{transform: rotate(0);}\n  100%{transform: rotate(360deg);}\n  }\n  .animationBox>.play {\n    position: relative;\n    margin: 50px 30px;\n    background:none;\n  }\n  .play .img{\n    position: absolute;\n    top: 0;\n    left:0;\n    z-index: 1;\n    width: 100px;height: 100px; background: #eee;\n    border-radius: 50%;\n\n    animation: rotate 5s linear infinite\n  }\n  .play span {\n    position: absolute;\n    top: 1px;\n    left:1px;\n    z-index: 0;\n    display: block;\n    width: 96px;\n    height: 96px;\n    border: 1px solid #999;\n    border-radius: 50%;\n  }\n  .play span p{display: block;width: 4px;height: 4px;background: #000;margin: -2px 0 0 50%;border-radius: 50%;opacity: 0.5;}\n  .play span .p2{margin: 50% 0 0 -2px;}\n  .play span{\n    animation: wave 5s linear infinite\n  }\n  .play>span:nth-child(3){\n    /* 延迟时间 */\n    animation-delay:1s;\n  }\n  .play>span:nth-child(4){\n    animation-delay:2.2s;\n  }\n  .play>span:nth-child(5){\n    animation-delay:3.8s;\n  }\n\n  @keyframes wave {\n    0%\n    {\n      transform:scale(1) rotate(360deg);\n      opacity: 0.8;\n    }\n  100%\n    {\n      transform:scale(1.8) rotate(0deg);\n      opacity: 0;\n    }\n  }\n\n\n  .elasticity{\n    animation: elasticity 1s linear 2s infinite\n  }\n\n  @keyframes elasticity{\n    0%{\n      transform: scale(0);\n    }\n    60%{\n      transform: scale(1.1);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n\n  .elasticity2{\n    animation: elasticity2 1s cubic-bezier(.39,.62,.74,1.39) 2s infinite\n  }\n  @keyframes elasticity2{\n    0%{\n      transform: scale(0);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n\n\n\n\n# 方法二：\n\n嵌入codepen\n\n<iframe height="400" style="width: 100%;" scrolling="no" title="【CSS：行为】使用:hover和attr()定制悬浮提示" src="https://codepen.io/xugaoyi/embed/vYNKNaq?height=400&theme-id=light&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy">\n  See the Pen <a href=\'https://codepen.io/xugaoyi/pen/vYNKNaq\'>【CSS：行为】使用:hover和attr()定制悬浮提示</a> by xugaoyi\n  (<a href=\'https://codepen.io/xugaoyi\'>@xugaoyi</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n\n\n1\n2\n3\n4\n\nSee the Pen 【CSS：行为】使用:hover和attr()定制悬浮提示 by xugaoyi (@xugaoyi) on CodePen.\n\n笔记\n\n<iframe>标签还可以嵌入其他任何外部网页，如视频、地图等',normalizedContent:'你的知识笔记枯燥无味没有重点？基于本主题，配合各种骚操作，让你的知识笔记表现力爆棚~~\n\n笔记\n\nmarkdown的基本语法就不再重复啦 (对markdown不了解的可以看 这里), 下面将介绍一些可以在本主题markdown中使用的骚操作~\n\n\n# 1. 文本高亮\n\n使用<mark>标签让文本高亮\n\nvdoing是一款简洁高效的 &lt;mark>知识管理&amp;博客&lt;/mark> 主题\n\n\n1\n\n\nvdoing是一款简洁高效的 知识管理&博客 主题\n\n\n# 2. 标记\n\n\n# 内置标记\n\n主题内置的badge组件，直接在 markdown 文件中使用\n\n<badge text="beta" type="warning"/>\n<badge text="vdoing主题"/>\n\n\n1\n2\n\n\n\n# 外部标记\n\n使用 shields 生成标记，在markdown中使用\n\n![npm](https://img.shields.io/npm/v/vuepress-theme-vdoing)\n![star](https://img.shields.io/github/stars/xugaoyi/vuepress-theme-vdoing)\n\n\n1\n2\n\n\n\n\n> 这类标记图标可以生成动态统计数据。\n\n\n# 3. 折叠列表\n\n主题内置的容器，直接在 markdown 文件中使用\n\n::: details\n这是一个详情块\n```js\nconsole.log(\'这是一个详情块\')\n```\n:::\n\n\n1\n2\n3\n4\n5\n6\n\n点击查看\n\n这是一个详情块\n\nconsole.log(\'这是一个详情块\')\n\n\n1\n\n\n> 更多：markdown 容器\n\n\n# 4. 思维导图 & 流程图\n\n\n# 方法一：\n\n 1. 使用markmap生成思维导图html文件\n 2. 将html文件放在docs/.vuepress/public/markmap/\n 3. 通过<iframe>插入到markdown\n\n  <iframe :src="$withbase(\'/markmap/01.html\')" width="100%" height="400" frameborder="0" scrolling="no" leftmargin="0" topmargin="0"></iframe>\n\n\n1\n\n\n\n# 方法二：\n\n通过<iframe>标签引入processon或其他在线作图工具生成的链接。\n\n<iframe src="https://www.processon.com/view/link/5e718942e4b015182028682c" width="100%" height="500" frameborder="0" scrolling="no" leftmargin="0" topmargin="0"></iframe>\n\n\n1\n\n\n\n# 方法三：\n\n使用流程图插件：\n\n * vuepress-plugin-flowchart\n * vuepress-plugin-mermaidjs\n\n\n# 5.demo演示框\n\n\n# 方法一：\n\n 1. 安装 vuepress-plugin-demo-block或其他同类插件，使用方法看插件文档\n 2. 在.vuepress/config.js配置插件\n 3. markdown中使用\n\n> 同类插件：vuepress-plugin-demo-container\n\n<html>\n  <div class="animationbox">\n    <div class="rotate">旋转动画1</div>\n    <div class="play">\n      <div class="img">旋转动画2</div>\n      <span><p class="p2"></p></span>\n      <span><p></p></span>\n      <span><p></p></span>\n      <span><p class="p2"></p></span>\n    </div>\n    <div class="elasticity">弹性动画</div>\n    <div class="elasticity2">曲线弹性</div>\n  </div>\n</html>\n\n<style>\n  .animationbox{overflow: hidden;}\n  .animationbox>div{\n    width: 100px;height: 100px;background: #eee;border-radius: 50%;text-align: center;line-height: 100px;margin: 30px;float:left;\n  }\n  .rotate{\n    animation: rotate 5s linear infinite\n  }\n  .rotate:hover{ animation-play-state: paused}\n  @keyframes rotate {\n    0%{transform: rotate(0);}\n  100%{transform: rotate(360deg);}\n  }\n  .animationbox>.play {\n    position: relative;\n    margin: 50px 30px;\n    background:none;\n  }\n  .play .img{\n    position: absolute;\n    top: 0;\n    left:0;\n    z-index: 1;\n    width: 100px;height: 100px; background: #eee;\n    border-radius: 50%;\n\n    animation: rotate 5s linear infinite\n  }\n  .play span {\n    position: absolute;\n    top: 1px;\n    left:1px;\n    z-index: 0;\n    display: block;\n    width: 96px;\n    height: 96px;\n    border: 1px solid #999;\n    border-radius: 50%;\n  }\n  .play span p{display: block;width: 4px;height: 4px;background: #000;margin: -2px 0 0 50%;border-radius: 50%;opacity: 0.5;}\n  .play span .p2{margin: 50% 0 0 -2px;}\n  .play span{\n    animation: wave 5s linear infinite\n  }\n  .play>span:nth-child(3){\n    /* 延迟时间 */\n    animation-delay:1s;\n  }\n  .play>span:nth-child(4){\n    animation-delay:2.2s;\n  }\n  .play>span:nth-child(5){\n    animation-delay:3.8s;\n  }\n\n  @keyframes wave {\n    0%\n    {\n      transform:scale(1) rotate(360deg);\n      opacity: 0.8;\n    }\n  100%\n    {\n      transform:scale(1.8) rotate(0deg);\n      opacity: 0;\n    }\n  }\n\n\n  .elasticity{\n    animation: elasticity 1s linear 2s infinite\n  }\n\n  @keyframes elasticity{\n    0%{\n      transform: scale(0);\n    }\n    60%{\n      transform: scale(1.1);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n\n  .elasticity2{\n    animation: elasticity2 1s cubic-bezier(.39,.62,.74,1.39) 2s infinite\n  }\n  @keyframes elasticity2{\n    0%{\n      transform: scale(0);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n\n\n\n\n# 方法二：\n\n嵌入codepen\n\n<iframe height="400" style="width: 100%;" scrolling="no" title="【css：行为】使用:hover和attr()定制悬浮提示" src="https://codepen.io/xugaoyi/embed/vynknaq?height=400&theme-id=light&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy">\n  see the pen <a href=\'https://codepen.io/xugaoyi/pen/vynknaq\'>【css：行为】使用:hover和attr()定制悬浮提示</a> by xugaoyi\n  (<a href=\'https://codepen.io/xugaoyi\'>@xugaoyi</a>) on <a href=\'https://codepen.io\'>codepen</a>.\n</iframe>\n\n\n1\n2\n3\n4\n\nsee the pen 【css：行为】使用:hover和attr()定制悬浮提示 by xugaoyi (@xugaoyi) on codepen.\n\n笔记\n\n<iframe>标签还可以嵌入其他任何外部网页，如视频、地图等',charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"批量操作front matter工具",frontmatter:{title:"批量操作front matter工具",date:"2020-05-13T11:52:45.000Z",permalink:"/pages/2b8e22",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/07.%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9Cfront%20matter%E5%B7%A5%E5%85%B7.html",relativePath:"60.关于/10.指南/02.相关文章/07.批量操作front matter工具.md",key:"v-0ce44bc7",path:"/pages/2b8e22/",headersStr:null,content:'当你想为某个文件夹下的所有.md文件添加、修改、删除某些front matter字段时，这个工具可以快速的为你批量操作。\n\n首先，你需要在package.json的scripts中写入脚本：\n\n// package.json\n{\n  "scripts": {\n       "editFm": "node utils/editFrontmatter.js",\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在utils/config.yml配置要批量操作的文件夹和要编辑的字段，示例：\n\n# utils/config.yml\n#批量添加和修改、删除front matter配置文件\n\n# 需要批量处理的路径，docs文件夹内的文件夹 (数组。映射路径：docs/arr[1]/arr[2] ... )\npath:\n  - docs # 第一个成员必须是docs\n  - 《JS教程》专辑\n  - 第一章节\n\n# 要删除的字段 (数组)\ndelete:  \n  - article\n\n # 要添加、修改front matter的数据 （front matter中没有的数据则添加，已有的数据则覆盖）\ndata:\n  author: 齐天大圣\n  sidebar: false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n比如你要操作的文件夹路径是docs/《JS教程》专辑/第一章节，你需要这样配置路径：\n\npath:\n  - docs # 第一个成员必须是docs\n  - 《JS教程》专辑\n  - 第一章节\n\n\n1\n2\n3\n4\n\n\npath数组的第一个成员必须是docs，如果你想操作docs底下除了首页之外所有的.md文件，只需保留第一个成员docs即可。\n\n你想删除article字段：\n\ndelete:  \n  - article\n\n\n1\n2\n\n\n你想为这个文件夹下的所有.md文件添加作者author和隐藏侧边栏sidebar：\n\ndata:\n  author: 齐天大圣\n  sidebar: false\n\n\n1\n2\n3\n\n\n最后，执行npm run editFm命令，为了防止误操作，会有一个询问过程：\n\nnpm run editFm\n? 批量操作frontmatter有修改数据的风险，确定要继续吗？ (Y/n) \n...\n\n\n1\n2\n3\n',normalizedContent:'当你想为某个文件夹下的所有.md文件添加、修改、删除某些front matter字段时，这个工具可以快速的为你批量操作。\n\n首先，你需要在package.json的scripts中写入脚本：\n\n// package.json\n{\n  "scripts": {\n       "editfm": "node utils/editfrontmatter.js",\n   }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n在utils/config.yml配置要批量操作的文件夹和要编辑的字段，示例：\n\n# utils/config.yml\n#批量添加和修改、删除front matter配置文件\n\n# 需要批量处理的路径，docs文件夹内的文件夹 (数组。映射路径：docs/arr[1]/arr[2] ... )\npath:\n  - docs # 第一个成员必须是docs\n  - 《js教程》专辑\n  - 第一章节\n\n# 要删除的字段 (数组)\ndelete:  \n  - article\n\n # 要添加、修改front matter的数据 （front matter中没有的数据则添加，已有的数据则覆盖）\ndata:\n  author: 齐天大圣\n  sidebar: false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n比如你要操作的文件夹路径是docs/《js教程》专辑/第一章节，你需要这样配置路径：\n\npath:\n  - docs # 第一个成员必须是docs\n  - 《js教程》专辑\n  - 第一章节\n\n\n1\n2\n3\n4\n\n\npath数组的第一个成员必须是docs，如果你想操作docs底下除了首页之外所有的.md文件，只需保留第一个成员docs即可。\n\n你想删除article字段：\n\ndelete:  \n  - article\n\n\n1\n2\n\n\n你想为这个文件夹下的所有.md文件添加作者author和隐藏侧边栏sidebar：\n\ndata:\n  author: 齐天大圣\n  sidebar: false\n\n\n1\n2\n3\n\n\n最后，执行npm run editfm命令，为了防止误操作，会有一个询问过程：\n\nnpm run editfm\n? 批量操作frontmatter有修改数据的风险，确定要继续吗？ (y/n) \n...\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"部署",frontmatter:{title:"部署",date:"2020-05-13T12:10:53.000Z",permalink:"/pages/0fc1d2",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/08.%E9%83%A8%E7%BD%B2.html",relativePath:"60.关于/10.指南/02.相关文章/08.部署.md",key:"v-680b8ef6",path:"/pages/0fc1d2/",headers:[{level:2,title:"1.使用deploy.sh脚本部署",slug:"_1-使用deploy-sh脚本部署",normalizedTitle:"1.使用deploy.sh脚本部署",charIndex:122},{level:2,title:"2. 使用GitHub Action自动持续集成",slug:"_2-使用github-action自动持续集成",normalizedTitle:"2. 使用github action自动持续集成",charIndex:598},{level:2,title:"部署升级：同时部署到github和coding",slug:"部署升级-同时部署到github和coding",normalizedTitle:"部署升级：同时部署到github和coding",charIndex:931},{level:3,title:"部署方式有两种：",slug:"部署方式有两种",normalizedTitle:"部署方式有两种：",charIndex:1104},{level:4,title:"1) 、使用如下命令一键部署到github和coding",slug:"_1-、使用如下命令一键部署到github和coding",normalizedTitle:"1) 、使用如下命令一键部署到github和coding",charIndex:1116},{level:4,title:"2）、使用GitHub Action自动部署到github和coding",slug:"_2-、使用github-action自动部署到github和coding",normalizedTitle:"2）、使用github action自动部署到github和coding",charIndex:1169}],headersStr:"1.使用deploy.sh脚本部署 2. 使用GitHub Action自动持续集成 部署升级：同时部署到github和coding 部署方式有两种： 1) 、使用如下命令一键部署到github和coding 2）、使用GitHub Action自动部署到github和coding",content:"注意\n\n目前作者使用的部署方式已改为 vercel，部署方法参考 这里。（2022.01.01）\n更多 部署方式\n\n本项目内置了两种自动部署脚本，用于一键部署到 GitHub Pages 或 国内访问速度更快的Coding Pages\n\n\n# 1.使用deploy.sh脚本部署\n\n第一步，修改deploy.sh脚本内的仓库地址为你的仓库，如有自定义域名则一并修改，没有则注释\n\n# 如果是发布到自定义域名\necho 'xugaoyi.com' > CNAME\n\n# 如果发布到 https://<USERNAME>.github.io\n# git push -f git@github.com:<USERNAME>/<USERNAME>.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>\n# git push -f git@github.com:<USERNAME>/<REPO>.git master:gh-pages\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第二步，一键部署命令\n\nnpm run deploy\n\n\n1\n\n\n> windows系统下使用bash命令窗\n\n第三步，设置仓库的GitHub Pages。\n\n> deploy.sh文件看 这里 看不懂shell代码？ 参考：shell教程\n\n\n# 2. 使用GitHub Action自动持续集成\n\n第一步，按照官方文档，生成一个github token (令牌)。\n\n第二步，将这个密钥储存到当前仓库的Settings/Secrets里面。\n\n> Settings/Secrets是储存秘密的环境变量的地方。环境变量的名字可以随便起，这里用的是ACCESS_TOKEN。如果你不用这个名字，.github/workflows/ci.yml脚本里的变量名也要跟着改。\n\n第三步，push提交代码到GitHub仓库master分支。\n\n第四步，设置仓库的GitHub Pages\n\n> 参考 GitHub Action实现自动部署静态博客 ci.yml文件看 这里 看不懂yaml代码？ 参考：yaml教程\n\n\n# 部署升级：同时部署到github和coding\n\n为了让博客站能够让百度收录，因此我把博客部署到了coding。相关文章。\n\n在原有部署方式上做了升级，主要修改代码文件有下面这两个：\n\n使用前先将github token (令牌) 和coding token (令牌) 同时设置到github仓库的Settings/Secrets位置。\n\n\n# 部署方式有两种：\n\n# 1) 、使用如下命令一键部署到github和coding\n\nnpm run deploy\n\n\n1\n\n\n# 2）、使用GitHub Action自动部署到github和coding\n\n只需要push提交代码到github仓库master分支即可。\n\n> 参考 《GitHub Action实现自动部署静态博客》",normalizedContent:"注意\n\n目前作者使用的部署方式已改为 vercel，部署方法参考 这里。（2022.01.01）\n更多 部署方式\n\n本项目内置了两种自动部署脚本，用于一键部署到 github pages 或 国内访问速度更快的coding pages\n\n\n# 1.使用deploy.sh脚本部署\n\n第一步，修改deploy.sh脚本内的仓库地址为你的仓库，如有自定义域名则一并修改，没有则注释\n\n# 如果是发布到自定义域名\necho 'xugaoyi.com' > cname\n\n# 如果发布到 https://<username>.github.io\n# git push -f git@github.com:<username>/<username>.github.io.git master\n\n# 如果发布到 https://<username>.github.io/<repo>\n# git push -f git@github.com:<username>/<repo>.git master:gh-pages\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n第二步，一键部署命令\n\nnpm run deploy\n\n\n1\n\n\n> windows系统下使用bash命令窗\n\n第三步，设置仓库的github pages。\n\n> deploy.sh文件看 这里 看不懂shell代码？ 参考：shell教程\n\n\n# 2. 使用github action自动持续集成\n\n第一步，按照官方文档，生成一个github token (令牌)。\n\n第二步，将这个密钥储存到当前仓库的settings/secrets里面。\n\n> settings/secrets是储存秘密的环境变量的地方。环境变量的名字可以随便起，这里用的是access_token。如果你不用这个名字，.github/workflows/ci.yml脚本里的变量名也要跟着改。\n\n第三步，push提交代码到github仓库master分支。\n\n第四步，设置仓库的github pages\n\n> 参考 github action实现自动部署静态博客 ci.yml文件看 这里 看不懂yaml代码？ 参考：yaml教程\n\n\n# 部署升级：同时部署到github和coding\n\n为了让博客站能够让百度收录，因此我把博客部署到了coding。相关文章。\n\n在原有部署方式上做了升级，主要修改代码文件有下面这两个：\n\n使用前先将github token (令牌) 和coding token (令牌) 同时设置到github仓库的settings/secrets位置。\n\n\n# 部署方式有两种：\n\n# 1) 、使用如下命令一键部署到github和coding\n\nnpm run deploy\n\n\n1\n\n\n# 2）、使用github action自动部署到github和coding\n\n只需要push提交代码到github仓库master分支即可。\n\n> 参考 《github action实现自动部署静态博客》",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"关于写文章和一级标题",frontmatter:{title:"关于写文章和一级标题",date:"2020-05-13T12:07:32.000Z",permalink:"/pages/9ae0bd",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/09.%E5%85%B3%E4%BA%8E%E5%86%99%E6%96%87%E7%AB%A0%E5%92%8C%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98.html",relativePath:"60.关于/10.指南/02.相关文章/09.关于写文章和一级标题.md",key:"v-24155794",path:"/pages/9ae0bd/",excerpt:'<p>写文章时，大概的流程是这样的：</p>\n<p>1.首先是创建<code>.md</code>文件，如果在结构化目录下则<strong>需要</strong>添加相应的序号，在碎片化博文目录<code>_posts</code>下<strong>不需要</strong>添加序号，文件名填写文章的标题。</p>\n<p>2.如果你想手动指定文章的分类、标签，则需要在头部front matter填写相应的字段。一般情况下不需要再填写其他字段。不想手动指定分类和标签也可以省略这一步。</p>\n\x3c!--beforebegin--\x3e<div class="language-yaml line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-yaml"><code><span class="token punctuation">---</span>\n<span class="token key atrule">categories</span><span class="token punctuation">:</span> \n  <span class="token punctuation">-</span> 分类1\n<span class="token key atrule">tags</span><span class="token punctuation">:</span> \n  <span class="token punctuation">-</span> 标签1\n  <span class="token punctuation">-</span> 标签2\n<span class="token punctuation">---</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>3.<strong>关于一级标题</strong>，即markdown中的一级标题(<code># 标题</code>)，你可以写也可以不写，在页面中实际显示的文章标题是取自front matter中的<code>title</code>，然后把<code>.md</code>中的一级标题隐藏了。</p>\n<blockquote>\n<p>这样做即可以保留本地文件的一级标题，也可以兼容线上页面的标题。\n同时，对于在新建<code>.md</code>文件时已经输入了一次标题在文件名，不想在文档中重复输入一次标题的，也是可以实现的。</p>\n</blockquote>\n<p>4.<strong>关于文章摘要</strong>，你想在首先文章列表中显示摘要时可以在合适的位置添加一个`</p>\n',headersStr:null,content:"写文章时，大概的流程是这样的：\n\n1.首先是创建.md文件，如果在结构化目录下则需要添加相应的序号，在碎片化博文目录_posts下不需要添加序号，文件名填写文章的标题。\n\n2.如果你想手动指定文章的分类、标签，则需要在头部front matter填写相应的字段。一般情况下不需要再填写其他字段。不想手动指定分类和标签也可以省略这一步。\n\n---\ncategories: \n  - 分类1\ntags: \n  - 标签1\n  - 标签2\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3.关于一级标题，即markdown中的一级标题(# 标题)，你可以写也可以不写，在页面中实际显示的文章标题是取自front matter中的title，然后把.md中的一级标题隐藏了。\n\n> 这样做即可以保留本地文件的一级标题，也可以兼容线上页面的标题。 同时，对于在新建.md文件时已经输入了一次标题在文件名，不想在文档中重复输入一次标题的，也是可以实现的。\n\n4.关于文章摘要，你想在首先文章列表中显示摘要时可以在合适的位置添加一个\x3c!-- more --\x3e注释，参考：添加摘要\n\n5.最后，就可以正式开始写作啦。",normalizedContent:"写文章时，大概的流程是这样的：\n\n1.首先是创建.md文件，如果在结构化目录下则需要添加相应的序号，在碎片化博文目录_posts下不需要添加序号，文件名填写文章的标题。\n\n2.如果你想手动指定文章的分类、标签，则需要在头部front matter填写相应的字段。一般情况下不需要再填写其他字段。不想手动指定分类和标签也可以省略这一步。\n\n---\ncategories: \n  - 分类1\ntags: \n  - 标签1\n  - 标签2\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n3.关于一级标题，即markdown中的一级标题(# 标题)，你可以写也可以不写，在页面中实际显示的文章标题是取自front matter中的title，然后把.md中的一级标题隐藏了。\n\n> 这样做即可以保留本地文件的一级标题，也可以兼容线上页面的标题。 同时，对于在新建.md文件时已经输入了一次标题在文件名，不想在文档中重复输入一次标题的，也是可以实现的。\n\n4.关于文章摘要，你想在首先文章列表中显示摘要时可以在合适的位置添加一个\x3c!-- more --\x3e注释，参考：添加摘要\n\n5.最后，就可以正式开始写作啦。",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"关于博客搭建与管理",frontmatter:{title:"关于博客搭建与管理",date:"2020-05-13T12:12:33.000Z",permalink:"/pages/26997d",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/10.%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E4%B8%8E%E7%AE%A1%E7%90%86.html",relativePath:"60.关于/10.指南/02.相关文章/10.关于博客搭建与管理.md",key:"v-1fe008ed",path:"/pages/26997d/",headersStr:null,content:"这里是我在搭建和管理博客过程中写的一些文章和小技巧。\n\n 1. 评论模块的搭建\n    \n    使用Gitalk实现静态博客无后台评论系统\n\n 2. 自定义域名及解析，详情\n\n 3. SEO相关\n    \n    // config.js\n    module.exports = {\n        description: '填写网站描述', // 以 <meta> 标签渲染到页面html中\n        head: [ // 注入到页面<head> 中的标签,[tagName, { attrName: attrValue }]\n            ['meta', { name: 'keywords', content: '填写关键字'}]\n        ]\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 图床\n    \n    GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\n\n 5. 结合GitHub Actions开发的每天定时百度推送，加快收录\n    \n    GitHub Actions 定时运行代码：每天定时百度链接推送",normalizedContent:"这里是我在搭建和管理博客过程中写的一些文章和小技巧。\n\n 1. 评论模块的搭建\n    \n    使用gitalk实现静态博客无后台评论系统\n\n 2. 自定义域名及解析，详情\n\n 3. seo相关\n    \n    // config.js\n    module.exports = {\n        description: '填写网站描述', // 以 <meta> 标签渲染到页面html中\n        head: [ // 注入到页面<head> 中的标签,[tagname, { attrname: attrvalue }]\n            ['meta', { name: 'keywords', content: '填写关键字'}]\n        ]\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 4. 图床\n    \n    github + jsdelivr + tinypng+ picgo 打造稳定快速、高效免费图床\n\n 5. 结合github actions开发的每天定时百度推送，加快收录\n    \n    github actions 定时运行代码：每天定时百度链接推送",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"在线编辑和新增文章的方法",frontmatter:{title:"在线编辑和新增文章的方法",date:"2020-05-19T11:17:58.000Z",permalink:"/pages/c5a54d",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/10.%E6%8C%87%E5%8D%97/02.%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0/11.%E5%9C%A8%E7%BA%BF%E7%BC%96%E8%BE%91%E5%92%8C%E6%96%B0%E5%A2%9E%E6%96%87%E7%AB%A0%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"60.关于/10.指南/02.相关文章/11.在线编辑和新增文章的方法.md",key:"v-20c337c8",path:"/pages/c5a54d/",headers:[{level:3,title:"在线编辑原有的文章",slug:"在线编辑原有的文章",normalizedTitle:"在线编辑原有的文章",charIndex:61},{level:3,title:"在线新增文章",slug:"在线新增文章",normalizedTitle:"在线新增文章",charIndex:442}],headersStr:"在线编辑原有的文章 在线新增文章",content:"说明\n\n以下方法实现的前提是把博客源码上传到github仓库，并配置好 GitHub Actions 自动部署。\n\n\n# 在线编辑原有的文章\n\n首先，在config.js启用页面的编辑按钮，并配置好github仓库和.md文件所在根目录等，详见 官方文档。\n\n示例：\n\n// config.js\nmodule.exports = {\n  themeConfig: {\n    repo: 'xugaoyi/vuepress-theme-vdoing', // Github仓库地址\n    docsDir: 'docs', // .md文件放在了docs目录下\n    editLinks: true, // 启用编辑链接\n    editLinkText: '编辑',\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n配置好之后，每个文章页面底下都会有一个编辑按钮，点击即可跳到github在线编辑，编辑完成后提交就会自动触发GitHub Actions自动部署。\n\n\n# 在线新增文章\n\n在github博客源码仓库相应的文章目录下，新建.md文件，编辑好文章并提交后会触发GitHub Actions自动部署。\n\n> 提示：当使用过在线编辑或新增后，下次在本地编辑之前先拉取代码。",normalizedContent:"说明\n\n以下方法实现的前提是把博客源码上传到github仓库，并配置好 github actions 自动部署。\n\n\n# 在线编辑原有的文章\n\n首先，在config.js启用页面的编辑按钮，并配置好github仓库和.md文件所在根目录等，详见 官方文档。\n\n示例：\n\n// config.js\nmodule.exports = {\n  themeconfig: {\n    repo: 'xugaoyi/vuepress-theme-vdoing', // github仓库地址\n    docsdir: 'docs', // .md文件放在了docs目录下\n    editlinks: true, // 启用编辑链接\n    editlinktext: '编辑',\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n配置好之后，每个文章页面底下都会有一个编辑按钮，点击即可跳到github在线编辑，编辑完成后提交就会自动触发github actions自动部署。\n\n\n# 在线新增文章\n\n在github博客源码仓库相应的文章目录下，新建.md文件，编辑好文章并提交后会触发github actions自动部署。\n\n> 提示：当使用过在线编辑或新增后，下次在本地编辑之前先拉取代码。",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"列表",frontmatter:{title:"列表",date:"2023-03-08T11:39:00.000Z",permalink:"/pages/83ed2b/",titleTag:"原创",categories:"+ 关于",tags:"+ 关于",sticky:1},regularPath:"/60.%E5%85%B3%E4%BA%8E/2.%E5%88%97%E8%A1%A8.html",relativePath:"60.关于/2.列表.md",key:"v-10a5e49a",path:"/pages/83ed2b/",headers:[{level:2,title:"编程基础-C++",slug:"编程基础-c",normalizedTitle:"编程基础-c++",charIndex:36},{level:3,title:"STL 库",slug:"stl-库",normalizedTitle:"stl 库",charIndex:759},{level:3,title:"c++泛型编程",slug:"c-泛型编程",normalizedTitle:"c++泛型编程",charIndex:915},{level:3,title:"c++的 DLL 相关知识",slug:"c-的-dll-相关知识",normalizedTitle:"c++的 dll 相关知识",charIndex:986},{level:3,title:"c++效率优化",slug:"c-效率优化",normalizedTitle:"c++效率优化",charIndex:1038},{level:2,title:"编程基础-Java",slug:"编程基础-java",normalizedTitle:"编程基础-java",charIndex:1086},{level:2,title:"编程基础-算法",slug:"编程基础-算法",normalizedTitle:"编程基础-算法",charIndex:1502},{level:2,title:"编程基础-操作系统",slug:"编程基础-操作系统",normalizedTitle:"编程基础-操作系统",charIndex:2311},{level:2,title:"架构设计-面向对象",slug:"架构设计-面向对象",normalizedTitle:"架构设计-面向对象",charIndex:2442},{level:2,title:"架构设计-设计模式",slug:"架构设计-设计模式",normalizedTitle:"架构设计-设计模式",charIndex:2456},{level:2,title:"架构设计-领域分析",slug:"架构设计-领域分析",normalizedTitle:"架构设计-领域分析",charIndex:3410},{level:2,title:"数据库-MySQL",slug:"数据库-mysql",normalizedTitle:"数据库-mysql",charIndex:3807},{level:2,title:"数据库-MongoDB",slug:"数据库-mongodb",normalizedTitle:"数据库-mongodb",charIndex:3904},{level:2,title:"常用框架-Spring",slug:"常用框架-spring",normalizedTitle:"常用框架-spring",charIndex:3920},{level:2,title:"常用工具-Git",slug:"常用工具-git",normalizedTitle:"常用工具-git",charIndex:4446},{level:2,title:"常用工具-Nginx",slug:"常用工具-nginx",normalizedTitle:"常用工具-nginx",charIndex:5009}],excerpt:'<div class="custom-block note"><p class="custom-block-title">序言</p>\n<p>记录、归纳，了解自己</p>\n<div class="custom-block right">\n<p>2023-03-08 @苏呆呆</p>\n</div>\n</div>\n',headersStr:"编程基础-C++ STL 库 c++泛型编程 c++的 DLL 相关知识 c++效率优化 编程基础-Java 编程基础-算法 编程基础-操作系统 架构设计-面向对象 架构设计-设计模式 架构设计-领域分析 数据库-MySQL 数据库-MongoDB 常用框架-Spring 常用工具-Git 常用工具-Nginx",content:"序言\n\n记录、归纳，了解自己\n\n2023-03-08 @苏呆呆\n\n\n# 编程基础-C++\n\n归类    内容                   创建时间         完成时间\nC++   c++简介                2022-09-25   2022-09-25\nC++   Hello world          2022-09-26   2022-09-26\nC++   C++基础概念              2023-01-29   2023-01-29\nC++   C++基础语法              2022-09-26   2022-09-26\nC++   C++结构体联合体            2023-02-01   2023-02-01\nC++   C++类的基础概念:封装、继承、多态   2023-01-29   2023-01-29\nC++   C++抽象类接口             2023-02-02   2023-02-02\nC++   C++声明定义头文件           2023-02-14   2023-02-14\nC++   C++枚举和枚举类            2023-02-01   2023-02-01\nC++   C++类的默认函数            2023-01-08   \nC++   深入理解：C++内存分配         2023-01-08   \nC++   深入理解：变量、引用、指针        2022-12-25   \nC++   总结：const的使用          2023-01-30   \nC++   深入理解：继承和虚表           2023-01-30   \n\n\n# STL 库\n\n编码    名称        进度\n1     容器        否\n1.1   List      否\n1.2   Vector    否\n1.3   Map       否\n1.4   hashMap   否\n2     锁         否\n3     智能指针      否\n\n\n# c++泛型编程\n\n编码   名称          进度\n1    Template    否\n2    观察者应用：信号槽   否\n\n\n# c++的 DLL 相关知识\n\n编码   名称       进度\n1    dll 导出   否\n\n\n# c++效率优化\n\n编码   名称        进度\n1    效率优化的思路   否\n\n\n# 编程基础-Java\n\n归类     内容                 完成时间\nJava   Java--基础语法         2022-05-04\nJava   Java--JavaBean     2022-05-15\nJava   Java--容器           2022-05-04\nJava   Java--List列表       2022-05-15\nJava   Java--set集合        2022-05-15\nJava   Java--map表         2022-05-15\nJava   Java--泛型和数据结构      2022-05-04\nJava   Java--反射：框架设计的灵魂   2022-05-15\nJava   Java--JUnit单元测试    2022-05-15\nJava   Java--JAVA内存       2022-05-15\n\n\n# 编程基础-算法\n\n归类     内容                创建时间   完成时间\n算法     算法--枚举（穷举）               \n算法     算法--递推                   \n算法     算法--递归                   \n算法     算法--分治                   \n算法     算法--概率算法                 \n算法     算法--回溯（试探）               \n算法     算法--贪心                   \n算法     算法--迭代（辗转）               \n算法     算法--模拟                   \n算法     算法--动态规划                 \n算法     算法--分支界限                 \n算法     算法--近似                   \n算法     算法--遗传算法                 \n算法     算法--模拟退火算法               \n算法     算法--蚁群算法                 \n算法实例   算法实例--排序算法               \n算法实例   算法实例--B+树                \n算法实例   算法实例--LSM-Tree           \n算法实例   算法实例--布隆过滤               \n算法实例   算法实例--Tire树              \n算法实例   算法实例--红黑树                \n算法实例   算法实例--雷达树                \n算法实例   算法实例--Quad-Tree          \n\n\n# 编程基础-操作系统\n\n归类     内容           创建时间   完成时间\n操作系统   操作系统--基础概念          \n操作系统   操作系统--进程            \n操作系统   操作系统--线程            \n\n\n# 架构设计-面向对象\n\n\n# 架构设计-设计模式\n\n归类     内容               完成时间\n设计模式   设计模式--总览         2022-05-01\n设计模式   设计模式--简单工厂       2022-05-03\n设计模式   设计模式--工厂模式       2022-05-03\n设计模式   设计模式--外观（面板）模式   2022-05-03\n设计模式   设计模式--单例模式       2022-05-03\n设计模式   设计模式--原型模式       2022-05-03\n设计模式   设计模式--抽象工厂       2022-05-03\n设计模式   设计模式--模板方法       2022-05-03\n设计模式   设计模式--策略模式       2022-05-03\n设计模式   设计模式--享元模式       2022-05-03\n设计模式   设计模式--装饰模式       2022-05-03\n设计模式   设计模式--代理模式       2022-05-03\n设计模式   设计模式--桥模式        2022-05-03\n设计模式   设计模式--适配器模型      2022-05-03\n设计模式   设计模式--迭代器模型      2022-06-11\n设计模式   设计模式--备忘录模型      2022-06-11\n设计模式   设计模式--命令模式       2022-07-21\n设计模式   设计模式--组合模型       2022-07-23\n设计模式   设计模式--职责链模式      2022-07-28\n设计模式   设计模式--访问者模式      2022-08-01\n设计模式   设计模式--解释器模式      2022-08-31\n设计模式   设计模式--中介者模式      2022-09-02\n设计模式   设计模式--观察者模式      2022-09-05\n设计模式   设计模式--状态模式       2022-09-14\n设计模式   设计模式--建造者模式      2022-09-14\n设计模式   设计模式--整体回顾       2022-09-22\n\n\n# 架构设计-领域分析\n\n归类     内容                  创建时间         完成时间\nDDDD   DDD--初识             2022-05-26   2022-05-26\nDDDD   DDD--概览             2022-05-29   2022-05-29\nDDDD   DDD--值对象、DP         2022-05-04   2022-05-04\nDDDD   DDD--实体、领域服务、应用服务   2O22-05-05   2O22-05-05\nDDDD   DDD--基于Cola的初步实践    2022-05-05   2022-05-05\nDDDD   DDD--贫血模型和充血模型      2022-05-04   \nDDDD   DDD--统一语言           2022-05-05   \n\n\n# 数据库-MySQL\n\n归类      内容               创建时间         完成时间\nMySQL   MySQL--SQL基本语法   2022-05-14   \n\n\n# 数据库-MongoDB\n\n\n# 常用框架-Spring\n\n归类       内容                     完成时间\nSpring   Spring--初识             2022-05-25\nSpring   Spring--Xml配置          2022-05-25\nSpring   Spring--IOC的XML实现      2022-05-14\nSpring   Spring--AOP的XML实现      2022-05-25\nSpring   Spring--IOC的注解实现       022-05-14\nSpring   Spring--AOP的注解实现       2022-05-14\nSpring   Spring--restful注解      2022-05-04\nSpring   Spring--定时任务           2022-05-10\nSpring   Spring--动态定时任务         2022-05-10\nSpring   Spring--注册失败           2022-05-13\nSpring   Spring--API文档knife4j   2022-05-30\n\n\n# 常用工具-Git\n\n归类    内容                  完成时间\nGit   Git--常用命令清单         2020-11-18\nGit   Git--变基合并           2020-11-18\nGit   Git--命令思维导图         2020-11-18\nGit   Git--基础与命令          2020-11-18\nGit   Git分支--分支原理         2020-11-18\nGit   Git分支的新建与合并--分支操作   2020-11-18\nGit   Git分支管理--查看分支       2020-11-18\nGit   Git分支--开发工作流        2020-11-18\nGit   Git分支--远程分支         2020-11-18\nGit   Git分支--变基           2020-11-18\nGit   Git工具--查看修订版本       2020-11-18\nGit   Git工具--交互式暂存        2020-11-18\nGit   Git工具--重写历史         2020-11-18\nGit   Git工具--重置揭密         2020-11-18\n\n\n# 常用工具-Nginx\n\n归类      内容               创建时间         完成时间\nNginx   Nginx--认知nginx   2022-05-13   ",normalizedContent:"序言\n\n记录、归纳，了解自己\n\n2023-03-08 @苏呆呆\n\n\n# 编程基础-c++\n\n归类    内容                   创建时间         完成时间\nc++   c++简介                2022-09-25   2022-09-25\nc++   hello world          2022-09-26   2022-09-26\nc++   c++基础概念              2023-01-29   2023-01-29\nc++   c++基础语法              2022-09-26   2022-09-26\nc++   c++结构体联合体            2023-02-01   2023-02-01\nc++   c++类的基础概念:封装、继承、多态   2023-01-29   2023-01-29\nc++   c++抽象类接口             2023-02-02   2023-02-02\nc++   c++声明定义头文件           2023-02-14   2023-02-14\nc++   c++枚举和枚举类            2023-02-01   2023-02-01\nc++   c++类的默认函数            2023-01-08   \nc++   深入理解：c++内存分配         2023-01-08   \nc++   深入理解：变量、引用、指针        2022-12-25   \nc++   总结：const的使用          2023-01-30   \nc++   深入理解：继承和虚表           2023-01-30   \n\n\n# stl 库\n\n编码    名称        进度\n1     容器        否\n1.1   list      否\n1.2   vector    否\n1.3   map       否\n1.4   hashmap   否\n2     锁         否\n3     智能指针      否\n\n\n# c++泛型编程\n\n编码   名称          进度\n1    template    否\n2    观察者应用：信号槽   否\n\n\n# c++的 dll 相关知识\n\n编码   名称       进度\n1    dll 导出   否\n\n\n# c++效率优化\n\n编码   名称        进度\n1    效率优化的思路   否\n\n\n# 编程基础-java\n\n归类     内容                 完成时间\njava   java--基础语法         2022-05-04\njava   java--javabean     2022-05-15\njava   java--容器           2022-05-04\njava   java--list列表       2022-05-15\njava   java--set集合        2022-05-15\njava   java--map表         2022-05-15\njava   java--泛型和数据结构      2022-05-04\njava   java--反射：框架设计的灵魂   2022-05-15\njava   java--junit单元测试    2022-05-15\njava   java--java内存       2022-05-15\n\n\n# 编程基础-算法\n\n归类     内容                创建时间   完成时间\n算法     算法--枚举（穷举）               \n算法     算法--递推                   \n算法     算法--递归                   \n算法     算法--分治                   \n算法     算法--概率算法                 \n算法     算法--回溯（试探）               \n算法     算法--贪心                   \n算法     算法--迭代（辗转）               \n算法     算法--模拟                   \n算法     算法--动态规划                 \n算法     算法--分支界限                 \n算法     算法--近似                   \n算法     算法--遗传算法                 \n算法     算法--模拟退火算法               \n算法     算法--蚁群算法                 \n算法实例   算法实例--排序算法               \n算法实例   算法实例--b+树                \n算法实例   算法实例--lsm-tree           \n算法实例   算法实例--布隆过滤               \n算法实例   算法实例--tire树              \n算法实例   算法实例--红黑树                \n算法实例   算法实例--雷达树                \n算法实例   算法实例--quad-tree          \n\n\n# 编程基础-操作系统\n\n归类     内容           创建时间   完成时间\n操作系统   操作系统--基础概念          \n操作系统   操作系统--进程            \n操作系统   操作系统--线程            \n\n\n# 架构设计-面向对象\n\n\n# 架构设计-设计模式\n\n归类     内容               完成时间\n设计模式   设计模式--总览         2022-05-01\n设计模式   设计模式--简单工厂       2022-05-03\n设计模式   设计模式--工厂模式       2022-05-03\n设计模式   设计模式--外观（面板）模式   2022-05-03\n设计模式   设计模式--单例模式       2022-05-03\n设计模式   设计模式--原型模式       2022-05-03\n设计模式   设计模式--抽象工厂       2022-05-03\n设计模式   设计模式--模板方法       2022-05-03\n设计模式   设计模式--策略模式       2022-05-03\n设计模式   设计模式--享元模式       2022-05-03\n设计模式   设计模式--装饰模式       2022-05-03\n设计模式   设计模式--代理模式       2022-05-03\n设计模式   设计模式--桥模式        2022-05-03\n设计模式   设计模式--适配器模型      2022-05-03\n设计模式   设计模式--迭代器模型      2022-06-11\n设计模式   设计模式--备忘录模型      2022-06-11\n设计模式   设计模式--命令模式       2022-07-21\n设计模式   设计模式--组合模型       2022-07-23\n设计模式   设计模式--职责链模式      2022-07-28\n设计模式   设计模式--访问者模式      2022-08-01\n设计模式   设计模式--解释器模式      2022-08-31\n设计模式   设计模式--中介者模式      2022-09-02\n设计模式   设计模式--观察者模式      2022-09-05\n设计模式   设计模式--状态模式       2022-09-14\n设计模式   设计模式--建造者模式      2022-09-14\n设计模式   设计模式--整体回顾       2022-09-22\n\n\n# 架构设计-领域分析\n\n归类     内容                  创建时间         完成时间\ndddd   ddd--初识             2022-05-26   2022-05-26\ndddd   ddd--概览             2022-05-29   2022-05-29\ndddd   ddd--值对象、dp         2022-05-04   2022-05-04\ndddd   ddd--实体、领域服务、应用服务   2o22-05-05   2o22-05-05\ndddd   ddd--基于cola的初步实践    2022-05-05   2022-05-05\ndddd   ddd--贫血模型和充血模型      2022-05-04   \ndddd   ddd--统一语言           2022-05-05   \n\n\n# 数据库-mysql\n\n归类      内容               创建时间         完成时间\nmysql   mysql--sql基本语法   2022-05-14   \n\n\n# 数据库-mongodb\n\n\n# 常用框架-spring\n\n归类       内容                     完成时间\nspring   spring--初识             2022-05-25\nspring   spring--xml配置          2022-05-25\nspring   spring--ioc的xml实现      2022-05-14\nspring   spring--aop的xml实现      2022-05-25\nspring   spring--ioc的注解实现       022-05-14\nspring   spring--aop的注解实现       2022-05-14\nspring   spring--restful注解      2022-05-04\nspring   spring--定时任务           2022-05-10\nspring   spring--动态定时任务         2022-05-10\nspring   spring--注册失败           2022-05-13\nspring   spring--api文档knife4j   2022-05-30\n\n\n# 常用工具-git\n\n归类    内容                  完成时间\ngit   git--常用命令清单         2020-11-18\ngit   git--变基合并           2020-11-18\ngit   git--命令思维导图         2020-11-18\ngit   git--基础与命令          2020-11-18\ngit   git分支--分支原理         2020-11-18\ngit   git分支的新建与合并--分支操作   2020-11-18\ngit   git分支管理--查看分支       2020-11-18\ngit   git分支--开发工作流        2020-11-18\ngit   git分支--远程分支         2020-11-18\ngit   git分支--变基           2020-11-18\ngit   git工具--查看修订版本       2020-11-18\ngit   git工具--交互式暂存        2020-11-18\ngit   git工具--重写历史         2020-11-18\ngit   git工具--重置揭密         2020-11-18\n\n\n# 常用工具-nginx\n\n归类      内容               创建时间         完成时间\nnginx   nginx--认知nginx   2022-05-13   ",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"主题配置",frontmatter:{title:"主题配置",date:"2020-05-12T14:57:21.000Z",permalink:"/pages/a20ce8",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/01.%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE.html",relativePath:"60.关于/20.配置/01.配置/01.主题配置.md",key:"v-f4316aea",path:"/pages/a20ce8/",headers:[{level:2,title:"是否打开分类、标签、归档",slug:"是否打开分类、标签、归档",normalizedTitle:"是否打开分类、标签、归档",charIndex:107},{level:3,title:"category",slug:"category",normalizedTitle:"category",charIndex:124},{level:3,title:"tag",slug:"tag",normalizedTitle:"tag",charIndex:271},{level:3,title:"archive",slug:"archive",normalizedTitle:"archive",charIndex:413},{level:3,title:"使用分类页、标签页、归档页链接",slug:"使用分类页、标签页、归档页链接",normalizedTitle:"使用分类页、标签页、归档页链接",charIndex:560},{level:2,title:"碎片化文章默认分类值",slug:"碎片化文章默认分类值",normalizedTitle:"碎片化文章默认分类值",charIndex:682},{level:3,title:"categoryText",slug:"categorytext",normalizedTitle:"categorytext",charIndex:697},{level:2,title:"页面风格",slug:"页面风格",normalizedTitle:"页面风格",charIndex:768},{level:3,title:"pageStyle",slug:"pagestyle",normalizedTitle:"pagestyle",charIndex:777},{level:3,title:"defaultMode",slug:"defaultmode",normalizedTitle:"defaultmode",charIndex:932},{level:2,title:"body背景大图",slug:"body背景大图",normalizedTitle:"body背景大图",charIndex:1056},{level:3,title:"bodyBgImg",slug:"bodybgimg",normalizedTitle:"bodybgimg",charIndex:833},{level:3,title:"bodyBgImgOpacity",slug:"bodybgimgopacity",normalizedTitle:"bodybgimgopacity",charIndex:1190},{level:3,title:"bodyBgImgInterval",slug:"bodybgimginterval",normalizedTitle:"bodybgimginterval",charIndex:1162},{level:2,title:"文章标题前的图标",slug:"文章标题前的图标",normalizedTitle:"文章标题前的图标",charIndex:1335},{level:3,title:"titleBadge",slug:"titlebadge",normalizedTitle:"titlebadge",charIndex:1348},{level:3,title:"titleBadgeIcons",slug:"titlebadgeicons",normalizedTitle:"titlebadgeicons",charIndex:1401},{level:2,title:"文章内容块的背景底纹",slug:"文章内容块的背景底纹",normalizedTitle:"文章内容块的背景底纹",charIndex:1456},{level:3,title:"contentBgStyle",slug:"contentbgstyle",normalizedTitle:"contentbgstyle",charIndex:1471},{level:2,title:"侧边栏",slug:"侧边栏",normalizedTitle:"侧边栏",charIndex:1598},{level:3,title:"sidebar",slug:"sidebar",normalizedTitle:"sidebar",charIndex:1606},{level:3,title:"sidebarOpen",slug:"sidebaropen",normalizedTitle:"sidebaropen",charIndex:1860},{level:3,title:"对指定页面禁用侧边栏",slug:"对指定页面禁用侧边栏",normalizedTitle:"对指定页面禁用侧边栏",charIndex:1958},{level:3,title:"碎片化文章的侧边栏",slug:"碎片化文章的侧边栏",normalizedTitle:"碎片化文章的侧边栏",charIndex:2039},{level:2,title:"最近更新栏",slug:"最近更新栏",normalizedTitle:"最近更新栏",charIndex:2134},{level:3,title:"updateBar",slug:"updatebar",normalizedTitle:"updatebar",charIndex:2144},{level:3,title:"非文章页的设置",slug:"非文章页的设置",normalizedTitle:"非文章页的设置",charIndex:2332},{level:2,title:"右侧文章大纲栏",slug:"右侧文章大纲栏",normalizedTitle:"右侧文章大纲栏",charIndex:2495},{level:3,title:"rightMenuBar",slug:"rightmenubar",normalizedTitle:"rightmenubar",charIndex:2507},{level:2,title:"快捷翻页按钮",slug:"快捷翻页按钮",normalizedTitle:"快捷翻页按钮",charIndex:2635},{level:3,title:"pageButton",slug:"pagebutton",normalizedTitle:"pagebutton",charIndex:2646},{level:2,title:"文章作者信息",slug:"文章作者信息",normalizedTitle:"文章作者信息",charIndex:2727},{level:3,title:"author",slug:"author",normalizedTitle:"author",charIndex:2738},{level:3,title:"指定的文章作者信息",slug:"指定的文章作者信息",normalizedTitle:"指定的文章作者信息",charIndex:2858},{level:2,title:"博主信息",slug:"博主信息",normalizedTitle:"博主信息",charIndex:3015},{level:3,title:"blogger",slug:"blogger",normalizedTitle:"blogger",charIndex:3024},{level:2,title:"社交图标",slug:"社交图标",normalizedTitle:"社交图标",charIndex:3179},{level:3,title:"social",slug:"social",normalizedTitle:"social",charIndex:3188},{level:3,title:"主题内置的社交图标",slug:"主题内置的社交图标",normalizedTitle:"主题内置的社交图标",charIndex:3483},{level:2,title:"扩展自动生成front matter",slug:"扩展自动生成front-matter",normalizedTitle:"扩展自动生成front matter",charIndex:3744},{level:3,title:"extendFrontmatter",slug:"extendfrontmatter",normalizedTitle:"extendfrontmatter",charIndex:3767},{level:2,title:"页脚版权栏",slug:"页脚版权栏",normalizedTitle:"页脚版权栏",charIndex:4154},{level:3,title:"footer",slug:"footer",normalizedTitle:"footer",charIndex:4164},{level:2,title:"自定义html模块",slug:"自定义html模块",normalizedTitle:"自定义html模块",charIndex:4372},{level:3,title:"htmlModules",slug:"htmlmodules",normalizedTitle:"htmlmodules",charIndex:4399}],headersStr:"是否打开分类、标签、归档 category tag archive 使用分类页、标签页、归档页链接 碎片化文章默认分类值 categoryText 页面风格 pageStyle defaultMode body背景大图 bodyBgImg bodyBgImgOpacity bodyBgImgInterval 文章标题前的图标 titleBadge titleBadgeIcons 文章内容块的背景底纹 contentBgStyle 侧边栏 sidebar sidebarOpen 对指定页面禁用侧边栏 碎片化文章的侧边栏 最近更新栏 updateBar 非文章页的设置 右侧文章大纲栏 rightMenuBar 快捷翻页按钮 pageButton 文章作者信息 author 指定的文章作者信息 博主信息 blogger 社交图标 social 主题内置的社交图标 扩展自动生成front matter extendFrontmatter 页脚版权栏 footer 自定义html模块 htmlModules",content:"主题的配置在.vuepress/config.ts文件的themeConfig字段中，是在原有配置的基础上做的新增和修改，配置示例请查看：config.ts。\n\n更多官方配置，请查看vuepress文档。\n\n\n# 是否打开分类、标签、归档\n\n\n# category\n\n * 类型：boolean\n * 默认：true\n\n是否打开分类功能。 如打开，会做的事情有：\n\n 1. 自动生成的front matter包含分类字段\n 2. 页面中显示与分类相关的信息和模块\n 3. 自动生成分类页面（在@pages文件夹）\n\n如关闭，则反之。\n\n\n# tag\n\n * 类型：boolean\n * 默认：true\n\n是否打开标签功能。 如打开，会做的事情有：\n\n 1. 自动生成的front matter包含标签字段\n 2. 页面中显示与标签相关的信息和模块\n 3. 自动生成标签页面（在@pages文件夹）\n\n如关闭，则反之。\n\n\n# archive\n\n * 类型：boolean\n * 默认：true\n\n是否打开归档功能。 如打开，会做的事情有：\n\n 1. 自动生成归档页面（在@pages文件夹）\n\n如关闭，则反之。\n\n提示\n\n如果你仅仅是想使用这个主题来搭建知识库，并不想使用分类、标签、归档功能，就可以关闭它们。\n\n\n# 使用分类页、标签页、归档页链接\n\n当你打开了分类、标签、归档功能，就可以在导航或其他地方添加分类页、标签页、归档页的链接：\n\n * 分类页: /categories/\n * 标签页: /tags/\n * 归档页: /archives/\n\n\n# 碎片化文章默认分类值\n\n\n# categoryText\n\n * 类型：string\n * 默认：'随笔'\n\n碎片化文章（_posts文件夹的文章）默认生成的分类值\n\n\n# 页面风格\n\n\n# pageStyle\n\n * 类型：string\n * 可选值：'card' | 'line' （line在未设置bodyBgImg时才生效）\n * 默认：'card'\n\n页面风格，card时背景显示灰色衬托出卡片样式，line时背景显示纯色，并且部分模块带线条边框（未设置bodyBgImg时才生效）\n\n\n# defaultMode\n\n * 类型：string\n * 可选值：'auto' | 'light' | 'dark' | 'read'\n * 默认：'auto'\n\n默认外观模式，用户未在页面手动修改过模式时才生效，否则以用户设置的模式为准\n\n\n# body背景大图\n\n\n# bodyBgImg\n\n * 类型：string | array\n * 默认：undefined\n\nbody背景大图，单张图片使用String，多张图片使用Array， 多张图片时每隔 <bodyBgImgInterval> 秒换一张\n\n\n# bodyBgImgOpacity\n\n * 类型：number\n * 默认：0.5\n * 选值范围：0 ~ 1.0\n\nbody背景图透明度\n\n\n# bodyBgImgInterval\n\n * 类型：number\n * 默认：15\n * 单位：s\n\nbody有多张背景大图时的切换间隔\n\n\n# 文章标题前的图标\n\n\n# titleBadge\n\n * 类型：boolean\n * 默认：true\n\n是否打开文章标题图标\n\n\n# titleBadgeIcons\n\n * 类型：array\n * 默认：内置图标\n\n文章标题图标的地址\n\n\n# 文章内容块的背景底纹\n\n\n# contentBgStyle\n\n * 类型：number\n * 默认：undefined\n * 选值：1 => 方格 | 2 => 横线 | 3 => 竖线 | 4 => 左斜线 | 5 => 右斜线 | 6 => 点状\n\n文章内容块的背景底纹\n\n\n# 侧边栏\n\n\n# sidebar\n\n * 类型：srting | object | array\n * 在默认主题原有的配置上新增两项参数：\n   * 'structuring' 自动生成结构化侧边栏\n   * { mode: 'structuring', collapsable: Boolean} 自动生成结构化侧边栏，并设置侧边栏是否可折叠，默认true\n\n提示\n\n如需构建结构化站点请把此配置设置为structuring 或 { mode: 'structuring', collapsable: false}\n\n\n# sidebarOpen\n\n * 类型：boolean\n * 默认：true\n\n初始状态下是否打开侧边栏\n\n提示\n\n在侧边栏关闭状态下，页面向下滚动时会隐藏顶部导航栏，让用户更专注于阅读。\n\n\n# 对指定页面禁用侧边栏\n\n你可以通过 front matter 来禁用指定页面的侧边栏：\n\n---\nsidebar: false\n---\n\n\n1\n2\n3\n\n\n\n# 碎片化文章的侧边栏\n\n在_posts文件夹的文章会自动在 front matter 添加 sidebar: auto\n\n---\nsidebar: auto\n---\n\n\n1\n2\n3\n\n\n\n# 最近更新栏\n\n\n# updateBar\n\n * 类型：object\n * 默认：{showToArticle: true, moreArticle: '/archives/'}\n   * showToArticle 显示到文章页底部，默认true\n   * moreArticle “更多文章”跳转的页面，默认'/archives/'\n\n最近更新栏，显示于文章页底部和简约版首页文章列表\n\n\n# 非文章页的设置\n\n对于非文章页，如目录页、关于、友情链接等自定义页面，最好在front matter设置article: false，设置之后这个页面将被认定为非文章页，不显示面包屑和作者、时间，不显示最近更新栏，不会参与到最近更新文章的数据计算中。\n\n---\narticle: false\n---\n\n\n1\n2\n3\n\n\n\n# 右侧文章大纲栏\n\n\n# rightMenuBar\n\n * 类型：boolean\n * 默认：true\n\n是否显示右侧文章大纲栏。设置为false或屏宽小于1300px时，文章大纲将与左侧侧边栏混合在一起。 (注：在屏宽小于1300px下无论如何都不显示右侧文章大纲栏。)\n\n\n# 快捷翻页按钮\n\n\n# pageButton\n\n * 类型：boolean\n * 默认：true\n\n是否显示快捷翻页按钮 (此按钮是文章页左右两边的箭头按钮，小屏中不会显示。)\n\n\n# 文章作者信息\n\n\n# author\n\n * 类型：string | {name: String, link: String}\n * 默认：undefined\n * 属性：\n   * name 作者名称\n   * link 作者链接\n\n文章默认的作者信息\n\n\n# 指定的文章作者信息\n\n你也可以在指定的文章front matter设置作者信息，优先级比默认作者信息高，示例：\n\n---\nauthor:\n  name: 作者名\n  link: https://xxx.com\n---\n 或\n---\nauthor: 作者名\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 博主信息\n\n\n# blogger\n\n * 参数和类型：{avatar: String, name: String, slogan: String}\n * 默认：undefined\n   * avatar 头像，必需\n   * name 博主名称，必需\n   * slogan 标语，可选\n\n博主信息显示于首页博主信息栏\n\n\n# 社交图标\n\n\n# social\n\n * 参数和类型：{iconfontCssFile: String, icons: [{iconClass: String, title: String, link: String}]}\n * 默认：undefined\n   * iconfontCssFile 可选，阿里图标库（或其他）的在线css字体图标文件地址，对于主题没有的图标可自由添加\n   * icons 图标列表，数量自由\n     * iconClass 图标的Class名称\n     * title 图标的title\n     * link 图标的跳转链接\n\n社交图标显示于博主信息栏和页脚栏\n\n\n# 主题内置的社交图标\n\n微信            QQ        邮件             npm        github        gitee        微博\n                                                                             \nicon-weixin   icon-QQ   icon-youjian   icon-npm   icon-github   icon-gitee   icon-weibo\n\n\n# 扩展自动生成front matter\n\n\n# extendFrontmatter\n\n * 类型：Object\n * 默认：undefined\n\n当.md文件的front matter不存在extendFrontmatter内相应的字段时，将在运行开发服务dev或打包build时自动添加，但不会覆盖已有的数据。\n\n例子：\n\nextendFrontmatter: {\n  author: {\n    name: 'xugaoyi',\n    link: 'https://github.com/xugaoyi'\n  },\n  titleTag: '',\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n生成到front matter：\n\n---\nauthor:\n  name: xugaoyi\n  link: https://github.com/xugaoyi\ntitleTag:\n---\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 页脚版权栏\n\n\n# footer\n\n * 参数和类型：{createYear: Number | String, copyrightInfo: String}\n * 默认：undefined\n   * createYear 博客创建的年份\n   * copyrightInfo 可以配置包括版权信息、备案信息在内的所有信息，支持a标签\n\n页脚版权栏信息，原默认主题在首页的front matter中的footer配置项已弃用。\n\n\n# 自定义html模块\n\n> 可用于插入广告模块\n\n\n# htmlModules\n\n * 类型：object\n\n * 默认：undefined\n\n * 属性：\n   \n   * homeSidebarB 首页侧边栏底部\n   * sidebarT 所有左侧边栏顶部\n   * sidebarB 所有左侧边栏底部\n   * pageT 页面顶部\n   * pageB 页面底部\n   * pageTshowMode 页面顶部的显示方式\n     * 未配置 默认所有页面显示\n     * 'article' 仅文章页①显示\n     * 'custom' 仅自定义页①显示\n   * pageBshowMode 页面底部的显示方式\n     * 未配置 默认全局显示\n     * 'article' 仅文章页①显示\n     * 'custom' 仅自定义页①显示\n   * windowLB 全局窗口左下角②\n   * windowRB 全局窗口右下角②\n   \n   \n   > ①注：在.md文件front matter配置article: false的页面是自定义页，未配置的默认是文章页（首页除外）。\n   > \n   > ②注：windowLB 和 windowRB：1.展示区块最大宽高200px*400px。2.请给自定义元素定一个不超过200px*400px的宽高。3.在屏幕宽度小于960px时无论如何都不会显示。\n\n * 格式：\n\nhtmlModules: {\n   homeSidebarB: htmlString,\n   sidebarT: htmlString,\n   sidebarB: htmlString,\n   pageT: htmlString,\n   pageB: htmlString,\n   pageTshowMode: 'article' | 'custom',\n   pageBshowMode: 'article' | 'custom',\n   windowLB: htmlString,\n   windowRB: htmlString,\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"主题的配置在.vuepress/config.ts文件的themeconfig字段中，是在原有配置的基础上做的新增和修改，配置示例请查看：config.ts。\n\n更多官方配置，请查看vuepress文档。\n\n\n# 是否打开分类、标签、归档\n\n\n# category\n\n * 类型：boolean\n * 默认：true\n\n是否打开分类功能。 如打开，会做的事情有：\n\n 1. 自动生成的front matter包含分类字段\n 2. 页面中显示与分类相关的信息和模块\n 3. 自动生成分类页面（在@pages文件夹）\n\n如关闭，则反之。\n\n\n# tag\n\n * 类型：boolean\n * 默认：true\n\n是否打开标签功能。 如打开，会做的事情有：\n\n 1. 自动生成的front matter包含标签字段\n 2. 页面中显示与标签相关的信息和模块\n 3. 自动生成标签页面（在@pages文件夹）\n\n如关闭，则反之。\n\n\n# archive\n\n * 类型：boolean\n * 默认：true\n\n是否打开归档功能。 如打开，会做的事情有：\n\n 1. 自动生成归档页面（在@pages文件夹）\n\n如关闭，则反之。\n\n提示\n\n如果你仅仅是想使用这个主题来搭建知识库，并不想使用分类、标签、归档功能，就可以关闭它们。\n\n\n# 使用分类页、标签页、归档页链接\n\n当你打开了分类、标签、归档功能，就可以在导航或其他地方添加分类页、标签页、归档页的链接：\n\n * 分类页: /categories/\n * 标签页: /tags/\n * 归档页: /archives/\n\n\n# 碎片化文章默认分类值\n\n\n# categorytext\n\n * 类型：string\n * 默认：'随笔'\n\n碎片化文章（_posts文件夹的文章）默认生成的分类值\n\n\n# 页面风格\n\n\n# pagestyle\n\n * 类型：string\n * 可选值：'card' | 'line' （line在未设置bodybgimg时才生效）\n * 默认：'card'\n\n页面风格，card时背景显示灰色衬托出卡片样式，line时背景显示纯色，并且部分模块带线条边框（未设置bodybgimg时才生效）\n\n\n# defaultmode\n\n * 类型：string\n * 可选值：'auto' | 'light' | 'dark' | 'read'\n * 默认：'auto'\n\n默认外观模式，用户未在页面手动修改过模式时才生效，否则以用户设置的模式为准\n\n\n# body背景大图\n\n\n# bodybgimg\n\n * 类型：string | array\n * 默认：undefined\n\nbody背景大图，单张图片使用string，多张图片使用array， 多张图片时每隔 <bodybgimginterval> 秒换一张\n\n\n# bodybgimgopacity\n\n * 类型：number\n * 默认：0.5\n * 选值范围：0 ~ 1.0\n\nbody背景图透明度\n\n\n# bodybgimginterval\n\n * 类型：number\n * 默认：15\n * 单位：s\n\nbody有多张背景大图时的切换间隔\n\n\n# 文章标题前的图标\n\n\n# titlebadge\n\n * 类型：boolean\n * 默认：true\n\n是否打开文章标题图标\n\n\n# titlebadgeicons\n\n * 类型：array\n * 默认：内置图标\n\n文章标题图标的地址\n\n\n# 文章内容块的背景底纹\n\n\n# contentbgstyle\n\n * 类型：number\n * 默认：undefined\n * 选值：1 => 方格 | 2 => 横线 | 3 => 竖线 | 4 => 左斜线 | 5 => 右斜线 | 6 => 点状\n\n文章内容块的背景底纹\n\n\n# 侧边栏\n\n\n# sidebar\n\n * 类型：srting | object | array\n * 在默认主题原有的配置上新增两项参数：\n   * 'structuring' 自动生成结构化侧边栏\n   * { mode: 'structuring', collapsable: boolean} 自动生成结构化侧边栏，并设置侧边栏是否可折叠，默认true\n\n提示\n\n如需构建结构化站点请把此配置设置为structuring 或 { mode: 'structuring', collapsable: false}\n\n\n# sidebaropen\n\n * 类型：boolean\n * 默认：true\n\n初始状态下是否打开侧边栏\n\n提示\n\n在侧边栏关闭状态下，页面向下滚动时会隐藏顶部导航栏，让用户更专注于阅读。\n\n\n# 对指定页面禁用侧边栏\n\n你可以通过 front matter 来禁用指定页面的侧边栏：\n\n---\nsidebar: false\n---\n\n\n1\n2\n3\n\n\n\n# 碎片化文章的侧边栏\n\n在_posts文件夹的文章会自动在 front matter 添加 sidebar: auto\n\n---\nsidebar: auto\n---\n\n\n1\n2\n3\n\n\n\n# 最近更新栏\n\n\n# updatebar\n\n * 类型：object\n * 默认：{showtoarticle: true, morearticle: '/archives/'}\n   * showtoarticle 显示到文章页底部，默认true\n   * morearticle “更多文章”跳转的页面，默认'/archives/'\n\n最近更新栏，显示于文章页底部和简约版首页文章列表\n\n\n# 非文章页的设置\n\n对于非文章页，如目录页、关于、友情链接等自定义页面，最好在front matter设置article: false，设置之后这个页面将被认定为非文章页，不显示面包屑和作者、时间，不显示最近更新栏，不会参与到最近更新文章的数据计算中。\n\n---\narticle: false\n---\n\n\n1\n2\n3\n\n\n\n# 右侧文章大纲栏\n\n\n# rightmenubar\n\n * 类型：boolean\n * 默认：true\n\n是否显示右侧文章大纲栏。设置为false或屏宽小于1300px时，文章大纲将与左侧侧边栏混合在一起。 (注：在屏宽小于1300px下无论如何都不显示右侧文章大纲栏。)\n\n\n# 快捷翻页按钮\n\n\n# pagebutton\n\n * 类型：boolean\n * 默认：true\n\n是否显示快捷翻页按钮 (此按钮是文章页左右两边的箭头按钮，小屏中不会显示。)\n\n\n# 文章作者信息\n\n\n# author\n\n * 类型：string | {name: string, link: string}\n * 默认：undefined\n * 属性：\n   * name 作者名称\n   * link 作者链接\n\n文章默认的作者信息\n\n\n# 指定的文章作者信息\n\n你也可以在指定的文章front matter设置作者信息，优先级比默认作者信息高，示例：\n\n---\nauthor:\n  name: 作者名\n  link: https://xxx.com\n---\n 或\n---\nauthor: 作者名\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 博主信息\n\n\n# blogger\n\n * 参数和类型：{avatar: string, name: string, slogan: string}\n * 默认：undefined\n   * avatar 头像，必需\n   * name 博主名称，必需\n   * slogan 标语，可选\n\n博主信息显示于首页博主信息栏\n\n\n# 社交图标\n\n\n# social\n\n * 参数和类型：{iconfontcssfile: string, icons: [{iconclass: string, title: string, link: string}]}\n * 默认：undefined\n   * iconfontcssfile 可选，阿里图标库（或其他）的在线css字体图标文件地址，对于主题没有的图标可自由添加\n   * icons 图标列表，数量自由\n     * iconclass 图标的class名称\n     * title 图标的title\n     * link 图标的跳转链接\n\n社交图标显示于博主信息栏和页脚栏\n\n\n# 主题内置的社交图标\n\n微信            qq        邮件             npm        github        gitee        微博\n                                                                             \nicon-weixin   icon-qq   icon-youjian   icon-npm   icon-github   icon-gitee   icon-weibo\n\n\n# 扩展自动生成front matter\n\n\n# extendfrontmatter\n\n * 类型：object\n * 默认：undefined\n\n当.md文件的front matter不存在extendfrontmatter内相应的字段时，将在运行开发服务dev或打包build时自动添加，但不会覆盖已有的数据。\n\n例子：\n\nextendfrontmatter: {\n  author: {\n    name: 'xugaoyi',\n    link: 'https://github.com/xugaoyi'\n  },\n  titletag: '',\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n生成到front matter：\n\n---\nauthor:\n  name: xugaoyi\n  link: https://github.com/xugaoyi\ntitletag:\n---\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 页脚版权栏\n\n\n# footer\n\n * 参数和类型：{createyear: number | string, copyrightinfo: string}\n * 默认：undefined\n   * createyear 博客创建的年份\n   * copyrightinfo 可以配置包括版权信息、备案信息在内的所有信息，支持a标签\n\n页脚版权栏信息，原默认主题在首页的front matter中的footer配置项已弃用。\n\n\n# 自定义html模块\n\n> 可用于插入广告模块\n\n\n# htmlmodules\n\n * 类型：object\n\n * 默认：undefined\n\n * 属性：\n   \n   * homesidebarb 首页侧边栏底部\n   * sidebart 所有左侧边栏顶部\n   * sidebarb 所有左侧边栏底部\n   * paget 页面顶部\n   * pageb 页面底部\n   * pagetshowmode 页面顶部的显示方式\n     * 未配置 默认所有页面显示\n     * 'article' 仅文章页①显示\n     * 'custom' 仅自定义页①显示\n   * pagebshowmode 页面底部的显示方式\n     * 未配置 默认全局显示\n     * 'article' 仅文章页①显示\n     * 'custom' 仅自定义页①显示\n   * windowlb 全局窗口左下角②\n   * windowrb 全局窗口右下角②\n   \n   \n   > ①注：在.md文件front matter配置article: false的页面是自定义页，未配置的默认是文章页（首页除外）。\n   > \n   > ②注：windowlb 和 windowrb：1.展示区块最大宽高200px*400px。2.请给自定义元素定一个不超过200px*400px的宽高。3.在屏幕宽度小于960px时无论如何都不会显示。\n\n * 格式：\n\nhtmlmodules: {\n   homesidebarb: htmlstring,\n   sidebart: htmlstring,\n   sidebarb: htmlstring,\n   paget: htmlstring,\n   pageb: htmlstring,\n   pagetshowmode: 'article' | 'custom',\n   pagebshowmode: 'article' | 'custom',\n   windowlb: htmlstring,\n   windowrb: htmlstring,\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"首页配置",frontmatter:{title:"首页配置",date:"2020-05-12T15:36:50.000Z",permalink:"/pages/f14bdb",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/02.%E9%A6%96%E9%A1%B5%E9%85%8D%E7%BD%AE.html",relativePath:"60.关于/20.配置/01.配置/02.首页配置.md",key:"v-65e9a99b",path:"/pages/f14bdb/",headers:[{level:3,title:"bannerBg",slug:"bannerbg",normalizedTitle:"bannerbg",charIndex:219},{level:3,title:"features",slug:"features",normalizedTitle:"features",charIndex:373},{level:3,title:"postList",slug:"postlist",normalizedTitle:"postlist",charIndex:776},{level:3,title:"simplePostListLength",slug:"simplepostlistlength",normalizedTitle:"simplepostlistlength",charIndex:797},{level:3,title:"hideRightBar",slug:"hiderightbar",normalizedTitle:"hiderightbar",charIndex:871}],headersStr:"bannerBg features postList simplePostListLength hideRightBar",content:"在docs目录下的index.md或README.md的 front matter 指定 home: true，就会为你的站点生成一个首页，示例：\n\n---\nhome: true\n# heroImage: /img/web.png\nheroText: Evan's blog\ntagline: Web前端技术博客，积跬步以至千里，致敬每个爱学习的你。\n# actionText: 立刻进入 →\n# actionLink: /web/\n# bannerBg: auto # auto => 网格纹背景(有bodyBgImg时无背景)，默认 | none => 无 | '大图地址' | background: 自定义背景样式       提示：如发现文本颜色不适应你的背景时可以到palette.styl修改$bannerTextColor变量\n\nfeatures: # 可选的\n  - title: 前端\n    details: JavaScript、ES6、Vue框架等前端技术\n    link: /web/ # 可选\n    imgUrl: /img/web.png # 可选\n  - title: 页面\n    details: html(5)/css(3)，前端页面相关技术\n    link: /ui/\n    imgUrl: /img/ui.png\n  - title: 技术\n    details: 技术文档、教程、技巧、总结等文章\n    link: /technology/\n    imgUrl: /img/other.png\n\n# 文章列表显示方式: detailed 默认，显示详细版文章列表（包括作者、分类、标签、摘要、分页等）| simple => 显示简约版文章列表（仅标题和日期）| none 不显示文章列表\n# postList: detailed\n# simplePostListLength: 10 # 简约版文章列表显示的文章数量，默认10。（仅在postList设置为simple时生效）\n# hideRightBar: true # 是否隐藏右侧边栏 (v1.11.2+)\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n一些字段还是沿用默认主题的，这里只对修改的地方做一个补充。\n\n\n# bannerBg\n\n * 类型：string\n * 可选参数：\n   * auto 自动背景，一般会显示网格纹背景，如果在config.js设置了bodyBgImg时则无背景\n   * none 无背景\n   * <大图地址>，如/img/bg.jpeg\n   * background: <自定义背景样式>，如background: blue\n * 默认： auto\n\n\n# features\n\n * 类型：{title: string, details: string, link?: string, imgUrl?: string}[]\n\nfeatures是在banner栏显示的特性描述，主题添加了图片的展示和点击跳转的链接\n\n * features[index].link 当前feature跳转的链接，可选\n * features[index].imgUrl 当前feature的图片地址，可选\n\n\n# postList\n\n * 类型：'detailed' | 'simple' | 'none'\n * 可选参数：\n   * detailed 显示详细版文章列表（包括标题、日期、作者、分类、标签、摘要、分页等）\n   * simple 显示简约版文章列表（仅标题和日期）\n   * none 不显示文章列表\n * 默认： detailed\n\n首页内容中的文章列表显示方式\n\n\n# simplePostListLength\n\n * 类型：number\n * 默认： 10\n\n简约版文章列表显示的文章数量，默认10。（仅在postList设置为simple时生效）\n\n\n# hideRightBar\n\n * 类型：boolean\n * 默认： false\n\n是否隐藏右侧边栏\n\n注意\n\n原默认主题首页的footer字段已改到config.js文件里设置",normalizedContent:"在docs目录下的index.md或readme.md的 front matter 指定 home: true，就会为你的站点生成一个首页，示例：\n\n---\nhome: true\n# heroimage: /img/web.png\nherotext: evan's blog\ntagline: web前端技术博客，积跬步以至千里，致敬每个爱学习的你。\n# actiontext: 立刻进入 →\n# actionlink: /web/\n# bannerbg: auto # auto => 网格纹背景(有bodybgimg时无背景)，默认 | none => 无 | '大图地址' | background: 自定义背景样式       提示：如发现文本颜色不适应你的背景时可以到palette.styl修改$bannertextcolor变量\n\nfeatures: # 可选的\n  - title: 前端\n    details: javascript、es6、vue框架等前端技术\n    link: /web/ # 可选\n    imgurl: /img/web.png # 可选\n  - title: 页面\n    details: html(5)/css(3)，前端页面相关技术\n    link: /ui/\n    imgurl: /img/ui.png\n  - title: 技术\n    details: 技术文档、教程、技巧、总结等文章\n    link: /technology/\n    imgurl: /img/other.png\n\n# 文章列表显示方式: detailed 默认，显示详细版文章列表（包括作者、分类、标签、摘要、分页等）| simple => 显示简约版文章列表（仅标题和日期）| none 不显示文章列表\n# postlist: detailed\n# simplepostlistlength: 10 # 简约版文章列表显示的文章数量，默认10。（仅在postlist设置为simple时生效）\n# hiderightbar: true # 是否隐藏右侧边栏 (v1.11.2+)\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n一些字段还是沿用默认主题的，这里只对修改的地方做一个补充。\n\n\n# bannerbg\n\n * 类型：string\n * 可选参数：\n   * auto 自动背景，一般会显示网格纹背景，如果在config.js设置了bodybgimg时则无背景\n   * none 无背景\n   * <大图地址>，如/img/bg.jpeg\n   * background: <自定义背景样式>，如background: blue\n * 默认： auto\n\n\n# features\n\n * 类型：{title: string, details: string, link?: string, imgurl?: string}[]\n\nfeatures是在banner栏显示的特性描述，主题添加了图片的展示和点击跳转的链接\n\n * features[index].link 当前feature跳转的链接，可选\n * features[index].imgurl 当前feature的图片地址，可选\n\n\n# postlist\n\n * 类型：'detailed' | 'simple' | 'none'\n * 可选参数：\n   * detailed 显示详细版文章列表（包括标题、日期、作者、分类、标签、摘要、分页等）\n   * simple 显示简约版文章列表（仅标题和日期）\n   * none 不显示文章列表\n * 默认： detailed\n\n首页内容中的文章列表显示方式\n\n\n# simplepostlistlength\n\n * 类型：number\n * 默认： 10\n\n简约版文章列表显示的文章数量，默认10。（仅在postlist设置为simple时生效）\n\n\n# hiderightbar\n\n * 类型：boolean\n * 默认： false\n\n是否隐藏右侧边栏\n\n注意\n\n原默认主题首页的footer字段已改到config.js文件里设置",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"front matter配置",frontmatter:{title:"front matter配置",date:"2020-05-12T15:37:00.000Z",permalink:"/pages/3216b0",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/03.front%20matter%E9%85%8D%E7%BD%AE.html",relativePath:"60.关于/20.配置/01.配置/03.front matter配置.md",key:"v-1bd16c74",path:"/pages/3216b0/",headers:[{level:2,title:"配置项",slug:"配置项",normalizedTitle:"配置项",charIndex:325},{level:3,title:"titleTag",slug:"titletag",normalizedTitle:"titletag",charIndex:131},{level:3,title:"sidebar",slug:"sidebar",normalizedTitle:"sidebar",charIndex:154},{level:3,title:"article",slug:"article",normalizedTitle:"article",charIndex:169},{level:3,title:"comment",slug:"comment",normalizedTitle:"comment",charIndex:184},{level:3,title:"editLink",slug:"editlink",normalizedTitle:"editlink",charIndex:199},{level:3,title:"author",slug:"author",normalizedTitle:"author",charIndex:215},{level:3,title:"sticky (置顶)",slug:"sticky-置顶",normalizedTitle:"sticky (置顶)",charIndex:861}],headersStr:"配置项 titleTag sidebar article comment editLink author sticky (置顶)",content:"一个比较完整的front matter示例：\n\n---\ntitle: 标题\ndate: 2020-02-21 14:40:19\npermalink: /pages/a1bc87\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\ntitleTag: 原创 # v1.9.0+\nsidebar: false\narticle: false\ncomment: false\neditLink: false\nauthor:\n name: 作者\n link: https://xxx.com\nsticky: 1\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 配置项\n\n自动生成的front matter字段包括title、date、permalink、categories、tags，这里就不再重复赘述，参考：自动生成front matter\n\n\n# titleTag\n\n * 用于给标题添加 原创、转载 、优质、推荐 等自定义标记。\n\n添加了标题标记的文章，在文章页和文章列表、最近更新栏、归档页的文章标题都会显示此标记。\n\n\n# sidebar\n\n * false 不显示侧边栏\n * auto 显示自动侧边栏（只包含本文标题和子标题）\n\n\n# article\n\n * false 判定当前页面为非文章页\n\n对于非文章页，如目录页、关于、友情链接等自定义页面，需要设置此项。设置之后这个页面将被认定为非文章页，不显示面包屑和作者、时间，不显示最近更新栏，不会参与到最近更新文章的数据计算中。\n\n\n# comment\n\n * false 不显示评论区，这是评论插件的一个配置\n\n\n# editLink\n\n * false 不显示编辑链接\n\n\n# author\n\n * author.name 作者名称\n * author.link 作者链接\n\n指定当前页面的作者信息，如没有作者链接时可以这样：author: 作者名称\n\n\n# sticky (置顶)\n\n * 类型： number\n * 排序：允许有多个置顶文章，按照 1, 2, 3, ... 来降低置顶文章的排列优先级\n\n文章置顶，设置了此项将在首页详细版文章列表中处于置顶位置。",normalizedContent:"一个比较完整的front matter示例：\n\n---\ntitle: 标题\ndate: 2020-02-21 14:40:19\npermalink: /pages/a1bc87\ncategories:\n  - 分类1\n  - 分类2\ntags:\n  - 标签1\ntitletag: 原创 # v1.9.0+\nsidebar: false\narticle: false\ncomment: false\neditlink: false\nauthor:\n name: 作者\n link: https://xxx.com\nsticky: 1\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 配置项\n\n自动生成的front matter字段包括title、date、permalink、categories、tags，这里就不再重复赘述，参考：自动生成front matter\n\n\n# titletag\n\n * 用于给标题添加 原创、转载 、优质、推荐 等自定义标记。\n\n添加了标题标记的文章，在文章页和文章列表、最近更新栏、归档页的文章标题都会显示此标记。\n\n\n# sidebar\n\n * false 不显示侧边栏\n * auto 显示自动侧边栏（只包含本文标题和子标题）\n\n\n# article\n\n * false 判定当前页面为非文章页\n\n对于非文章页，如目录页、关于、友情链接等自定义页面，需要设置此项。设置之后这个页面将被认定为非文章页，不显示面包屑和作者、时间，不显示最近更新栏，不会参与到最近更新文章的数据计算中。\n\n\n# comment\n\n * false 不显示评论区，这是评论插件的一个配置\n\n\n# editlink\n\n * false 不显示编辑链接\n\n\n# author\n\n * author.name 作者名称\n * author.link 作者链接\n\n指定当前页面的作者信息，如没有作者链接时可以这样：author: 作者名称\n\n\n# sticky (置顶)\n\n * 类型： number\n * 排序：允许有多个置顶文章，按照 1, 2, 3, ... 来降低置顶文章的排列优先级\n\n文章置顶，设置了此项将在首页详细版文章列表中处于置顶位置。",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"目录页配置",frontmatter:{title:"目录页配置",date:"2020-05-13T10:58:07.000Z",permalink:"/pages/54651a",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/04.%E7%9B%AE%E5%BD%95%E9%A1%B5%E9%85%8D%E7%BD%AE.html",relativePath:"60.关于/20.配置/01.配置/04.目录页配置.md",key:"v-771f9586",path:"/pages/54651a/",headers:[{level:2,title:"目录页说明",slug:"目录页说明",normalizedTitle:"目录页说明",charIndex:2},{level:2,title:"配置项",slug:"配置项",normalizedTitle:"配置项",charIndex:952},{level:3,title:"pageComponent.name",slug:"pagecomponent-name",normalizedTitle:"pagecomponent.name",charIndex:960},{level:3,title:"pageComponent.data",slug:"pagecomponent-data",normalizedTitle:"pagecomponent.data",charIndex:1020},{level:3,title:"pageComponent.data.path",slug:"pagecomponent-data-path",normalizedTitle:"pagecomponent.data.path",charIndex:1057},{level:3,title:"pageComponent.data.imgUrl",slug:"pagecomponent-data-imgurl",normalizedTitle:"pagecomponent.data.imgurl",charIndex:1227},{level:3,title:"pageComponent.data.description",slug:"pagecomponent-data-description",normalizedTitle:"pagecomponent.data.description",charIndex:1309},{level:2,title:"如何在导航栏中添加目录页链接",slug:"如何在导航栏中添加目录页链接",normalizedTitle:"如何在导航栏中添加目录页链接",charIndex:1389}],headersStr:"目录页说明 配置项 pageComponent.name pageComponent.data pageComponent.data.path pageComponent.data.imgUrl pageComponent.data.description 如何在导航栏中添加目录页链接",content:"# 目录页说明\n\n注意\n\n目录页数据需要依赖于结构化的侧边栏数据，就是说你需要在config.js配置 sidebar: 'structuring' 或 sidebar: { mode: 'structuring', collapsable: false} 才能实现目录页数据的获取。\n\n>  * 目录页文件(.md文件)可以放置在二级目录、三级目录和四级目录。（级别说明）\n>  * 如果你不想在侧边栏显示目录页，你可以在一级目录中单独创建一个文件夹放置你的目录页(.md文件)，并在front matter中设置sidebar: false。\n>  * 如果你想让目录页和其他页面一起出现在侧边栏，你可以和其他页面共同放置在相应的文件夹。(不要设置sidebar: false)\n>  * 参照下面的示例配置好front matter，然后就可以在导航栏或首页添加目录页链接了。\n\n示例：\n\n---\npageComponent: # 使用页面组件\n  name: Catalogue # 组件名：Catalogue => 目录页组件\n  data: # 组件所需数据\n    path:  01.学习笔记/01.前端 # 设置为`docs/`下面的某个文件夹相对路径，如‘01.学习笔记/01.前端’ 或 ’01.学习笔记‘ (有序号的要带序号)\n    imgUrl: /img/web.png # 目录页内的图片\n    description: JavaScript、ES6、Vue框架等前端技术 # 目录描述（可加入a标签）\n\ntitle: 前端 # 页面标题\ndate: 2020-01-12 11:51:53 # 创建日期\npermalink: /note/javascript # 永久链接\nsidebar: false # 不显示侧边栏\narticle: false # 不是文章页 (不显示面包屑栏、最近更新栏等)\ncomment: false # 不显示评论栏\neditLink: false # 不显示编辑按钮\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n提示\n\n配置好目录页之后，点击文章页的面包屑将会跳转到目录页。\n\n\n# 配置项\n\n\n# pageComponent.name\n\n * 组件名，必需\n * 使用目录页时 必须 设置为Catalogue\n\n\n# pageComponent.data\n\n * 组件所需数据，必需\n\n\n# pageComponent.data.path\n\n * 要为其生成目录页的文件夹的相对路径，必需\n * 必须是在docs目录底下的文件夹相对路径\n * 示例：01.学习笔记或01.学习笔记/01.前端(有序号的要带序号)\n\n注意\n\n在v1.8.2版本之前，没有path属性，使用key代替。但key只支持指定一级目录的文件夹名称。\n\n\n# pageComponent.data.imgUrl\n\n * 目录页内的图片，可选。(v1.9.4之前必填)\n * 图片尺寸在页面中显示为80px*80px\n\n\n# pageComponent.data.description\n\n * 目录描述，必需\n * 可加a标签（如需加入a标签时，标签内部的引号请使用单引号）\n\n\n# 如何在导航栏中添加目录页链接\n\n // config.js\nmodule.exports = {\n    themeConfig: {\n        nav:  [\n            // 没有二级导航时可以直接添加\n           {text: '目录页', link: '/web/'},\n\n          // 有二级导航时\n           {text: '页面',\n               link: '/ui/',   //目录页， vdoing主题新增的配置项，有二级导航时，可以点击一级导航跳到目录页\n               items: [\n                 {text: 'HTML', link: '/pages/11/'},\n                 {text: 'CSS', link: '/pages/22/'},\n               ]\n            },\n       ]\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n参考：.vuepress/config/nav.js",normalizedContent:"# 目录页说明\n\n注意\n\n目录页数据需要依赖于结构化的侧边栏数据，就是说你需要在config.js配置 sidebar: 'structuring' 或 sidebar: { mode: 'structuring', collapsable: false} 才能实现目录页数据的获取。\n\n>  * 目录页文件(.md文件)可以放置在二级目录、三级目录和四级目录。（级别说明）\n>  * 如果你不想在侧边栏显示目录页，你可以在一级目录中单独创建一个文件夹放置你的目录页(.md文件)，并在front matter中设置sidebar: false。\n>  * 如果你想让目录页和其他页面一起出现在侧边栏，你可以和其他页面共同放置在相应的文件夹。(不要设置sidebar: false)\n>  * 参照下面的示例配置好front matter，然后就可以在导航栏或首页添加目录页链接了。\n\n示例：\n\n---\npagecomponent: # 使用页面组件\n  name: catalogue # 组件名：catalogue => 目录页组件\n  data: # 组件所需数据\n    path:  01.学习笔记/01.前端 # 设置为`docs/`下面的某个文件夹相对路径，如‘01.学习笔记/01.前端’ 或 ’01.学习笔记‘ (有序号的要带序号)\n    imgurl: /img/web.png # 目录页内的图片\n    description: javascript、es6、vue框架等前端技术 # 目录描述（可加入a标签）\n\ntitle: 前端 # 页面标题\ndate: 2020-01-12 11:51:53 # 创建日期\npermalink: /note/javascript # 永久链接\nsidebar: false # 不显示侧边栏\narticle: false # 不是文章页 (不显示面包屑栏、最近更新栏等)\ncomment: false # 不显示评论栏\neditlink: false # 不显示编辑按钮\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n提示\n\n配置好目录页之后，点击文章页的面包屑将会跳转到目录页。\n\n\n# 配置项\n\n\n# pagecomponent.name\n\n * 组件名，必需\n * 使用目录页时 必须 设置为catalogue\n\n\n# pagecomponent.data\n\n * 组件所需数据，必需\n\n\n# pagecomponent.data.path\n\n * 要为其生成目录页的文件夹的相对路径，必需\n * 必须是在docs目录底下的文件夹相对路径\n * 示例：01.学习笔记或01.学习笔记/01.前端(有序号的要带序号)\n\n注意\n\n在v1.8.2版本之前，没有path属性，使用key代替。但key只支持指定一级目录的文件夹名称。\n\n\n# pagecomponent.data.imgurl\n\n * 目录页内的图片，可选。(v1.9.4之前必填)\n * 图片尺寸在页面中显示为80px*80px\n\n\n# pagecomponent.data.description\n\n * 目录描述，必需\n * 可加a标签（如需加入a标签时，标签内部的引号请使用单引号）\n\n\n# 如何在导航栏中添加目录页链接\n\n // config.js\nmodule.exports = {\n    themeconfig: {\n        nav:  [\n            // 没有二级导航时可以直接添加\n           {text: '目录页', link: '/web/'},\n\n          // 有二级导航时\n           {text: '页面',\n               link: '/ui/',   //目录页， vdoing主题新增的配置项，有二级导航时，可以点击一级导航跳到目录页\n               items: [\n                 {text: 'html', link: '/pages/11/'},\n                 {text: 'css', link: '/pages/22/'},\n               ]\n            },\n       ]\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n参考：.vuepress/config/nav.js",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"添加摘要",frontmatter:{title:"添加摘要",date:"2020-05-13T11:47:49.000Z",permalink:"/pages/1cc523",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/05.%E6%B7%BB%E5%8A%A0%E6%91%98%E8%A6%81.html",relativePath:"60.关于/20.配置/01.配置/05.添加摘要.md",key:"v-4616cb7c",path:"/pages/1cc523/",excerpt:"<p>文章摘要会显示于首页的详细版文章列表中，在编写文章时（<code>.md</code>文件中）在合适的位置添加一个`</p>\n",headersStr:null,content:"文章摘要会显示于首页的详细版文章列表中，在编写文章时（.md文件中）在合适的位置添加一个\x3c!-- more --\x3e注释。注释前面的内容将会暴露在摘要中。\n\n示例：\n\n# 如何根据系统主题自动响应CSS深色模式\n\n![Dark](https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200427163531.jpg)\n\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\n\n\x3c!-- more --\x3e\n\n## CSS 深色模式 (Dark Mode)\n\n...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如示例的内容，在\x3c!-- more --\x3e注释前面的除了标题之外所有内容将显示到摘要中。摘要在文章列表的显示效果如下：\n\n\n\n\n\n值得注意的是摘要的内容也是文章内容的一部分，会显示在文章详情页中。",normalizedContent:"文章摘要会显示于首页的详细版文章列表中，在编写文章时（.md文件中）在合适的位置添加一个\x3c!-- more --\x3e注释。注释前面的内容将会暴露在摘要中。\n\n示例：\n\n# 如何根据系统主题自动响应css深色模式\n\n![dark](https://fastly.jsdelivr.net/gh/xugaoyi/image_store/blog/20200427163531.jpg)\n\n很多人喜欢选择app或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的css深色模式，根据访客的系统主题来自动响应。\n\n\x3c!-- more --\x3e\n\n## css 深色模式 (dark mode)\n\n...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n如示例的内容，在\x3c!-- more --\x3e注释前面的除了标题之外所有内容将显示到摘要中。摘要在文章列表的显示效果如下：\n\n\n\n\n\n值得注意的是摘要的内容也是文章内容的一部分，会显示在文章详情页中。",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"修改主题颜色和样式",frontmatter:{title:"修改主题颜色和样式",date:"2020-05-13T11:48:50.000Z",permalink:"/pages/f51918",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/06.%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2%E5%92%8C%E6%A0%B7%E5%BC%8F.html",relativePath:"60.关于/20.配置/01.配置/06.修改主题颜色和样式.md",key:"v-1d501bea",path:"/pages/f51918/",headers:[{level:2,title:"主题样式变量",slug:"主题样式变量",normalizedTitle:"主题样式变量",charIndex:2},{level:2,title:"样式修改与适配",slug:"样式修改与适配",normalizedTitle:"样式修改与适配",charIndex:1593}],headersStr:"主题样式变量 样式修改与适配",content:"# 主题样式变量\n\n下面是vdoing主题使用的css变量，你可以在.vuepress/styles/palette.styl修改这些变量覆盖它们：\n\n//***vdoing主题-CSS变量***//\n\n// 颜色\n$bannerTextColor = #fff // 首页banner区(博客标题区)的文本颜色\n$accentColor = #11A8CD\n$activeColor = #ff5722\n$arrowBgColor = #ccc\n\n// 布局\n$navbarHeight = 3.6rem\n$sidebarWidth = 18rem\n$contentWidth = 860px\n$homePageWidth = 1100px\n$rightMenuWidth = 230px // 右侧菜单\n\n// 代码块\n$lineNumbersWrapperWidth = 2.5rem\n\n// 浅色模式\n.theme-mode-light\n  --bodyBg: #f4f4f4\n  --mainBg: rgba(255,255,255,1)\n  --sidebarBg: rgba(255,255,255,.8)\n  --blurBg: rgba(255,255,255,.9)\n  --textColor: #004050\n  --textLightenColor: #0085AD\n  --borderColor: rgba(0,0,0,.15)\n  // 代码块浅色主题\n  --codeBg: #f6f6f6\n  --codeColor: #525252\n  codeThemeLight()\n  // 代码块深色主题\n  // --codeBg: #252526\n  // --codeColor: #fff\n  // codeThemeDark()\n\n// 深色模式\n.theme-mode-dark\n  --bodyBg: rgb(39,39,43)\n  --mainBg: rgba(30,30,34,1)\n  --sidebarBg: rgba(30,30,34,.8)\n  --blurBg: rgba(30,30,34,.8)\n  --textColor: rgb(140,140,150)\n  --textLightenColor: #0085AD\n  --borderColor: #2C2C3A\n  --codeBg: #252526\n  --codeColor: #fff\n  codeThemeDark()\n\n// 阅读模式\n.theme-mode-read\n  --bodyBg: rgb(240,240,208)\n  --mainBg: rgba(245,245,213,1)\n  --sidebarBg: rgba(245,245,213,.8)\n  --blurBg: rgba(245,245,213,.9)\n  --textColor: #004050\n  --textLightenColor: #0085AD\n  --borderColor: rgba(0,0,0,.15)\n  --codeBg: #282c34\n  --codeColor: #fff\n  codeThemeDark()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n上面的变量值可能不是最新的，最新的变量值可查看：palette.styl\n\n\n# 样式修改与适配\n\n当你想修改主题某个地方的样式时，或者你在给博客添加了一些新的模块或插件，发现样式和主题的样式不协调时，都可以在.vuepress/styles/index.styl 添加css样式来做修改。 需要注意的是，你在自己写的css样式中，请尽量使用主题提供的变量来进行适配。\n\n> 小技巧：当你发现自己写的css样式优先级没有原来的样式高时，可以在样式后面添加!improtant后缀，使你的样式优先级是最高的。",normalizedContent:"# 主题样式变量\n\n下面是vdoing主题使用的css变量，你可以在.vuepress/styles/palette.styl修改这些变量覆盖它们：\n\n//***vdoing主题-css变量***//\n\n// 颜色\n$bannertextcolor = #fff // 首页banner区(博客标题区)的文本颜色\n$accentcolor = #11a8cd\n$activecolor = #ff5722\n$arrowbgcolor = #ccc\n\n// 布局\n$navbarheight = 3.6rem\n$sidebarwidth = 18rem\n$contentwidth = 860px\n$homepagewidth = 1100px\n$rightmenuwidth = 230px // 右侧菜单\n\n// 代码块\n$linenumberswrapperwidth = 2.5rem\n\n// 浅色模式\n.theme-mode-light\n  --bodybg: #f4f4f4\n  --mainbg: rgba(255,255,255,1)\n  --sidebarbg: rgba(255,255,255,.8)\n  --blurbg: rgba(255,255,255,.9)\n  --textcolor: #004050\n  --textlightencolor: #0085ad\n  --bordercolor: rgba(0,0,0,.15)\n  // 代码块浅色主题\n  --codebg: #f6f6f6\n  --codecolor: #525252\n  codethemelight()\n  // 代码块深色主题\n  // --codebg: #252526\n  // --codecolor: #fff\n  // codethemedark()\n\n// 深色模式\n.theme-mode-dark\n  --bodybg: rgb(39,39,43)\n  --mainbg: rgba(30,30,34,1)\n  --sidebarbg: rgba(30,30,34,.8)\n  --blurbg: rgba(30,30,34,.8)\n  --textcolor: rgb(140,140,150)\n  --textlightencolor: #0085ad\n  --bordercolor: #2c2c3a\n  --codebg: #252526\n  --codecolor: #fff\n  codethemedark()\n\n// 阅读模式\n.theme-mode-read\n  --bodybg: rgb(240,240,208)\n  --mainbg: rgba(245,245,213,1)\n  --sidebarbg: rgba(245,245,213,.8)\n  --blurbg: rgba(245,245,213,.9)\n  --textcolor: #004050\n  --textlightencolor: #0085ad\n  --bordercolor: rgba(0,0,0,.15)\n  --codebg: #282c34\n  --codecolor: #fff\n  codethemedark()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n上面的变量值可能不是最新的，最新的变量值可查看：palette.styl\n\n\n# 样式修改与适配\n\n当你想修改主题某个地方的样式时，或者你在给博客添加了一些新的模块或插件，发现样式和主题的样式不协调时，都可以在.vuepress/styles/index.styl 添加css样式来做修改。 需要注意的是，你在自己写的css样式中，请尽量使用主题提供的变量来进行适配。\n\n> 小技巧：当你发现自己写的css样式优先级没有原来的样式高时，可以在样式后面添加!improtant后缀，使你的样式优先级是最高的。",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"评论栏",frontmatter:{title:"评论栏",date:"2020-05-13T12:00:39.000Z",permalink:"/pages/ce175c",article:!1},regularPath:"/60.%E5%85%B3%E4%BA%8E/20.%E9%85%8D%E7%BD%AE/01.%E9%85%8D%E7%BD%AE/07.%E8%AF%84%E8%AE%BA%E6%A0%8F.html",relativePath:"60.关于/20.配置/01.配置/07.评论栏.md",key:"v-aeda6256",path:"/pages/ce175c/",headers:[{level:3,title:"vuepress-plugin-comment",slug:"vuepress-plugin-comment",normalizedTitle:"vuepress-plugin-comment",charIndex:61},{level:3,title:"vuepress-plugin-vssue",slug:"vuepress-plugin-vssue",normalizedTitle:"vuepress-plugin-vssue",charIndex:117},{level:3,title:"vuepress-plugin-vssue-global",slug:"vuepress-plugin-vssue-global",normalizedTitle:"vuepress-plugin-vssue-global",charIndex:169},{level:3,title:"Twikoo",slug:"twikoo",normalizedTitle:"twikoo",charIndex:235}],headersStr:"vuepress-plugin-comment vuepress-plugin-vssue vuepress-plugin-vssue-global Twikoo",content:"评论栏推荐使用vuepress插件的方式来导入，这里推荐一些vuepress的评论插件，使用方法查阅相应的文档。\n\n\n# vuepress-plugin-comment\n\n * vuepress-plugin-comment\n\n\n# vuepress-plugin-vssue\n\n * vuepress-plugin-vssue\n\n\n# vuepress-plugin-vssue-global\n\n * vuepress-plugin-vssue-global\n\n\n# Twikoo\n\n * Twikoo",normalizedContent:"评论栏推荐使用vuepress插件的方式来导入，这里推荐一些vuepress的评论插件，使用方法查阅相应的文档。\n\n\n# vuepress-plugin-comment\n\n * vuepress-plugin-comment\n\n\n# vuepress-plugin-vssue\n\n * vuepress-plugin-vssue\n\n\n# vuepress-plugin-vssue-global\n\n * vuepress-plugin-vssue-global\n\n\n# twikoo\n\n * twikoo",charsets:{cjk:!0},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"资料收集",frontmatter:{title:"资料收集",date:"2023-03-08T11:45:14.000Z",permalink:"/pages/0a2075/",titleTag:"原创",categories:["关于"],tags:["关于"],sticky:2},regularPath:"/60.%E5%85%B3%E4%BA%8E/3.%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86.html",relativePath:"60.关于/3.资料收集.md",key:"v-6dea94dd",path:"/pages/0a2075/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/15, 18:57:22",lastUpdatedTimestamp:1678877842e3},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2020-04-19T11:33:04.000Z",article:!1},regularPath:"/70.%E6%94%B6%E8%97%8F/01.%E7%BD%91%E7%AB%99.html",relativePath:"70.收藏/01.网站.md",key:"v-58f7ed24",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:167},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:375},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:596},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:623},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:711},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:775},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:833},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:897},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:382},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1148},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1197},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1269},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1330},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1493},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1753},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:875},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2090},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2150},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2180},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2241},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:574},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3342},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1967},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2420},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:139},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1839},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4444},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:251},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3329},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4688},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5061},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2330},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5141},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5169}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n</ul>\n<p align="center">\n<img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg" width="200">\n</p>\n<div class="center-container"><p>关注公众号[有趣研究社]，回复<code>前端资源</code>，获取 <a href="https://github.com/xugaoyi/blog-gitalk-comment/wiki/Front-end-Study" target="_blank" rel="noopener noreferrer">前端学习资料<OutboundLink/></a></p>\n</div>',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"常用的前端轮子",frontmatter:{title:"常用的前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/pages/47cf96/",article:!1},regularPath:"/70.%E6%94%B6%E8%97%8F/02.%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",relativePath:"70.收藏/02.常用的前端轮子.md",key:"v-edcbc950",path:"/pages/47cf96/",headers:[{level:2,title:"React UI 组件库",slug:"react-ui-组件库",normalizedTitle:"react ui 组件库",charIndex:2},{level:2,title:"Vue UI组件库",slug:"vue-ui组件库",normalizedTitle:"vue ui组件库",charIndex:68},{level:2,title:"常用效果组件",slug:"常用效果组件",normalizedTitle:"常用效果组件",charIndex:124},{level:2,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:201},{level:2,title:"Vue工具类",slug:"vue工具类",normalizedTitle:"vue工具类",charIndex:331},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:469}],headersStr:"React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类 其他",content:"# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * H5带笔锋手写签名，支持PC端和移动端",normalizedContent:"# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * h5带笔锋手写签名，支持pc端和移动端",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-f6fe71b6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/12, 22:40:00",lastUpdatedTimestamp:1647096e6},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-b1641af6",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/12, 22:40:00",lastUpdatedTimestamp:1647096e6},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-442bcca5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/12, 22:40:00",lastUpdatedTimestamp:1647096e6},{title:"水平扩展和垂直扩展",frontmatter:{title:"水平扩展和垂直扩展",date:"2022-06-09T22:26:59.000Z",permalink:"/pages/560a28/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/1.%E6%B0%B4%E5%B9%B3%E6%89%A9%E5%B1%95%E5%92%8C%E5%9E%82%E7%9B%B4%E6%89%A9%E5%B1%95.html",relativePath:"_posts/随笔/1.水平扩展和垂直扩展.md",key:"v-44635ae9",path:"/pages/560a28/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:2}],headersStr:"定义",content:"# 定义\n\n对付性能瓶颈，系统本身已无潜力可供压榨，榨无可榨的情况下，可以考虑进行扩展。扩展方式又可分为垂直扩展和水平扩展2种。\n\n垂直扩展，就是升级机器，加强装备。换一台更贵更豪华的机器，CPU啦，内存啦，磁盘阵列啦，升之换之。以质取胜。\n\n水平扩展，就是添加机器。一台不够，就加两台。以数量弥补质量的不足，或曰，量变达成质变。",normalizedContent:"# 定义\n\n对付性能瓶颈，系统本身已无潜力可供压榨，榨无可榨的情况下，可以考虑进行扩展。扩展方式又可分为垂直扩展和水平扩展2种。\n\n垂直扩展，就是升级机器，加强装备。换一台更贵更豪华的机器，cpu啦，内存啦，磁盘阵列啦，升之换之。以质取胜。\n\n水平扩展，就是添加机器。一台不够，就加两台。以数量弥补质量的不足，或曰，量变达成质变。",charsets:{cjk:!0},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"后向纠错",frontmatter:{title:"后向纠错",date:"2022-06-10T20:13:11.000Z",permalink:"/pages/7cdb84/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/10.%E5%90%8E%E5%90%91%E7%BA%A0%E9%94%99.html",relativePath:"_posts/随笔/10.后向纠错.md",key:"v-6b5259f3",path:"/pages/7cdb84/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"教育的意义",frontmatter:{title:"教育的意义",date:"2022-05-04T19:59:18.000Z",permalink:"/pages/5ce909/",categories:["生活记杂"],tags:["教育"],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/100.%E6%95%99%E8%82%B2%E7%9A%84%E6%84%8F%E4%B9%89.html",relativePath:"_posts/随笔/100.教育的意义.md",key:"v-c2f13d5e",path:"/pages/5ce909/",headers:[{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:43},{level:2,title:"思考",slug:"思考",normalizedTitle:"思考",charIndex:538},{level:2,title:"解决",slug:"解决",normalizedTitle:"解决",charIndex:543}],excerpt:'<h1 id="教育的意义"><a class="header-anchor" href="#教育的意义">#</a> 教育的意义</h1>\n<p>这篇文字来源于我和我妻子的讨论。前些天媳妇想同我一起聊一聊孩子的教育问题。这里我想记录下来，以便以后再回顾这个问题时，可以回忆当时。</p>\n',headersStr:"问题 思考 解决",content:"# 教育的意义\n\n这篇文字来源于我和我妻子的讨论。前些天媳妇想同我一起聊一聊孩子的教育问题。这里我想记录下来，以便以后再回顾这个问题时，可以回忆当时。\n\n4月30号，这天时2022年五一长假的开端。我在上海闵行，寄居于同事家中。这一场席间整个世界的新冠疫情中，国内一直做的很好；但也有百密一疏的时候，我们已经居家隔离将近2个月了。 媳妇在教育宝宝的事情上，遇到了困扰；由于二宝在闹，我们微信聊天没有能继续多久。\n\n\n# 问题\n\n5月3日，媳妇把二宝哄睡着后，我们终于又延续上这个讨论。我们的困扰是大宝现在有很多不好的情况：\n\n> 1、挑食：不吃青菜；蔬菜只吃：土豆，\n> \n> 2、迷恋于看电视，对于其他的没有耐心。\n> \n> 3、会大吵大闹，没有办法好好沟通。\n\n这3点在孩子身上出现后，3个问题又相互纠缠，有越来越糟糕的倾向。\n\n同时我们的对大宝的教育也发生了一些问题：\n\n> 1、我作为孩子的父亲，长期在外，对孩子缺少陪伴。\n> \n> 2、爷爷奶奶都是严厉惯了的性格，爷爷很凶，孩子有些怕爷爷。\n> \n> 3、媳妇的性格善良而软弱，没能约束孩子，也没能在孩子的教育上同我爸妈做好沟通。\n\n这3个问题叠加在一起，导致了：作为家长我们没有能使用很好的方式引导孩子。\n\n\n# 思考\n\n在解决问题前，我们先需要搞清楚，我们教育的意义是什么。\n\n我们是从这样的一个思考开始的：我们为什么会有这样的问题嗯?\n\n思考1：\n\n> 问题：我们为什么会有这样的问题嗯?\n> \n> 答案：我们希望给孩更好的教育。\n\n思考2：\n\n> 问题：我们为什么要给更好孩子教育嗯？\n> \n> 答案：希望孩子长大后，能更好的生活。\n\n思考3：\n\n> 问题：那一个人怎么样，才能过好自己的生活嗯？\n> \n> 媳妇的回答：\n> \n> 1、具有良好的为人处世能力\n> \n> 2、具有良好的学习能力\n> \n> 3、具有良好的做事能力\n> \n> 我的回答：\n> \n> 机遇也许比能力更重要；这个世界上有能力的人很多。但不是每个有能力的人都可以有机会做一番事情。\n> \n> 要有能力，更要勇于承担；这样才能更好的生活。\n\n总结： 我们希望孩子具备两个基本人生认知：\n\n> 谦逊：只有付出，才有回报。\n> \n> 勇气：只要付出，就必然能获得回报。\n\n\n# 解决",normalizedContent:"# 教育的意义\n\n这篇文字来源于我和我妻子的讨论。前些天媳妇想同我一起聊一聊孩子的教育问题。这里我想记录下来，以便以后再回顾这个问题时，可以回忆当时。\n\n4月30号，这天时2022年五一长假的开端。我在上海闵行，寄居于同事家中。这一场席间整个世界的新冠疫情中，国内一直做的很好；但也有百密一疏的时候，我们已经居家隔离将近2个月了。 媳妇在教育宝宝的事情上，遇到了困扰；由于二宝在闹，我们微信聊天没有能继续多久。\n\n\n# 问题\n\n5月3日，媳妇把二宝哄睡着后，我们终于又延续上这个讨论。我们的困扰是大宝现在有很多不好的情况：\n\n> 1、挑食：不吃青菜；蔬菜只吃：土豆，\n> \n> 2、迷恋于看电视，对于其他的没有耐心。\n> \n> 3、会大吵大闹，没有办法好好沟通。\n\n这3点在孩子身上出现后，3个问题又相互纠缠，有越来越糟糕的倾向。\n\n同时我们的对大宝的教育也发生了一些问题：\n\n> 1、我作为孩子的父亲，长期在外，对孩子缺少陪伴。\n> \n> 2、爷爷奶奶都是严厉惯了的性格，爷爷很凶，孩子有些怕爷爷。\n> \n> 3、媳妇的性格善良而软弱，没能约束孩子，也没能在孩子的教育上同我爸妈做好沟通。\n\n这3个问题叠加在一起，导致了：作为家长我们没有能使用很好的方式引导孩子。\n\n\n# 思考\n\n在解决问题前，我们先需要搞清楚，我们教育的意义是什么。\n\n我们是从这样的一个思考开始的：我们为什么会有这样的问题嗯?\n\n思考1：\n\n> 问题：我们为什么会有这样的问题嗯?\n> \n> 答案：我们希望给孩更好的教育。\n\n思考2：\n\n> 问题：我们为什么要给更好孩子教育嗯？\n> \n> 答案：希望孩子长大后，能更好的生活。\n\n思考3：\n\n> 问题：那一个人怎么样，才能过好自己的生活嗯？\n> \n> 媳妇的回答：\n> \n> 1、具有良好的为人处世能力\n> \n> 2、具有良好的学习能力\n> \n> 3、具有良好的做事能力\n> \n> 我的回答：\n> \n> 机遇也许比能力更重要；这个世界上有能力的人很多。但不是每个有能力的人都可以有机会做一番事情。\n> \n> 要有能力，更要勇于承担；这样才能更好的生活。\n\n总结： 我们希望孩子具备两个基本人生认知：\n\n> 谦逊：只有付出，才有回报。\n> \n> 勇气：只要付出，就必然能获得回报。\n\n\n# 解决",charsets:{cjk:!0},lastUpdated:"2023/03/09, 13:48:21",lastUpdatedTimestamp:1678340901e3},{title:"HelloWord的执行过程",frontmatter:{title:"HelloWord的执行过程",date:"2022-06-10T23:14:46.000Z",permalink:"/pages/f96e78/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/11.HelloWord%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.html",relativePath:"_posts/随笔/11.HelloWord的执行过程.md",key:"v-2b03f108",path:"/pages/f96e78/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"DNS是怎么工作的",frontmatter:{title:"DNS是怎么工作的",date:"2022-06-10T23:33:47.000Z",permalink:"/pages/876d21/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/12.DNS%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84.html",relativePath:"_posts/随笔/12.DNS是怎么工作的.md",key:"v-37304324",path:"/pages/876d21/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"http和https有什么区别",frontmatter:{title:"http和https有什么区别",date:"2022-06-10T23:30:07.000Z",permalink:"/pages/6a8491/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/13.http%E5%92%8Chttps%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html",relativePath:"_posts/随笔/13.http和https有什么区别.md",key:"v-feca9b46",path:"/pages/6a8491/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"ipv4和ipv6有什么区别",frontmatter:{title:"ipv4和ipv6有什么区别",date:"2022-06-10T23:35:05.000Z",permalink:"/pages/0ad58c/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/14.ipv4%E5%92%8Cipv6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB.html",relativePath:"_posts/随笔/14.ipv4和ipv6有什么区别.md",key:"v-7dfce7ab",path:"/pages/0ad58c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"一个网页的执行过程",frontmatter:{title:"一个网页的执行过程",date:"2022-06-10T23:15:04.000Z",permalink:"/pages/fe33e1/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/20.%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.html",relativePath:"_posts/随笔/20.一个网页的执行过程.md",key:"v-59c4f32d",path:"/pages/fe33e1/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"如何稳定占用一半的CPU",frontmatter:{title:"如何稳定占用一半的CPU",date:"2022-06-10T23:22:08.000Z",permalink:"/pages/71575b/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/30.%E5%A6%82%E4%BD%95%E7%A8%B3%E5%AE%9A%E5%8D%A0%E7%94%A8%E4%B8%80%E5%8D%8A%E7%9A%84CPU.html",relativePath:"_posts/随笔/30.如何稳定占用一半的CPU.md",key:"v-1a24ff19",path:"/pages/71575b/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"如何稳定的占用一半的内存",frontmatter:{title:"如何稳定的占用一半的内存",date:"2022-06-10T23:22:30.000Z",permalink:"/pages/b9419f/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/40.%E5%A6%82%E4%BD%95%E7%A8%B3%E5%AE%9A%E7%9A%84%E5%8D%A0%E7%94%A8%E4%B8%80%E5%8D%8A%E7%9A%84%E5%86%85%E5%AD%98.html",relativePath:"_posts/随笔/40.如何稳定的占用一半的内存.md",key:"v-fa7509dc",path:"/pages/b9419f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"如何使用udp做一个安全的传输",frontmatter:{title:"如何使用udp做一个安全的传输",date:"2022-06-10T23:30:57.000Z",permalink:"/pages/2e9782/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/50.%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8udp%E5%81%9A%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%9A%84%E4%BC%A0%E8%BE%93.html",relativePath:"_posts/随笔/50.如何使用udp做一个安全的传输.md",key:"v-1aa23326",path:"/pages/2e9782/",headers:[{level:2,title:"应用层协议保障",slug:"应用层协议保障",normalizedTitle:"应用层协议保障",charIndex:2}],headersStr:"应用层协议保障",content:"# 应用层协议保障\n\nudt \\ ktp",normalizedContent:"# 应用层协议保障\n\nudt \\ ktp",charsets:{cjk:!0},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"TCP下载一个大文件的过程",frontmatter:{title:"TCP下载一个大文件的过程",date:"2022-06-10T23:31:28.000Z",permalink:"/pages/35cb80/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/70.TCP%E4%B8%8B%E8%BD%BD%E4%B8%80%E4%B8%AA%E5%A4%A7%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B.html",relativePath:"_posts/随笔/70.TCP下载一个大文件的过程.md",key:"v-7d93fff2",path:"/pages/35cb80/",headers:[{level:2,title:"3次握手",slug:"_3次握手",normalizedTitle:"3次握手",charIndex:2},{level:2,title:"慢启动/拥塞控制",slug:"慢启动-拥塞控制",normalizedTitle:"慢启动/拥塞控制",charIndex:11},{level:2,title:"4次分手",slug:"_4次分手",normalizedTitle:"4次分手",charIndex:24}],headersStr:"3次握手 慢启动/拥塞控制 4次分手",content:"# 3次握手\n\n\n# 慢启动/拥塞控制\n\n\n# 4次分手",normalizedContent:"# 3次握手\n\n\n# 慢启动/拥塞控制\n\n\n# 4次分手",charsets:{cjk:!0},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"Qt原子操作",frontmatter:{title:"Qt原子操作",date:"2023-03-15T17:53:39.000Z",permalink:"/pages/1eec76/",sidebar:"auto",categories:["随笔"],tags:["QAtomicInt"]},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/71.Qt%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.html",relativePath:"_posts/随笔/71.Qt原子操作.md",key:"v-0ccea3d1",path:"/pages/1eec76/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:219},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:1040},{level:2,title:"QAtomicInt函数说明",slug:"qatomicint函数说明",normalizedTitle:"qatomicint函数说明",charIndex:1862},{level:3,title:"T QAtomicInteger::load() const",slug:"t-qatomicinteger-load-const",normalizedTitle:"t qatomicinteger::load() const",charIndex:1881},{level:3,title:"T QAtomicInteger::loadAcquire() const",slug:"t-qatomicinteger-loadacquire-const",normalizedTitle:"t qatomicinteger::loadacquire() const",charIndex:2091},{level:3,title:"bool QAtomicInteger::ref()",slug:"bool-qatomicinteger-ref",normalizedTitle:"bool qatomicinteger::ref()",charIndex:2314},{level:3,title:"void QAtomicInteger::store(T newValue)",slug:"void-qatomicinteger-store-t-newvalue",normalizedTitle:"void qatomicinteger::store(t newvalue)",charIndex:2629},{level:3,title:"void QAtomicInteger::storeRelease(T newValue)",slug:"void-qatomicinteger-storerelease-t-newvalue",normalizedTitle:"void qatomicinteger::storerelease(t newvalue)",charIndex:2764},{level:3,title:"bool QAtomicInteger::testAndSetAcquire(T expectedValue, T newValue)",slug:"bool-qatomicinteger-testandsetacquire-t-expectedvalue-t-newvalue",normalizedTitle:"bool qatomicinteger::testandsetacquire(t expectedvalue, t newvalue)",charIndex:2912},{level:3,title:"bool QAtomicInteger::testAndSetOrdered(T expectedValue, T newValue)",slug:"bool-qatomicinteger-testandsetordered-t-expectedvalue-t-newvalue",normalizedTitle:"bool qatomicinteger::testandsetordered(t expectedvalue, t newvalue)",charIndex:3425},{level:3,title:"bool QAtomicInteger::testAndSetRelaxed(T expectedValue, T newValue)",slug:"bool-qatomicinteger-testandsetrelaxed-t-expectedvalue-t-newvalue",normalizedTitle:"bool qatomicinteger::testandsetrelaxed(t expectedvalue, t newvalue)",charIndex:3917},{level:3,title:"bool QAtomicInteger::testAndSetRelease(T expectedValue, T newValue)",slug:"bool-qatomicinteger-testandsetrelease-t-expectedvalue-t-newvalue",normalizedTitle:"bool qatomicinteger::testandsetrelease(t expectedvalue, t newvalue)",charIndex:4341}],headersStr:"背景 问题 解决方案 QAtomicInt函数说明 T QAtomicInteger::load() const T QAtomicInteger::loadAcquire() const bool QAtomicInteger::ref() void QAtomicInteger::store(T newValue) void QAtomicInteger::storeRelease(T newValue) bool QAtomicInteger::testAndSetAcquire(T expectedValue, T newValue) bool QAtomicInteger::testAndSetOrdered(T expectedValue, T newValue) bool QAtomicInteger::testAndSetRelaxed(T expectedValue, T newValue) bool QAtomicInteger::testAndSetRelease(T expectedValue, T newValue)",content:'# 背景\n\n很久很久很久以前，CPU忠厚老实，一条一条指令的执行我们给它的程序，规规矩矩的进行计算和内存的存取。\n\n很久很久以前， CPU学会了Out-Of-Order，CPU有了Cache，但一切都工作的很好，就像很久很久很久以前一样，而且工作效率得到了很大的提高。\n\n很久以前，我们需要多个CPU一起工作，于是出现了传说中的SMP系统，每个CPU都有独立的Cache，都会乱序执行，会打乱内存存取顺序，于是事情变得复杂了……\n\n\n# 问题\n\n由于每个CPU都有自己的Cache，内存读写不再一定需要真的作内存访问，而是直接从Cache里面操作，同时CPU可能会在合适的时候对于内存访问进行重新排序以提高效率，在只有一个CPU的时候，这很完美。\n\n而当有多个CPU的时候：从Cache到内存的flush操作通常是被延迟的，所以就需要某种方法保证CPU A进行的内存写操作真的可以被CPU B读取到。\n\nCPU可能会因为某些原因（比如某两个变量同在一个Cacheline中）而打乱\n\n 1. 实际内存写入顺序\n 2. 实际内存读取顺序\n\n所以就需要某种方法保证在需要的时候\n\n 1. 之前的读写操作已经完成\n 2. 未来的读写操作还没开始\n\n考虑一个例子： Thread A:\n\nwhile (flag == 0)\n        ; // do nothing\nprintf("%d\\n", data);\n\n\n1\n2\n3\n\n\nThread B:\n\ndata = 523;\nflag = 1;\n\n\n1\n2\n\n\n这里data代表了某种数据，它可以像这里一样是一个简单的整数，也可能是某种复杂的数据结构\n\n总之：我们在Thread B中对 data 进行了写入，并利用 flag 变量表示 data 已经准备好了。 在Thread A中，一个忙等待直到发现 data 已经准备好了，然后开始使用 data ，这里是简单的把 data 打印出来。 现在考虑如果CPU发现对于 data 和 flag 的写入，如果按照先写入 flag 后写入 data 的方式进行，或者考虑由于Cache的 flush 操作的延迟，使得内存中变量的实际修改顺序是先 flag 后 data ，那么都将导致Thread A的结果不正确。事实上，由于内存读入操作同样是可能乱序进行的，Thread A甚至可能在读入 flag 进行判断之前就已经完成了对 data 的读入操作，这同样导致错误的结果。\n\n\n# 解决方案\n\n在这个例子中，我们的需求是，Thread A中对于 flag 判断时，后面的任何读入操作都没有开始，Thread B中对于 flag 写入时，任何之前的写入操作都已经完成。\n\n在Linux内核中，smp_rmb()、smp_wmb()、smp_mb()就是用来解决这类问题\n\nmb表示memory barrier rmb表示读操作不可跨越（注意，不是人民币的意思:-P），也就是我们这个例子中的Thread A所需要的 wmb表示写操作不可跨越，也就是这里Thread B所需要的 mb集合了rmb和wmb的能力，读写操作都不可跨越\n\n在Qt中，其支持原子操作的类QAtomicInt支持四种类型的操作， Relaxed 、Acquired 、 Release 、 Ordered\n\n其中:\n\nRelaxed 最为简单，就是不做特殊要求，由编译器和处理器对读写进行合适的排序\n\nAcquired 表示原子操作之后的内存操作不可被重排至原子操作之前\n\nRelease 表示原子操作之前的内存操作不可被重排至原子操作之后\n\nOrdered 表示 Acquired + Release\n\n在前面的例子中：\n\nThread A对于 flag 的读取操作需要 Acquired Thread B对于 flag 的写入操作需要 Release\n\n在实际实现中，不同体系结构的实现方法各不相同，很多RISC机器提供了专门的指令用于实现mb，而在x86上面，通常使用lock指令前缀加上一个空操作来实现，注意当然不能真的是nop指令，但是可以用来实现空操作的指令其实是很多的，比如Linux中采用的addl $0, 0(%esp)。\n\nQt的不同类型原子操作由于本身就需要进行某种可被lock前缀修饰的操作，所以就不需要画蛇添足的再写一条空操作了，比如 testAndSetOrdered 就可以直接使用lock cmpxchgl 实现。\n\n\n# QAtomicInt函数说明\n\n\n# T QAtomicInteger::load() const\n\nAtomically loads the value of this QAtomicInteger using relaxed memory ordering. The value is not modified in any way, but note that there\'s no guarantee that it remains so.\n\n\n# T QAtomicInteger::loadAcquire() const\n\nAtomically loads the value of this QAtomicInteger using the "Acquire" memory ordering. The value is not modified in any way, but note that there\'s no guarantee that it remains so.\n\n\n# bool QAtomicInteger::ref()\n\nAtomically increments the value of this QAtomicInteger. Returns true if the new value is non-zero, false otherwise. This function uses ordered memory ordering semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.\n\n\n# void QAtomicInteger::store(T newValue)\n\nAtomically stores the newValue value into this atomic type, using relaxed memory ordering.\n\n\n# void QAtomicInteger::storeRelease(T newValue)\n\nAtomically stores the newValue value into this atomic type, using the "Release" memory ordering.\n\n\n# bool QAtomicInteger::testAndSetAcquire(T expectedValue, T newValue)\n\nAtomic test-and-set. If the current value of this QAtomicInteger is the expectedValue, the test-and-set functions assign the newValue to this QAtomicInteger and return true. If the values are not the same, this function does nothing and returns false. This function uses acquire memory ordering semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.\n\n\n# bool QAtomicInteger::testAndSetOrdered(T expectedValue, T newValue)\n\nAtomic test-and-set. If the current value of this QAtomicInteger is the expectedValue, the test-and-set functions assign the newValue to this QAtomicInteger and return true. If the values are not the same, this function does nothing and returns false. This function uses ordered memory ordering semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.\n\n\n# bool QAtomicInteger::testAndSetRelaxed(T expectedValue, T newValue)\n\nAtomic test-and-set. If the current value of this QAtomicInteger is the expectedValue, the test-and-set functions assign the newValue to this QAtomicInteger and return true. If the values are not the same, this function does nothing and returns false. This function uses relaxed memory ordering semantics, leaving the compiler and processor to freely\n\n\n# bool QAtomicInteger::testAndSetRelease(T expectedValue, T newValue)\n\nAtomic test-and-set. If the current value of this QAtomicInteger is the expectedValue, the test-and-set functions assign the newValue to this QAtomicInteger and return true. If the values are not the same, this function does nothing and returns false. This function uses release memory ordering semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.',normalizedContent:'# 背景\n\n很久很久很久以前，cpu忠厚老实，一条一条指令的执行我们给它的程序，规规矩矩的进行计算和内存的存取。\n\n很久很久以前， cpu学会了out-of-order，cpu有了cache，但一切都工作的很好，就像很久很久很久以前一样，而且工作效率得到了很大的提高。\n\n很久以前，我们需要多个cpu一起工作，于是出现了传说中的smp系统，每个cpu都有独立的cache，都会乱序执行，会打乱内存存取顺序，于是事情变得复杂了……\n\n\n# 问题\n\n由于每个cpu都有自己的cache，内存读写不再一定需要真的作内存访问，而是直接从cache里面操作，同时cpu可能会在合适的时候对于内存访问进行重新排序以提高效率，在只有一个cpu的时候，这很完美。\n\n而当有多个cpu的时候：从cache到内存的flush操作通常是被延迟的，所以就需要某种方法保证cpu a进行的内存写操作真的可以被cpu b读取到。\n\ncpu可能会因为某些原因（比如某两个变量同在一个cacheline中）而打乱\n\n 1. 实际内存写入顺序\n 2. 实际内存读取顺序\n\n所以就需要某种方法保证在需要的时候\n\n 1. 之前的读写操作已经完成\n 2. 未来的读写操作还没开始\n\n考虑一个例子： thread a:\n\nwhile (flag == 0)\n        ; // do nothing\nprintf("%d\\n", data);\n\n\n1\n2\n3\n\n\nthread b:\n\ndata = 523;\nflag = 1;\n\n\n1\n2\n\n\n这里data代表了某种数据，它可以像这里一样是一个简单的整数，也可能是某种复杂的数据结构\n\n总之：我们在thread b中对 data 进行了写入，并利用 flag 变量表示 data 已经准备好了。 在thread a中，一个忙等待直到发现 data 已经准备好了，然后开始使用 data ，这里是简单的把 data 打印出来。 现在考虑如果cpu发现对于 data 和 flag 的写入，如果按照先写入 flag 后写入 data 的方式进行，或者考虑由于cache的 flush 操作的延迟，使得内存中变量的实际修改顺序是先 flag 后 data ，那么都将导致thread a的结果不正确。事实上，由于内存读入操作同样是可能乱序进行的，thread a甚至可能在读入 flag 进行判断之前就已经完成了对 data 的读入操作，这同样导致错误的结果。\n\n\n# 解决方案\n\n在这个例子中，我们的需求是，thread a中对于 flag 判断时，后面的任何读入操作都没有开始，thread b中对于 flag 写入时，任何之前的写入操作都已经完成。\n\n在linux内核中，smp_rmb()、smp_wmb()、smp_mb()就是用来解决这类问题\n\nmb表示memory barrier rmb表示读操作不可跨越（注意，不是人民币的意思:-p），也就是我们这个例子中的thread a所需要的 wmb表示写操作不可跨越，也就是这里thread b所需要的 mb集合了rmb和wmb的能力，读写操作都不可跨越\n\n在qt中，其支持原子操作的类qatomicint支持四种类型的操作， relaxed 、acquired 、 release 、 ordered\n\n其中:\n\nrelaxed 最为简单，就是不做特殊要求，由编译器和处理器对读写进行合适的排序\n\nacquired 表示原子操作之后的内存操作不可被重排至原子操作之前\n\nrelease 表示原子操作之前的内存操作不可被重排至原子操作之后\n\nordered 表示 acquired + release\n\n在前面的例子中：\n\nthread a对于 flag 的读取操作需要 acquired thread b对于 flag 的写入操作需要 release\n\n在实际实现中，不同体系结构的实现方法各不相同，很多risc机器提供了专门的指令用于实现mb，而在x86上面，通常使用lock指令前缀加上一个空操作来实现，注意当然不能真的是nop指令，但是可以用来实现空操作的指令其实是很多的，比如linux中采用的addl $0, 0(%esp)。\n\nqt的不同类型原子操作由于本身就需要进行某种可被lock前缀修饰的操作，所以就不需要画蛇添足的再写一条空操作了，比如 testandsetordered 就可以直接使用lock cmpxchgl 实现。\n\n\n# qatomicint函数说明\n\n\n# t qatomicinteger::load() const\n\natomically loads the value of this qatomicinteger using relaxed memory ordering. the value is not modified in any way, but note that there\'s no guarantee that it remains so.\n\n\n# t qatomicinteger::loadacquire() const\n\natomically loads the value of this qatomicinteger using the "acquire" memory ordering. the value is not modified in any way, but note that there\'s no guarantee that it remains so.\n\n\n# bool qatomicinteger::ref()\n\natomically increments the value of this qatomicinteger. returns true if the new value is non-zero, false otherwise. this function uses ordered memory ordering semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.\n\n\n# void qatomicinteger::store(t newvalue)\n\natomically stores the newvalue value into this atomic type, using relaxed memory ordering.\n\n\n# void qatomicinteger::storerelease(t newvalue)\n\natomically stores the newvalue value into this atomic type, using the "release" memory ordering.\n\n\n# bool qatomicinteger::testandsetacquire(t expectedvalue, t newvalue)\n\natomic test-and-set. if the current value of this qatomicinteger is the expectedvalue, the test-and-set functions assign the newvalue to this qatomicinteger and return true. if the values are not the same, this function does nothing and returns false. this function uses acquire memory ordering semantics, which ensures that memory access following the atomic operation (in program order) may not be re-ordered before the atomic operation.\n\n\n# bool qatomicinteger::testandsetordered(t expectedvalue, t newvalue)\n\natomic test-and-set. if the current value of this qatomicinteger is the expectedvalue, the test-and-set functions assign the newvalue to this qatomicinteger and return true. if the values are not the same, this function does nothing and returns false. this function uses ordered memory ordering semantics, which ensures that memory access before and after the atomic operation (in program order) may not be re-ordered.\n\n\n# bool qatomicinteger::testandsetrelaxed(t expectedvalue, t newvalue)\n\natomic test-and-set. if the current value of this qatomicinteger is the expectedvalue, the test-and-set functions assign the newvalue to this qatomicinteger and return true. if the values are not the same, this function does nothing and returns false. this function uses relaxed memory ordering semantics, leaving the compiler and processor to freely\n\n\n# bool qatomicinteger::testandsetrelease(t expectedvalue, t newvalue)\n\natomic test-and-set. if the current value of this qatomicinteger is the expectedvalue, the test-and-set functions assign the newvalue to this qatomicinteger and return true. if the values are not the same, this function does nothing and returns false. this function uses release memory ordering semantics, which ensures that memory access before the atomic operation (in program order) may not be re-ordered after the atomic operation.',charsets:{cjk:!0},lastUpdated:"2023/03/15, 19:29:34",lastUpdatedTimestamp:1678879774e3},{title:"前向纠错",frontmatter:{title:"前向纠错",date:"2022-06-10T20:12:46.000Z",permalink:"/pages/7d6e5c/",categories:["随笔"],tags:[null],sidebar:"auto"},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/9.%E5%89%8D%E5%90%91%E7%BA%A0%E9%94%99.html",relativePath:"_posts/随笔/9.前向纠错.md",key:"v-21aac14b",path:"/pages/7d6e5c/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/16, 22:24:48",lastUpdatedTimestamp:1678976688e3},{title:"Home",frontmatter:{home:!0,heroText:"苏呆呆的博客",tagline:"一个向往美好生活的笨人。",pageClass:"vdoing-index-class"},regularPath:"/",relativePath:"index.md",key:"v-4640f53e",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/17, 23:46:47",lastUpdatedTimestamp:1679068007e3},{title:"spring_restful注解",frontmatter:{title:"spring_restful注解",date:"2022-05-04T19:29:07.000Z",permalink:"/pages/185350/",categories:["Spring相关"],tags:["RESTFUL"]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/10.spring_restful%E6%B3%A8%E8%A7%A3.html",relativePath:"后端框架--Spring/10.spring_restful注解.md",key:"v-0200859b",path:"/pages/185350/",headers:[{level:2,title:"2.1、name",slug:"_2-1、name",normalizedTitle:"2.1、name",charIndex:826},{level:2,title:"2.2、path和value",slug:"_2-2、path和value",normalizedTitle:"2.2、path和value",charIndex:848},{level:3,title:"2.2.1、@pathVariable",slug:"_2-2-1、-pathvariable",normalizedTitle:"2.2.1、@pathvariable",charIndex:1271},{level:2,title:"2.3、method",slug:"_2-3、method",normalizedTitle:"2.3、method",charIndex:1747},{level:2,title:"2.4、params和header",slug:"_2-4、params和header",normalizedTitle:"2.4、params和header",charIndex:2072},{level:2,title:"2.5、consumes和produces",slug:"_2-5、consumes和produces",normalizedTitle:"2.5、consumes和produces",charIndex:2630},{level:3,title:"示例1：url 传参",slug:"示例1-url-传参",normalizedTitle:"示例1：url 传参",charIndex:3882},{level:3,title:"示例2：body中form形式的传参",slug:"示例2-body中form形式的传参",normalizedTitle:"示例2：body中form形式的传参",charIndex:4086}],excerpt:'<h1 id="spring框架中restful接口相关注解"><a class="header-anchor" href="#spring框架中restful接口相关注解">#</a> spring框架中RESTFUL接口相关注解</h1>\n<h1 id="_1、说明"><a class="header-anchor" href="#_1、说明">#</a> 1、说明</h1>\n<p>springboot 是国内最常用的web框架，因为它的http server功能是最重要的。本文列举了一些现在通用的restful形式的接口所需要的注解</p>\n',headersStr:"2.1、name 2.2、path和value 2.2.1、@pathVariable 2.3、method 2.4、params和header 2.5、consumes和produces 示例1：url 传参 示例2：body中form形式的传参",content:'# spring框架中RESTFUL接口相关注解\n\n\n# 1、说明\n\nspringboot 是国内最常用的web框架，因为它的http server功能是最重要的。本文列举了一些现在通用的restful形式的接口所需要的注解\n\n\n# 2、@RequestMapping\n\n@RequestMapping 注解用于请求地址的解析，是最常用的一种注解\n\n源码如下：\n\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface RequestMapping {\n    String name() default "";\n\n    @AliasFor("path")\n    String[] value() default {};\n\n    @AliasFor("value")\n    String[] path() default {};\n\n    RequestMethod[] method() default {};\n\n    String[] params() default {};\n\n    String[] headers() default {};\n\n    String[] consumes() default {};\n\n    String[] produces() default {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * @Target 表示，此注解可以用在类和方法上；\n * @Retention(RetentionPolicy.RUNTIME) 表示，测注解保留到程序运行时，即程序运行时此注解有效；\n\n该注解的参数如下：\n\n\n# 2.1、name\n\n为映射设置名称\n\n\n# 2.2、path和value\n\n * path ，顾名思义，运行时，它能够得到地址；\n * 该属性是一个字符串数组，表示，可以同时映射多个地址；\n\n而之所以把path和value写在一起，是因为这两个属性的作用的相同的。可以看到，这两个属性都使用spring的注解 @AliasFor 互相修饰，表示这两个属性互为别名\n\n这里之所以使用 value 属性，是因为，java注解中，如果有多个属性，而使用时，又不指定参数名，则默认传递给 value 熟悉。所以，这里使用别名的作用是，使用时可以不使用属性名，直接使用值来表示地址\n\nspring框架中的注解都会有value属性\n\n@RequestMapping("/index")\npublic String index(){\n\treturn "hello";\n}\n\n\n1\n2\n3\n4\n\n\n如上例，表示，“/index” 以为没有指定属性名，属于传递给了value属性，也就是path属性\n\n\n# 2.2.1、@pathVariable\n\n使用path映射url的path，但是对于同一个类型的url，只是path不同，但是处理方式不一样，如果各自写一个方法的话，就显得很多余了，所以可以使用path变量\n\n * 变量使用中括号修饰，配合注解 @PathVariable 一起使用，可以得到传入的path；\n * 这里还可以使用正则表达式对变量允许的值进行过滤；\n\n示例：\n\n@RequestMapping(value="/index/{name}")\npublic String index(){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n上例中，可以映射path为 /index/xxxx 等的url\n\n@RequestMapping(value="/index/{name:[a-z]}")\npublic String index(){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n上例中，使用了正则表达式，[a-z] 表示a-z的一个字符，所以，只能映射/index/a等，二级目录只是一个字母的url\n\n\n# 2.3、method\n\n故名思议，表示，http请求使用的方法，它的类型是 RequestMethod 数组，RequestMethod 是一个枚举，源码如下：\n\npublic enum RequestMethod {\n    GET,\n    HEAD,\n    POST,\n    PUT,\n    PATCH,\n    DELETE,\n    OPTIONS,\n    TRACE;\n\n    private RequestMethod() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以看到，它是包含一系列HTTP方法的枚举类型\n\n而类型是数组表示，它可以指定该接口/类可以监听多种方法\n\n\n# 2.4、params和header\n\nparams 参数用于过滤请求，根据该参数值，只将符合条件的请求传递到该方法/类中\n\n如果有多个参数，则参数之间是 与 的关系\n\n示例：\n\n@RequestMapping(value="/index", params = "age=12")\npublic String index(){\n\treturn "bbb";\n}\n\n@RequestMapping(value="/index", params = {"age=13,name=ab"})\npublic String index2(){\n\treturn "ccc";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上例中，index() 映射请求中，参数age为12的请求\n\nindex2() 方法映射请求中，参数age为13且name为ab的请求\n\nheaders 参数的效果和 params 类似，区别是header 过滤的是HTTP协议中的header参数\n\n示例：\n\n@RequestMapping(value="/index", headers="content-type=text/html")\npublic String index2(){\n\treturn "aaa";\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2.5、consumes和produces\n\nconsumes 用于过滤请求内容类型（Content-Type 值）\n\nproduces 用于指定返回值类型\n\nContent-Type 在HTTP协议的消息头中用于表示资源的媒体类型，consumes 的作用就是根据参数过滤\n\n@RequestMapping(value = "/index", consumes = "application/json")\npublic String index3(){\n\treturn "aaa";\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3、@PathVariable\n\n@PathVariable 用于接口的参数获取\n\n在上文的2.2.1中，path变量配合此注解，可以得到传入的path\n\n@PathVariable 只有name和value两个参数，互为别名，使用时需要传入一个name\n\n示例：\n\n@RequestMapping(value="/index/{name}")\npublic String index(@PathVariable("name") String myName){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n@PathVariable 的参数 name 的要和 @RequestMapping 的 path 参数中的path变量一致\n\n上例中，myName 参数的值为url的二级path\n\n\n# 4、@RequestParam\n\n@RequestParam 用于 通过接受表单形式的参数，即传入的参数必须可以是拼接在URL后面的key-value，也可以是body里面的表单形式的key-value\n\n源码如下：\n\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RequestParam {\n    @AliasFor("name")\n    String value() default "";\n\n    @AliasFor("value")\n    String name() default "";\n\n    boolean required() default true;\n\n    String defaultValue() default "\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可见，@RequestParam 特性如下：\n\n * 需要传三个参数：name/value、required和defaultValue，name表示参数名，reuqired表示此参数是否必须传入，defaultValue表示默认值；\n * 若不指定默认值，则未传的参数会设为nul；\n\n\n# 示例1：url 传参\n\n@RequestMapping(value="/index")\npublic String index(@RequestParam("name") Integer name){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n需要注意的是，如果参数类型设置为基本的数据类型，而请求又没有传参的话，会报错，因为基本数据类型没有null类型，所以使用Java包装类即可\n\n\n# 示例2：body中form形式的传参\n\n需要注意的是，HTTP协议body中传参的形式有多种，这里需要分别处理\n\n默认接受以文本的形式传递的参数，也有的软件叫 raw\n\n若传参的形式不同，接口需要设置 HTTP 协议头的 Content-Type 的值来接受参数，即，spring 中使用 @RequestMapping 的 consumes 属性\n\n\n\n@RequestMapping(value="/index2", \n                consumes="application/x-www-form-urlencoded")\npublic String index2(\n    @RequestParam("name") String myName, \n    @RequestParam("age") Integer age){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里使用了 key-value 键值对的表单形式，@RequestParam 可以忽略，简化成如下代码，效果相同\n\n@RequestMapping(value="/index2", \n                consumes="application/x-www-form-urlencoded")\npublic String index2(String name, Integer age){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n5\n\n\n但是，如果参数过多，则函数的参数列表就会很长，所以这里可以封装成一个类\n\npublic class People {\n    private Integer id;\n    private String name;\n    private Integer age;\n    //忽略getter和setter\n}\n @RequestMapping(value="/index2", \n                 consumes="application/x-www-form-urlencoded")\n    public String index2(People people){\n        return "bbb";\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n并且，此时无需使用注解，spring 会自动拼装类\n\n\n# 5、@RequestBody\n\n@RequestBody 接受的body内的单一参数，即非表单形式的参数，因为，其也就不能接收GET方法的传参了\n\n其源码如下：\n\n@Target({ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RequestBody {\n    boolean required() default true;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n@RequestBody 有一个属性 required，默认true，表示单一参数是否必须传入\n\n示例1：\n\nraw 的方式\n\n\n\n@RequestMapping(value="/index")\npublic String index(@RequestBody String requestParam){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n上例中，可以接受到以raw方式传递的参数\n\n示例2：\n\nx-www-form-urlencoded 的方式\n\nx-www-form-urlencoded 是一种把表单数据编码成单一数据的格式，所以可以使用 @RequestBody 来获取\n\n@RequestMapping(value="/index2", consumes="application/x-www-form-urlencoded")\npublic String index2(@RequestBody String requestParam){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n示例3：\n\n@RequestBody 能够将单一形式的参数转换成Java类，这需要参数的key和java类的属性一对一相同，不同的属性则设置为null\n\n@RequestMapping(value="/index")\npublic String index(@RequestBody Product product){\n\treturn "aaa";\n}\n\n\n1\n2\n3\n4\n\n\n如上，执行后，controller 内的参数能够自动解析raw方式的传参\n\n\n# 6、@ResponseBody\n\n@ResponseBody 注解的作用是将 java 对象转换位 json 格式的数据\n\n声明如下：\n\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface ResponseBody {\n}\n\n\n1\n2\n3\n4\n5\n\n\n由此可知\n\n * 该注解可以用在类和方法上；\n * 程序运行时有效；\n * 无参数属性；\n\n@ResponseBody 注解可以将 controller 方法返回的 java 对象通过适当的转换器转换成指定的格式，并返回到 http response 的 body 区内，通常返回 json 和 xml\n\n使用该注解后，不会走视图处理器，而是直接将数据写入到流中，效果等同于使用 response 对象输出指定格式的数据\n\n本文内容来自：https://www.cnblogs.com/sherlock-lin/p/13021051.html',normalizedContent:'# spring框架中restful接口相关注解\n\n\n# 1、说明\n\nspringboot 是国内最常用的web框架，因为它的http server功能是最重要的。本文列举了一些现在通用的restful形式的接口所需要的注解\n\n\n# 2、@requestmapping\n\n@requestmapping 注解用于请求地址的解析，是最常用的一种注解\n\n源码如下：\n\n@target({elementtype.type, elementtype.method})\n@retention(retentionpolicy.runtime)\n@documented\n@mapping\npublic @interface requestmapping {\n    string name() default "";\n\n    @aliasfor("path")\n    string[] value() default {};\n\n    @aliasfor("value")\n    string[] path() default {};\n\n    requestmethod[] method() default {};\n\n    string[] params() default {};\n\n    string[] headers() default {};\n\n    string[] consumes() default {};\n\n    string[] produces() default {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n * @target 表示，此注解可以用在类和方法上；\n * @retention(retentionpolicy.runtime) 表示，测注解保留到程序运行时，即程序运行时此注解有效；\n\n该注解的参数如下：\n\n\n# 2.1、name\n\n为映射设置名称\n\n\n# 2.2、path和value\n\n * path ，顾名思义，运行时，它能够得到地址；\n * 该属性是一个字符串数组，表示，可以同时映射多个地址；\n\n而之所以把path和value写在一起，是因为这两个属性的作用的相同的。可以看到，这两个属性都使用spring的注解 @aliasfor 互相修饰，表示这两个属性互为别名\n\n这里之所以使用 value 属性，是因为，java注解中，如果有多个属性，而使用时，又不指定参数名，则默认传递给 value 熟悉。所以，这里使用别名的作用是，使用时可以不使用属性名，直接使用值来表示地址\n\nspring框架中的注解都会有value属性\n\n@requestmapping("/index")\npublic string index(){\n\treturn "hello";\n}\n\n\n1\n2\n3\n4\n\n\n如上例，表示，“/index” 以为没有指定属性名，属于传递给了value属性，也就是path属性\n\n\n# 2.2.1、@pathvariable\n\n使用path映射url的path，但是对于同一个类型的url，只是path不同，但是处理方式不一样，如果各自写一个方法的话，就显得很多余了，所以可以使用path变量\n\n * 变量使用中括号修饰，配合注解 @pathvariable 一起使用，可以得到传入的path；\n * 这里还可以使用正则表达式对变量允许的值进行过滤；\n\n示例：\n\n@requestmapping(value="/index/{name}")\npublic string index(){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n上例中，可以映射path为 /index/xxxx 等的url\n\n@requestmapping(value="/index/{name:[a-z]}")\npublic string index(){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n上例中，使用了正则表达式，[a-z] 表示a-z的一个字符，所以，只能映射/index/a等，二级目录只是一个字母的url\n\n\n# 2.3、method\n\n故名思议，表示，http请求使用的方法，它的类型是 requestmethod 数组，requestmethod 是一个枚举，源码如下：\n\npublic enum requestmethod {\n    get,\n    head,\n    post,\n    put,\n    patch,\n    delete,\n    options,\n    trace;\n\n    private requestmethod() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以看到，它是包含一系列http方法的枚举类型\n\n而类型是数组表示，它可以指定该接口/类可以监听多种方法\n\n\n# 2.4、params和header\n\nparams 参数用于过滤请求，根据该参数值，只将符合条件的请求传递到该方法/类中\n\n如果有多个参数，则参数之间是 与 的关系\n\n示例：\n\n@requestmapping(value="/index", params = "age=12")\npublic string index(){\n\treturn "bbb";\n}\n\n@requestmapping(value="/index", params = {"age=13,name=ab"})\npublic string index2(){\n\treturn "ccc";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上例中，index() 映射请求中，参数age为12的请求\n\nindex2() 方法映射请求中，参数age为13且name为ab的请求\n\nheaders 参数的效果和 params 类似，区别是header 过滤的是http协议中的header参数\n\n示例：\n\n@requestmapping(value="/index", headers="content-type=text/html")\npublic string index2(){\n\treturn "aaa";\n}\n\n\n1\n2\n3\n4\n\n\n\n# 2.5、consumes和produces\n\nconsumes 用于过滤请求内容类型（content-type 值）\n\nproduces 用于指定返回值类型\n\ncontent-type 在http协议的消息头中用于表示资源的媒体类型，consumes 的作用就是根据参数过滤\n\n@requestmapping(value = "/index", consumes = "application/json")\npublic string index3(){\n\treturn "aaa";\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3、@pathvariable\n\n@pathvariable 用于接口的参数获取\n\n在上文的2.2.1中，path变量配合此注解，可以得到传入的path\n\n@pathvariable 只有name和value两个参数，互为别名，使用时需要传入一个name\n\n示例：\n\n@requestmapping(value="/index/{name}")\npublic string index(@pathvariable("name") string myname){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n@pathvariable 的参数 name 的要和 @requestmapping 的 path 参数中的path变量一致\n\n上例中，myname 参数的值为url的二级path\n\n\n# 4、@requestparam\n\n@requestparam 用于 通过接受表单形式的参数，即传入的参数必须可以是拼接在url后面的key-value，也可以是body里面的表单形式的key-value\n\n源码如下：\n\n@target({elementtype.parameter})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface requestparam {\n    @aliasfor("name")\n    string value() default "";\n\n    @aliasfor("value")\n    string name() default "";\n\n    boolean required() default true;\n\n    string defaultvalue() default "\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n可见，@requestparam 特性如下：\n\n * 需要传三个参数：name/value、required和defaultvalue，name表示参数名，reuqired表示此参数是否必须传入，defaultvalue表示默认值；\n * 若不指定默认值，则未传的参数会设为nul；\n\n\n# 示例1：url 传参\n\n@requestmapping(value="/index")\npublic string index(@requestparam("name") integer name){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n需要注意的是，如果参数类型设置为基本的数据类型，而请求又没有传参的话，会报错，因为基本数据类型没有null类型，所以使用java包装类即可\n\n\n# 示例2：body中form形式的传参\n\n需要注意的是，http协议body中传参的形式有多种，这里需要分别处理\n\n默认接受以文本的形式传递的参数，也有的软件叫 raw\n\n若传参的形式不同，接口需要设置 http 协议头的 content-type 的值来接受参数，即，spring 中使用 @requestmapping 的 consumes 属性\n\n\n\n@requestmapping(value="/index2", \n                consumes="application/x-www-form-urlencoded")\npublic string index2(\n    @requestparam("name") string myname, \n    @requestparam("age") integer age){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n这里使用了 key-value 键值对的表单形式，@requestparam 可以忽略，简化成如下代码，效果相同\n\n@requestmapping(value="/index2", \n                consumes="application/x-www-form-urlencoded")\npublic string index2(string name, integer age){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n5\n\n\n但是，如果参数过多，则函数的参数列表就会很长，所以这里可以封装成一个类\n\npublic class people {\n    private integer id;\n    private string name;\n    private integer age;\n    //忽略getter和setter\n}\n @requestmapping(value="/index2", \n                 consumes="application/x-www-form-urlencoded")\n    public string index2(people people){\n        return "bbb";\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n并且，此时无需使用注解，spring 会自动拼装类\n\n\n# 5、@requestbody\n\n@requestbody 接受的body内的单一参数，即非表单形式的参数，因为，其也就不能接收get方法的传参了\n\n其源码如下：\n\n@target({elementtype.parameter})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface requestbody {\n    boolean required() default true;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n@requestbody 有一个属性 required，默认true，表示单一参数是否必须传入\n\n示例1：\n\nraw 的方式\n\n\n\n@requestmapping(value="/index")\npublic string index(@requestbody string requestparam){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n上例中，可以接受到以raw方式传递的参数\n\n示例2：\n\nx-www-form-urlencoded 的方式\n\nx-www-form-urlencoded 是一种把表单数据编码成单一数据的格式，所以可以使用 @requestbody 来获取\n\n@requestmapping(value="/index2", consumes="application/x-www-form-urlencoded")\npublic string index2(@requestbody string requestparam){\n\treturn "bbb";\n}\n\n\n1\n2\n3\n4\n\n\n示例3：\n\n@requestbody 能够将单一形式的参数转换成java类，这需要参数的key和java类的属性一对一相同，不同的属性则设置为null\n\n@requestmapping(value="/index")\npublic string index(@requestbody product product){\n\treturn "aaa";\n}\n\n\n1\n2\n3\n4\n\n\n如上，执行后，controller 内的参数能够自动解析raw方式的传参\n\n\n# 6、@responsebody\n\n@responsebody 注解的作用是将 java 对象转换位 json 格式的数据\n\n声明如下：\n\n@target({elementtype.type, elementtype.method})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface responsebody {\n}\n\n\n1\n2\n3\n4\n5\n\n\n由此可知\n\n * 该注解可以用在类和方法上；\n * 程序运行时有效；\n * 无参数属性；\n\n@responsebody 注解可以将 controller 方法返回的 java 对象通过适当的转换器转换成指定的格式，并返回到 http response 的 body 区内，通常返回 json 和 xml\n\n使用该注解后，不会走视图处理器，而是直接将数据写入到流中，效果等同于使用 response 对象输出指定格式的数据\n\n本文内容来自：https://www.cnblogs.com/sherlock-lin/p/13021051.html',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Spring定时任务",frontmatter:{title:"Spring定时任务",date:"2022-05-10T11:29:07.000Z",permalink:"/pages/a5092c/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/20.Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html",relativePath:"后端框架--Spring/20.Spring定时任务.md",key:"v-2d62fca3",path:"/pages/a5092c/",headers:[{level:2,title:"@EnableScheduling",slug:"enablescheduling",normalizedTitle:"@enablescheduling",charIndex:2},{level:2,title:"@Scheduled",slug:"scheduled",normalizedTitle:"@scheduled",charIndex:333},{level:2,title:"fixed定时语法",slug:"fixed定时语法",normalizedTitle:"fixed定时语法",charIndex:589},{level:2,title:"crond定时语法",slug:"crond定时语法",normalizedTitle:"crond定时语法",charIndex:1594},{level:3,title:"通配符说明",slug:"通配符说明",normalizedTitle:"通配符说明",charIndex:2041}],headersStr:"@EnableScheduling @Scheduled fixed定时语法 crond定时语法 通配符说明",content:'# @EnableScheduling\n\n在启动类上加@EnableScheduling注解；允许支持定时器。\n\n@SpringBootApplication\n@EnableScheduling //允许支持定时器了\npublic class SpringbootWebsocketSpringdataJpaApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootWebsocketSpringdataJpaApplication.class, args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# @Scheduled\n\n在函数上添加@Scheduled注解；以添加task任务。要注意的是，需要在被识别为组件的类中使用；如：@Component注解的类。\n\n@Component\npublic class TestScheduler {\n    @Scheduled(cron="0/30 * * * * ?")\n    private void task(){\n        System.err.println("这句话每30秒打印一次");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# fixed定时语法\n\n明确间隔时间\n\n参数                   作用\nfixedDelay           上一次执行完毕时间点之后多长时间再执行\nfixedDelayString     上一次执行完毕时间点之后多长时间再执行\nfixedRate            上一次开始执行时间点之后多长时间再执行\nfixedRateString      上一次开始执行时间点之后多长时间再执行\ninitialDelay         第一次延迟多长时间后再执行\ninitialDelayString   第一次延迟多长时间后再执行\n\n@Component\npublic class TestScheduler {\n\n    @Scheduled(fixedDelay=5000)\n    private void task1(){\n        System.err.println("执行完成后，5s再执行。");\n    }\n\n    @Scheduled(fixedDelayString=\'5000\')\n    private void task2(){\n        System.err.println("执行完成后，5s再执行。");\n    }\n\n    @Scheduled(fixedRate=5000)\n    private void task3(){\n        System.err.println("执行开始后，5s再执行。");\n    }\n\n    @Scheduled(fixedRateString=\'5000\')\n    private void task4(){\n        System.err.println("执行开始后，5s再执行。");\n    }\n\n    @Scheduled(initialDelay=10000, fixedRateString=\'5000\')\n    private void task5(){\n        System.err.println("第一次为延时10s后执行;以后为：执行开始后，5s再执行。");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# crond定时语法\n\ncron表达式语法：[秒] [分] [小时] [日] [月] [周] [年]\n\n> 注：[年]不是必须的域，可以省略[年]，则一共6个域\n\n序号   说明   是否必填   允许填的值              允许通配符\n1    秒    是      0~59               , - * /\n2    分    是      0~59               , - * /\n3    时    是      0~23               , - * /\n4    日    是      1~31               , - * ? / L W\n5    月    是      1-12或JAN-DEC       , - * /\n6    周    是      1-7或SUN-SAT        , - * ? / L W\n7    年    否      empty 或1970-2099   , - * /\n\n\n# 通配符说明\n\n 1. *表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。\n 2. ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?\n 3. -表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。\n 4. , 表示指定多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发\n 5. / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。\n 6. L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”SAT”。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示“本月最后一个星期五”\n 7. W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)。\n 8. #序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’L’和 ‘W’可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即MON与mon相同。\n\n示例：\n\n每隔5秒执行一次：*/5 * * * * ?\n\n每隔1分钟执行一次：0 */1 * * * ?\n\n每天23点执行一次：0 0 23 * * ?\n\n每天凌晨1点执行一次：0 0 1 * * ?\n\n每月1号凌晨1点执行一次：0 0 1 1 * ?\n\n每月最后一天23点执行一次：0 0 23 L * ?\n\n每周星期天凌晨1点实行一次：0 0 1 ? * L\n\n在26分、29分、33分执行一次：0 26,29,33 * * * ?\n\n每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?\n',normalizedContent:'# @enablescheduling\n\n在启动类上加@enablescheduling注解；允许支持定时器。\n\n@springbootapplication\n@enablescheduling //允许支持定时器了\npublic class springbootwebsocketspringdatajpaapplication {\n\n    public static void main(string[] args) {\n        springapplication.run(springbootwebsocketspringdatajpaapplication.class, args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# @scheduled\n\n在函数上添加@scheduled注解；以添加task任务。要注意的是，需要在被识别为组件的类中使用；如：@component注解的类。\n\n@component\npublic class testscheduler {\n    @scheduled(cron="0/30 * * * * ?")\n    private void task(){\n        system.err.println("这句话每30秒打印一次");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# fixed定时语法\n\n明确间隔时间\n\n参数                   作用\nfixeddelay           上一次执行完毕时间点之后多长时间再执行\nfixeddelaystring     上一次执行完毕时间点之后多长时间再执行\nfixedrate            上一次开始执行时间点之后多长时间再执行\nfixedratestring      上一次开始执行时间点之后多长时间再执行\ninitialdelay         第一次延迟多长时间后再执行\ninitialdelaystring   第一次延迟多长时间后再执行\n\n@component\npublic class testscheduler {\n\n    @scheduled(fixeddelay=5000)\n    private void task1(){\n        system.err.println("执行完成后，5s再执行。");\n    }\n\n    @scheduled(fixeddelaystring=\'5000\')\n    private void task2(){\n        system.err.println("执行完成后，5s再执行。");\n    }\n\n    @scheduled(fixedrate=5000)\n    private void task3(){\n        system.err.println("执行开始后，5s再执行。");\n    }\n\n    @scheduled(fixedratestring=\'5000\')\n    private void task4(){\n        system.err.println("执行开始后，5s再执行。");\n    }\n\n    @scheduled(initialdelay=10000, fixedratestring=\'5000\')\n    private void task5(){\n        system.err.println("第一次为延时10s后执行;以后为：执行开始后，5s再执行。");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# crond定时语法\n\ncron表达式语法：[秒] [分] [小时] [日] [月] [周] [年]\n\n> 注：[年]不是必须的域，可以省略[年]，则一共6个域\n\n序号   说明   是否必填   允许填的值              允许通配符\n1    秒    是      0~59               , - * /\n2    分    是      0~59               , - * /\n3    时    是      0~23               , - * /\n4    日    是      1~31               , - * ? / l w\n5    月    是      1-12或jan-dec       , - * /\n6    周    是      1-7或sun-sat        , - * ? / l w\n7    年    否      empty 或1970-2099   , - * /\n\n\n# 通配符说明\n\n 1. *表示所有值。 例如:在分的字段上设置 *,表示每一分钟都会触发。\n 2. ? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为”?” 具体设置为 0 0 0 10 * ?\n 3. -表示区间。例如 在小时上设置 “10-12”,表示 10,11,12点都会触发。\n 4. , 表示指定多个值，例如在周字段上设置 “mon,wed,fri” 表示周一，周三和周五触发\n 5. / 用于递增触发。如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50)。 在月字段上设置’1/3’所示每月1号开始，每隔三天触发一次。\n 6. l 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于”7”或”sat”。如果在”l”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6l”这样的格式,则表示“本月最后一个星期五”\n 7. w 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上置”15w”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1w”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”w”前只能设置具体的数字,不允许区间”-“)。\n 8. #序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六.注意如果指定”#5”,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) ；小提示：’l’和 ‘w’可以一组合使用。如果在日字段上设置”lw”,则表示在本月的最后一个工作日触发；周字段的设置，若使用英文字母是不区分大小写的，即mon与mon相同。\n\n示例：\n\n每隔5秒执行一次：*/5 * * * * ?\n\n每隔1分钟执行一次：0 */1 * * * ?\n\n每天23点执行一次：0 0 23 * * ?\n\n每天凌晨1点执行一次：0 0 1 * * ?\n\n每月1号凌晨1点执行一次：0 0 1 1 * ?\n\n每月最后一天23点执行一次：0 0 23 l * ?\n\n每周星期天凌晨1点实行一次：0 0 1 ? * l\n\n在26分、29分、33分执行一次：0 26,29,33 * * * ?\n\n每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?\n',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Spring动态定时任务",frontmatter:{title:"Spring动态定时任务",date:"2022-05-10T14:35:45.000Z",permalink:"/pages/ab0f00/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/30.Spring%E5%8A%A8%E6%80%81%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html",relativePath:"后端框架--Spring/30.Spring动态定时任务.md",key:"v-4b2407b4",path:"/pages/ab0f00/",headers:[{level:2,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:2},{level:2,title:"代码实现",slug:"代码实现",normalizedTitle:"代码实现",charIndex:158},{level:2,title:"API介绍",slug:"api介绍",normalizedTitle:"api介绍",charIndex:2279}],headersStr:"思路 代码实现 API介绍",content:'# 思路\n\n动态定时任务要求，可以动态的增加、删除、开始、结束定时任务；所以使用注解的方式是一定不行的。\n\n这里需要使用 ThreadPoolTaskScheduler 定时线程池； 任务以Runnable 的形式加载。\n\nRunnable可以多种形式加载，这里使用适用性最好的cron表达式作为定时规则。\n\n\n# 代码实现\n\n1、任务执行\n\n这里简化代码，体现主体思路：\n\npublic Response start(Long taskId) {\n    try {\n        Task task = schedulerTaskMapper.findById(taskId);\n        //获取并实例化Runnable任务类\n        TaskRunnable taskRunnable = taskRunnableMapper.findById(task.getRunnableId());\n        Class<?> clazz = Class.forName(taskRunnable.getClasspath());\n        Taskable runnable = (Taskable)clazz.newInstance();\n        //Cron表达式\n        CronTrigger cron = new CronTrigger(task.getExpr());\n        //执行，并put到runTasks\n        TaskSchedulerServiceImpl.runTasks.put(\n                taskId, Objects.requireNonNull(this.threadPoolTaskScheduler.schedule(runnable, cron)));\n        task.setStatus(new Long(1));\n        schedulerTaskMapper.update(task);\n        return Response.buildSuccess();\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {\n        e.printStackTrace();\n        return Response.buildFailure("400", "任务启动失败");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n2、停止任务\n\npublic Response stop(Long taskId) {\n    if (!TaskSchedulerServiceImpl.runTasks.containsKey(taskId)) {\n        return Response.buildSuccess();\n    }\n    TaskSchedulerServiceImpl.runTasks.get(taskId).cancel(true);\n    TaskSchedulerServiceImpl.runTasks.remove(taskId);\n    Task task = schedulerTaskMapper.findById(taskId);\n    task.setStatus(new Long(0));\n    schedulerTaskMapper.update(task);\n    return Response.buildSuccess();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3、保存任务\n\npublic Response save(TaskDTO taskDTO) {\n    Task task = new Task();\n    BeanUtils.copyProperties(taskDTO, task);\n    if ((null == task.getId()) || (null == schedulerTaskMapper.findById(task.getId()))) {\n        task.setId(null);\n        schedulerTaskMapper.add(task);\n    } else {\n        this.stop(task.getId());\n        schedulerTaskMapper.update(task);\n    }\n    return Response.buildSuccess();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n4、删除任务\n\npublic Response delete(Long taskId) {\n    this.stop(taskId);\n    schedulerTaskMapper.delete(taskId);\n    return Response.buildSuccess();\n}\n\n\n1\n2\n3\n4\n5\n\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：Spring相关/40Demo\n\n\n# API介绍\n\nThreadPoolTaskScheduler有多种方式执行Runnable：\n\n 1. schedule(Runnable task, Date stateTime)，在指定时间执行一次定时任务\n\n 2. schedule(Runnable task, Trigger trigger)，动态创建指定表达式cron的定时任务\n\n 3. scheduleAtFixedRate(Runnable task, Date startTime, long period)，从指定的时间开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行开始到下一次任务开始时间\n\n 4. scheduleAtFixedRate(Runnable task, long period)，从现在开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行开始到下一次任务开始时间\n\n 5. scheduleWithFixedDelay(Runnable task, Date startTime, long delay)，从指定的时间开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行完成到下一次任务开始时间\n\n 6. scheduleWithFixedDelay(Runnable task, Duration delay)，从现在开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行完成到下一次任务开始时间',normalizedContent:'# 思路\n\n动态定时任务要求，可以动态的增加、删除、开始、结束定时任务；所以使用注解的方式是一定不行的。\n\n这里需要使用 threadpooltaskscheduler 定时线程池； 任务以runnable 的形式加载。\n\nrunnable可以多种形式加载，这里使用适用性最好的cron表达式作为定时规则。\n\n\n# 代码实现\n\n1、任务执行\n\n这里简化代码，体现主体思路：\n\npublic response start(long taskid) {\n    try {\n        task task = schedulertaskmapper.findbyid(taskid);\n        //获取并实例化runnable任务类\n        taskrunnable taskrunnable = taskrunnablemapper.findbyid(task.getrunnableid());\n        class<?> clazz = class.forname(taskrunnable.getclasspath());\n        taskable runnable = (taskable)clazz.newinstance();\n        //cron表达式\n        crontrigger cron = new crontrigger(task.getexpr());\n        //执行，并put到runtasks\n        taskschedulerserviceimpl.runtasks.put(\n                taskid, objects.requirenonnull(this.threadpooltaskscheduler.schedule(runnable, cron)));\n        task.setstatus(new long(1));\n        schedulertaskmapper.update(task);\n        return response.buildsuccess();\n    } catch (classnotfoundexception | instantiationexception | illegalaccessexception e) {\n        e.printstacktrace();\n        return response.buildfailure("400", "任务启动失败");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n2、停止任务\n\npublic response stop(long taskid) {\n    if (!taskschedulerserviceimpl.runtasks.containskey(taskid)) {\n        return response.buildsuccess();\n    }\n    taskschedulerserviceimpl.runtasks.get(taskid).cancel(true);\n    taskschedulerserviceimpl.runtasks.remove(taskid);\n    task task = schedulertaskmapper.findbyid(taskid);\n    task.setstatus(new long(0));\n    schedulertaskmapper.update(task);\n    return response.buildsuccess();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n3、保存任务\n\npublic response save(taskdto taskdto) {\n    task task = new task();\n    beanutils.copyproperties(taskdto, task);\n    if ((null == task.getid()) || (null == schedulertaskmapper.findbyid(task.getid()))) {\n        task.setid(null);\n        schedulertaskmapper.add(task);\n    } else {\n        this.stop(task.getid());\n        schedulertaskmapper.update(task);\n    }\n    return response.buildsuccess();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n4、删除任务\n\npublic response delete(long taskid) {\n    this.stop(taskid);\n    schedulertaskmapper.delete(taskid);\n    return response.buildsuccess();\n}\n\n\n1\n2\n3\n4\n5\n\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：spring相关/40demo\n\n\n# api介绍\n\nthreadpooltaskscheduler有多种方式执行runnable：\n\n 1. schedule(runnable task, date statetime)，在指定时间执行一次定时任务\n\n 2. schedule(runnable task, trigger trigger)，动态创建指定表达式cron的定时任务\n\n 3. scheduleatfixedrate(runnable task, date starttime, long period)，从指定的时间开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行开始到下一次任务开始时间\n\n 4. scheduleatfixedrate(runnable task, long period)，从现在开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行开始到下一次任务开始时间\n\n 5. schedulewithfixeddelay(runnable task, date starttime, long delay)，从指定的时间开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行完成到下一次任务开始时间\n\n 6. schedulewithfixeddelay(runnable task, duration delay)，从现在开始以指定间隔时间（以毫秒为单位）执行一次任务，间隔时间为前一次执行完成到下一次任务开始时间',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Spring注册失败",frontmatter:{title:"Spring注册失败",date:"2022-05-13T14:27:55.000Z",permalink:"/pages/0c8435/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/40.Spring%E6%B3%A8%E5%86%8C%E5%A4%B1%E8%B4%A5.html",relativePath:"后端框架--Spring/40.Spring注册失败.md",key:"v-7881fa56",path:"/pages/0c8435/",headers:[{level:2,title:"问题描述",slug:"问题描述",normalizedTitle:"问题描述",charIndex:2},{level:2,title:"原因",slug:"原因",normalizedTitle:"原因",charIndex:1329},{level:2,title:"思路",slug:"思路",normalizedTitle:"思路",charIndex:1542},{level:2,title:"代码方案：",slug:"代码方案",normalizedTitle:"代码方案：",charIndex:2041}],headersStr:"问题描述 原因 思路 代码方案：",content:'# 问题描述\n\n当使用 @AutoWired 标记类的 成员变量a 做自动注入时，当我们使用new的方式创建类对象A时，就会发现A中的a 为空。 强行使用a，就会报错: java.lang.NullPointerException\n\n例：任务A对任务B的调用，代码如下\n\n@Component\npublic class TaskA {\n\n    @Autowired\n    TaskB taskB;\n\n    void run() {\n        System.out.println("TaskA is run");\n        taskB.run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n@Component\npublic class TaskB {\n\n    void run() {\n        System.out.println("TaskB is run");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用A的方式：\n\n@SpringBootApplication\npublic class Demo40 implements CommandLineRunner {\n    @Autowired\n    TaskA taskA;\n\n    @Override\n    public void run(String... args) throws Exception {\n        // 方式1：@Autowired注解的对象进行调用\n        System.out.println("test1:");\n        taskA.run();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(Demo40.class, args);\n\n        System.out.println("test2:");\n        // 方式2: new初始化的变量进行调用\n        try {\n            TaskA task = new TaskA();\n            task.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\ntest1:\nTaskA is run\nTaskB is run\ntest2:\nTaskA is run\njava.lang.NullPointerException\n\tat com.spring.demo40.TaskA.run(TaskA.java:14)\n\tat com.spring.demo40.Demo40.main(Demo40.java:27)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 原因\n\n依赖注入的主要目的是让容器去产生一个对象的实例，然后交给spring容器管理，在整个生命周期中使用他们，更加方便灵活。\n\n@Autowired是根据类型进行自动装配，并且是从容器中获取实例并进行注入，我们称之为依赖注入。\n\n而new()是直接创建一个新的对象。\n\n这个是他们最本质的区别，一个是从spring容器获取，一个是直接创建新对象。即Autowired是全局实例，而new创建的是仅可以在当前类使用。\n\n\n# 思路\n\n既然New不是使用spring容器获取，那就意味着：如果通过Spring容器获取，就可以随时随地创建程序需要的对象。\n\n这是我们需要引入：ApplicationContextAware\n\npublic interface ApplicationContextAware extends Aware {\n    void setApplicationContext(ApplicationContext var1) throws BeansException;\n}\n\n\n1\n2\n3\n\n\n程序启动后，Spring容器会检测容器中的所有Bean，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的 setApplicationContextAware() 方法，并将容器 ApplicationContext 本身作为参数传给该方法。\n\n如果这时将，ApplicationContext 存入变量中，后面就可以直接使用，ApplicationContext实例来进行从Spring容器取对象的操作。\n\n\n# 代码方案：\n\n\n/**\n * 动态加载Bean\n */\n@Component\npublic class SpringContextUtil implements ApplicationContextAware {\n    // Spring应用上下文\n    private static ApplicationContext applicationContext;\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        SpringContextUtil.applicationContext = applicationContext;\n    }\n\n    public static ApplicationContext getApplicationContext() {\n        return applicationContext;\n    }\n\n    public static Object getBean(String name) throws BeansException {\n        return applicationContext.getBean(name);\n    }\n\n    public static  <T> T getBean(Class<T> requiredType) {\n        return applicationContext.getBean(requiredType);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n使用方式：\n\nSystem.out.println("test3:");\n// 方式3: 通过SpringContext封装创建\ntry {\n    TaskA task = SpringContextUtil.getBean(TaskA.class);\n    task.run();\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\nSystem.out.println("test4:");\n// 方式4: 通过SpringContext封装创建\ntry {\n    TaskA task = (TaskA) SpringContextUtil.getBean("taskA");\n    task.run();\n} catch (Exception e) {\n    e.printStackTrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：Spring相关/40Demo',normalizedContent:'# 问题描述\n\n当使用 @autowired 标记类的 成员变量a 做自动注入时，当我们使用new的方式创建类对象a时，就会发现a中的a 为空。 强行使用a，就会报错: java.lang.nullpointerexception\n\n例：任务a对任务b的调用，代码如下\n\n@component\npublic class taska {\n\n    @autowired\n    taskb taskb;\n\n    void run() {\n        system.out.println("taska is run");\n        taskb.run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n@component\npublic class taskb {\n\n    void run() {\n        system.out.println("taskb is run");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n调用a的方式：\n\n@springbootapplication\npublic class demo40 implements commandlinerunner {\n    @autowired\n    taska taska;\n\n    @override\n    public void run(string... args) throws exception {\n        // 方式1：@autowired注解的对象进行调用\n        system.out.println("test1:");\n        taska.run();\n    }\n\n    public static void main(string[] args) {\n        springapplication.run(demo40.class, args);\n\n        system.out.println("test2:");\n        // 方式2: new初始化的变量进行调用\n        try {\n            taska task = new taska();\n            task.run();\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\ntest1:\ntaska is run\ntaskb is run\ntest2:\ntaska is run\njava.lang.nullpointerexception\n\tat com.spring.demo40.taska.run(taska.java:14)\n\tat com.spring.demo40.demo40.main(demo40.java:27)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 原因\n\n依赖注入的主要目的是让容器去产生一个对象的实例，然后交给spring容器管理，在整个生命周期中使用他们，更加方便灵活。\n\n@autowired是根据类型进行自动装配，并且是从容器中获取实例并进行注入，我们称之为依赖注入。\n\n而new()是直接创建一个新的对象。\n\n这个是他们最本质的区别，一个是从spring容器获取，一个是直接创建新对象。即autowired是全局实例，而new创建的是仅可以在当前类使用。\n\n\n# 思路\n\n既然new不是使用spring容器获取，那就意味着：如果通过spring容器获取，就可以随时随地创建程序需要的对象。\n\n这是我们需要引入：applicationcontextaware\n\npublic interface applicationcontextaware extends aware {\n    void setapplicationcontext(applicationcontext var1) throws beansexception;\n}\n\n\n1\n2\n3\n\n\n程序启动后，spring容器会检测容器中的所有bean，如果发现某个bean实现了applicationcontextaware接口，spring容器会在创建该bean之后，自动调用该bean的 setapplicationcontextaware() 方法，并将容器 applicationcontext 本身作为参数传给该方法。\n\n如果这时将，applicationcontext 存入变量中，后面就可以直接使用，applicationcontext实例来进行从spring容器取对象的操作。\n\n\n# 代码方案：\n\n\n/**\n * 动态加载bean\n */\n@component\npublic class springcontextutil implements applicationcontextaware {\n    // spring应用上下文\n    private static applicationcontext applicationcontext;\n\n    @override\n    public void setapplicationcontext(applicationcontext applicationcontext) throws beansexception {\n        springcontextutil.applicationcontext = applicationcontext;\n    }\n\n    public static applicationcontext getapplicationcontext() {\n        return applicationcontext;\n    }\n\n    public static object getbean(string name) throws beansexception {\n        return applicationcontext.getbean(name);\n    }\n\n    public static  <t> t getbean(class<t> requiredtype) {\n        return applicationcontext.getbean(requiredtype);\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n使用方式：\n\nsystem.out.println("test3:");\n// 方式3: 通过springcontext封装创建\ntry {\n    taska task = springcontextutil.getbean(taska.class);\n    task.run();\n} catch (exception e) {\n    e.printstacktrace();\n}\n\nsystem.out.println("test4:");\n// 方式4: 通过springcontext封装创建\ntry {\n    taska task = (taska) springcontextutil.getbean("taska");\n    task.run();\n} catch (exception e) {\n    e.printstacktrace();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：spring相关/40demo',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Spring初识",frontmatter:{title:"Spring初识",date:"2022-05-25T21:31:40.000Z",permalink:"/pages/d62e19/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/5.Spring%E5%9F%BA%E7%A1%80/10.Spring%E5%88%9D%E8%AF%86.html",relativePath:"后端框架--Spring/5.Spring基础/10.Spring初识.md",key:"v-ecf90178",path:"/pages/d62e19/",headers:[{level:2,title:"1、Spring是什么",slug:"_1、spring是什么",normalizedTitle:"1、spring是什么",charIndex:2},{level:2,title:"2、Spring发展历程",slug:"_2、spring发展历程",normalizedTitle:"2、spring发展历程",charIndex:248},{level:2,title:"3、Spring的优势",slug:"_3、spring的优势",normalizedTitle:"3、spring的优势",charIndex:338},{level:2,title:"4、Spring的体系结构",slug:"_4、spring的体系结构",normalizedTitle:"4、spring的体系结构",charIndex:395}],headersStr:"1、Spring是什么 2、Spring发展历程 3、Spring的优势 4、Spring的体系结构",content:"# 1、Spring是什么\n\nSpring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核。\n\n提供了展现层 SpringMVC和持久层 Spring JDBCTemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架\n\n\n# 2、Spring发展历程\n\nRod Johnson （ Spring 之父）\n\n2017 年 9 月份发布了 Spring 的最新版本 Spring5.0 通用版（GA）\n\n\n# 3、Spring的优势\n\n方便解耦，简化开发\n\nAOP 编程的支持\n\n声明式事务的支持\n\n方便程序的测试\n\n\n# 4、Spring的体系结构\n\n",normalizedContent:"# 1、spring是什么\n\nspring是分层的 java se/ee应用 full-stack 轻量级开源框架，以 ioc（inverse of control：反转控制）和 aop（aspect oriented programming：面向切面编程）为内核。\n\n提供了展现层 springmvc和持久层 spring jdbctemplate以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的java ee 企业应用开源框架\n\n\n# 2、spring发展历程\n\nrod johnson （ spring 之父）\n\n2017 年 9 月份发布了 spring 的最新版本 spring5.0 通用版（ga）\n\n\n# 3、spring的优势\n\n方便解耦，简化开发\n\naop 编程的支持\n\n声明式事务的支持\n\n方便程序的测试\n\n\n# 4、spring的体系结构\n\n",charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Spring_Xml配置",frontmatter:{title:"Spring_Xml配置",date:"2022-05-25T21:36:16.000Z",permalink:"/pages/2c89d0/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/5.Spring%E5%9F%BA%E7%A1%80/20.Spring_Xml%E9%85%8D%E7%BD%AE.html",relativePath:"后端框架--Spring/5.Spring基础/20.Spring_Xml配置.md",key:"v-a48cd908",path:"/pages/2c89d0/",headers:[{level:2,title:"1、导入Spring包坐标",slug:"_1、导入spring包坐标",normalizedTitle:"1、导入spring包坐标",charIndex:2},{level:2,title:"2、创建Spring配置文件",slug:"_2、创建spring配置文件",normalizedTitle:"2、创建spring配置文件",charIndex:435},{level:2,title:"3、一个简单的类和对应配置",slug:"_3、一个简单的类和对应配置",normalizedTitle:"3、一个简单的类和对应配置",charIndex:934},{level:2,title:"4、依赖注入，Bean实例化",slug:"_4、依赖注入-bean实例化",normalizedTitle:"4、依赖注入，bean实例化",charIndex:1487},{level:3,title:"4.1 ClassPathXmlApplicationContext",slug:"_4-1-classpathxmlapplicationcontext",normalizedTitle:"4.1 classpathxmlapplicationcontext",charIndex:1506},{level:3,title:"4.2 FileSystemXmlApplicationContext",slug:"_4-2-filesystemxmlapplicationcontext",normalizedTitle:"4.2 filesystemxmlapplicationcontext",charIndex:2614},{level:2,title:"5、Git",slug:"_5、git",normalizedTitle:"5、git",charIndex:3703}],headersStr:"1、导入Spring包坐标 2、创建Spring配置文件 3、一个简单的类和对应配置 4、依赖注入，Bean实例化 4.1 ClassPathXmlApplicationContext 4.2 FileSystemXmlApplicationContext 5、Git",content:'# 1、导入Spring包坐标\n\n    <properties>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.8.RELEASE</version>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2、创建Spring配置文件\n\n路径:src/main/resources/applicationContext.xml\n\nDemo\n |__src\n\t|__main\n\t|\t|_java\n\t|\t|_resources\n\t|\t\t|__applicationContext.xml\n\t|__test\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n内容：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、一个简单的类和对应配置\n\n类：\n\npackage com.study;\n\npublic class Student {\n    public void study() {\n        System.out.println("always study...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在Spring配置文件中配置：\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="student" class="com.study.Student"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4、依赖注入，Bean实例化\n\n\n# 4.1 ClassPathXmlApplicationContext\n\n路径参数：\n\n对于 ClassPathXmlApplicationContext 的使用：\n\n 1. 默认使用：项目的 classpath 路径； classpath: 前缀是可加可不加的 。\n 2. 如果要使用绝对路径 , 需要加上 file: , 前缀表示这是绝对路径。\n 3. 如果是两个以上 , 可以使用字符串数组 ；或者使用通配符（正则表达）\n\n代码：\n\npackage com.study;\n\nimport javafx.application.Application;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class Main1 {\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n        //ApplicationContext applicationContext = new ClassPathXmlApplicationContext("file:E:/applicationContext.xml");\n        //ApplicationContext applicationContext = new ClassPathXmlApplicationContext(new String[]{"applicationContext.xml","SpringTest.xml"});\n        //ApplicationContext applicationContext = new ClassPathXmlApplicationContext("classpath:/*.xml");\n        Student student = (Student) applicationContext.getBean("student");\n        student.study();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.2 FileSystemXmlApplicationContext\n\n路径参数：\n\n 1. 默认使用：项目的根路径，没有盘符的是项目工作路径\n 2. 有盘符表示的是文件绝对路径 ，file: 可加可不加。\n 3. 如果要使用 classpath 路径 , 需要前缀 classpath:。\n 4. 如果是两个以上 , 可以使用字符串数组 ；或者使用通配符（正则表达）\n\n代码：\n\npackage com.study;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.FileSystemXmlApplicationContext;\n\npublic class Main2 {\n    public static void main(String[] args) {\n\n        ApplicationContext applicationContext = new FileSystemXmlApplicationContext("src/main/resources/applicationContext.xml");\n        //ApplicationContext applicationContext = new FileSystemXmlApplicationContext("classpath:applicationContext.xml");\n        //ApplicationContext applicationContext = new FileSystemXmlApplicationContext(new String[]{"classpath:applicationContext.xml","classpath:SpringTest.xml"});\n        //ApplicationContext applicationContext = new FileSystemXmlApplicationContext("classpath:/*.xml");\n        Student student = (Student) applicationContext.getBean("student");\n        student.study();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 5、Git\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：Spring相关/2Demo\n\nDemo路径：https://github.com/su-dd/KnowledgeStack.git\n\n具体路径：JavaWeb/TestCode/_03_Spring/Demo1',normalizedContent:'# 1、导入spring包坐标\n\n    <properties>\n        <maven.compiler.source>1.8</maven.compiler.source>\n        <maven.compiler.target>1.8</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context</artifactid>\n            <version>5.2.8.release</version>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2、创建spring配置文件\n\n路径:src/main/resources/applicationcontext.xml\n\ndemo\n |__src\n\t|__main\n\t|\t|_java\n\t|\t|_resources\n\t|\t\t|__applicationcontext.xml\n\t|__test\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n内容：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3、一个简单的类和对应配置\n\n类：\n\npackage com.study;\n\npublic class student {\n    public void study() {\n        system.out.println("always study...");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在spring配置文件中配置：\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    <bean id="student" class="com.study.student"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4、依赖注入，bean实例化\n\n\n# 4.1 classpathxmlapplicationcontext\n\n路径参数：\n\n对于 classpathxmlapplicationcontext 的使用：\n\n 1. 默认使用：项目的 classpath 路径； classpath: 前缀是可加可不加的 。\n 2. 如果要使用绝对路径 , 需要加上 file: , 前缀表示这是绝对路径。\n 3. 如果是两个以上 , 可以使用字符串数组 ；或者使用通配符（正则表达）\n\n代码：\n\npackage com.study;\n\nimport javafx.application.application;\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.classpathxmlapplicationcontext;\n\npublic class main1 {\n    public static void main(string[] args) {\n        applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n        //applicationcontext applicationcontext = new classpathxmlapplicationcontext("file:e:/applicationcontext.xml");\n        //applicationcontext applicationcontext = new classpathxmlapplicationcontext(new string[]{"applicationcontext.xml","springtest.xml"});\n        //applicationcontext applicationcontext = new classpathxmlapplicationcontext("classpath:/*.xml");\n        student student = (student) applicationcontext.getbean("student");\n        student.study();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.2 filesystemxmlapplicationcontext\n\n路径参数：\n\n 1. 默认使用：项目的根路径，没有盘符的是项目工作路径\n 2. 有盘符表示的是文件绝对路径 ，file: 可加可不加。\n 3. 如果要使用 classpath 路径 , 需要前缀 classpath:。\n 4. 如果是两个以上 , 可以使用字符串数组 ；或者使用通配符（正则表达）\n\n代码：\n\npackage com.study;\n\nimport org.springframework.context.applicationcontext;\nimport org.springframework.context.support.filesystemxmlapplicationcontext;\n\npublic class main2 {\n    public static void main(string[] args) {\n\n        applicationcontext applicationcontext = new filesystemxmlapplicationcontext("src/main/resources/applicationcontext.xml");\n        //applicationcontext applicationcontext = new filesystemxmlapplicationcontext("classpath:applicationcontext.xml");\n        //applicationcontext applicationcontext = new filesystemxmlapplicationcontext(new string[]{"classpath:applicationcontext.xml","classpath:springtest.xml"});\n        //applicationcontext applicationcontext = new filesystemxmlapplicationcontext("classpath:/*.xml");\n        student student = (student) applicationcontext.getbean("student");\n        student.study();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 5、git\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：spring相关/2demo\n\ndemo路径：https://github.com/su-dd/knowledgestack.git\n\n具体路径：javaweb/testcode/_03_spring/demo1',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Spring_IOC的XML实现",frontmatter:{title:"Spring_IOC的XML实现",date:"2022-05-14T11:54:22.000Z",permalink:"/pages/c35ea5/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/5.Spring%E5%9F%BA%E7%A1%80/30.Spring_IOC%E7%9A%84XML%E5%AE%9E%E7%8E%B0.html",relativePath:"后端框架--Spring/5.Spring基础/30.Spring_IOC的XML实现.md",key:"v-57d84b4a",path:"/pages/c35ea5/",headers:[{level:2,title:"1 Spring初识Bean",slug:"_1-spring初识bean",normalizedTitle:"1 spring初识bean",charIndex:2},{level:3,title:"1.1 JavaBean的定义",slug:"_1-1-javabean的定义",normalizedTitle:"1.1 javabean的定义",charIndex:21},{level:3,title:"1.2 SpringBean",slug:"_1-2-springbean",normalizedTitle:"1.2 springbean",charIndex:427},{level:2,title:"2 SpringBean实例化",slug:"_2-springbean实例化",normalizedTitle:"2 springbean实例化",charIndex:608},{level:3,title:"2.1 SpringBean的范围",slug:"_2-1-springbean的范围",normalizedTitle:"2.1 springbean的范围",charIndex:628},{level:3,title:"2.2 SpringBean的生命周期",slug:"_2-2-springbean的生命周期",normalizedTitle:"2.2 springbean的生命周期",charIndex:1004},{level:3,title:"2.3 SpringBean的创建方式",slug:"_2-3-springbean的创建方式",normalizedTitle:"2.3 springbean的创建方式",charIndex:1423},{level:2,title:"3 SpringBean依赖注入",slug:"_3-springbean依赖注入",normalizedTitle:"3 springbean依赖注入",charIndex:2448},{level:3,title:"3.1 构造函数注入",slug:"_3-1-构造函数注入",normalizedTitle:"3.1 构造函数注入",charIndex:2469},{level:3,title:"3.2 set方法注入",slug:"_3-2-set方法注入",normalizedTitle:"3.2 set方法注入",charIndex:2990},{level:3,title:"3.3 P命名空间注入",slug:"_3-3-p命名空间注入",normalizedTitle:"3.3 p命名空间注入",charIndex:3419},{level:3,title:"3.4 不同类型注入",slug:"_3-4-不同类型注入",normalizedTitle:"3.4 不同类型注入",charIndex:4052},{level:2,title:"4引入其他配置文件",slug:"_4引入其他配置文件",normalizedTitle:"4引入其他配置文件",charIndex:5164},{level:2,title:"5 Demo",slug:"_5-demo",normalizedTitle:"5 demo",charIndex:5248}],headersStr:"1 Spring初识Bean 1.1 JavaBean的定义 1.2 SpringBean 2 SpringBean实例化 2.1 SpringBean的范围 2.2 SpringBean的生命周期 2.3 SpringBean的创建方式 3 SpringBean依赖注入 3.1 构造函数注入 3.2 set方法注入 3.3 P命名空间注入 3.4 不同类型注入 4引入其他配置文件 5 Demo",content:'# 1 Spring初识Bean\n\n\n# 1.1 JavaBean的定义\n\n百度百科：JavaBean 是一种JAVA语言写成的可重用组件。为写成JavaBean，类必须是具体的和公共的，并且具有无参数的构造器。JavaBean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他Java 类可以通过自省机制(反射机制)发现和操作这些JavaBean 的属性。\n\nRUMNOOB.com:JavaBean 是特殊的 Java 类，使用 Java 语言书写，并且遵守 JavaBean API 规范。\n\n接下来给出的是 JavaBean 与其它 Java 类相比而言独一无二的特征：\n\n * 提供一个默认的无参构造函数。\n * 需要被序列化并且实现了 Serializable 接口。\n * 可能有一系列可读写属性。\n * 可能有一系列的 getter 或 setter 方法。\n\n\n# 1.2 SpringBean\n\nSpringBean是受Spring管理的对象，所有能受Spring容器管理的对象都可以成为SpringBean。\n\n基本配置：\n\n<bean id="student" class="com.study.Student"/>\n\n\n1\n\n\nid：Bean实例在Spring容器中唯一标识\n\nclass：Bean的全限定名称\n\n\n# 2 SpringBean实例化\n\n\n# 2.1 SpringBean的范围\n\n**Xml属性：**scope\n\nBean有两种方式：\n\n 1. singleton\n    \n    * 实例个数：1个\n    * 创建时机：当Spring核心文件被加载时，创建\n\n 2. prototype\n    \n    * 实例个数：多个\n    \n    * 创建时机：当调用getBean()方法时实例化Bean\n\nxml配置Demo：\n\n<bean id="school" class="com.study.instantiation.School" scope="singleton"></bean>\n<bean id="student" class="com.study.instantiation.Student" scope="prototype"></bean>\n\n\n1\n2\n\n\n\n# 2.2 SpringBean的生命周期\n\nsingleton：\n\n * 对象创建：当应用加载，创建容器时，对象就被创建了\n\n * 对象运行：只要容器在，对象一直活着\n\n * 对象销毁：当应用卸载，销毁容器时，对象就被销毁了\n\nprototype：\n\n * 对象创建：当使用对象时，创建新的对象实例\n * 对象运行：只要对象在使用中，就一直活着\n * 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了\n\ninit-method：指定类中的初始化方法名称\n\ndestroy-method：指定类中销毁方法名称\n\nxml配置Demo：\n\n<bean id="school" class="com.study.instantiation.School" scope="singleton" init-method="initValue" destroy-method="destroyValue"></bean>\n\n\n1\n\n\n\n# 2.3 SpringBean的创建方式\n\n 1. 使用构造函数，如果没有对应的构造函数将创建失败。\n    \n    如无参构造Demo：\n    \n    <bean id="school" class="com.study.instantiation.School"></bean>\n    \n    \n    1\n    \n\n 2. 使用工厂实例化\n    \n    * 静态工厂方法\n      \n      public class StaticFactoryBean {\n          public static UserDao createSchool(){    \n          return new School();\n          }\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      \n      \n      <bean id="staticFactorySchool" class="com.study.instantiation.StaticFactoryBean" factory-method="createSchool"/>\n      \n      \n      1\n      \n    \n    * 工厂实例的方法\n      \n      public class DynamicFactoryBean {\n          public School createSchool() {\n              return new School();\n          }\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      \n      \n      <bean id="dynamicFactoryBean" class="com.study.instantiation.DynamicFactoryBean"/>\n      <bean id="dynamicFactorySchool" factory-bean="dynamicFactoryBean" factory-method="createSchool"/>\n      \n      \n      1\n      2\n      \n\n\n# 3 SpringBean依赖注入\n\n\n# 3.1 构造函数注入\n\n标签：constructor-arg\n\n常用属性：\n\n- name：参数名\n- value：值，用于简单类型\n- ref：引用，用于引用类型，引用标记为bean的id\n\n\n注意点：\n\n通过构造函数创建Bean实例，所以需要对应的构造函数。\n\nXmlDemo:\n\n<bean id="information112" class="com.study.injection.Information">\n    <constructor-arg name="phoneNum" value="112"/>\n</bean>\n\n<bean id="studentXiaoMing" class="com.study.injection.Student">\n    <constructor-arg name="name" value="小明"/>\n    <constructor-arg name="age" value="16"/>\n    <constructor-arg name="information" ref="information112"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.2 set方法注入\n\n标签：property\n\n常用属性：\n\n * name：参数名\n * value：值，用于简单类型\n * ref：引用，用于引用类型，引用标记为bean的id\n\n注意点：\n\n通过无参构造创建Bean实例，所以需要无参构造。通过set函数注入，所以需要set函数（PS时机操作，不写set也行；搜索结果为通过反射直接赋值了）。\n\nXmlDemo:\n\n\x3c!--  需要无参构造  --\x3e\n<bean id="studentXiaoHong" class="com.study.injection.Student">\n    <property name="name" value="小红"/>\n    <property name="age" value="16"/>\n    <property name="information" ref="information110"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.3 P命名空间注入\n\nbeans标签增加属性引用P命名空间 xmlns:p="http://www.springframework.org/schema/p"\n\n实际效果：\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n</beans>\n\n\n1\n2\n3\n4\n5\n\n\nP命名空间的本质也是Set方法注入，所以注意点也同Set方法注入。\n\nXmlDemo：\n\n<bean id="studentXiaoFang" class="com.study.injection.Student" p:name="小芳" p:age="15" p:information-ref="information110"/>\n\n\n1\n\n\n于P命名空间相对的有一个C命名空间，本质上就是构造方法注入；\n\n\n# 3.4 不同类型注入\n\n注入的类基本可以分为3种：基本类型，引用类类，集合类型。\n\n上述注入方式中已经演示了：基本类型和引用类型，分别使用value和ref属性；这里主要演示集合类型。\n\nList集合：\n\n标签：list\n\nXmlDemo:\n\n<property name="studentNames">\n    <list>\n        <value>小红</value>\n        <value>小明</value>\n        <value>小芳</value>\n        <value>小王</value>\n    </list>\n</property>\n<property name="mathClass">\n    <list>\n        <bean id="studentXiaoWang" class="com.study.injection.Student" p:name="小王" p:age="17" p:information-ref="information112"/>\n        <ref bean="studentXiaoMing"/>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nMap集合：\n\n标签：map\n\nXmlDemo：\n\n<property name="studentMap">\n    <map>\n        <entry key="小明" value-ref="studentXiaoMing"/>\n        <entry key="小红" value-ref="studentXiaoHong"/>\n        <entry key="小芳" value-ref="studentXiaoFang"/>\n        <entry key="小王" value-ref="studentXiaoWang"/>\n    </map>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nProperties：\n\n标签：props\n\nXmlDemo：\n\n<property name="classTeacher">\n\t<props>\n    \t<prop key="math">大王</prop>\n        <prop key="chinese">大明</prop>\n        <prop key="english">大芳</prop>\n    </props>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4引入其他配置文件\n\n使用import导入\n\n<import resource="appliactionContext-Student.xml"/>\n\n\n1\n\n\n\n# 5 Demo\n\nDemo路径：https://github.com/su-dd/KnowledgeStack.git\n\n具体路径：JavaWeb/TestCode/_03_Spring/Demo2',normalizedContent:'# 1 spring初识bean\n\n\n# 1.1 javabean的定义\n\n百度百科：javabean 是一种java语言写成的可重用组件。为写成javabean，类必须是具体的和公共的，并且具有无参数的构造器。javabean 通过提供符合一致性设计模式的公共方法将内部域暴露成员属性，set和get方法获取。众所周知，属性名称符合这种模式，其他java 类可以通过自省机制(反射机制)发现和操作这些javabean 的属性。\n\nrumnoob.com:javabean 是特殊的 java 类，使用 java 语言书写，并且遵守 javabean api 规范。\n\n接下来给出的是 javabean 与其它 java 类相比而言独一无二的特征：\n\n * 提供一个默认的无参构造函数。\n * 需要被序列化并且实现了 serializable 接口。\n * 可能有一系列可读写属性。\n * 可能有一系列的 getter 或 setter 方法。\n\n\n# 1.2 springbean\n\nspringbean是受spring管理的对象，所有能受spring容器管理的对象都可以成为springbean。\n\n基本配置：\n\n<bean id="student" class="com.study.student"/>\n\n\n1\n\n\nid：bean实例在spring容器中唯一标识\n\nclass：bean的全限定名称\n\n\n# 2 springbean实例化\n\n\n# 2.1 springbean的范围\n\n**xml属性：**scope\n\nbean有两种方式：\n\n 1. singleton\n    \n    * 实例个数：1个\n    * 创建时机：当spring核心文件被加载时，创建\n\n 2. prototype\n    \n    * 实例个数：多个\n    \n    * 创建时机：当调用getbean()方法时实例化bean\n\nxml配置demo：\n\n<bean id="school" class="com.study.instantiation.school" scope="singleton"></bean>\n<bean id="student" class="com.study.instantiation.student" scope="prototype"></bean>\n\n\n1\n2\n\n\n\n# 2.2 springbean的生命周期\n\nsingleton：\n\n * 对象创建：当应用加载，创建容器时，对象就被创建了\n\n * 对象运行：只要容器在，对象一直活着\n\n * 对象销毁：当应用卸载，销毁容器时，对象就被销毁了\n\nprototype：\n\n * 对象创建：当使用对象时，创建新的对象实例\n * 对象运行：只要对象在使用中，就一直活着\n * 对象销毁：当对象长时间不用时，被 java 的垃圾回收器回收了\n\ninit-method：指定类中的初始化方法名称\n\ndestroy-method：指定类中销毁方法名称\n\nxml配置demo：\n\n<bean id="school" class="com.study.instantiation.school" scope="singleton" init-method="initvalue" destroy-method="destroyvalue"></bean>\n\n\n1\n\n\n\n# 2.3 springbean的创建方式\n\n 1. 使用构造函数，如果没有对应的构造函数将创建失败。\n    \n    如无参构造demo：\n    \n    <bean id="school" class="com.study.instantiation.school"></bean>\n    \n    \n    1\n    \n\n 2. 使用工厂实例化\n    \n    * 静态工厂方法\n      \n      public class staticfactorybean {\n          public static userdao createschool(){    \n          return new school();\n          }\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      \n      \n      <bean id="staticfactoryschool" class="com.study.instantiation.staticfactorybean" factory-method="createschool"/>\n      \n      \n      1\n      \n    \n    * 工厂实例的方法\n      \n      public class dynamicfactorybean {\n          public school createschool() {\n              return new school();\n          }\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      \n      \n      <bean id="dynamicfactorybean" class="com.study.instantiation.dynamicfactorybean"/>\n      <bean id="dynamicfactoryschool" factory-bean="dynamicfactorybean" factory-method="createschool"/>\n      \n      \n      1\n      2\n      \n\n\n# 3 springbean依赖注入\n\n\n# 3.1 构造函数注入\n\n标签：constructor-arg\n\n常用属性：\n\n- name：参数名\n- value：值，用于简单类型\n- ref：引用，用于引用类型，引用标记为bean的id\n\n\n注意点：\n\n通过构造函数创建bean实例，所以需要对应的构造函数。\n\nxmldemo:\n\n<bean id="information112" class="com.study.injection.information">\n    <constructor-arg name="phonenum" value="112"/>\n</bean>\n\n<bean id="studentxiaoming" class="com.study.injection.student">\n    <constructor-arg name="name" value="小明"/>\n    <constructor-arg name="age" value="16"/>\n    <constructor-arg name="information" ref="information112"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3.2 set方法注入\n\n标签：property\n\n常用属性：\n\n * name：参数名\n * value：值，用于简单类型\n * ref：引用，用于引用类型，引用标记为bean的id\n\n注意点：\n\n通过无参构造创建bean实例，所以需要无参构造。通过set函数注入，所以需要set函数（ps时机操作，不写set也行；搜索结果为通过反射直接赋值了）。\n\nxmldemo:\n\n\x3c!--  需要无参构造  --\x3e\n<bean id="studentxiaohong" class="com.study.injection.student">\n    <property name="name" value="小红"/>\n    <property name="age" value="16"/>\n    <property name="information" ref="information110"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.3 p命名空间注入\n\nbeans标签增加属性引用p命名空间 xmlns:p="http://www.springframework.org/schema/p"\n\n实际效果：\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n</beans>\n\n\n1\n2\n3\n4\n5\n\n\np命名空间的本质也是set方法注入，所以注意点也同set方法注入。\n\nxmldemo：\n\n<bean id="studentxiaofang" class="com.study.injection.student" p:name="小芳" p:age="15" p:information-ref="information110"/>\n\n\n1\n\n\n于p命名空间相对的有一个c命名空间，本质上就是构造方法注入；\n\n\n# 3.4 不同类型注入\n\n注入的类基本可以分为3种：基本类型，引用类类，集合类型。\n\n上述注入方式中已经演示了：基本类型和引用类型，分别使用value和ref属性；这里主要演示集合类型。\n\nlist集合：\n\n标签：list\n\nxmldemo:\n\n<property name="studentnames">\n    <list>\n        <value>小红</value>\n        <value>小明</value>\n        <value>小芳</value>\n        <value>小王</value>\n    </list>\n</property>\n<property name="mathclass">\n    <list>\n        <bean id="studentxiaowang" class="com.study.injection.student" p:name="小王" p:age="17" p:information-ref="information112"/>\n        <ref bean="studentxiaoming"/>\n    </list>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nmap集合：\n\n标签：map\n\nxmldemo：\n\n<property name="studentmap">\n    <map>\n        <entry key="小明" value-ref="studentxiaoming"/>\n        <entry key="小红" value-ref="studentxiaohong"/>\n        <entry key="小芳" value-ref="studentxiaofang"/>\n        <entry key="小王" value-ref="studentxiaowang"/>\n    </map>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nproperties：\n\n标签：props\n\nxmldemo：\n\n<property name="classteacher">\n\t<props>\n    \t<prop key="math">大王</prop>\n        <prop key="chinese">大明</prop>\n        <prop key="english">大芳</prop>\n    </props>\n</property>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4引入其他配置文件\n\n使用import导入\n\n<import resource="appliactioncontext-student.xml"/>\n\n\n1\n\n\n\n# 5 demo\n\ndemo路径：https://github.com/su-dd/knowledgestack.git\n\n具体路径：javaweb/testcode/_03_spring/demo2',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Spring_AOP的XML实现",frontmatter:{title:"Spring_AOP的XML实现",date:"2022-05-25T22:06:28.000Z",permalink:"/pages/af24c9/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/5.Spring%E5%9F%BA%E7%A1%80/40.Spring_AOP%E7%9A%84XML%E5%AE%9E%E7%8E%B0.html",relativePath:"后端框架--Spring/5.Spring基础/40.Spring_AOP的XML实现.md",key:"v-5d8f37ec",path:"/pages/af24c9/",headers:[{level:2,title:"1 SpringAOP的实现",slug:"_1-springaop的实现",normalizedTitle:"1 springaop的实现",charIndex:2},{level:2,title:"2 AOP的Maven坐标",slug:"_2-aop的maven坐标",normalizedTitle:"2 aop的maven坐标",charIndex:134},{level:2,title:"3 AOP的术语",slug:"_3-aop的术语",normalizedTitle:"3 aop的术语",charIndex:624},{level:2,title:"4 XML配置",slug:"_4-xml配置",normalizedTitle:"4 xml配置",charIndex:1111},{level:3,title:"4.1 Beans属性",slug:"_4-1-beans属性",normalizedTitle:"4.1 beans属性",charIndex:1123},{level:3,title:"4.2 简单的Demo讲解",slug:"_4-2-简单的demo讲解",normalizedTitle:"4.2 简单的demo讲解",charIndex:1810},{level:3,title:"4.3 通知/增强的类型",slug:"_4-3-通知-增强的类型",normalizedTitle:"4.3 通知/增强的类型",charIndex:2828},{level:3,title:"4.4 aop:declare-parents",slug:"_4-4-aop-declare-parents",normalizedTitle:"4.4 aop:declare-parents",charIndex:3812},{level:3,title:"4.5 向增强函数传参数",slug:"_4-5-向增强函数传参数",normalizedTitle:"4.5 向增强函数传参数",charIndex:4436},{level:3,title:"4.5.1 通过 JoinPoint(推荐)",slug:"_4-5-1-通过-joinpoint-推荐",normalizedTitle:"4.5.1 通过 joinpoint(推荐)",charIndex:4494},{level:4,title:"4.5.2 通过xml配置",slug:"_4-5-2-通过xml配置",normalizedTitle:"4.5.2 通过xml配置",charIndex:4930},{level:2,title:"5 Demo",slug:"_5-demo",normalizedTitle:"5 demo",charIndex:5383}],headersStr:"1 SpringAOP的实现 2 AOP的Maven坐标 3 AOP的术语 4 XML配置 4.1 Beans属性 4.2 简单的Demo讲解 4.3 通知/增强的类型 4.4 aop:declare-parents 4.5 向增强函数传参数 4.5.1 通过 JoinPoint(推荐) 4.5.2 通过xml配置 5 Demo",content:'# 1 SpringAOP的实现\n\nAOP的本质是通过对原对象的介入，去增强原对象的功能。\n\nSpringAOP是在运行期，通过动态代理技术生成代理对象实现的。\n\n常用的动态代理技术：JDK代理，cglib代理 （具体理论在后面文章中讨论，本章关注使用）\n\n\n\n\n# 2 AOP的Maven坐标\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.8.RELEASE</version>\n        </dependency>\n        \x3c!--    aspectj的织入    --\x3e\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.6</version>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3 AOP的术语\n\nSpringAOP的实现就是通过代理对象替换掉原对象，同时增强原有类的功能。这里涉及了一些术语：\n\n术语               逻辑\nTarget（目标对象）     代理的目标对象\nProxy （代理）       一个类被 AOP 织入增强后，就产生一个结果代理类\nJoinpoint（连接点）   所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点\nPointcut（切入）     所谓切入是指我们要对哪些 Joinpoint 进行拦截的定义\nAdvice（通知/ 增强）   所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知\nAspect（切面）       是切入和通知/ 增强的结合 【Pointcut + Advice】\nWeaving（织入）      是指把Advice应用到目标对象来创建新的代理对象的过程。Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入\n                 【形成Aspect的过程】\n\n\n# 4 XML配置\n\n\n# 4.1 Beans属性\n\n增加属性xmlns:aop\n\nxmlns:aop="http://www.springframework.org/schema/aop"\n\n\n1\n\n\n属性xsi:schemaLocation增加值\n\nhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n\n\n1\n\n\nXMLDemo:\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.2 简单的Demo讲解\n\nXmlDemo:\n\n<aop:config>\n    <aop:aspect ref="studentAspect">\n        <aop:before method="before" pointcut="execution(public void com.study.aop.Student.study())"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n\n\naop:config：引入aop配置\n\naop:aspect：配置一个aop切面类\n\naop:before：配置前置增强/通知，method增强使用的函数\n\n切点：\n\n标记：aop:before的pointcut属性。\n\n切点表达式：execution([修饰符] 返回值类型 包名.类名.方法名(参数))\n\n- 访问修饰符可省略\n- 返回值类型、包名、类名、方法名可以使用星号*  代表任意\n- 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类\n- 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表\n\n\nxmlDemo：\n\n<aop:before method="before" pointcut="execution(public void com.study.aop.Student.study())"/>\n<aop:before method="before" pointcut="execution(void com.study.aop.Student.study())"/>\n<aop:before method="before" pointcut="execution(* com.study.aop.Student.study())"/>\n<aop:before method="before" pointcut="execution(* com.study.aop.Student.*(..))"/>\n<aop:before method="before" pointcut="execution(* com.study.aop..*.*(..))"/>\n<aop:before method="before" pointcut="execution(* *..*.*(..))"/>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.3 通知/增强的类型\n\naop:通知类型标记：\n\n- `method`：切面类中方法名\n- `pointcut`：切点表达式\n- `pointcut-ref`：切点引用\n\n\naop:pointcut标记：\n\n<aop:pointcut id="test" expression="public void com.study.aop.Student.study()"/>\n\n\n1\n\n\n标签类型：\n\n标签                    作用         运行时机\naop:before            指定前置通知     切入点执行之前\naop:after-returning   指定后置通知     切入点执行之后\naop:around            指定环绕通知     切入点执行前后都执行\naop:after-throwing    指定异常抛出通知   切入点异常抛出时\naop:after             指定最终通知     无论是否抛出异常都执行\n\n备注：aop:around 的实际效果是覆盖了原来的运行方法，通过ProceedingJoinPoint调用原方法\n\npublic void around(ProceedingJoinPoint jp) throws Throwable {\n    System.out.println("around, 环绕增强 ... ");\n\n    Object[] args=jp.getArgs();\n    if(args.length>0){\n        System.out.print("Arguments passed: " );\n        for (int i = 0; i < args.length; i++) {\n            System.out.print("arg "+(i+1)+": "+args[i]);\n        }\n    }\n    jp.proceed(args);\n    System.out.println("around, 运行完 ... ");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以认为：aop:around是其他所有标记 + 切入点 的集合。\n\n\n# 4.4 aop:declare-parents\n\n为一个已知的API添加一个新的功能\n\n对于我们不能修改类代码，只能通过外部包装的情况。如果通过之前的AOP前置或后置通知，又不太合理，最简单的办法就是实现某个我们自定义的接口，这个接口包含了想要添加的方法。\n\n但是JAVA不是一门动态的语言，无法再编译后动态添加新的功能，这时就可以使用 aop:declare-parents\n\nXmlDemo:\n\n<aop:declare-parents \n                     types-matching="com.study.aop.Student" \n                     implement-interface="com.study.aop.imp.People" \n                     delegate-ref="studentAspect"/>\n\n\n1\n2\n3\n4\n\n\n属性：\n\n * types-matching：待增强类的表达式，支持通配符\n * implement-interface：引入增强的方法所在的接口\n * delegate-ref：引入增强的实现bean的id\n * default-impl：引入增强的实现类的全路径名称（使用该方式，无需把增强类的Bean注入到Spring容器中）\n\n注：delegate-ref和default-impl仍选一个实现即可\n\n\n# 4.5 向增强函数传参数\n\n切入函数不是一成不变的，有很大的可能性是需要根据切入点的参数而发生不同的变化。\n\n\n# 4.5.1 通过 JoinPoint(推荐)\n\n切点类和切点函数：\n\npublic class StudentAspect {\n\tpublic void before(JoinPoint joinPoint) {\n        Object[] args = joinPoint.getArgs();\n        System.out.println("before, 前置增强 ... " + args[0]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nxml：\n\n<aop:config>\n    <aop:aspect ref="studentAspect">\n        <aop:before method="before" pointcut="execution(void com.study.aop.Student.study(..))"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.5.2 通过xml配置\n\n切点类和切点函数：\n\npublic class StudentAspect implements People {\n    public void after(String course, String teacher) {\n        System.out.println("after-returning, 后置增强 ... ");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\nxml:\n\n<aop:config>\n    <aop:aspect ref="studentAspect">\n        <aop:after-returning method="after" pointcut="execution( * com.study.aop.Student.study(String,String)) and args(course, teacher)"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5 Demo\n\nDemo路径：https://github.com/su-dd/KnowledgeStack.git\n\n具体路径：JavaWeb/TestCode/_03_Spring/Demo3',normalizedContent:'# 1 springaop的实现\n\naop的本质是通过对原对象的介入，去增强原对象的功能。\n\nspringaop是在运行期，通过动态代理技术生成代理对象实现的。\n\n常用的动态代理技术：jdk代理，cglib代理 （具体理论在后面文章中讨论，本章关注使用）\n\n\n\n\n# 2 aop的maven坐标\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context</artifactid>\n            <version>5.2.8.release</version>\n        </dependency>\n        \x3c!--    aspectj的织入    --\x3e\n        <dependency>\n            <groupid>org.aspectj</groupid>\n            <artifactid>aspectjweaver</artifactid>\n            <version>1.9.6</version>\n        </dependency>\n    </dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3 aop的术语\n\nspringaop的实现就是通过代理对象替换掉原对象，同时增强原有类的功能。这里涉及了一些术语：\n\n术语               逻辑\ntarget（目标对象）     代理的目标对象\nproxy （代理）       一个类被 aop 织入增强后，就产生一个结果代理类\njoinpoint（连接点）   所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点\npointcut（切入）     所谓切入是指我们要对哪些 joinpoint 进行拦截的定义\nadvice（通知/ 增强）   所谓通知是指拦截到 joinpoint 之后所要做的事情就是通知\naspect（切面）       是切入和通知/ 增强的结合 【pointcut + advice】\nweaving（织入）      是指把advice应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而aspectj采用编译期织入和类装载期织入\n                 【形成aspect的过程】\n\n\n# 4 xml配置\n\n\n# 4.1 beans属性\n\n增加属性xmlns:aop\n\nxmlns:aop="http://www.springframework.org/schema/aop"\n\n\n1\n\n\n属性xsi:schemalocation增加值\n\nhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n\n\n1\n\n\nxmldemo:\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.2 简单的demo讲解\n\nxmldemo:\n\n<aop:config>\n    <aop:aspect ref="studentaspect">\n        <aop:before method="before" pointcut="execution(public void com.study.aop.student.study())"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n\n\naop:config：引入aop配置\n\naop:aspect：配置一个aop切面类\n\naop:before：配置前置增强/通知，method增强使用的函数\n\n切点：\n\n标记：aop:before的pointcut属性。\n\n切点表达式：execution([修饰符] 返回值类型 包名.类名.方法名(参数))\n\n- 访问修饰符可省略\n- 返回值类型、包名、类名、方法名可以使用星号*  代表任意\n- 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类\n- 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表\n\n\nxmldemo：\n\n<aop:before method="before" pointcut="execution(public void com.study.aop.student.study())"/>\n<aop:before method="before" pointcut="execution(void com.study.aop.student.study())"/>\n<aop:before method="before" pointcut="execution(* com.study.aop.student.study())"/>\n<aop:before method="before" pointcut="execution(* com.study.aop.student.*(..))"/>\n<aop:before method="before" pointcut="execution(* com.study.aop..*.*(..))"/>\n<aop:before method="before" pointcut="execution(* *..*.*(..))"/>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.3 通知/增强的类型\n\naop:通知类型标记：\n\n- `method`：切面类中方法名\n- `pointcut`：切点表达式\n- `pointcut-ref`：切点引用\n\n\naop:pointcut标记：\n\n<aop:pointcut id="test" expression="public void com.study.aop.student.study()"/>\n\n\n1\n\n\n标签类型：\n\n标签                    作用         运行时机\naop:before            指定前置通知     切入点执行之前\naop:after-returning   指定后置通知     切入点执行之后\naop:around            指定环绕通知     切入点执行前后都执行\naop:after-throwing    指定异常抛出通知   切入点异常抛出时\naop:after             指定最终通知     无论是否抛出异常都执行\n\n备注：aop:around 的实际效果是覆盖了原来的运行方法，通过proceedingjoinpoint调用原方法\n\npublic void around(proceedingjoinpoint jp) throws throwable {\n    system.out.println("around, 环绕增强 ... ");\n\n    object[] args=jp.getargs();\n    if(args.length>0){\n        system.out.print("arguments passed: " );\n        for (int i = 0; i < args.length; i++) {\n            system.out.print("arg "+(i+1)+": "+args[i]);\n        }\n    }\n    jp.proceed(args);\n    system.out.println("around, 运行完 ... ");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以认为：aop:around是其他所有标记 + 切入点 的集合。\n\n\n# 4.4 aop:declare-parents\n\n为一个已知的api添加一个新的功能\n\n对于我们不能修改类代码，只能通过外部包装的情况。如果通过之前的aop前置或后置通知，又不太合理，最简单的办法就是实现某个我们自定义的接口，这个接口包含了想要添加的方法。\n\n但是java不是一门动态的语言，无法再编译后动态添加新的功能，这时就可以使用 aop:declare-parents\n\nxmldemo:\n\n<aop:declare-parents \n                     types-matching="com.study.aop.student" \n                     implement-interface="com.study.aop.imp.people" \n                     delegate-ref="studentaspect"/>\n\n\n1\n2\n3\n4\n\n\n属性：\n\n * types-matching：待增强类的表达式，支持通配符\n * implement-interface：引入增强的方法所在的接口\n * delegate-ref：引入增强的实现bean的id\n * default-impl：引入增强的实现类的全路径名称（使用该方式，无需把增强类的bean注入到spring容器中）\n\n注：delegate-ref和default-impl仍选一个实现即可\n\n\n# 4.5 向增强函数传参数\n\n切入函数不是一成不变的，有很大的可能性是需要根据切入点的参数而发生不同的变化。\n\n\n# 4.5.1 通过 joinpoint(推荐)\n\n切点类和切点函数：\n\npublic class studentaspect {\n\tpublic void before(joinpoint joinpoint) {\n        object[] args = joinpoint.getargs();\n        system.out.println("before, 前置增强 ... " + args[0]);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\nxml：\n\n<aop:config>\n    <aop:aspect ref="studentaspect">\n        <aop:before method="before" pointcut="execution(void com.study.aop.student.study(..))"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n\n\n# 4.5.2 通过xml配置\n\n切点类和切点函数：\n\npublic class studentaspect implements people {\n    public void after(string course, string teacher) {\n        system.out.println("after-returning, 后置增强 ... ");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\nxml:\n\n<aop:config>\n    <aop:aspect ref="studentaspect">\n        <aop:after-returning method="after" pointcut="execution( * com.study.aop.student.study(string,string)) and args(course, teacher)"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5 demo\n\ndemo路径：https://github.com/su-dd/knowledgestack.git\n\n具体路径：javaweb/testcode/_03_spring/demo3',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Spring_IOC的注解实现",frontmatter:{title:"Spring_IOC的注解实现",date:"2022-05-14T11:53:39.000Z",permalink:"/pages/4ea055/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/5.Spring%E5%9F%BA%E7%A1%80/50.Spring_IOC%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0.html",relativePath:"后端框架--Spring/5.Spring基础/50.Spring_IOC的注解实现.md",key:"v-784843da",path:"/pages/4ea055/",headers:[{level:2,title:"1 基本定义",slug:"_1-基本定义",normalizedTitle:"1 基本定义",charIndex:2},{level:2,title:"2 Xml配置",slug:"_2-xml配置",normalizedTitle:"2 xml配置",charIndex:121},{level:3,title:"2.1 Beas属性",slug:"_2-1-beas属性",normalizedTitle:"2.1 beas属性",charIndex:133},{level:3,title:"2.2 组价扫描",slug:"_2-2-组价扫描",normalizedTitle:"2.2 组价扫描",charIndex:381},{level:2,title:"3 注解",slug:"_3-注解",normalizedTitle:"3 注解",charIndex:1043},{level:3,title:"3.1 实例化Bean",slug:"_3-1-实例化bean",normalizedTitle:"3.1 实例化bean",charIndex:1052},{level:3,title:"3.2 设置Bean范围",slug:"_3-2-设置bean范围",normalizedTitle:"3.2 设置bean范围",charIndex:1468},{level:3,title:"3.3 设置Bean的初始化和销毁",slug:"_3-3-设置bean的初始化和销毁",normalizedTitle:"3.3 设置bean的初始化和销毁",charIndex:1734},{level:3,title:"3.4 依赖注入",slug:"_3-4-依赖注入",normalizedTitle:"3.4 依赖注入",charIndex:2351},{level:4,title:"3.4.1 @Value",slug:"_3-4-1-value",normalizedTitle:"3.4.1 @value",charIndex:2710},{level:4,title:"3.4.2 @Autowired",slug:"_3-4-2-autowired",normalizedTitle:"3.4.2 @autowired",charIndex:2947},{level:4,title:"3.4.3 @Qualifier",slug:"_3-4-3-qualifier",normalizedTitle:"3.4.3 @qualifier",charIndex:3234},{level:4,title:"3.4.4 @Resource",slug:"_3-4-4-resource",normalizedTitle:"3.4.4 @resource",charIndex:3584},{level:2,title:"4 新注解",slug:"_4-新注解",normalizedTitle:"4 新注解",charIndex:4189},{level:3,title:"4.1 组件扫描 @ComponentScan",slug:"_4-1-组件扫描-componentscan",normalizedTitle:"4.1 组件扫描 @componentscan",charIndex:4473},{level:3,title:"4.2 @Configuration和@Bean",slug:"_4-2-configuration和-bean",normalizedTitle:"4.2 @configuration和@bean",charIndex:5096},{level:3,title:"4.3 @Import",slug:"_4-3-import",normalizedTitle:"4.3 @import",charIndex:5828},{level:3,title:"4.4 @PropertySource",slug:"_4-4-propertysource",normalizedTitle:"4.4 @propertysource",charIndex:5957},{level:2,title:"5、 容器的注解注入",slug:"_5、-容器的注解注入",normalizedTitle:"5、 容器的注解注入",charIndex:6194},{level:3,title:"5.1 @Autowired 或者 @Resource",slug:"_5-1-autowired-或者-resource",normalizedTitle:"5.1 @autowired 或者 @resource",charIndex:6209},{level:2,title:"6 Git路径",slug:"_6-git路径",normalizedTitle:"6 git路径",charIndex:7883},{level:2,title:"6 Demo",slug:"_6-demo",normalizedTitle:"6 demo",charIndex:7957}],headersStr:"1 基本定义 2 Xml配置 2.1 Beas属性 2.2 组价扫描 3 注解 3.1 实例化Bean 3.2 设置Bean范围 3.3 设置Bean的初始化和销毁 3.4 依赖注入 3.4.1 @Value 3.4.2 @Autowired 3.4.3 @Qualifier 3.4.4 @Resource 4 新注解 4.1 组件扫描 @ComponentScan 4.2 @Configuration和@Bean 4.3 @Import 4.4 @PropertySource 5、 容器的注解注入 5.1 @Autowired 或者 @Resource 6 Git路径 6 Demo",content:'# 1 基本定义\n\n随着Spring程序的日益增大，Xml注解文件也会变得繁杂不易维护。所以注解开发成为你Spring的趋势。\n\n基础定义在Spring DI和IoC理解 和 Spring IoC的Xml配置已经阐述清楚，不做赘述。\n\n\n# 2 Xml配置\n\n\n# 2.1 Beas属性\n\n添加属性： xmlns:context\n\nxmlns:context="http://www.springframework.org/schema/context"\n\n\n1\n\n\n属性xsi:schemaLocation数据增加：\n\nhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n\n\n1\n\n\n\n# 2.2 组价扫描\n\n标签：context:component-scan\n\n<context:component-scan base-package="com.study"/>\n\n\n1\n\n\nXmlDemo:\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!--  组价扫描  --\x3e\n    <context:component-scan base-package="com.study"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3 注解\n\n\n# 3.1 实例化Bean\n\n对应Xml的<bean>标签， 标识需要Spring进行实例化\n\n注解            说明                       作用位置\n@Component    使用在类上用于实例化Bean           类声明上\n@Controller   使用在web层类上用于实例化Bean       类声明上\n@Service      使用在service层类上用于实例化Bean   类声明上\n@Repository   使用在dao层类上用于实例化Bean       类声明上\n\nDemo:\n\n@Component("school")\npublic class School {\n    public School() {\n        System.out.println("——运行 School 无参构造——");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.2 设置Bean范围\n\n对应Xml的<bean>标签的scope属性\n\n注解       说明            作用位置\n@Scope   标注Bean的作用范围   类声明上\n\nDemo:\n\n@Component("school")\n@Scope("prototype")\npublic class School {\n    public School() {\n        System.out.println("——运行 School 无参构造——");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.3 设置Bean的初始化和销毁\n\n对应Xml的<bean>标签的属性init-method 、destroy-method\n\n注解               说明                       作用位置\n@PostConstruct   使用在方法上标注该方法是Bean的初始化方法   函数上\n@PreDestroy      使用在方法上标注该方法是Bean的销毁方法    函数上\n\nDemo:\n\n@Component("school")\n@Scope("singleton")\npublic class School {\n    public School() {\n        System.out.println("——运行 School 无参构造——");\n    }\n\n    @PostConstruct\n    public void initValue() {\n        System.out.println("——运行 School 初始化函数——");\n    }\n\n    @PreDestroy\n    public void destroyValue() {\n        System.out.println("——运行 School 销毁函数——");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3.4 依赖注入\n\n注解           说明                                          作用位置\n@Value       注入普通属性                                      set函数上、或者 参数上\n@Autowired   使用在字段上用于根据类型依赖注入（byType）                    set函数上、或者 参数上\n@Qualifier   结合@Autowired一起使用用于根据名称进行依赖注入（byName）        set函数上、或者 参数上\n@Resource    相当于@Autowired+@Qualifier，按照名称进行注入（byName）   set函数上、或者 参数上\n\n# 3.4.1 @Value\n\n@Service("information110")\npublic class Information110 implements Information {\n    private String phone;\n    @Value("110")\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3.4.2 @Autowired\n\n按照类型注册\n\n@Service("information110")\npublic class Information110 implements Information {\n    ...省略...\n}\n\n@Controller("studentXiaoHong")\npublic class StudentXiaoHong implements Student {\n    @Autowired\n    private Information110 information;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3.4.3 @Qualifier\n\n配合@Autowired一起使用，按照名称注入\n\n@Controller("studentXiaoHong")\npublic class StudentXiaoHong implements Student {\n    private Information110 information;\n    \n    @Autowired\n    @Qualifier("information110")\n    public void setInformation(Information information) {\n        this.information = information;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3.4.4 @Resource\n\n@Resource默认是按照名称去注入\n\n@Controller("studentXiaoHong")\npublic class StudentXiaoHong implements Student {\n    @Resource\n    private Information information110;\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用name属性按照名称注入\n\n@Controller("studentXiaoHong")\npublic class StudentXiaoHong implements Student {\n    @Resource(name = "information110")\n    private Information information;\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用type属性按照l类型注入\n\n@Controller("studentXiaoHong")\npublic class StudentXiaoHong implements Student {\n    @Resource(type = com.study.injection.info.impl.Information110.class)\n    private Information information;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4 新注解\n\n使用上面的注解还不能全部替代xml配置文件，还需要下面的注解\n\n注解                说明\n@ComponentScan    用于指定 Spring 在初始化容器时要扫描的包。\n@Configuration    用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解\n@Bean             使用在方法上，标注将该方法的返回值存储到 Spring 容器中\n@PropertySource   用于加载 .properties 文件中的配置\n@Import           用于导入其他配置类\n\n\n# 4.1 组件扫描 @ComponentScan\n\n在上面我们是通过组件扫描，知道组件的位置\n\n\x3c!--  组价扫描  --\x3e\n<context:component-scan base-package="com.study.newAnnotation"/>\n\n\n1\n2\n\n\n标记需要配合AnnotationConfigApplicationContext使用：\n\n@ComponentScan(value = "com.study.newAnnotation")\npublic class MainScanConfig {\n}\npublic class MainApp {\n    public static void main(String[] args) {\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainScanConfig.class);\n        Information information = (Information) applicationContext.getBean("information110");\n        System.out.println(information.info());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.2 @Configuration和@Bean\n\n某些XMl配置的用法，通过以上的方式我们不能实现。如对于一个类创建不同的对象。 这是可以使用@Configuration和@Bean\n\n@Configuration：指定对象是 Bean 定义的源。本质上是一个@Component。\n\n@Bean：等价于Xml的<bean>，可以同任何@Component一起使用。但是通常只和@Configuration一起使用。@Bean默认是单例的，可以通过@Scope设置范围。\n\n属性：\n\n * name：等价于Xml里<bean>的<id>，自定义名称\n * initMethod :等价于Xml里<bean>的<init-method>，指定初始化函数\n * destroyMethod :等价于Xml里<bean>的<destroy-method >，指定释放处理函数\n * autowireCandidate：标准是否常用自动注入，两个值： true，false\n * autowire：自动注入，有3个值：Autowire.NO ，Autowire.BY_NAME ，Autowire.BY_TYPE\n\n@ComponentScan(value = "com.study.newAnnotation")\npublic class MainScanConfig {\n    @Bean(name = "information110")\n    public Information getInformation110(){\n        return new Information("110");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.3 @Import\n\n导入配置类，同xml的<import>\n\n@Import(ServiceConfig.class)\n@Import({ServiceConfig.class, RepositoryConfig.class})\n\n\n1\n2\n\n\n\n# 4.4 @PropertySource\n\n加载properties文件的配置,同Xml的< context:property-placeholder>\n\n@PropertySource("classpath:info.properties")\npublic class DataSourceConfiguration {\n    @Value("${jdbc.xiaoming}")\n    private String phone;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5、 容器的注解注入\n\n\n# 5.1 @Autowired 或者 @Resource\n\n@Order可指定顺序， 对有顺序的容器有效\n\nStudentXiaoHong.java\n\n@Order(1)\n@Controller("studentXiaoHong")\npublic class StudentXiaoHong implements Student {\n\n    @Value("小红")\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return "StudentXiaoHong{" +\n                "name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nStudentXiMing.java\n\n@Order(2)\n@Controller("studentXiMing")\npublic class StudentXiMing implements Student {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    @Value("小明")\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public String toString() {\n        return "Student{" +\n                "name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nSchool.java\n\npublic class School {\n    @Autowired\n    private List<Student> studentList;\n\n    @Resource\n    private Map<String, Student> studentMap;\n\n    @Override\n    public String toString() {\n        return "School{" +\n                "studentList=" + studentList +\n                ", studentMap=" + studentMap +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n数据：\n\nSchool\n{\n\tstudentList=\n\t[\n\t\tStudentXiaoHong{name=\'小红\'},\n\t\tStudent{name=\'小明\'}\n\t],\n\t\n\tstudentMap=\n\t{\n\t\tstudentXiMing=Student{name=\'小明\'},\n\t\tstudentXiaoHong=StudentXiaoHong{name=\'小红\'}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这种注入只能对Bean有效果，普通类型不能注入。\n\n\n# 6 Git路径\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：Spring相关/40Demo\n\n\n# 6 Demo\n\nDemo路径：https://github.com/su-dd/KnowledgeStack.git\n\n具体路径：JavaWeb/TestCode/_03_Spring/Demo4',normalizedContent:'# 1 基本定义\n\n随着spring程序的日益增大，xml注解文件也会变得繁杂不易维护。所以注解开发成为你spring的趋势。\n\n基础定义在spring di和ioc理解 和 spring ioc的xml配置已经阐述清楚，不做赘述。\n\n\n# 2 xml配置\n\n\n# 2.1 beas属性\n\n添加属性： xmlns:context\n\nxmlns:context="http://www.springframework.org/schema/context"\n\n\n1\n\n\n属性xsi:schemalocation数据增加：\n\nhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n\n\n1\n\n\n\n# 2.2 组价扫描\n\n标签：context:component-scan\n\n<context:component-scan base-package="com.study"/>\n\n\n1\n\n\nxmldemo:\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \x3c!--  组价扫描  --\x3e\n    <context:component-scan base-package="com.study"/>\n</beans>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 3 注解\n\n\n# 3.1 实例化bean\n\n对应xml的<bean>标签， 标识需要spring进行实例化\n\n注解            说明                       作用位置\n@component    使用在类上用于实例化bean           类声明上\n@controller   使用在web层类上用于实例化bean       类声明上\n@service      使用在service层类上用于实例化bean   类声明上\n@repository   使用在dao层类上用于实例化bean       类声明上\n\ndemo:\n\n@component("school")\npublic class school {\n    public school() {\n        system.out.println("——运行 school 无参构造——");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 3.2 设置bean范围\n\n对应xml的<bean>标签的scope属性\n\n注解       说明            作用位置\n@scope   标注bean的作用范围   类声明上\n\ndemo:\n\n@component("school")\n@scope("prototype")\npublic class school {\n    public school() {\n        system.out.println("——运行 school 无参构造——");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.3 设置bean的初始化和销毁\n\n对应xml的<bean>标签的属性init-method 、destroy-method\n\n注解               说明                       作用位置\n@postconstruct   使用在方法上标注该方法是bean的初始化方法   函数上\n@predestroy      使用在方法上标注该方法是bean的销毁方法    函数上\n\ndemo:\n\n@component("school")\n@scope("singleton")\npublic class school {\n    public school() {\n        system.out.println("——运行 school 无参构造——");\n    }\n\n    @postconstruct\n    public void initvalue() {\n        system.out.println("——运行 school 初始化函数——");\n    }\n\n    @predestroy\n    public void destroyvalue() {\n        system.out.println("——运行 school 销毁函数——");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3.4 依赖注入\n\n注解           说明                                          作用位置\n@value       注入普通属性                                      set函数上、或者 参数上\n@autowired   使用在字段上用于根据类型依赖注入（bytype）                    set函数上、或者 参数上\n@qualifier   结合@autowired一起使用用于根据名称进行依赖注入（byname）        set函数上、或者 参数上\n@resource    相当于@autowired+@qualifier，按照名称进行注入（byname）   set函数上、或者 参数上\n\n# 3.4.1 @value\n\n@service("information110")\npublic class information110 implements information {\n    private string phone;\n    @value("110")\n    public void setphone(string phone) {\n        this.phone = phone;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3.4.2 @autowired\n\n按照类型注册\n\n@service("information110")\npublic class information110 implements information {\n    ...省略...\n}\n\n@controller("studentxiaohong")\npublic class studentxiaohong implements student {\n    @autowired\n    private information110 information;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3.4.3 @qualifier\n\n配合@autowired一起使用，按照名称注入\n\n@controller("studentxiaohong")\npublic class studentxiaohong implements student {\n    private information110 information;\n    \n    @autowired\n    @qualifier("information110")\n    public void setinformation(information information) {\n        this.information = information;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 3.4.4 @resource\n\n@resource默认是按照名称去注入\n\n@controller("studentxiaohong")\npublic class studentxiaohong implements student {\n    @resource\n    private information information110;\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用name属性按照名称注入\n\n@controller("studentxiaohong")\npublic class studentxiaohong implements student {\n    @resource(name = "information110")\n    private information information;\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用type属性按照l类型注入\n\n@controller("studentxiaohong")\npublic class studentxiaohong implements student {\n    @resource(type = com.study.injection.info.impl.information110.class)\n    private information information;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4 新注解\n\n使用上面的注解还不能全部替代xml配置文件，还需要下面的注解\n\n注解                说明\n@componentscan    用于指定 spring 在初始化容器时要扫描的包。\n@configuration    用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解\n@bean             使用在方法上，标注将该方法的返回值存储到 spring 容器中\n@propertysource   用于加载 .properties 文件中的配置\n@import           用于导入其他配置类\n\n\n# 4.1 组件扫描 @componentscan\n\n在上面我们是通过组件扫描，知道组件的位置\n\n\x3c!--  组价扫描  --\x3e\n<context:component-scan base-package="com.study.newannotation"/>\n\n\n1\n2\n\n\n标记需要配合annotationconfigapplicationcontext使用：\n\n@componentscan(value = "com.study.newannotation")\npublic class mainscanconfig {\n}\npublic class mainapp {\n    public static void main(string[] args) {\n        applicationcontext applicationcontext = new annotationconfigapplicationcontext(mainscanconfig.class);\n        information information = (information) applicationcontext.getbean("information110");\n        system.out.println(information.info());\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.2 @configuration和@bean\n\n某些xml配置的用法，通过以上的方式我们不能实现。如对于一个类创建不同的对象。 这是可以使用@configuration和@bean\n\n@configuration：指定对象是 bean 定义的源。本质上是一个@component。\n\n@bean：等价于xml的<bean>，可以同任何@component一起使用。但是通常只和@configuration一起使用。@bean默认是单例的，可以通过@scope设置范围。\n\n属性：\n\n * name：等价于xml里<bean>的<id>，自定义名称\n * initmethod :等价于xml里<bean>的<init-method>，指定初始化函数\n * destroymethod :等价于xml里<bean>的<destroy-method >，指定释放处理函数\n * autowirecandidate：标准是否常用自动注入，两个值： true，false\n * autowire：自动注入，有3个值：autowire.no ，autowire.by_name ，autowire.by_type\n\n@componentscan(value = "com.study.newannotation")\npublic class mainscanconfig {\n    @bean(name = "information110")\n    public information getinformation110(){\n        return new information("110");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 4.3 @import\n\n导入配置类，同xml的<import>\n\n@import(serviceconfig.class)\n@import({serviceconfig.class, repositoryconfig.class})\n\n\n1\n2\n\n\n\n# 4.4 @propertysource\n\n加载properties文件的配置,同xml的< context:property-placeholder>\n\n@propertysource("classpath:info.properties")\npublic class datasourceconfiguration {\n    @value("${jdbc.xiaoming}")\n    private string phone;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 5、 容器的注解注入\n\n\n# 5.1 @autowired 或者 @resource\n\n@order可指定顺序， 对有顺序的容器有效\n\nstudentxiaohong.java\n\n@order(1)\n@controller("studentxiaohong")\npublic class studentxiaohong implements student {\n\n    @value("小红")\n    private string name;\n\n    public string getname() {\n        return name;\n    }\n\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    @override\n    public string tostring() {\n        return "studentxiaohong{" +\n                "name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nstudentximing.java\n\n@order(2)\n@controller("studentximing")\npublic class studentximing implements student {\n    private string name;\n\n    public string getname() {\n        return name;\n    }\n\n    @value("小明")\n    public void setname(string name) {\n        this.name = name;\n    }\n\n    @override\n    public string tostring() {\n        return "student{" +\n                "name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nschool.java\n\npublic class school {\n    @autowired\n    private list<student> studentlist;\n\n    @resource\n    private map<string, student> studentmap;\n\n    @override\n    public string tostring() {\n        return "school{" +\n                "studentlist=" + studentlist +\n                ", studentmap=" + studentmap +\n                \'}\';\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n数据：\n\nschool\n{\n\tstudentlist=\n\t[\n\t\tstudentxiaohong{name=\'小红\'},\n\t\tstudent{name=\'小明\'}\n\t],\n\t\n\tstudentmap=\n\t{\n\t\tstudentximing=student{name=\'小明\'},\n\t\tstudentxiaohong=studentxiaohong{name=\'小红\'}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这种注入只能对bean有效果，普通类型不能注入。\n\n\n# 6 git路径\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：spring相关/40demo\n\n\n# 6 demo\n\ndemo路径：https://github.com/su-dd/knowledgestack.git\n\n具体路径：javaweb/testcode/_03_spring/demo4',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Spring_AOP的注解实现",frontmatter:{title:"Spring_AOP的注解实现",date:"2022-05-14T11:53:39.000Z",permalink:"/pages/4ea056/",categories:["Spring相关"],tags:[null]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/5.Spring%E5%9F%BA%E7%A1%80/60.Spring_AOP%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0.html",relativePath:"后端框架--Spring/5.Spring基础/60.Spring_AOP的注解实现.md",key:"v-4f15d4c2",path:"/pages/4ea056/",headers:[{level:2,title:"1 基础认知",slug:"_1-基础认知",normalizedTitle:"1 基础认知",charIndex:2},{level:2,title:"2 Xml配置",slug:"_2-xml配置",normalizedTitle:"2 xml配置",charIndex:73},{level:2,title:"3 注解",slug:"_3-注解",normalizedTitle:"3 注解",charIndex:189},{level:2,title:"4 Git路径",slug:"_4-git路径",normalizedTitle:"4 git路径",charIndex:2766}],headersStr:"1 基础认知 2 Xml配置 3 注解 4 Git路径",content:'# 1 基础认知\n\nSpring AOP的基础在SpringAOP的Xml配置 已经做了详细的介绍。请移步SpringAOP的Xml配置\n\n\n# 2 Xml配置\n\nxml中增加 <aop:aspectj-autoproxy>\n\n\x3c!--aop的自动代理--\x3e\n<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\n\n1\n2\n\n\n\n# 3 注解\n\n标签                作用         运行时机\n@Aspect           标注切面类      \n@Before           指定前置通知     切入点执行之前\n@AfterReturning   指定后置通知     切入点执行之后\n@Around           指定环绕通知     切入点执行前后都执行\n@AfterThrowing    指定异常抛出通知   切入点异常抛出时\n@After            指定最终通知     无论是否抛出异常都执行\n@Pointcut         指定切点       \n@DeclareParents   指定添加新接口    \n\nDemo:\n\n@Component("studentAspect")\n@Aspect\npublic class StudentAspect implements People {\n\n    @DeclareParents(value = "com.study.aop.Student", defaultImpl = com.study.aop.imp.StudentAspect.class)\n    public People people;\n\n    @Before("execution(void com.study.aop.Student.study(..))")\n    public void before(JoinPoint joinPoint) {\n        //System.out.println(joinPoint.getSignature().getName());\n        System.out.println("before, 前置增强 ... " + joinPoint.getArgs()[0]);\n    }\n\n    //@AfterReturning(pointcut = "execution( * com.study.aop.Student.study(String,String)) && args(course, teacher)")\n    @AfterReturning(pointcut = "execution( * com.study.aop.Student.study(String,String)) && args(course, teacher)", argNames = "course, teacher")\n    public void after(String course, String teacher) {\n        System.out.println("after-returning, 后置增强 ... " + teacher);\n    }\n\n    @Around(value = "execution( * com.study.aop.Student.study(..))")\n    public void around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println("around, 环绕增强 ... ");\n\n        Object[] args = joinPoint.getArgs();\n        if (args.length > 0) {\n            System.out.print("Arguments passed: " );\n            for (int i = 0; i < args.length; i++) {\n                System.out.print("arg "+(i+1)+": "+args[i]);\n            }\n        }\n\n        joinPoint.proceed(args);\n\n        System.out.println("around, 运行完 ... ");\n    }\n\n    @AfterThrowing(value = "execution( * com.study.aop.Student.study(..))")\n    public void throwing() {\n        System.out.println("after-throwing, 异常增强 ... ");\n    }\n\n    @After(value = "StudentAspect.pointcut(course, teacher)", argNames = "teacher, course")\n    public void afterAll(String teacher, String course) {\n        System.out.println("after, 最终通知增强 ... " + course + "_" + teacher);\n    }\n\n\n    @Override\n    public void eat() {\n        System.out.println("吃 吃 吃，就知道吃 ... ");\n    }\n\n\n    @Pointcut(value = "execution( * com.study.aop.Student.study(String,String)) && args(p1, p2)", argNames = "p1, p2")\n    public void pointcut(String p1, String p2){}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 4 Git路径\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：Spring相关/40Demo\n\nDemo路径：https://github.com/su-dd/KnowledgeStack.git\n\n具体路径：JavaWeb/TestCode/_03_Spring/Demo5',normalizedContent:'# 1 基础认知\n\nspring aop的基础在springaop的xml配置 已经做了详细的介绍。请移步springaop的xml配置\n\n\n# 2 xml配置\n\nxml中增加 <aop:aspectj-autoproxy>\n\n\x3c!--aop的自动代理--\x3e\n<aop:aspectj-autoproxy></aop:aspectj-autoproxy>\n\n\n1\n2\n\n\n\n# 3 注解\n\n标签                作用         运行时机\n@aspect           标注切面类      \n@before           指定前置通知     切入点执行之前\n@afterreturning   指定后置通知     切入点执行之后\n@around           指定环绕通知     切入点执行前后都执行\n@afterthrowing    指定异常抛出通知   切入点异常抛出时\n@after            指定最终通知     无论是否抛出异常都执行\n@pointcut         指定切点       \n@declareparents   指定添加新接口    \n\ndemo:\n\n@component("studentaspect")\n@aspect\npublic class studentaspect implements people {\n\n    @declareparents(value = "com.study.aop.student", defaultimpl = com.study.aop.imp.studentaspect.class)\n    public people people;\n\n    @before("execution(void com.study.aop.student.study(..))")\n    public void before(joinpoint joinpoint) {\n        //system.out.println(joinpoint.getsignature().getname());\n        system.out.println("before, 前置增强 ... " + joinpoint.getargs()[0]);\n    }\n\n    //@afterreturning(pointcut = "execution( * com.study.aop.student.study(string,string)) && args(course, teacher)")\n    @afterreturning(pointcut = "execution( * com.study.aop.student.study(string,string)) && args(course, teacher)", argnames = "course, teacher")\n    public void after(string course, string teacher) {\n        system.out.println("after-returning, 后置增强 ... " + teacher);\n    }\n\n    @around(value = "execution( * com.study.aop.student.study(..))")\n    public void around(proceedingjoinpoint joinpoint) throws throwable {\n        system.out.println("around, 环绕增强 ... ");\n\n        object[] args = joinpoint.getargs();\n        if (args.length > 0) {\n            system.out.print("arguments passed: " );\n            for (int i = 0; i < args.length; i++) {\n                system.out.print("arg "+(i+1)+": "+args[i]);\n            }\n        }\n\n        joinpoint.proceed(args);\n\n        system.out.println("around, 运行完 ... ");\n    }\n\n    @afterthrowing(value = "execution( * com.study.aop.student.study(..))")\n    public void throwing() {\n        system.out.println("after-throwing, 异常增强 ... ");\n    }\n\n    @after(value = "studentaspect.pointcut(course, teacher)", argnames = "teacher, course")\n    public void afterall(string teacher, string course) {\n        system.out.println("after, 最终通知增强 ... " + course + "_" + teacher);\n    }\n\n\n    @override\n    public void eat() {\n        system.out.println("吃 吃 吃，就知道吃 ... ");\n    }\n\n\n    @pointcut(value = "execution( * com.study.aop.student.study(string,string)) && args(p1, p2)", argnames = "p1, p2")\n    public void pointcut(string p1, string p2){}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 4 git路径\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：spring相关/40demo\n\ndemo路径：https://github.com/su-dd/knowledgestack.git\n\n具体路径：javaweb/testcode/_03_spring/demo5',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"SpringAPI文档knife4j",frontmatter:{title:"SpringAPI文档knife4j",date:"2022-05-30T14:30:42.000Z",permalink:"/pages/30c07c/",categories:["Spring相关"],tags:["knife4j"]},regularPath:"/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6--Spring/50.SpringAPI%E6%96%87%E6%A1%A3knife4j.html",relativePath:"后端框架--Spring/50.SpringAPI文档knife4j.md",key:"v-9821a518",path:"/pages/30c07c/",headers:[{level:2,title:"knife4j背景介绍",slug:"knife4j背景介绍",normalizedTitle:"knife4j背景介绍",charIndex:2},{level:2,title:"功能",slug:"功能",normalizedTitle:"功能",charIndex:229},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:361},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:2561}],headersStr:"knife4j背景介绍 功能 教程 引用",content:'# knife4j背景介绍\n\nknife4j是为Java MVC框架集成Swagger生成Api文档的增强解决方案；\n\nKnife4j的前身是swagger-bootstrap-ui,前身swagger-bootstrap-ui是一个纯swagger-ui的ui皮肤项目。\n\n但是随着项目的发展,面对越来越多的个性化需求,不得不编写后端Java代码以满足新的需求；因此,项目正式更名为knife4j,取名knife4j是希望她能像一把匕首一样小巧,轻量,并且功能强悍。\n\n\n# 功能\n\n地址Url为：服务布置url/doc.html\n\n例：127.0.0.1/demo/doc.html\n\n1、接口文档显示\n\n2、接口调试\n\n3、Swagger Models\n\n4、支持导出离线Markdown、Html功能\n\n\n\n\n# 教程\n\n1、在maven项目的pom.xml中引入Knife4j的依赖包：\n\n<dependency>\n    <groupId>com.github.xiaoymin</groupId>\n    <artifactId>knife4j-spring-boot-starter</artifactId>\n    <version>2.0.7</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n2、创建Swagger配置依赖\n\n@Configuration\n@EnableSwagger2WebMvc\npublic class Knife4jConfiguration {\n\n    @Bean(value = "defaultApi2")\n    public Docket defaultApi2() {\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(new ApiInfoBuilder()\n                        //.title("swagger-bootstrap-ui-demo RESTful APIs")\n                        .description("# swagger-bootstrap-ui-demo RESTful APIs")\n                        .termsOfServiceUrl("http://www.xx.com/")\n                        .contact("xx@qq.com")\n                        .version("1.0")\n                        .build())\n                //分组名称\n                .groupName("2.X版本")\n                .select()\n                //这里指定Controller扫描包路径\n                .apis(RequestHandlerSelectors.basePackage("com.glodon.controller"))\n                .paths(PathSelectors.any())\n                .build();\n        return docket;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n3、代码常用注解\n\n> @Api：用在controller类，描述API接口\n> \n> @ApiOperation：描述接口方法\n> \n> @ApiModel：描述对象\n> \n> @ApiModelProperty：描述对象属性\n> \n> @ApiImplicitParams：描述接口参数\n> \n> @ApiResponses：描述接口响应\n> \n> @ApiIgnore：忽略接口方法\n\n@Api(tags = "文件处理")  // 制定api分类名称\n@Slf4j\n@Controller\npublic class FilePublisherController {\n\n    @ApiOperation(value = "上传")  // 制定api接口名称\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = "UserID", value = "用户Id", defaultValue = "123456", required = true, dataType = "String", paramType="header")\n    }) // 参数定义\n    @PostMapping("/UploadFile")\n    @ResponseBody\n    public CommonResult uploadFile(HttpServletRequest request, @RequestParam("file") MultipartFile file, HttpServletResponse response) {\n\n    }\n\n    @ApiOperation(value = "下载")\n    @PostMapping("/DownLoadFile")\n    @ResponseBody\n    public CommonResult downLoadFile(@RequestBody ParseFileMessage parseFileMsg, HttpServletRequest request, HttpServletResponse response){\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 引用\n\nknife4j官网\n\nSwagger官网',normalizedContent:'# knife4j背景介绍\n\nknife4j是为java mvc框架集成swagger生成api文档的增强解决方案；\n\nknife4j的前身是swagger-bootstrap-ui,前身swagger-bootstrap-ui是一个纯swagger-ui的ui皮肤项目。\n\n但是随着项目的发展,面对越来越多的个性化需求,不得不编写后端java代码以满足新的需求；因此,项目正式更名为knife4j,取名knife4j是希望她能像一把匕首一样小巧,轻量,并且功能强悍。\n\n\n# 功能\n\n地址url为：服务布置url/doc.html\n\n例：127.0.0.1/demo/doc.html\n\n1、接口文档显示\n\n2、接口调试\n\n3、swagger models\n\n4、支持导出离线markdown、html功能\n\n\n\n\n# 教程\n\n1、在maven项目的pom.xml中引入knife4j的依赖包：\n\n<dependency>\n    <groupid>com.github.xiaoymin</groupid>\n    <artifactid>knife4j-spring-boot-starter</artifactid>\n    <version>2.0.7</version>\n</dependency>\n\n\n1\n2\n3\n4\n5\n\n\n2、创建swagger配置依赖\n\n@configuration\n@enableswagger2webmvc\npublic class knife4jconfiguration {\n\n    @bean(value = "defaultapi2")\n    public docket defaultapi2() {\n        docket docket=new docket(documentationtype.swagger_2)\n                .apiinfo(new apiinfobuilder()\n                        //.title("swagger-bootstrap-ui-demo restful apis")\n                        .description("# swagger-bootstrap-ui-demo restful apis")\n                        .termsofserviceurl("http://www.xx.com/")\n                        .contact("xx@qq.com")\n                        .version("1.0")\n                        .build())\n                //分组名称\n                .groupname("2.x版本")\n                .select()\n                //这里指定controller扫描包路径\n                .apis(requesthandlerselectors.basepackage("com.glodon.controller"))\n                .paths(pathselectors.any())\n                .build();\n        return docket;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n3、代码常用注解\n\n> @api：用在controller类，描述api接口\n> \n> @apioperation：描述接口方法\n> \n> @apimodel：描述对象\n> \n> @apimodelproperty：描述对象属性\n> \n> @apiimplicitparams：描述接口参数\n> \n> @apiresponses：描述接口响应\n> \n> @apiignore：忽略接口方法\n\n@api(tags = "文件处理")  // 制定api分类名称\n@slf4j\n@controller\npublic class filepublishercontroller {\n\n    @apioperation(value = "上传")  // 制定api接口名称\n    @apiimplicitparams({\n            @apiimplicitparam(name = "userid", value = "用户id", defaultvalue = "123456", required = true, datatype = "string", paramtype="header")\n    }) // 参数定义\n    @postmapping("/uploadfile")\n    @responsebody\n    public commonresult uploadfile(httpservletrequest request, @requestparam("file") multipartfile file, httpservletresponse response) {\n\n    }\n\n    @apioperation(value = "下载")\n    @postmapping("/downloadfile")\n    @responsebody\n    public commonresult downloadfile(@requestbody parsefilemessage parsefilemsg, httpservletrequest request, httpservletresponse response){\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 引用\n\nknife4j官网\n\nswagger官网',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"SQL基本语法",frontmatter:{title:"SQL基本语法",date:"2022-05-14T23:45:15.000Z",permalink:"/pages/08040d/",categories:["知识积累","SQL"],tags:[null]},regularPath:"/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL/10.SQL%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95.html",relativePath:"数据库-MySQL/10.SQL基本语法.md",key:"v-5db5a612",path:"/pages/08040d/",headers:[{level:2,title:"基本类型",slug:"基本类型",normalizedTitle:"基本类型",charIndex:2},{level:2,title:"SELECT语句",slug:"select语句",normalizedTitle:"select语句",charIndex:658},{level:2,title:"UPDATE语句",slug:"update语句",normalizedTitle:"update语句",charIndex:671},{level:2,title:"DELETE语句",slug:"delete语句",normalizedTitle:"delete语句",charIndex:684}],headersStr:"基本类型 SELECT语句 UPDATE语句 DELETE语句",content:"# 基本类型\n\n对于一个关系表，除了定义每一列名称，还需要定义每一列的数据类型，关系数据库支持的标准数据类型如下：\n\n名称             类型        说明\nINT            整型        4字节整数类型，范围约+/-21亿\nBIGINT         长整型       8字节整数类型，范围约+/-922亿亿\nREAL           浮点型       4字节浮点数，范围约+/-10^38\nDOUBLE         浮点型       8字节浮点数，范围约+/-10^308\nDECIMAL(M,N)   高精度小数     由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算\nCHAR(N)        定长字符串     存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串\nVARCHAR(N)     变长字符串     存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串\nBOOLEAN        布尔类型      存储True或者False\nDATE           日期类型      存储日期，例如，2018-06-22\nTIME           时间类型      存储时间，例如，12:20:59\nDATETIME       日期和时间类型   存储日期+时间，例如，2018-06-22 12:20:59\n\n\n# SELECT语句\n\n\n# UPDATE语句\n\n\n# DELETE语句",normalizedContent:"# 基本类型\n\n对于一个关系表，除了定义每一列名称，还需要定义每一列的数据类型，关系数据库支持的标准数据类型如下：\n\n名称             类型        说明\nint            整型        4字节整数类型，范围约+/-21亿\nbigint         长整型       8字节整数类型，范围约+/-922亿亿\nreal           浮点型       4字节浮点数，范围约+/-10^38\ndouble         浮点型       8字节浮点数，范围约+/-10^308\ndecimal(m,n)   高精度小数     由用户指定精度的小数，例如，decimal(20,10)表示一共20位，其中小数10位，通常用于财务计算\nchar(n)        定长字符串     存储指定长度的字符串，例如，char(100)总是存储100个字符的字符串\nvarchar(n)     变长字符串     存储可变长度的字符串，例如，varchar(100)可以存储0~100个字符的字符串\nboolean        布尔类型      存储true或者false\ndate           日期类型      存储日期，例如，2018-06-22\ntime           时间类型      存储时间，例如，12:20:59\ndatetime       日期和时间类型   存储日期+时间，例如，2018-06-22 12:20:59\n\n\n# select语句\n\n\n# update语句\n\n\n# delete语句",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"C++简介",frontmatter:{title:"C++简介",date:"2022-09-25T20:04:36.000Z",permalink:"/pages/74c8e0/",categories:["C++"],tags:["C++"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/1.C++%E7%AE%80%E4%BB%8B.html",relativePath:"编程语言--C++/10.基础/1.C++简介.md",key:"v-72640f06",path:"/pages/74c8e0/",headers:[{level:2,title:"维基百科",slug:"维基百科",normalizedTitle:"维基百科",charIndex:1557}],excerpt:'<p>C++标准\n由ISO/IEC JTC1/SC22/WG21进行。已经出版的标准文档如下：</p>\n<table>\n<thead>\n<tr>\n<th style="text-align:center">发布时间</th>\n<th style="text-align:center">文档</th>\n<th style="text-align:center">通称</th>\n<th style="text-align:center">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style="text-align:center">2020</td>\n<td style="text-align:center">ISO/IEC 14882:2020[5]</td>\n<td style="text-align:center">C++20</td>\n<td style="text-align:center"></td>\n</tr>\n<tr>\n<td style="text-align:center">2018</td>\n<td style="text-align:center">ISO/IEC TS 21544:2018[6]</td>\n<td style="text-align:center">modules TS</td>\n<td style="text-align:center">模块</td>\n</tr>\n<tr>\n<td style="text-align:center">2018</td>\n<td style="text-align:center">ISO/IEC TS 19570:2018[7]</td>\n<td style="text-align:center">parallelism TS</td>\n<td style="text-align:center">并行扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2018</td>\n<td style="text-align:center">ISO/IEC TS 19216:2018[8]</td>\n<td style="text-align:center">networking TS</td>\n<td style="text-align:center">网络库</td>\n</tr>\n<tr>\n<td style="text-align:center">2017</td>\n<td style="text-align:center">ISO/IEC 14882:2017[9]</td>\n<td style="text-align:center">C++17</td>\n<td style="text-align:center">第五个C++标准</td>\n</tr>\n<tr>\n<td style="text-align:center">2017</td>\n<td style="text-align:center">ISO/IEC TS 22277:2017[10]</td>\n<td style="text-align:center">coroutines TS</td>\n<td style="text-align:center">协程库扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2017</td>\n<td style="text-align:center">ISO/IEC TS 21425:2017[11]</td>\n<td style="text-align:center">ranges TS</td>\n<td style="text-align:center">提供范围机制</td>\n</tr>\n<tr>\n<td style="text-align:center">2017</td>\n<td style="text-align:center">ISO/IEC TS 19568:2017[12]</td>\n<td style="text-align:center">library fundamentals TS</td>\n<td style="text-align:center">标准库扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2016</td>\n<td style="text-align:center">ISO/IEC TS 19571:2016[13]</td>\n<td style="text-align:center">concurrency TS</td>\n<td style="text-align:center">用于并发计算的扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2015</td>\n<td style="text-align:center">ISO/IEC TS 19217:2015[14]</td>\n<td style="text-align:center">concepts TS</td>\n<td style="text-align:center">概念库，用于优化编译期信息</td>\n</tr>\n<tr>\n<td style="text-align:center">2015</td>\n<td style="text-align:center">ISO/IEC TS 19841:2015[15]</td>\n<td style="text-align:center">TM TS</td>\n<td style="text-align:center">事务性内存操作</td>\n</tr>\n<tr>\n<td style="text-align:center">2015</td>\n<td style="text-align:center">ISO/IEC TS 19570:2015[16]</td>\n<td style="text-align:center">parallelism TS</td>\n<td style="text-align:center">用于并行计算的扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2015</td>\n<td style="text-align:center">ISO/IEC TS 18822:2015[17]</td>\n<td style="text-align:center">filesystem TS</td>\n<td style="text-align:center">文件系统</td>\n</tr>\n<tr>\n<td style="text-align:center">2014</td>\n<td style="text-align:center">ISO/IEC 14882:2014[18]</td>\n<td style="text-align:center">C++14</td>\n<td style="text-align:center">第四个C++标准</td>\n</tr>\n<tr>\n<td style="text-align:center">2011</td>\n<td style="text-align:center">ISO/IEC TR 24733:2011[19]</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">十进制浮点数扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2011</td>\n<td style="text-align:center">ISO/IEC 14882:2011[20]</td>\n<td style="text-align:center">C++11</td>\n<td style="text-align:center">第三个C++标准</td>\n</tr>\n<tr>\n<td style="text-align:center">2010</td>\n<td style="text-align:center">ISO/IEC TR 29124:2010[21]</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">数学函数扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2007</td>\n<td style="text-align:center">ISO/IEC TR 19768:2007[22]</td>\n<td style="text-align:center">C++TR1</td>\n<td style="text-align:center">C++技术报告：库扩展</td>\n</tr>\n<tr>\n<td style="text-align:center">2006</td>\n<td style="text-align:center">ISO/IEC TR 18015:2006[23]</td>\n<td style="text-align:center">-</td>\n<td style="text-align:center">C++性能技术报告</td>\n</tr>\n<tr>\n<td style="text-align:center">2003</td>\n<td style="text-align:center">ISO/IEC 14882:2003[24]</td>\n<td style="text-align:center">C++03</td>\n<td style="text-align:center">第二个C++标准</td>\n</tr>\n<tr>\n<td style="text-align:center">1998</td>\n<td style="text-align:center">ISO/IEC 14882:1998[25]</td>\n<td style="text-align:center">C++98</td>\n<td style="text-align:center">第一个C++标准</td>\n</tr>\n</tbody>\n</table>\n',headersStr:"维基百科",content:"C++标准 由ISO/IEC JTC1/SC22/WG21进行。已经出版的标准文档如下：\n\n发布时间   文档                          通称                        备注\n2020   ISO/IEC 14882:2020[5]       C++20                     \n2018   ISO/IEC TS 21544:2018[6]    modules TS                模块\n2018   ISO/IEC TS 19570:2018[7]    parallelism TS            并行扩展\n2018   ISO/IEC TS 19216:2018[8]    networking TS             网络库\n2017   ISO/IEC 14882:2017[9]       C++17                     第五个C++标准\n2017   ISO/IEC TS 22277:2017[10]   coroutines TS             协程库扩展\n2017   ISO/IEC TS 21425:2017[11]   ranges TS                 提供范围机制\n2017   ISO/IEC TS 19568:2017[12]   library fundamentals TS   标准库扩展\n2016   ISO/IEC TS 19571:2016[13]   concurrency TS            用于并发计算的扩展\n2015   ISO/IEC TS 19217:2015[14]   concepts TS               概念库，用于优化编译期信息\n2015   ISO/IEC TS 19841:2015[15]   TM TS                     事务性内存操作\n2015   ISO/IEC TS 19570:2015[16]   parallelism TS            用于并行计算的扩展\n2015   ISO/IEC TS 18822:2015[17]   filesystem TS             文件系统\n2014   ISO/IEC 14882:2014[18]      C++14                     第四个C++标准\n2011   ISO/IEC TR 24733:2011[19]   -                         十进制浮点数扩展\n2011   ISO/IEC 14882:2011[20]      C++11                     第三个C++标准\n2010   ISO/IEC TR 29124:2010[21]   -                         数学函数扩展\n2007   ISO/IEC TR 19768:2007[22]   C++TR1                    C++技术报告：库扩展\n2006   ISO/IEC TR 18015:2006[23]   -                         C++性能技术报告\n2003   ISO/IEC 14882:2003[24]      C++03                     第二个C++标准\n1998   ISO/IEC 14882:1998[25]      C++98                     第一个C++标准\n\n\n# 维基百科\n\nC++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程范式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。\n\n比雅尼·斯特劳斯特鲁普博士在贝尔实验室工作期间在20世纪80年代发明并实现了C++。起初，这种语言被称作“C with Classes”（“包含‘类’的C语言”），作为C语言的增强版出现。随后，C++不断增加新特性。虚函数、运算符重载、多继承、标准模板库、异常处理、运行时类型信息、名字空间等概念逐渐纳入标准草案。1998年，国际标准组织颁布了C++程序设计语言的第一个国际标准ISO/IEC 14882:1998，目前最新标准为ISO/IEC 14882:2020。ISO/IEC 14882通称ISO C++。ISO C++包含了主要包含了核心语言和标准库的规则。尽管从核心语言到标准库都有显著不同，ISO C++直接正式（normative）引用了ISO/IEC 9899（通称ISO C），且ISO C++标准库的一部分和ISO C的标准库的API完全相同，另有很小一部分和C标准库略有差异（例如，strcat等函数提供对const类型的重载）。这使得C和C++的标准库实现常常被一并提供，在核心语言规则很大一部分兼容的情况下，进一步确保用户通常较容易把符合ISO C的源程序不经修改或经极少修改直接作为C++源程序使用，也是C++语言继C语言之后流行的一个重要原因。\n\n作为广泛被使用的工业语言，C++存在多个流行的成熟实现：GCC、基于LLVM的Clang以及Visual C++等。这些实现同时也是成熟的C语言实现，但对C语言的支持程度不一（例如，VC++对ANSI C89之后的标准支持较不完善）。大多数流行的实现包含了编译器和C++部分标准库的实现。编译器直接提供核心语言规则的实现，而库提供ISO C++标准库的实现。这些实现中，库可能同时包含和ISO C标准库的共享实现（如VC++的msvcrt）；而另一些实现的ISO C标准库则是单独于编译器项目之外提供的，如glibc和musl。C++标准库的实现也可能支持多种编译器，如GCC的libstdc++库支持GCC的g++和LLVM Clang的clang++。这些不同的丰富组合使市面上的C++环境具有许多细节上的实现差异，因而遵循ISO C++这样的权威标准对维持可移植性显得更加重要。现今讨论的C++语言，除非另行指明，通常均指ISO C++规则定义的C++语言（虽然因为实现的差异，可能不一定是最新的正式版本）。\n\n值得注意，和流行的误解不同，ISO C和ISO C++都从未明确要求源程序被编译（compile），而仅要求翻译（translate），因此C和C++并不是所谓的编译型语言。技术上，实现C和C++程序的单位是翻译单元（translation unit）。作为对比，Java语言规范中就明确要求Java程序被编译实现，明确存在编译单元（compilation unit）。实际上C和C++也存在REPL形式的解释器实现，如CINT和Cling。但因为传统上C和C++多以编译器实现，习惯上仍有一些混用，甚至至今仍出现在ISO C++某节标准库条款的标题 （页面存档备份，存于互联网档案馆）上。\n\n传统上，C++语言被视为和C语言实现性能相近的语言，强调运行时的高效。根据《C++编程思想》（Thinking in C++）一书，C++与C的代码执行效率往往相差在±5%之间[1]。",normalizedContent:"c++标准 由iso/iec jtc1/sc22/wg21进行。已经出版的标准文档如下：\n\n发布时间   文档                          通称                        备注\n2020   iso/iec 14882:2020[5]       c++20                     \n2018   iso/iec ts 21544:2018[6]    modules ts                模块\n2018   iso/iec ts 19570:2018[7]    parallelism ts            并行扩展\n2018   iso/iec ts 19216:2018[8]    networking ts             网络库\n2017   iso/iec 14882:2017[9]       c++17                     第五个c++标准\n2017   iso/iec ts 22277:2017[10]   coroutines ts             协程库扩展\n2017   iso/iec ts 21425:2017[11]   ranges ts                 提供范围机制\n2017   iso/iec ts 19568:2017[12]   library fundamentals ts   标准库扩展\n2016   iso/iec ts 19571:2016[13]   concurrency ts            用于并发计算的扩展\n2015   iso/iec ts 19217:2015[14]   concepts ts               概念库，用于优化编译期信息\n2015   iso/iec ts 19841:2015[15]   tm ts                     事务性内存操作\n2015   iso/iec ts 19570:2015[16]   parallelism ts            用于并行计算的扩展\n2015   iso/iec ts 18822:2015[17]   filesystem ts             文件系统\n2014   iso/iec 14882:2014[18]      c++14                     第四个c++标准\n2011   iso/iec tr 24733:2011[19]   -                         十进制浮点数扩展\n2011   iso/iec 14882:2011[20]      c++11                     第三个c++标准\n2010   iso/iec tr 29124:2010[21]   -                         数学函数扩展\n2007   iso/iec tr 19768:2007[22]   c++tr1                    c++技术报告：库扩展\n2006   iso/iec tr 18015:2006[23]   -                         c++性能技术报告\n2003   iso/iec 14882:2003[24]      c++03                     第二个c++标准\n1998   iso/iec 14882:1998[25]      c++98                     第一个c++标准\n\n\n# 维基百科\n\nc++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程范式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。\n\n比雅尼·斯特劳斯特鲁普博士在贝尔实验室工作期间在20世纪80年代发明并实现了c++。起初，这种语言被称作“c with classes”（“包含‘类’的c语言”），作为c语言的增强版出现。随后，c++不断增加新特性。虚函数、运算符重载、多继承、标准模板库、异常处理、运行时类型信息、名字空间等概念逐渐纳入标准草案。1998年，国际标准组织颁布了c++程序设计语言的第一个国际标准iso/iec 14882:1998，目前最新标准为iso/iec 14882:2020。iso/iec 14882通称iso c++。iso c++包含了主要包含了核心语言和标准库的规则。尽管从核心语言到标准库都有显著不同，iso c++直接正式（normative）引用了iso/iec 9899（通称iso c），且iso c++标准库的一部分和iso c的标准库的api完全相同，另有很小一部分和c标准库略有差异（例如，strcat等函数提供对const类型的重载）。这使得c和c++的标准库实现常常被一并提供，在核心语言规则很大一部分兼容的情况下，进一步确保用户通常较容易把符合iso c的源程序不经修改或经极少修改直接作为c++源程序使用，也是c++语言继c语言之后流行的一个重要原因。\n\n作为广泛被使用的工业语言，c++存在多个流行的成熟实现：gcc、基于llvm的clang以及visual c++等。这些实现同时也是成熟的c语言实现，但对c语言的支持程度不一（例如，vc++对ansi c89之后的标准支持较不完善）。大多数流行的实现包含了编译器和c++部分标准库的实现。编译器直接提供核心语言规则的实现，而库提供iso c++标准库的实现。这些实现中，库可能同时包含和iso c标准库的共享实现（如vc++的msvcrt）；而另一些实现的iso c标准库则是单独于编译器项目之外提供的，如glibc和musl。c++标准库的实现也可能支持多种编译器，如gcc的libstdc++库支持gcc的g++和llvm clang的clang++。这些不同的丰富组合使市面上的c++环境具有许多细节上的实现差异，因而遵循iso c++这样的权威标准对维持可移植性显得更加重要。现今讨论的c++语言，除非另行指明，通常均指iso c++规则定义的c++语言（虽然因为实现的差异，可能不一定是最新的正式版本）。\n\n值得注意，和流行的误解不同，iso c和iso c++都从未明确要求源程序被编译（compile），而仅要求翻译（translate），因此c和c++并不是所谓的编译型语言。技术上，实现c和c++程序的单位是翻译单元（translation unit）。作为对比，java语言规范中就明确要求java程序被编译实现，明确存在编译单元（compilation unit）。实际上c和c++也存在repl形式的解释器实现，如cint和cling。但因为传统上c和c++多以编译器实现，习惯上仍有一些混用，甚至至今仍出现在iso c++某节标准库条款的标题 （页面存档备份，存于互联网档案馆）上。\n\n传统上，c++语言被视为和c语言实现性能相近的语言，强调运行时的高效。根据《c++编程思想》（thinking in c++）一书，c++与c的代码执行效率往往相差在±5%之间[1]。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"C++ HelloWorld",frontmatter:{title:"C++ HelloWorld",date:"2022-09-26T19:49:53.000Z",permalink:"/pages/5805d0/",categories:["C++"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/2.HelloWorld.html",relativePath:"编程语言--C++/10.基础/2.HelloWorld.md",key:"v-2752c5bd",path:"/pages/5805d0/",headers:[{level:2,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:186},{level:2,title:"基本输入输出",slug:"基本输入输出",normalizedTitle:"基本输入输出",charIndex:379},{level:2,title:"变量&注释",slug:"变量-注释",normalizedTitle:"变量&amp;注释",charIndex:null},{level:3,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:820},{level:3,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:817}],excerpt:'<p>传说一切语言的第一个程序都是“HelloWorld！”</p>\n<p>如下为C++的：</p>\n\x3c!--beforebegin--\x3e<div class="language-cpp line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>\n\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Hello World!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"main函数 基本输入输出 变量&注释 注释 变量",content:'传说一切语言的第一个程序都是“HelloWorld！”\n\n如下为C++的：\n\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n std::cout << "Hello World!" << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简单做一个认识吧：\n\n\n# main函数\n\n函数的格式:\n\n返回值类型 函数名(参数类型 参数， ... )\n{\n  函数体\n}\n\n\n1\n2\n3\n4\n\n\nc++程序都是由main函数开始的;\n\nmain函数的返回值类型一般为int类型，返回0表示执行成功。\n\n例：\n\nint main(int argc, char* argv[])\n{\n *****\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 基本输入输出\n\n有输入和输出的程序才有意义。\n\nC++的基本输入输出流为：cin 和 cout\n\n需要：\n\n1、引入头文件\n\n#include <iostream>\n\n\n1\n\n\n2、使用命名空间：std\n\nusing namespace std;\n\n或\n\nstd::cout\nstd::cin\n\n\n1\n2\n3\n4\n5\n6\n\n\n代码：\n\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n cout << "Hello World!" << endl;\n\n cout << "请输入你的名字：";\n string name;\n cin >> name;\n cout << "你好！" << name << endl;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行：\n\n\n\n\n# 变量&注释\n\n\n\n\n# 注释\n\nC++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。\n\nC++ 注释一般有两种：\n\n// - 一般用于单行注释。\n\n/.../ - 一般用于多行注释。\n\n\n# 变量\n\nC++中，变量是程序运行中需要申请的存储空间的助记符；编译完成的程序中是不存在变量的。\n\n声明一个变量，即从申请了一个存储空间；初始化一个变量，即给存储空间一个值。',normalizedContent:'传说一切语言的第一个程序都是“helloworld！”\n\n如下为c++的：\n\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n std::cout << "hello world!" << std::endl;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n简单做一个认识吧：\n\n\n# main函数\n\n函数的格式:\n\n返回值类型 函数名(参数类型 参数， ... )\n{\n  函数体\n}\n\n\n1\n2\n3\n4\n\n\nc++程序都是由main函数开始的;\n\nmain函数的返回值类型一般为int类型，返回0表示执行成功。\n\n例：\n\nint main(int argc, char* argv[])\n{\n *****\n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 基本输入输出\n\n有输入和输出的程序才有意义。\n\nc++的基本输入输出流为：cin 和 cout\n\n需要：\n\n1、引入头文件\n\n#include <iostream>\n\n\n1\n\n\n2、使用命名空间：std\n\nusing namespace std;\n\n或\n\nstd::cout\nstd::cin\n\n\n1\n2\n3\n4\n5\n6\n\n\n代码：\n\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n cout << "hello world!" << endl;\n\n cout << "请输入你的名字：";\n string name;\n cin >> name;\n cout << "你好！" << name << endl;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n运行：\n\n\n\n\n# 变量&注释\n\n\n\n\n# 注释\n\nc++ 支持单行注释和多行注释。注释中的所有字符会被 c++ 编译器忽略。\n\nc++ 注释一般有两种：\n\n// - 一般用于单行注释。\n\n/.../ - 一般用于多行注释。\n\n\n# 变量\n\nc++中，变量是程序运行中需要申请的存储空间的助记符；编译完成的程序中是不存在变量的。\n\n声明一个变量，即从申请了一个存储空间；初始化一个变量，即给存储空间一个值。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"C++基础概念",frontmatter:{title:"C++基础概念",date:"2023-01-29T17:32:05.000Z",permalink:"/pages/29b4c6/",categories:["C++","基础语法"],tags:["函数","参数","返回值","变量","作用域","全局变量","局部变量","形参"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/3.C++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html",relativePath:"编程语言--C++/10.基础/3.C++基础概念.md",key:"v-630da19d",path:"/pages/29b4c6/",headers:[{level:2,title:"函数 & 参数 & 返回值",slug:"函数-参数-返回值",normalizedTitle:"函数 &amp; 参数 &amp; 返回值",charIndex:null},{level:2,title:"变量 & 作用域",slug:"变量-作用域",normalizedTitle:"变量 &amp; 作用域",charIndex:null},{level:3,title:"作用域：全局变量，局部变量，形参",slug:"作用域-全局变量-局部变量-形参",normalizedTitle:"作用域：全局变量，局部变量，形参",charIndex:348}],headersStr:"函数 & 参数 & 返回值 变量 & 作用域 作用域：全局变量，局部变量，形参",content:'# 函数 & 参数 & 返回值\n\n回到熟悉的Hello World,来学习一下函数、的概念。\n\n\n\n函数的一般形式为：\n\n返回值类型 函数名(参数列表)\n{\n  函数体\n}\n\n\n1\n2\n3\n4\n\n\n例：封装两个int相加的函数，并使用\n\nint add(int a, int b)\n{\n return a + b;\n}\n\nint main(int argc, char* argv[])\n{\n int a = add(1, 2);\n cout << a << endl;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n> 3\n\n\n# 变量 & 作用域\n\n在 HelloWorld 中 第一次说到变量，这里再一次提，主要想讲解 作用域是什么。\n\n\n# 作用域：全局变量，局部变量，形参\n\n作用域：简易理解，一个{}决定了一个作用域。如果不在任何{},就是全局。\n\n作用域和变量的关系，具体有以下几点：\n\n 1. 变量的作用域为：从变量定义开始，到对应的} 为止；\n 2. 变量只在其作用域内有效；\n 3. 同一个作用域，不能定义两个相同的变量；\n 4. 当使用一个变量a时，发现当前位置有两个不同的作用域都有a的声明定义；a取声明最近的一个。\n\n具体可以结合以下代码理解：\n\n#include <iostream>\nusing namespace std;\n\nint b = 2; // b 为 全局变量\n\nint add(int a, int b) // a、b 为 形式参数（简称：形参）\n{\n cout << "函数 ： " << endl;\n cout << "a ： " << a << endl;\n cout << "b ： " << b << endl;\n return a + b;\n}\n\nint main(int argc, char* argv[])  // argc、argv 为 形式参数（简称：形参）\n{\n int a = 1; // a 为 局部变量；\n\n {\n  int a = add(b, 1); // a 为 局部变量； b 为 全局变量\n  cout << "a ： " << a << endl;\n }\n\n cout << "a ： " << a << endl;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\n> 函数 ：\n> \n> a ： 2\n> \n> b ： 1\n> \n> a ： 3\n> \n> a ： 1\n\n名词解释：\n\n全局变量： 函数外部的变量，不做任何{}内的变量。\n\n局部变量： 存在某个{}内部的变量。\n\n形参： 函数的参数',normalizedContent:'# 函数 & 参数 & 返回值\n\n回到熟悉的hello world,来学习一下函数、的概念。\n\n\n\n函数的一般形式为：\n\n返回值类型 函数名(参数列表)\n{\n  函数体\n}\n\n\n1\n2\n3\n4\n\n\n例：封装两个int相加的函数，并使用\n\nint add(int a, int b)\n{\n return a + b;\n}\n\nint main(int argc, char* argv[])\n{\n int a = add(1, 2);\n cout << a << endl;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n> 3\n\n\n# 变量 & 作用域\n\n在 helloworld 中 第一次说到变量，这里再一次提，主要想讲解 作用域是什么。\n\n\n# 作用域：全局变量，局部变量，形参\n\n作用域：简易理解，一个{}决定了一个作用域。如果不在任何{},就是全局。\n\n作用域和变量的关系，具体有以下几点：\n\n 1. 变量的作用域为：从变量定义开始，到对应的} 为止；\n 2. 变量只在其作用域内有效；\n 3. 同一个作用域，不能定义两个相同的变量；\n 4. 当使用一个变量a时，发现当前位置有两个不同的作用域都有a的声明定义；a取声明最近的一个。\n\n具体可以结合以下代码理解：\n\n#include <iostream>\nusing namespace std;\n\nint b = 2; // b 为 全局变量\n\nint add(int a, int b) // a、b 为 形式参数（简称：形参）\n{\n cout << "函数 ： " << endl;\n cout << "a ： " << a << endl;\n cout << "b ： " << b << endl;\n return a + b;\n}\n\nint main(int argc, char* argv[])  // argc、argv 为 形式参数（简称：形参）\n{\n int a = 1; // a 为 局部变量；\n\n {\n  int a = add(b, 1); // a 为 局部变量； b 为 全局变量\n  cout << "a ： " << a << endl;\n }\n\n cout << "a ： " << a << endl;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\n> 函数 ：\n> \n> a ： 2\n> \n> b ： 1\n> \n> a ： 3\n> \n> a ： 1\n\n名词解释：\n\n全局变量： 函数外部的变量，不做任何{}内的变量。\n\n局部变量： 存在某个{}内部的变量。\n\n形参： 函数的参数',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"C++基础语法",frontmatter:{title:"C++基础语法",date:"2022-09-26T21:14:43.000Z",permalink:"/pages/8498db/",categories:["C++"],tags:["基础类型","修饰符","运算符","new","delete","malloc","free","数组","指针","数组","赋值语句","条件语句","循环语句","try","catch","throw"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/4.C++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"编程语言--C++/10.基础/4.C++基础语法.md",key:"v-727129f0",path:"/pages/8498db/",headers:[{level:2,title:"基础类型",slug:"基础类型",normalizedTitle:"基础类型",charIndex:2},{level:3,title:"修饰符",slug:"修饰符",normalizedTitle:"修饰符",charIndex:262},{level:3,title:"范围",slug:"范围",normalizedTitle:"范围",charIndex:524},{level:2,title:"基础运算符",slug:"基础运算符",normalizedTitle:"基础运算符",charIndex:4200},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:4978},{level:2,title:"指针&指针初始化",slug:"指针-指针初始化",normalizedTitle:"指针&amp;指针初始化",charIndex:null},{level:3,title:"malloc & free",slug:"malloc-free",normalizedTitle:"malloc &amp; free",charIndex:null},{level:3,title:"new & delete",slug:"new-delete",normalizedTitle:"new &amp; delete",charIndex:null},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:7294},{level:3,title:"基本操作（初始化和下标访问）",slug:"基本操作-初始化和下标访问",normalizedTitle:"基本操作（初始化和下标访问）",charIndex:7419},{level:4,title:"初始化1",slug:"初始化1",normalizedTitle:"初始化1",charIndex:7488},{level:4,title:"初始化2",slug:"初始化2",normalizedTitle:"初始化2",charIndex:7670},{level:4,title:"初始化3",slug:"初始化3",normalizedTitle:"初始化3",charIndex:7828},{level:4,title:"未初始化",slug:"未初始化",normalizedTitle:"未初始化",charIndex:7991},{level:3,title:"栈数组和堆数组（数组动态分配）",slug:"栈数组和堆数组-数组动态分配",normalizedTitle:"栈数组和堆数组（数组动态分配）",charIndex:8370},{level:4,title:"malloc & free",slug:"malloc-free-2",normalizedTitle:"malloc &amp; free",charIndex:null},{level:4,title:"new & delete",slug:"new-delete-2",normalizedTitle:"new &amp; delete",charIndex:null},{level:4,title:"指针和数组的关系",slug:"指针和数组的关系",normalizedTitle:"指针和数组的关系",charIndex:10042},{level:2,title:"常用语句",slug:"常用语句",normalizedTitle:"常用语句",charIndex:10247},{level:3,title:"赋值语句",slug:"赋值语句",normalizedTitle:"赋值语句",charIndex:10267},{level:3,title:"条件语句",slug:"条件语句",normalizedTitle:"条件语句",charIndex:10275},{level:4,title:"if else",slug:"if-else",normalizedTitle:"if else",charIndex:10472},{level:4,title:"三元运算符",slug:"三元运算符",normalizedTitle:"三元运算符",charIndex:10783},{level:4,title:"switch",slug:"switch",normalizedTitle:"switch",charIndex:10905},{level:3,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:10283},{level:4,title:"while",slug:"while",normalizedTitle:"while",charIndex:11766},{level:4,title:"do... while",slug:"do-while",normalizedTitle:"do... while",charIndex:11974},{level:4,title:"for",slug:"for",normalizedTitle:"for",charIndex:12198},{level:3,title:"try...catch...throw",slug:"try-catch-throw",normalizedTitle:"try...catch...throw",charIndex:10291},{level:4,title:"Demo & 理解throw",slug:"demo-理解throw",normalizedTitle:"demo &amp; 理解throw",charIndex:null}],excerpt:'<h2 id="基础类型"><a class="header-anchor" href="#基础类型">#</a> 基础类型</h2>\n<p>C++的基础数据类型有：</p>\n<p>bool ： 处理 布尔类型 值 true 或 false；</p>\n<p>char ： 处理 字符类型数据；</p>\n<p>int ：处理 整型 数据</p>\n<p>float ：处理 浮点数</p>\n<p>double ： 处理 双精度浮点数</p>\n<p>wchar_t（宽字符型）：如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。</p>\n<p>void ： 空类型</p>\n',headersStr:"基础类型 修饰符 范围 基础运算符 引用 指针&指针初始化 malloc & free new & delete 数组 基本操作（初始化和下标访问） 初始化1 初始化2 初始化3 未初始化 栈数组和堆数组（数组动态分配） malloc & free new & delete 指针和数组的关系 常用语句 赋值语句 条件语句 if else 三元运算符 switch 循环语句 while do... while for try...catch...throw Demo & 理解throw",content:'# 基础类型\n\nC++的基础数据类型有：\n\nbool ： 处理 布尔类型 值 true 或 false；\n\nchar ： 处理 字符类型数据；\n\nint ：处理 整型 数据\n\nfloat ：处理 浮点数\n\ndouble ： 处理 双精度浮点数\n\nwchar_t（宽字符型）：如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。\n\nvoid ： 空类型\n\n\n# 修饰符\n\n除此外，还有类型修饰符：signed、unsigned、long 和 short\n\n可以被类型修饰符修饰的类型有：int char 和 double\n\n其中：\n\nint 可以被 signed、unsigned、long 和 short 修饰 char 可以被 signed、unsigned 修饰 double 可以被 long 修饰\n\n如果只写：signed、unsigned、long 和 short 等价于： signed int、unsigned int、long int 和 short int\n\n\n# 范围\n\n不同的编译器，数据类型的大小不同\n\n#include <iostream>\n#include <limits>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    cout << "bool:\\t\\t\\t" << sizeof(bool) << "\\t字节\\t" << "范围:" << numeric_limits<bool>::min() << "~" << numeric_limits<bool>::max() << endl;\n    cout << "char:\\t\\t\\t" << sizeof(char) << "\\t字节\\t" << "范围:" << (int)numeric_limits<char>::min() << "~" << (int)numeric_limits<char>::max() << endl;\n    cout << "signed char:\\t\\t" << sizeof(signed char) << "\\t字节\\t" << "范围:" << (int)numeric_limits<signed char>::min() << "~" << (int)numeric_limits<signed char>::max() << endl;\n    cout << "unsigned char:\\t\\t" << sizeof(unsigned char) << "\\t字节\\t" << "范围:" << (int)numeric_limits<unsigned char>::min() << "~" << (int)numeric_limits<unsigned char>::max() << endl;\n    cout << "int:\\t\\t\\t" << sizeof(int) << "\\t字节\\t" << "范围:" << numeric_limits<int>::min() << "~" << numeric_limits<int>::max() << endl;\n    cout << "signed int:\\t\\t" << sizeof(signed int) << "\\t字节\\t" << "范围:" << numeric_limits<signed int>::min() << "~" << numeric_limits<signed int>::max() << endl;\n    cout << "signed:\\t\\t\\t" << sizeof(signed) << "\\t字节\\t" << "范围:" << numeric_limits<signed>::min() << "~" << numeric_limits<signed>::max() << endl;\n    cout << "unsigned int:\\t\\t" << sizeof(unsigned int) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned int>::min() << "~" << numeric_limits<unsigned int>::max() << endl;\n    cout << "unsigned:\\t\\t" << sizeof(unsigned) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned>::min() << "~" << numeric_limits<unsigned>::max() << endl;\n    cout << "short int:\\t\\t" << sizeof(short int) << "\\t字节\\t" << "范围:" << numeric_limits<short int>::min() << "~" << numeric_limits<short int>::max() << endl;\n    cout << "short:\\t\\t\\t" << sizeof(short) << "\\t字节\\t" << "范围:" << numeric_limits<short>::min() << "~" << numeric_limits<short>::max() << endl;\n    cout << "signed short int:\\t" << sizeof(signed short int) << "\\t字节\\t" << "范围:" << numeric_limits<signed short int>::min() << "~" << numeric_limits<signed short int>::max() << endl;\n    cout << "unsigned short int:\\t" << sizeof(unsigned short int) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned short int>::min() << "~" << numeric_limits<unsigned short int>::max() << endl;\n    cout << "long int:\\t\\t" << sizeof(long int) << "\\t字节\\t" << "范围:" << numeric_limits<long int>::min() << "~" << numeric_limits<long int>::max() << endl;\n    cout << "long:\\t\\t\\t" << sizeof(long) << "\\t字节\\t" << "范围:" << numeric_limits<long>::min() << "~" << numeric_limits<long>::max() << endl;\n    cout << "signed long int:\\t" << sizeof(signed long int) << "\\t字节\\t" << "范围:" << numeric_limits<signed long int>::min() << "~" << numeric_limits<unsigned long int>::max() << endl;\n    cout << "unsigned long int:\\t" << sizeof(unsigned long int) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned long int>::min() << "~" << numeric_limits<unsigned long int>::max() << endl;\n    cout << "float:\\t\\t\\t" << sizeof(float) << "\\t字节\\t" << "范围:" << numeric_limits<float>::min() << "~" << numeric_limits<float>::max() << endl;\n    cout << "double:\\t\\t\\t" << sizeof(double) << "\\t字节\\t" << "范围:" << numeric_limits<double>::min() << "~" << numeric_limits<double>::max() << endl;\n    cout << "long double:\\t\\t" << sizeof(long double) << "\\t字节\\t" << "范围:" << numeric_limits<long double>::min() << "~" << numeric_limits<long double>::max() << endl;\n    cout << "wchar_t:\\t\\t" << sizeof(wchar_t) << "\\t字节\\t" << "范围:" << numeric_limits<wchar_t>::min() << "~" << numeric_limits<wchar_t>::max() << endl;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n使用：Microsoft Visual C++ x86\n\n使用：Microsoft Visual C++ x64\n\n使用: Ubuntu GCC\n\n\n# 基础运算符\n\n优先权   运算符         说明                       结合性\n1     ()          括号                       由左至右\n2     !、-、++、--   逻辑运算符NOT、算术运算符负号、递增、递减   由右至左\n3     *、/、%       算术运算符的乘法、除法、余数           由左至右\n4     +、-         算术运算符加法、减法               由左至右\n5     <<、>>、>>>   位操作子左移、右移、无符号右移          由左至右\n6     >、>=、<、<=   关系运算符大于、大于等于、小于、小于等于     由左至右\n7     ==、!=       关系运算符等于、不等于              由左至右\n8     &           位操作子AND                  由左至右\n9     ^           位操作子XOR                  由左至右\n10    |           位操作子OR                   由左至右\n11    &&          逻辑运算符AND                 由左至右\n12    ||          逻辑运算符OR                  由左至右\n13    ?:          条件控制运算符                  由右至左\n14    =、op=       指定运算符                    由右至左\n\nop= 这里指： += 、 -= 、 *= 、 \\= 、 %= 、 &= 、 ^= 、 |=\n\n\n# 引用\n\n在前面一篇我们知道，变量是内存地址的一个名字；引用是给一个已经有名称的内存地址，再起一个名字。\n\n看下面代码，做一下深入理解：\n\n/*\n* 引用\n* 类型 & 引用变量名 = 引用实体；\n*/\nvoid test1()\n{\n int a = 1;  // 声明并初始化 int 类型变量 a\n int& b = a;  // 定义引用类型 b，指向 变量a\n cout << b << endl;\n int& c = b;  // 定义引用类型 b，指向 变量b\n cout << c << endl;\n\n cout << &a << endl; // 输出a的内存地址\n cout << &b << endl; // 输出b的内存地址\n cout << &c << endl; // 输出c的内存地址\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\n> 1\n> \n> 1\n> \n> 0x7fffffffe464\n> \n> 0x7fffffffe464\n> \n> 0x7fffffffe464\n\n引用 不是新定义一个变量，而 是给已存在变量取了一个别名 ，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。\n\n\n# 指针&指针初始化\n\n指针（pointer）是 C++中的一个核心概念；是c++中常见的用来存在内存的一种工具。\n\n理解指针有两个点：\n\n 1. 指针本身是一个大小等于int类型的变量。\n 2. 指针内存储着它指向的值的地址。\n\nvoid test1()\n{\n int a = 1; // 声明并初始化 int 类型变量 a\n int* ptr;  // 声明int类型指针 ptr\n ptr = &a;  // 让指针ptr指向 变量a 的地址\n cout << ptr  << endl; // 输出 指针指向的地址\n cout << *ptr << endl; // 输出 指针指向的地址的值\n cout << &ptr << endl; // 输出 指针的地址\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n结果：\n\n> 0x7fffffffe46c\n> \n> 1\n> \n> 0x7fffffffe470\n\n以上demo，指针是指向栈对象，其实在正式的编程工作中，指针大多是指向堆对象的。\n\n栈对象 和 堆对象的区别，我们会在后续讲解。\n\n堆对象 的 创建 和 释放 是需要特殊的关键字；\n\nC++中 一共有两对关键字：\n\nmalloc，free （C++，兼容C；所以可以用C的关键字）\n\nnew，delete （C++新增，常用这一对）\n\n这里注意： free 和 delete 是 释放指针指向地址的内存，这时指针依然指向对应地址，不为空。\n\n这时需要给指针赋空值，否则后续无法判断指针指向的位置是否有效，就会形成野指针。\n\n同理，在声明一个指针是，通常就应该初始化；如果暂不确定值，可以赋空，防止野指针。\n\n\n# malloc & free\n\nmalloc 和 free 的一般形式：\n\nvoid *malloc(size_t size) \nvoid free(void *ptr)\n\n\n1\n2\n\n\nmalloc 分配指定大小为 size字节的内存空间，返回一个指向该空间的void指针。 由于返回 void 指针，所以需要强制类型转换后才能引用其中的值。\n\nfree 释放一个由 malloc 所分配的内存空间。ptr 指向一个要释放内存的内存块， 该指针应当是之前调用 malloc 的返回值。\n\nvoid test3()\n{\n int* ptr = nullptr; // 通常指针变量声明时，就应该初始化；如果暂不确定值，可以赋空，防止野指针。\n ptr = (int*)malloc(sizeof(int)); // 申请一个int大小的堆内存，并进行强制类型转换\n *ptr = 1; // 对ptr指向的位置赋值\n cout << *ptr << endl; // 输出\n free(ptr);\n  ptr = nullptr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n结果：\n\n> 1\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb0\n\n\n# new & delete\n\nnew & delete 的一般形式：\n\n类型* 指针名 = new 类型();\ndelete 指针名\n\n\n1\n2\n\n\nnew 按照类型的大小，分配内存。 delete 释放指针指向地址的内存，这是指针依然指向对应地址，不为空。 通常会在 delete 后，增加一个 给指针变量赋空的操作；防止野指针。\n\nvoid test4()\n{\n int* ptr = new int(4); // 声明并初始化 int类型 指针 ptr\n cout << ptr << endl; // 输出 ptr 指向的地址\n cout << *ptr << endl; // 输出 ptr 指向地址的值\n delete ptr;\n cout << ptr << endl; // 输出 ptr 指向的地址\n cout << *ptr << endl; // 输出 ptr 指向地址的值\n  ptr = nullptr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结果：\n\n> 0x55555556aeb0\n> \n> 4\n> \n> 0x55555556aeb0\n> \n> 1431655786\n\n\n# 数组\n\n以int类型举例：\n\n当声明一个int类型的变量a，是在内存中声明了一个int类型大小（4Byte，32Bit）的内存\n\n当声明一个int类型的数组array，是在内存中声明了一组连续的int类型大小（4Byte，32Bit）的内存\n\n\n# 基本操作（初始化和下标访问）\n\n数据申明的基本形式：\n\n类型  参数[数量]\n\n\n1\n\n\n访问数组时，使用数组下标，下标从0开始。\n\n# 初始化1\n\n已知数组大小，和所有元素的值。\n\nvoid demo()\n{\n  int array[2] = { 1, 2 };\n  cout << array[0] << endl;\n  cout << array[1] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果为：\n\n> 1\n> \n> 2\n\n这种情况下也可以省略数组大小不写，结果等价。\n\n# 初始化2\n\n已知数组大小，和有元素的值，且值相同。\n\nvoid demo()\n{\n  int array[2] = { 1 };\n  cout << array[0] << endl;\n  cout << array[1] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果：\n\n> 1\n> \n> 1\n\n# 初始化3\n\n已知数组大小，值暂不清晰。\n\nvoid demo()\n{\n  int array[2];\n  array[0] = 0;\n  array[1] = 1;\n  cout << array[0] << endl;\n  cout << array[1] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 未初始化\n\n未初始化的数据为当前内存位置存的随机值（内存中本来的值）。\n\n存在两种为初始的情况： 1、数组刚声明，未赋值。 2、数组访问下标越界，虽然还是可以访问，但是值为随机值。\n\nvoid demo()\n{\n  int array1[2];\n  cout << array1[0] << endl;\n  cout << array1[1] << endl;\n\n  int array2[2] = {0};\n  cout << array2[0] << endl;\n  cout << array2[1] << endl;\n  cout << array2[2] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n-135408993\n32767\n\n0\n0\n-135408993\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 栈数组和堆数组（数组动态分配）\n\n栈数组：内容存储在栈中的数组。 上面的demo其实就是栈数组。 这样的数组有一个弊端，需要在写代码时，就定义好数组大小。\n\n如果我们暂时不知道数组的大小；需要在运行时决定数组大小，就需要堆数组；对数组大小进行动态分配。\n\n堆数组：内容存储在堆中的数组。 C++如果想把内存分配到堆上，就需要使用 C++操作堆的两组关键字：\n\nmalloc，free （C++，兼容C；所以可以用C的关键字）\n\nnew，delete （C++新增，常用这一对）\n\n具体理解查看下面的demo：\n\n# malloc & free\n\nvoid demo5()\n{\n int n = 2; // 定义数组的大小\n int* grade = (int*)malloc(sizeof(int) * n); // 创建数组 数组大小：int类型的大小 * n 。\n\n  cout << sizeof(grade) << endl; // 输出 grade 大小\n cout << grade << endl;  // 输出：指针的执行的位置\n cout << &grade[0] << endl; // 输出：数组0号位的位置 \n cout << &grade[1] << endl; // 输出：数组1号位的位置\n\n // 输出默认值\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n grade[0] = 0; // 给数组0号位赋值\n grade[1] = 1; // 给数组1号位赋值\n // 输出 赋值后结果\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n free(grade);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n> 8\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb4\n> \n> 0\n> \n> 0\n> \n> 0\n> \n> 1\n\n# new & delete\n\n需要注意的是 数组的操作符方式为： new[] 和 delete[]\n\n一般形式为：\n\n类型* 指针名 = new 类型[n]; // n 为数组个数\ndelete[] 指针名\n\n\n1\n2\n\n\nvoid demo6()\n{\n int n = 3; // 定义数组的大小\n int* grade = new int[n]; // 创建数组 数组大小：int类型的大小 * n 。\n\n  cout << sizeof(grade) << endl; // 输出 grade 大小\n cout << grade << endl;  // 输出：指针的执行的位置\n cout << &grade[0] << endl; // 输出：数组0号位的位置 \n cout << &grade[1] << endl; // 输出：数组1号位的位置\n\n // 输出默认值\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n grade[0] = 0; // 给数组0号位赋值\n grade[1] = 1; // 给数组1号位赋值\n // 输出 赋值后结果\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n delete[] grade;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n> 8\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb4\n> \n> 0\n> \n> 0\n> \n> 0\n> \n> 1\n\n# 指针和数组的关系\n\n从以上demo可以发现：堆数组是用指针的方式操作数组；来实现在运行期再决定数组大小的目的。\n\n现在的问题是 为什么我们可以这么做嗯？\n\n这是因为编译器在处理指针的 [n],++,--,+ n,- n 操作时，是按 对应类型大小 的 往上或往下找到第n个位置。\n\n即 指针，可以通过这样的方式操作连续内存，这恰好和数据契合；所以我们可以用指针来操作数组。\n\n但指针和数组是两个概念。\n\n\n# 常用语句\n\nC++ 常用语句有：\n\n1、赋值语句\n\n2、条件语句\n\n3、循环语句\n\n4、try...catch...throw\n\n\n# 赋值语句\n\n一般形式为：\n\nvalue = exp;\n\n\n1\n\n\nvalue 为变量，exp为可求值的表达式。\n\n例：\n\n\nint a = 0;\n\na = 1 + 1;\n\n\n\n1\n2\n3\n4\n5\n\n\n第一句 初始一个int类型变量a，并赋值为0； 第二句 求1 + 1 的值，并赋给 a；\n\n\n# 条件语句\n\n# if else\n\n一般形式为：\n\nif (exp)\n{\n  // 程序代码\n}\nelse\n{\n  // 程序代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexp 为求值为bool 类型的表达式。 程序代码中可以继续嵌套 if else 已完成复杂逻辑判断。\n\n如果只有为true的条件需要特殊的程序代码：\n\nif (exp)\n{\n  // 程序代码\n}\n\n\n1\n2\n3\n4\n\n\n如果有多个并列的不同条件：\n\nif (exp1)\n{\n  // 程序代码\n}\nelse if (exp2)\n{\n  // 程序代码\n}\nelse\n{\n  // 程序代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 三元运算符\n\n一般形式：\n\ncondition ? exp1 : exp2;\n\n\n1\n\n\n执行方式为：先执行 condition； condition为true，结果为exp1的值； condition为false，结果为exp2的值。\n\n# switch\n\n如果我们存在大量使用多个并列的不同条件需要判断，也可以使用switch。\n\n一般形式：\n\nswitch (exp) {\n  case condition_exp1:\n    // 程序代码1\n    break;\n  case condition_exp2:\n    // 程序代码2\n    break;\n  case condition_exp3:\n    // 程序代码3\n    break;\n  default:\n    // 程序代码4\n    break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexp、condition_exp1、condition_exp2 ... 可 计算为 int类型，或者为 枚举类型。\n\n逻辑为：exp求出的值，等于 哪一个 condition_exp；代码就跳转到那里执行，到break为止。\n\n如果没有，就执行 default。\n\n例1：\n\nint a = 2;\nswitch (a)\n{\ncase 1:\n cout << "case 1" << endl;\n break;\ncase 1 + 1 :\n cout << "case 2" << endl;\n break;\ndefault:\n cout << "case default" << endl;\n break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\ncase 2\n\n\n1\n\n\n例2：\n\nswitch (1 + 1)\n{\ncase 1+0:\n cout << "case 1" << endl;\ncase 2:\n cout << "case 2" << endl;\ndefault:\n cout << "case default" << endl;\n break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n运行结果：\n\ncase 2\ncase default\n\n\n1\n2\n\n\n\n# 循环语句\n\n# while\n\n一般形式：\n\nwhile (condition)\n{\n  循环体代码\n}\n\n\n1\n2\n3\n4\n\n\n例：计算 1 + 2 + 3 + ··· + 10 的结果\n\nvoid while_demo()\n{\n int i = 1;\n int amont = 0;\n while (i <= 10)\n {\n  amont += i;\n  i++;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# do... while\n\n一般形式：\n\ndo\n{\n  循环体代码\n} while (condition)\n\n\n1\n2\n3\n4\n\n\n例：计算 1 + 2 + 3 + ··· + 10 的结果\n\nvoid do_while_demo()\n{\n int i = 1;\n int amont = 0;\n do\n {\n  amont += i;\n  i++;\n } while (i <= 10);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# for\n\n一般形式：\n\nfor ( init ; condition ; increment )\n{\n  循环体代码\n}\n\n\n1\n2\n3\n4\n\n\n例：计算 1 + 2 + 3 + ··· + 10 的结果\n\nvoid for_demo()\n{\n int amont = 0;\n for (int i = 1; i <= 10; i++)\n {\n  amont += i;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# try...catch...throw\n\n当执行一段语句可能发生异常时，就需要将这段代码保护起来。\n\n一般形式：\n\ntry\n{\n  保护块代码:\n  包含：\n    throw\n  \n}\ncacth (ExceptionName e1)\n{\n  cacth块代码1：处理异常1的情况\n}\ncacth (ExceptionName e2)\n{\n  cacth块代码2：处理异常2的情况\n}\ncacth (...)\n{\n  cacth块代码 ... ：处理剩下的所有异常\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nthrow : 抛出异常 try : 执行保护代码中，一般包含throw catch : 接收处理异常\n\n# Demo & 理解throw\n\nthrow 在未被命中前，将跳过后续的所有代码；如果一直没有被处理，就会被系统接收，导致当前程序崩溃。\n\ndemo1： 正常命中异常\n\nvoid try_catch_deom()\n{\n try\n {\n  cout << "This is before throw" << endl;\n  throw 1;\n  cout << "This is after throw" << endl;\n }\n catch (int num)\n {\n  cout << "This is catch int" << endl;\n }\n}\n\n\nint main(int argc, char* argv[])\n{\n try_catch_deom();\n cout << "this is after demo" << endl;\n\n return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n结果：\n\n> This is before throw\n> \n> This is catch int\n> \n> this is after demo\n\ndemo2： 由...命中异常\n\n\nvoid try_catch_deom()\n{\n try\n {\n  cout << "This is before throw" << endl;\n  throw 1.1;\n  cout << "This is after throw" << endl;\n }\n catch (int num)\n {\n  cout << "This is catch int" << endl;\n }\n}\n\nint main(int argc, char* argv[])\n{\n try\n {\n  try_catch_deom();\n  cout << "this is after demo" << endl;\n }\n catch (...)\n {\n  cout << "This is catch ..." << endl;\n }\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n结果：\n\n> This is before throw\n> \n> This is catch ...\n\ndemo3: 无接收\n\nint main(int argc, char* argv[])\n{\n  throw 1;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n结果：程序崩溃',normalizedContent:'# 基础类型\n\nc++的基础数据类型有：\n\nbool ： 处理 布尔类型 值 true 或 false；\n\nchar ： 处理 字符类型数据；\n\nint ：处理 整型 数据\n\nfloat ：处理 浮点数\n\ndouble ： 处理 双精度浮点数\n\nwchar_t（宽字符型）：如果常量以 l（仅当大写时）开头，则表示它是一个宽字符常量（例如 l’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。\n\nvoid ： 空类型\n\n\n# 修饰符\n\n除此外，还有类型修饰符：signed、unsigned、long 和 short\n\n可以被类型修饰符修饰的类型有：int char 和 double\n\n其中：\n\nint 可以被 signed、unsigned、long 和 short 修饰 char 可以被 signed、unsigned 修饰 double 可以被 long 修饰\n\n如果只写：signed、unsigned、long 和 short 等价于： signed int、unsigned int、long int 和 short int\n\n\n# 范围\n\n不同的编译器，数据类型的大小不同\n\n#include <iostream>\n#include <limits>\nusing namespace std;\nint main(int argc, char* argv[])\n{\n    cout << "bool:\\t\\t\\t" << sizeof(bool) << "\\t字节\\t" << "范围:" << numeric_limits<bool>::min() << "~" << numeric_limits<bool>::max() << endl;\n    cout << "char:\\t\\t\\t" << sizeof(char) << "\\t字节\\t" << "范围:" << (int)numeric_limits<char>::min() << "~" << (int)numeric_limits<char>::max() << endl;\n    cout << "signed char:\\t\\t" << sizeof(signed char) << "\\t字节\\t" << "范围:" << (int)numeric_limits<signed char>::min() << "~" << (int)numeric_limits<signed char>::max() << endl;\n    cout << "unsigned char:\\t\\t" << sizeof(unsigned char) << "\\t字节\\t" << "范围:" << (int)numeric_limits<unsigned char>::min() << "~" << (int)numeric_limits<unsigned char>::max() << endl;\n    cout << "int:\\t\\t\\t" << sizeof(int) << "\\t字节\\t" << "范围:" << numeric_limits<int>::min() << "~" << numeric_limits<int>::max() << endl;\n    cout << "signed int:\\t\\t" << sizeof(signed int) << "\\t字节\\t" << "范围:" << numeric_limits<signed int>::min() << "~" << numeric_limits<signed int>::max() << endl;\n    cout << "signed:\\t\\t\\t" << sizeof(signed) << "\\t字节\\t" << "范围:" << numeric_limits<signed>::min() << "~" << numeric_limits<signed>::max() << endl;\n    cout << "unsigned int:\\t\\t" << sizeof(unsigned int) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned int>::min() << "~" << numeric_limits<unsigned int>::max() << endl;\n    cout << "unsigned:\\t\\t" << sizeof(unsigned) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned>::min() << "~" << numeric_limits<unsigned>::max() << endl;\n    cout << "short int:\\t\\t" << sizeof(short int) << "\\t字节\\t" << "范围:" << numeric_limits<short int>::min() << "~" << numeric_limits<short int>::max() << endl;\n    cout << "short:\\t\\t\\t" << sizeof(short) << "\\t字节\\t" << "范围:" << numeric_limits<short>::min() << "~" << numeric_limits<short>::max() << endl;\n    cout << "signed short int:\\t" << sizeof(signed short int) << "\\t字节\\t" << "范围:" << numeric_limits<signed short int>::min() << "~" << numeric_limits<signed short int>::max() << endl;\n    cout << "unsigned short int:\\t" << sizeof(unsigned short int) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned short int>::min() << "~" << numeric_limits<unsigned short int>::max() << endl;\n    cout << "long int:\\t\\t" << sizeof(long int) << "\\t字节\\t" << "范围:" << numeric_limits<long int>::min() << "~" << numeric_limits<long int>::max() << endl;\n    cout << "long:\\t\\t\\t" << sizeof(long) << "\\t字节\\t" << "范围:" << numeric_limits<long>::min() << "~" << numeric_limits<long>::max() << endl;\n    cout << "signed long int:\\t" << sizeof(signed long int) << "\\t字节\\t" << "范围:" << numeric_limits<signed long int>::min() << "~" << numeric_limits<unsigned long int>::max() << endl;\n    cout << "unsigned long int:\\t" << sizeof(unsigned long int) << "\\t字节\\t" << "范围:" << numeric_limits<unsigned long int>::min() << "~" << numeric_limits<unsigned long int>::max() << endl;\n    cout << "float:\\t\\t\\t" << sizeof(float) << "\\t字节\\t" << "范围:" << numeric_limits<float>::min() << "~" << numeric_limits<float>::max() << endl;\n    cout << "double:\\t\\t\\t" << sizeof(double) << "\\t字节\\t" << "范围:" << numeric_limits<double>::min() << "~" << numeric_limits<double>::max() << endl;\n    cout << "long double:\\t\\t" << sizeof(long double) << "\\t字节\\t" << "范围:" << numeric_limits<long double>::min() << "~" << numeric_limits<long double>::max() << endl;\n    cout << "wchar_t:\\t\\t" << sizeof(wchar_t) << "\\t字节\\t" << "范围:" << numeric_limits<wchar_t>::min() << "~" << numeric_limits<wchar_t>::max() << endl;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n使用：microsoft visual c++ x86\n\n使用：microsoft visual c++ x64\n\n使用: ubuntu gcc\n\n\n# 基础运算符\n\n优先权   运算符         说明                       结合性\n1     ()          括号                       由左至右\n2     !、-、++、--   逻辑运算符not、算术运算符负号、递增、递减   由右至左\n3     *、/、%       算术运算符的乘法、除法、余数           由左至右\n4     +、-         算术运算符加法、减法               由左至右\n5     <<、>>、>>>   位操作子左移、右移、无符号右移          由左至右\n6     >、>=、<、<=   关系运算符大于、大于等于、小于、小于等于     由左至右\n7     ==、!=       关系运算符等于、不等于              由左至右\n8     &           位操作子and                  由左至右\n9     ^           位操作子xor                  由左至右\n10    |           位操作子or                   由左至右\n11    &&          逻辑运算符and                 由左至右\n12    ||          逻辑运算符or                  由左至右\n13    ?:          条件控制运算符                  由右至左\n14    =、op=       指定运算符                    由右至左\n\nop= 这里指： += 、 -= 、 *= 、 \\= 、 %= 、 &= 、 ^= 、 |=\n\n\n# 引用\n\n在前面一篇我们知道，变量是内存地址的一个名字；引用是给一个已经有名称的内存地址，再起一个名字。\n\n看下面代码，做一下深入理解：\n\n/*\n* 引用\n* 类型 & 引用变量名 = 引用实体；\n*/\nvoid test1()\n{\n int a = 1;  // 声明并初始化 int 类型变量 a\n int& b = a;  // 定义引用类型 b，指向 变量a\n cout << b << endl;\n int& c = b;  // 定义引用类型 b，指向 变量b\n cout << c << endl;\n\n cout << &a << endl; // 输出a的内存地址\n cout << &b << endl; // 输出b的内存地址\n cout << &c << endl; // 输出c的内存地址\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\n> 1\n> \n> 1\n> \n> 0x7fffffffe464\n> \n> 0x7fffffffe464\n> \n> 0x7fffffffe464\n\n引用 不是新定义一个变量，而 是给已存在变量取了一个别名 ，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间。\n\n\n# 指针&指针初始化\n\n指针（pointer）是 c++中的一个核心概念；是c++中常见的用来存在内存的一种工具。\n\n理解指针有两个点：\n\n 1. 指针本身是一个大小等于int类型的变量。\n 2. 指针内存储着它指向的值的地址。\n\nvoid test1()\n{\n int a = 1; // 声明并初始化 int 类型变量 a\n int* ptr;  // 声明int类型指针 ptr\n ptr = &a;  // 让指针ptr指向 变量a 的地址\n cout << ptr  << endl; // 输出 指针指向的地址\n cout << *ptr << endl; // 输出 指针指向的地址的值\n cout << &ptr << endl; // 输出 指针的地址\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n结果：\n\n> 0x7fffffffe46c\n> \n> 1\n> \n> 0x7fffffffe470\n\n以上demo，指针是指向栈对象，其实在正式的编程工作中，指针大多是指向堆对象的。\n\n栈对象 和 堆对象的区别，我们会在后续讲解。\n\n堆对象 的 创建 和 释放 是需要特殊的关键字；\n\nc++中 一共有两对关键字：\n\nmalloc，free （c++，兼容c；所以可以用c的关键字）\n\nnew，delete （c++新增，常用这一对）\n\n这里注意： free 和 delete 是 释放指针指向地址的内存，这时指针依然指向对应地址，不为空。\n\n这时需要给指针赋空值，否则后续无法判断指针指向的位置是否有效，就会形成野指针。\n\n同理，在声明一个指针是，通常就应该初始化；如果暂不确定值，可以赋空，防止野指针。\n\n\n# malloc & free\n\nmalloc 和 free 的一般形式：\n\nvoid *malloc(size_t size) \nvoid free(void *ptr)\n\n\n1\n2\n\n\nmalloc 分配指定大小为 size字节的内存空间，返回一个指向该空间的void指针。 由于返回 void 指针，所以需要强制类型转换后才能引用其中的值。\n\nfree 释放一个由 malloc 所分配的内存空间。ptr 指向一个要释放内存的内存块， 该指针应当是之前调用 malloc 的返回值。\n\nvoid test3()\n{\n int* ptr = nullptr; // 通常指针变量声明时，就应该初始化；如果暂不确定值，可以赋空，防止野指针。\n ptr = (int*)malloc(sizeof(int)); // 申请一个int大小的堆内存，并进行强制类型转换\n *ptr = 1; // 对ptr指向的位置赋值\n cout << *ptr << endl; // 输出\n free(ptr);\n  ptr = nullptr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n结果：\n\n> 1\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb0\n\n\n# new & delete\n\nnew & delete 的一般形式：\n\n类型* 指针名 = new 类型();\ndelete 指针名\n\n\n1\n2\n\n\nnew 按照类型的大小，分配内存。 delete 释放指针指向地址的内存，这是指针依然指向对应地址，不为空。 通常会在 delete 后，增加一个 给指针变量赋空的操作；防止野指针。\n\nvoid test4()\n{\n int* ptr = new int(4); // 声明并初始化 int类型 指针 ptr\n cout << ptr << endl; // 输出 ptr 指向的地址\n cout << *ptr << endl; // 输出 ptr 指向地址的值\n delete ptr;\n cout << ptr << endl; // 输出 ptr 指向的地址\n cout << *ptr << endl; // 输出 ptr 指向地址的值\n  ptr = nullptr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结果：\n\n> 0x55555556aeb0\n> \n> 4\n> \n> 0x55555556aeb0\n> \n> 1431655786\n\n\n# 数组\n\n以int类型举例：\n\n当声明一个int类型的变量a，是在内存中声明了一个int类型大小（4byte，32bit）的内存\n\n当声明一个int类型的数组array，是在内存中声明了一组连续的int类型大小（4byte，32bit）的内存\n\n\n# 基本操作（初始化和下标访问）\n\n数据申明的基本形式：\n\n类型  参数[数量]\n\n\n1\n\n\n访问数组时，使用数组下标，下标从0开始。\n\n# 初始化1\n\n已知数组大小，和所有元素的值。\n\nvoid demo()\n{\n  int array[2] = { 1, 2 };\n  cout << array[0] << endl;\n  cout << array[1] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果为：\n\n> 1\n> \n> 2\n\n这种情况下也可以省略数组大小不写，结果等价。\n\n# 初始化2\n\n已知数组大小，和有元素的值，且值相同。\n\nvoid demo()\n{\n  int array[2] = { 1 };\n  cout << array[0] << endl;\n  cout << array[1] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果：\n\n> 1\n> \n> 1\n\n# 初始化3\n\n已知数组大小，值暂不清晰。\n\nvoid demo()\n{\n  int array[2];\n  array[0] = 0;\n  array[1] = 1;\n  cout << array[0] << endl;\n  cout << array[1] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 未初始化\n\n未初始化的数据为当前内存位置存的随机值（内存中本来的值）。\n\n存在两种为初始的情况： 1、数组刚声明，未赋值。 2、数组访问下标越界，虽然还是可以访问，但是值为随机值。\n\nvoid demo()\n{\n  int array1[2];\n  cout << array1[0] << endl;\n  cout << array1[1] << endl;\n\n  int array2[2] = {0};\n  cout << array2[0] << endl;\n  cout << array2[1] << endl;\n  cout << array2[2] << endl;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n-135408993\n32767\n\n0\n0\n-135408993\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 栈数组和堆数组（数组动态分配）\n\n栈数组：内容存储在栈中的数组。 上面的demo其实就是栈数组。 这样的数组有一个弊端，需要在写代码时，就定义好数组大小。\n\n如果我们暂时不知道数组的大小；需要在运行时决定数组大小，就需要堆数组；对数组大小进行动态分配。\n\n堆数组：内容存储在堆中的数组。 c++如果想把内存分配到堆上，就需要使用 c++操作堆的两组关键字：\n\nmalloc，free （c++，兼容c；所以可以用c的关键字）\n\nnew，delete （c++新增，常用这一对）\n\n具体理解查看下面的demo：\n\n# malloc & free\n\nvoid demo5()\n{\n int n = 2; // 定义数组的大小\n int* grade = (int*)malloc(sizeof(int) * n); // 创建数组 数组大小：int类型的大小 * n 。\n\n  cout << sizeof(grade) << endl; // 输出 grade 大小\n cout << grade << endl;  // 输出：指针的执行的位置\n cout << &grade[0] << endl; // 输出：数组0号位的位置 \n cout << &grade[1] << endl; // 输出：数组1号位的位置\n\n // 输出默认值\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n grade[0] = 0; // 给数组0号位赋值\n grade[1] = 1; // 给数组1号位赋值\n // 输出 赋值后结果\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n free(grade);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n> 8\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb4\n> \n> 0\n> \n> 0\n> \n> 0\n> \n> 1\n\n# new & delete\n\n需要注意的是 数组的操作符方式为： new[] 和 delete[]\n\n一般形式为：\n\n类型* 指针名 = new 类型[n]; // n 为数组个数\ndelete[] 指针名\n\n\n1\n2\n\n\nvoid demo6()\n{\n int n = 3; // 定义数组的大小\n int* grade = new int[n]; // 创建数组 数组大小：int类型的大小 * n 。\n\n  cout << sizeof(grade) << endl; // 输出 grade 大小\n cout << grade << endl;  // 输出：指针的执行的位置\n cout << &grade[0] << endl; // 输出：数组0号位的位置 \n cout << &grade[1] << endl; // 输出：数组1号位的位置\n\n // 输出默认值\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n grade[0] = 0; // 给数组0号位赋值\n grade[1] = 1; // 给数组1号位赋值\n // 输出 赋值后结果\n cout << grade[0] << endl;\n cout << grade[1] << endl;\n\n delete[] grade;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n> 8\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb0\n> \n> 0x55555556aeb4\n> \n> 0\n> \n> 0\n> \n> 0\n> \n> 1\n\n# 指针和数组的关系\n\n从以上demo可以发现：堆数组是用指针的方式操作数组；来实现在运行期再决定数组大小的目的。\n\n现在的问题是 为什么我们可以这么做嗯？\n\n这是因为编译器在处理指针的 [n],++,--,+ n,- n 操作时，是按 对应类型大小 的 往上或往下找到第n个位置。\n\n即 指针，可以通过这样的方式操作连续内存，这恰好和数据契合；所以我们可以用指针来操作数组。\n\n但指针和数组是两个概念。\n\n\n# 常用语句\n\nc++ 常用语句有：\n\n1、赋值语句\n\n2、条件语句\n\n3、循环语句\n\n4、try...catch...throw\n\n\n# 赋值语句\n\n一般形式为：\n\nvalue = exp;\n\n\n1\n\n\nvalue 为变量，exp为可求值的表达式。\n\n例：\n\n\nint a = 0;\n\na = 1 + 1;\n\n\n\n1\n2\n3\n4\n5\n\n\n第一句 初始一个int类型变量a，并赋值为0； 第二句 求1 + 1 的值，并赋给 a；\n\n\n# 条件语句\n\n# if else\n\n一般形式为：\n\nif (exp)\n{\n  // 程序代码\n}\nelse\n{\n  // 程序代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nexp 为求值为bool 类型的表达式。 程序代码中可以继续嵌套 if else 已完成复杂逻辑判断。\n\n如果只有为true的条件需要特殊的程序代码：\n\nif (exp)\n{\n  // 程序代码\n}\n\n\n1\n2\n3\n4\n\n\n如果有多个并列的不同条件：\n\nif (exp1)\n{\n  // 程序代码\n}\nelse if (exp2)\n{\n  // 程序代码\n}\nelse\n{\n  // 程序代码\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 三元运算符\n\n一般形式：\n\ncondition ? exp1 : exp2;\n\n\n1\n\n\n执行方式为：先执行 condition； condition为true，结果为exp1的值； condition为false，结果为exp2的值。\n\n# switch\n\n如果我们存在大量使用多个并列的不同条件需要判断，也可以使用switch。\n\n一般形式：\n\nswitch (exp) {\n  case condition_exp1:\n    // 程序代码1\n    break;\n  case condition_exp2:\n    // 程序代码2\n    break;\n  case condition_exp3:\n    // 程序代码3\n    break;\n  default:\n    // 程序代码4\n    break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nexp、condition_exp1、condition_exp2 ... 可 计算为 int类型，或者为 枚举类型。\n\n逻辑为：exp求出的值，等于 哪一个 condition_exp；代码就跳转到那里执行，到break为止。\n\n如果没有，就执行 default。\n\n例1：\n\nint a = 2;\nswitch (a)\n{\ncase 1:\n cout << "case 1" << endl;\n break;\ncase 1 + 1 :\n cout << "case 2" << endl;\n break;\ndefault:\n cout << "case default" << endl;\n break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n运行结果：\n\ncase 2\n\n\n1\n\n\n例2：\n\nswitch (1 + 1)\n{\ncase 1+0:\n cout << "case 1" << endl;\ncase 2:\n cout << "case 2" << endl;\ndefault:\n cout << "case default" << endl;\n break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n运行结果：\n\ncase 2\ncase default\n\n\n1\n2\n\n\n\n# 循环语句\n\n# while\n\n一般形式：\n\nwhile (condition)\n{\n  循环体代码\n}\n\n\n1\n2\n3\n4\n\n\n例：计算 1 + 2 + 3 + ··· + 10 的结果\n\nvoid while_demo()\n{\n int i = 1;\n int amont = 0;\n while (i <= 10)\n {\n  amont += i;\n  i++;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# do... while\n\n一般形式：\n\ndo\n{\n  循环体代码\n} while (condition)\n\n\n1\n2\n3\n4\n\n\n例：计算 1 + 2 + 3 + ··· + 10 的结果\n\nvoid do_while_demo()\n{\n int i = 1;\n int amont = 0;\n do\n {\n  amont += i;\n  i++;\n } while (i <= 10);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# for\n\n一般形式：\n\nfor ( init ; condition ; increment )\n{\n  循环体代码\n}\n\n\n1\n2\n3\n4\n\n\n例：计算 1 + 2 + 3 + ··· + 10 的结果\n\nvoid for_demo()\n{\n int amont = 0;\n for (int i = 1; i <= 10; i++)\n {\n  amont += i;\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# try...catch...throw\n\n当执行一段语句可能发生异常时，就需要将这段代码保护起来。\n\n一般形式：\n\ntry\n{\n  保护块代码:\n  包含：\n    throw\n  \n}\ncacth (exceptionname e1)\n{\n  cacth块代码1：处理异常1的情况\n}\ncacth (exceptionname e2)\n{\n  cacth块代码2：处理异常2的情况\n}\ncacth (...)\n{\n  cacth块代码 ... ：处理剩下的所有异常\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nthrow : 抛出异常 try : 执行保护代码中，一般包含throw catch : 接收处理异常\n\n# demo & 理解throw\n\nthrow 在未被命中前，将跳过后续的所有代码；如果一直没有被处理，就会被系统接收，导致当前程序崩溃。\n\ndemo1： 正常命中异常\n\nvoid try_catch_deom()\n{\n try\n {\n  cout << "this is before throw" << endl;\n  throw 1;\n  cout << "this is after throw" << endl;\n }\n catch (int num)\n {\n  cout << "this is catch int" << endl;\n }\n}\n\n\nint main(int argc, char* argv[])\n{\n try_catch_deom();\n cout << "this is after demo" << endl;\n\n return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n结果：\n\n> this is before throw\n> \n> this is catch int\n> \n> this is after demo\n\ndemo2： 由...命中异常\n\n\nvoid try_catch_deom()\n{\n try\n {\n  cout << "this is before throw" << endl;\n  throw 1.1;\n  cout << "this is after throw" << endl;\n }\n catch (int num)\n {\n  cout << "this is catch int" << endl;\n }\n}\n\nint main(int argc, char* argv[])\n{\n try\n {\n  try_catch_deom();\n  cout << "this is after demo" << endl;\n }\n catch (...)\n {\n  cout << "this is catch ..." << endl;\n }\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n结果：\n\n> this is before throw\n> \n> this is catch ...\n\ndemo3: 无接收\n\nint main(int argc, char* argv[])\n{\n  throw 1;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n\n\n结果：程序崩溃',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"C++结构体联合体",frontmatter:{title:"C++结构体联合体",date:"2023-02-01T16:31:17.000Z",permalink:"/pages/25293e/",categories:["C++","基础语法"],tags:["结构体","联合体"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/5.C++%E7%BB%93%E6%9E%84%E4%BD%93%E8%81%94%E5%90%88%E4%BD%93.html",relativePath:"编程语言--C++/10.基础/5.C++结构体联合体.md",key:"v-d712169e",path:"/pages/25293e/",headers:[{level:2,title:"总述",slug:"总述",normalizedTitle:"总述",charIndex:2},{level:2,title:"结构体 (struct)",slug:"结构体-struct",normalizedTitle:"结构体 (struct)",charIndex:69},{level:2,title:"联合体 (union)",slug:"联合体-union",normalizedTitle:"联合体 (union)",charIndex:111}],excerpt:'<h2 id="总述"><a class="header-anchor" href="#总述">#</a> 总述</h2>\n<p>之前了解过 int，char，bool，loog 等基础类型，<strong>结构体</strong>和<strong>联合体</strong> 都是C++继承兼容C的一种自定义类型的方式。</p>\n<p><strong>结构体 (struct)：</strong> 将几个变量的内存组合在一起；长度为所有变量长度之和。</p>\n<p><strong>联合体 (union)：</strong> 让几个变量使用同一段内存；长度为内存占用最大的参数。</p>\n<p><em>值得注意的是：这里的<strong>变量</strong>，可以是基础类型，也可是自定义类型。</em></p>\n',headersStr:"总述 结构体 (struct) 联合体 (union)",content:'# 总述\n\n之前了解过 int，char，bool，loog 等基础类型，结构体和联合体 都是C++继承兼容C的一种自定义类型的方式。\n\n结构体 (struct)： 将几个变量的内存组合在一起；长度为所有变量长度之和。\n\n联合体 (union)： 让几个变量使用同一段内存；长度为内存占用最大的参数。\n\n值得注意的是：这里的变量，可以是基础类型，也可是自定义类型。\n\n\n# 结构体 (struct)\n\n一般形式：\n\nstruct 结构体名称\n{\n    结构体\n};\n\n\n1\n2\n3\n4\n\n\n举例：定义一个同学类型，并使用\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// 声明结构体 Student\nstruct Student\n{\n char name[20]; // 姓名\n int age;  // 年龄\n double height; // 身高 cm\n double weight; // 体重 kg\n};\n\n\nint main(int argc, char* argv[])\n{\n Student a; // 定义同学：a\n strcpy(a.name, "小红");\n a.age = 4;\n a.height = 100;\n a.weight = 20.03;\n \n cout << "姓名：" << a.name << endl;\n cout << "年龄：" << a.age << endl;\n cout << "身高：" << a.height << endl;\n cout << "体重：" << a.weight << endl;\n\n return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n结果：\n\n> 姓名：小红\n> \n> 年龄：4\n> \n> 身高：100\n> \n> 体重：20.03\n\n我们还可以在声明结构体的同时去定义对象：\n\nstruct 结构体名称\n{\n    结构体\n} 变量名1, 变量名2 ... 变量名n;\n\n\n1\n2\n3\n4\n\n\n例：\n\n// 声明结构体 Student\nstruct Student\n{\n char name[20]; // 姓名\n int age;  // 年龄\n double height; // 身高 cm\n double weight; // 体重 kg\n} a; // 定义全局对象 同学：a\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 联合体 (union)\n\n一般形式：\n\nunion 结构体名称\n{\n    结构体\n};\n\n\n1\n2\n3\n4\n\n\n这里也支持同时去定义对象：\n\nunion 结构体名称\n{\n    结构体\n} 变量名1, 变量名2 ... 变量名n;\n\n\n1\n2\n3\n4\n\n\n联合体会几个变量使用同一段内存，可结合下面一段代码理解。\n\n例：给以上同学类型再加一个学号\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// 声明结构体 Student\nstruct Student\n{\n int num;  // 学号\n char name[20]; // 姓名\n int age;  // 年龄\n double height; // 身高 cm\n double weight; // 体重 kg\n};\n\nunion StudentU\n{\n Student student;\n int key;\n};\n\nint main(int argc, char* argv[])\n{\n StudentU a; // 定义同学：a\n a.student.num = 101; // 学号为1\n strcpy(a.student.name, "小红");\n a.student.age = 4;\n a.student.height = 100;\n a.student.weight = 20.03;\n \n cout << "关键值：" << a.key << endl;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n结果：\n\n> 关键值：101\n\n可以看到我们没有对 key 赋值，但是 key 里面存了我们想要的东西；取的是num对应的内存中的值。\n\n联合体多用于网络编程，如果希望做相关开发工作，可以看看理解相关概念。',normalizedContent:'# 总述\n\n之前了解过 int，char，bool，loog 等基础类型，结构体和联合体 都是c++继承兼容c的一种自定义类型的方式。\n\n结构体 (struct)： 将几个变量的内存组合在一起；长度为所有变量长度之和。\n\n联合体 (union)： 让几个变量使用同一段内存；长度为内存占用最大的参数。\n\n值得注意的是：这里的变量，可以是基础类型，也可是自定义类型。\n\n\n# 结构体 (struct)\n\n一般形式：\n\nstruct 结构体名称\n{\n    结构体\n};\n\n\n1\n2\n3\n4\n\n\n举例：定义一个同学类型，并使用\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// 声明结构体 student\nstruct student\n{\n char name[20]; // 姓名\n int age;  // 年龄\n double height; // 身高 cm\n double weight; // 体重 kg\n};\n\n\nint main(int argc, char* argv[])\n{\n student a; // 定义同学：a\n strcpy(a.name, "小红");\n a.age = 4;\n a.height = 100;\n a.weight = 20.03;\n \n cout << "姓名：" << a.name << endl;\n cout << "年龄：" << a.age << endl;\n cout << "身高：" << a.height << endl;\n cout << "体重：" << a.weight << endl;\n\n return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n结果：\n\n> 姓名：小红\n> \n> 年龄：4\n> \n> 身高：100\n> \n> 体重：20.03\n\n我们还可以在声明结构体的同时去定义对象：\n\nstruct 结构体名称\n{\n    结构体\n} 变量名1, 变量名2 ... 变量名n;\n\n\n1\n2\n3\n4\n\n\n例：\n\n// 声明结构体 student\nstruct student\n{\n char name[20]; // 姓名\n int age;  // 年龄\n double height; // 身高 cm\n double weight; // 体重 kg\n} a; // 定义全局对象 同学：a\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 联合体 (union)\n\n一般形式：\n\nunion 结构体名称\n{\n    结构体\n};\n\n\n1\n2\n3\n4\n\n\n这里也支持同时去定义对象：\n\nunion 结构体名称\n{\n    结构体\n} 变量名1, 变量名2 ... 变量名n;\n\n\n1\n2\n3\n4\n\n\n联合体会几个变量使用同一段内存，可结合下面一段代码理解。\n\n例：给以上同学类型再加一个学号\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// 声明结构体 student\nstruct student\n{\n int num;  // 学号\n char name[20]; // 姓名\n int age;  // 年龄\n double height; // 身高 cm\n double weight; // 体重 kg\n};\n\nunion studentu\n{\n student student;\n int key;\n};\n\nint main(int argc, char* argv[])\n{\n studentu a; // 定义同学：a\n a.student.num = 101; // 学号为1\n strcpy(a.student.name, "小红");\n a.student.age = 4;\n a.student.height = 100;\n a.student.weight = 20.03;\n \n cout << "关键值：" << a.key << endl;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n结果：\n\n> 关键值：101\n\n可以看到我们没有对 key 赋值，但是 key 里面存了我们想要的东西；取的是num对应的内存中的值。\n\n联合体多用于网络编程，如果希望做相关开发工作，可以看看理解相关概念。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 15:45:01",lastUpdatedTimestamp:1681026301e3},{title:"C++类的基础概念:封装、继承、多态",frontmatter:{title:"C++类的基础概念:封装、继承、多态",date:"2023-01-29T16:28:38.000Z",permalink:"/pages/a8b12f/",categories:["C++","基础语法"],tags:["Class","封装","继承","多态","抽象","类","对象","this指针","构造函数","析构函数"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/6.C++%E7%B1%BB%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5.html",relativePath:"编程语言--C++/10.基础/6.C++类基础概念.md",key:"v-1fc9e54e",path:"/pages/a8b12f/",headers:[{level:2,title:"类的封装",slug:"类的封装",normalizedTitle:"类的封装",charIndex:238},{level:3,title:"抽象",slug:"抽象",normalizedTitle:"抽象",charIndex:249},{level:3,title:"类",slug:"类",normalizedTitle:"类",charIndex:10},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:100},{level:3,title:"this指针",slug:"this指针",normalizedTitle:"this指针",charIndex:1630},{level:3,title:"构造函数 & 析构函数",slug:"构造函数-析构函数",normalizedTitle:"构造函数 &amp; 析构函数",charIndex:null},{level:2,title:"类的继承",slug:"类的继承",normalizedTitle:"类的继承",charIndex:2908},{level:2,title:"类的多态",slug:"类的多态",normalizedTitle:"类的多态",charIndex:4236},{level:3,title:"重载（overload）",slug:"重载-overload",normalizedTitle:"重载（overload）",charIndex:4417},{level:3,title:"隐藏 （hide）",slug:"隐藏-hide",normalizedTitle:"隐藏 （hide）",charIndex:5368},{level:4,title:"属性隐藏",slug:"属性隐藏",normalizedTitle:"属性隐藏",charIndex:5464},{level:4,title:"行为隐藏（函数隐藏）",slug:"行为隐藏-函数隐藏",normalizedTitle:"行为隐藏（函数隐藏）",charIndex:6381},{level:3,title:"覆盖 （override）",slug:"覆盖-override",normalizedTitle:"覆盖 （override）",charIndex:7153},{level:3,title:"综述",slug:"综述",normalizedTitle:"综述",charIndex:8376},{level:3,title:"扩展认知",slug:"扩展认知",normalizedTitle:"扩展认知",charIndex:8641}],excerpt:'<p>首先，简单的认知一下类：C++不同于C的一种自定义类型的方式。</p>\n<p>类（Class） 是 C++ 和 C 的最重要区别，C++ 的早期命名就是 C with Class。</p>\n<p>类的存在给C++ 带来了<a href="https://blog.addai.cn/pages/9ac8f7" target="_blank" rel="noopener noreferrer">面向对象<OutboundLink/></a>，封装、继承、多态为类的三大特性。</p>\n<p>在学习Class的具体使用方式前，我们必须先对面向对象的核心概念有大致的认知。大家可以通过：</p>\n<p><a href="https://blog.addai.cn/pages/9ac8f7" target="_blank" rel="noopener noreferrer">面向对象的核心概念<OutboundLink/></a>：<a href="https://blog.addai.cn/pages/9ac8f7" target="_blank" rel="noopener noreferrer">https://blog.addai.cn/pages/9ac8f7<OutboundLink/></a></p>\n<p>做一下概要认知，后面再通过代码理解。</p>\n',headersStr:"类的封装 抽象 类 对象 this指针 构造函数 & 析构函数 类的继承 类的多态 重载（overload） 隐藏 （hide） 属性隐藏 行为隐藏（函数隐藏） 覆盖 （override） 综述 扩展认知",content:'首先，简单的认知一下类：C++不同于C的一种自定义类型的方式。\n\n类（Class） 是 C++ 和 C 的最重要区别，C++ 的早期命名就是 C with Class。\n\n类的存在给C++ 带来了面向对象，封装、继承、多态为类的三大特性。\n\n在学习Class的具体使用方式前，我们必须先对面向对象的核心概念有大致的认知。大家可以通过：\n\n面向对象的核心概念：https://blog.addai.cn/pages/9ac8f7\n\n做一下概要认知，后面再通过代码理解。\n\n\n# 类的封装\n\n定义： 将抽象出的 数据、行为 进行有机结合；隐藏细节，指对外提供特定功能的接口 的动作\n\n封装可以分级向外提供访问权限：public、protected、private。\n\n要完成封装，需要做两件事：\n\n 1. 从实体猫中抽象 出我们需要的猫的行为和属性。\n\n 2. 将抽象的结果，转换为代码：类\n\n\n# 抽象\n\n定义: 从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程。 衡量特征是否为本质特征，要看编程的目的。\n\n举例：我们想看关注一群猫吃的动作\n\n这时我们的抽象：\n\n\n\n当我们只关注猫的吃这个动作时，猫的其他属性和动作对我们而言就没有意义了。\n\n\n# 类\n\n定义：类是抽象化后的成果。\n\n一般形式：\n\nclass 类名称\n{\npublic:\n  公开的行为定义[函数定义]\nprotected:\n  保护的行为定义[函数定义]\nprivate:\n  私有的行为定义[函数定义]\npublic:\n  公开的属性定义[变量定义]\nprotected:\n  保护的属性定义[变量定义]\nprivate:\n  私有的属性定义[变量定义]\n};  // 一定注意这里有一个`;`，实际编码中常见的错误；会导致一些无法预知的编译错误。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n关键字解读：\n\n> class：类定义关键字\n> \n> public、protected、private ：限定函数、属性的使用范围的关键字， 范围 public > protected > private\n> \n> 封装时范围说明：\n> \n> public：类内部可以访问、子类可访问、类外部可访问\n> \n> protected：类内部可以访问、子类可访问\n> \n> private：类内部可以访问\n> \n> 如果 类 声明时未使用范围的关键字进行标注 函数、属性； 默认为 private\n> \n> public、protected、private在继承上的使用，呆呆 会在下面 见继承中讲解\n\n例：上面的猫的抽象得到类\n\nclass Cat   // 声明一个类\n{\npublic:\n void eat()\n {\n  cout << "猫:" << num << " 在吃鱼 " << endl;\n }\npublic:\n int num;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 对象\n\n定义：类的实例化结果就是对象。\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Cat\n{\npublic:\n void eat()\n {\n  cout << "猫:" << num << " 在吃鱼 " << endl;\n }\npublic:\n int num;\n};\n\nint main(int argc, char* argv[])\n{\n Cat cat;    // 声明一个对象\n cat.num = 1;\n cat.eat();\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n> 猫:1 在吃鱼\n\n\n# this指针\n\nthis指针是类的成员函数的一个隐藏参数，处于形参链表的第一位;它指向当前类对象。\n\n例：\n\nclass Cat\n{\npublic:\n void eat()\n {\n  cout << "猫:" << this->num << " 在吃鱼 " << endl;\n }\npublic:\n int num;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造函数 & 析构函数\n\n构造和析构是类中两个重要的概念；\n\n构造函数 ：用于初始化类对象，在对象初始化（new 或 直接对象创建）时调用。 析构函数 ：用于对象资源释放，在对象释放（delete 或 出作用域时对象直接释放）时调用。\n\n一般形式：\n\nclass ClassName\n{\npublic:\n  ClassName(参数列表) // 函数名 必须同类名\n    : 初始化列表      // 在初始化列表阶段，对象内存还没建立完成；this是不存在的\n  {\n    函数体            // this 可使用\n  }\n\n  ~ ClassName()      // 函数名 必须同类名; 同时 在前面加上 `~`\n  {\n    函数体            // this 可使用\n  }\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Cat\n{\npublic:\n Cat(int num)\n  : m_num(num)\n {\n  cout << "猫: " << this->m_num << " 出生了" << endl;\n }\n\n ~Cat()\n {\n  cout << "猫: " << this->m_num << " 嗝屁了" << endl;\n }\n\n void eat()\n {\n  cout << "猫: " << this->m_num << " 在吃鱼 " << endl;\n }\npublic:\n int m_num;\n};\n\nint main(int argc, char* argv[])\n{\n { // 添加作用域，让 cat析构\n  Cat cat(1);\n  cat.eat();\n }\n\n Cat *pCat = new Cat(2);\n pCat->eat();\n delete pCat;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n结果：\n\n> 猫: 1 出生了\n> \n> 猫: 1 在吃鱼\n> \n> 猫: 1 嗝屁了\n> \n> 猫: 2 出生了\n> \n> 猫: 2 在吃鱼\n> \n> 猫: 2 嗝屁了\n\n\n# 类的继承\n\n定义： 描述父子类的关系，子类继承于父类；子类就是父类的一种特例，子类拥有父类的所有信息\n\n继承的方式一般有：public、protected、private\n\n一般形式：\n\nclass 子类 : public\\protected\\private 父类\n{\n 类实现;\n};\n\n\n1\n2\n3\n4\n\n\n关键词解释：\n\n> public、protected、private ：限定函数、属性的使用范围的关键字， 范围 public > protected > private\n> \n> 继承时时范围说明：\n> \n> 访问方式       PUBLIC             PROTECTED   PRIVATE\n> 子类访问父类     public、protected   public      无权限\n> 子类对象访问父类   public             无权限         无权限\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Pet\n{\npublic:\n Pet(int num)\n  : m_num(num)\n {\n  cout << "宠物: " << this->getNum() << " 出生了" << endl;\n }\n\n ~Pet()\n {\n  cout << "宠物: " << this->getNum() << " 嗝屁了" << endl;\n }\n\n void eat()\n {\n  cout << "宠物: " << this->m_num << " 在吃食物 " << endl;\n }\n\nprotected:\n int getNum()\n {\n  return m_num;\n }\n\nprivate:\n int m_num;\n};\n\n\nclass Cat : public Pet\n{\npublic:\n Cat(int num)\n  : Pet(num)\n {\n  cout << "猫: " << this->getNum() << " 出生了" << endl;\n }\n\n ~Cat()\n {\n  cout << "猫: " << getNum() << " 嗝屁了" << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n { // 添加作用域，让 cat析构\n  Cat cat(1);\n  cat.eat();\n }\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n结果：\n\n> 宠物: 1 出生了\n> \n> 猫: 1 出生了\n> \n> 宠物: 1 在吃食物\n> \n> 猫: 1 嗝屁了\n> \n> 宠物: 1 嗝屁了\n\n\n# 类的多态\n\n定义： 为不同数据类型的实体提供统一接口，并表现出不同的行为。多态是针对行为（函数）的知识\n\n一般认为多态有 ：重载(overload)、隐藏(hide)、覆盖(override) 三种情况\n\n呆呆这里还没有讲到内存结构，大家可能还不能很好的理解；这一节建议大家：一要看代码，二要自己写demo体会 后面将内存结构时，相信可以让大家豁然开朗\n\n\n# 重载（overload）\n\n定义：\n\n> 条件1： 同一个类中\n> \n> 条件2： 相同函数名\n> \n> 条件3： 参数不同(参数类型，或参数个数)\n> \n> 结果： 函数调用由传入参数决定\n\n例：\n\nclass Cat\n{\npublic:\n Cat(int num)\n  : m_num(num)\n {\n  cout << "猫: " << this->m_num << " 出生了" << endl;\n }\n\n ~Cat()\n {\n  cout << "猫: " << this->m_num << " 嗝屁了" << endl;\n }\n\n void eat(int weight)\n {\n  cout << "(int)猫: " << this->m_num << " 吃了 " << weight << " kg 鱼 " << endl;\n }\n\n void eat(double weight)\n {\n  cout << "(double)猫: " << this->m_num << " 吃了 " << weight << " kg 鱼 " << endl;\n }\n\npublic:\n int m_num;\n};\n\nint main(int argc, char* argv[])\n{\n Cat* pCat = new Cat(2);\n pCat->eat(1);\n pCat->eat(1.3);\n delete pCat;\n\n return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n这里呆呆两次调用了eat方法，只是传入参数的类型不同；对应的结果也不相同。\n\n结果：\n\n> 猫: 2 出生了\n> \n> (int)猫: 2 吃了 1 kg 鱼\n> \n> (double)猫: 2 吃了 1.3 kg 鱼\n> \n> 猫: 2 嗝屁了\n\n这里可能会有疑问：如果是函数名、参数相同，返回值不同会是什么情况？\n\n呆呆这里需要提醒大家：在一个类中，C++类中不能声明两个 函数名和参数都相同的函数。\n\n\n# 隐藏 （hide）\n\n定义： 隐藏是子类对父类的一种覆盖隐藏的行为，对象是 同名的标识符（函数和属性）； 如果子类中存在和父类相同的标识符，且不构成覆盖（override），则是隐藏。\n\n# 属性隐藏\n\n> 条件1： 两个类呈 父子关系； class A 继承 class B\n> \n> 条件1： A、B 中存在同名属性： attitude\n> \n> 使用： 使用Class A 创建一个对象，赋值给A类型的变量； 使用attitude\n> \n> 结果： 使用的是 A 中的 属性\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Pet\n{\npublic:\n Pet(int num)\n  : m_num(num) {}\n\n ~Pet() { }\n\npublic:\n int m_num;\n};\n\n\nclass Cat : public Pet\n{\npublic:\n Cat(int num)\n  : Pet(num)   // 父类的m_num 赋值为num\n  , m_num(100) // 子类的m_num 赋值为 100\n { }\n\n ~Cat() { }\n\npublic:\n int m_num;\n};\n\nint main(int argc, char* argv[])\n{\n Cat* pCat = new Cat(2);  // 创建 Cat对象赋值给 Cat变量\n cout << pCat->m_num << endl;// 输出Cat变量的m_num\n delete pCat;\n\n Pet* pPet = new Cat(2);  // 创建 Cat对象赋值给 Pet变量\n cout << pPet->m_num << endl;// 输出Pet变量的m_num\n delete pPet;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n结果：\n\n> 100\n> \n> 2\n\n这里可以发现，父子类的属性都是存在内存中的；我们可以分别使用父子类的变量，去访问他们的属性\n\n# 行为隐藏（函数隐藏）\n\n> 条件1： 两个类呈 父子关系； class A 继承 class B\n> \n> 条件2： A、B 中存在同名函数： fun\n> \n> 条件3： A、B中的fun不呈覆盖逻辑\n> \n> 使用： 使用Class A 创建一个对象，赋值给A类型的变量； 使用fun\n> \n> 结果： 使用的是 A 中的 函数\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Pet\n{\npublic:\n void eat() // 定义eat函数\n {\n  cout << "Pet eat!!!" << endl;\n }\n};\n\n\nclass Cat : public Pet\n{\npublic:\n void eat(int num) // 子类声明了同名eat函数，就会隐藏父类eat\n {\n  cout << "Cat eat!!!" << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n Cat* pCat = new Cat();\n // pCat->eat(); // eat() 函数被隐藏，无法被调用\n pCat->eat(1);\n delete pCat;\n\n Pet* pPet = new Cat();\n pPet->eat();\n delete pPet;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n结果：\n\n> Cat eat!!!\n> \n> Pet eat!!!\n\n\n# 覆盖 （override）\n\n定义：\n\n> 条件1： 两个类呈 父子关系； class A 继承 class B\n> \n> 条件2： A、B中存在函数 fun（fun_a、fun_b）：函数名、函数参数完全相同，返回值相同 或 为父子关系（fun_a 的返回值 是 fun_b的返回值的子类）\n> \n> 条件3： Class B 的 函数 有virtual修饰符\n> \n> 使用： 使用Class A 创建一个对象，赋值给B类型的变量； 调用 fun\n> \n> 结果： 调用结果为 Class A 定义的 fun_a\n\n这里用virtual标识的函数，又称 虚函数\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Pet\n{\npublic:\n Pet(int num)\n  : m_num(num) {}\n\n // 需要注意的是：类成员中存在一个虚函数，那析构函数一定要是虚函数\n // 这是一个编程习惯，后续有机会；再讲解\n virtual ~Pet() { } \n // 父类的 virtual 是必须的\n virtual void eat()\n {\n  cout << "宠物: " << this->m_num << " 在吃食物 " << endl;\n }\n\nprotected:\n int m_num;\n};\n\nclass Cat : public Pet\n{\npublic:\n Cat(int num)\n  : Pet(num) { }\n\n ~Cat() { }\n // 子类的 virtual 和 override 关键字可以省略； \n // virtual: 添加上增加可读性\n // override: 添加上可以帮助编译器做编译器检查\n virtual void eat() override\n {\n  cout << "猫: " << this->m_num << " 在吃食物 " << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n // 这里使用 Cat 类 创建一个 Pet类型 的 变量 pCat\n Pet* pCat = new Cat(2);\n pCat->eat();\n delete pCat;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n虽然 pCat类型是Pet，但是它的内存中存储的是 Cat类的对象；这时由于覆盖的特性，调用的是Cat类的函数\n\n结果：\n\n> 猫: 2 在吃食物\n\n\n# 综述\n\n重载（overload）：描述的是一个类的同名函数使用规则\n\n隐藏（hide）：描述的是父子类的同名函数，同名属性的使用规则\n\n覆盖（override）：描述的是父子类的虚函数使用规则\n\n呆呆在这里提醒：在正式的编程生产时，函数的隐藏（hide）特性是不被提倡的；\n\n> 即：子类不要有和父类相同名称的函数；\n> \n> > 解决方案：\n> > \n> >  1. 业务意义相同使用父类\n> > \n> >  2. 业务意义不相同，重命名；子类单独实现\n\n这会干扰编程设计，一个对象在不同的变量状态下，可能行为结果不同\n\n\n# 扩展认知\n\n多态还可以分为：\n\n变量多态：基础类型变量可以被赋值基础类型对象，也可以被赋值派生类型对象。\n\n函数多态：相同的函数调用（函数名和实参数表），传递给一个对象变量a，可以有不同的行为。行为由变量a的类型决定。\n\n也可以分为：\n\n动态多态：在运行期决定的多态，主要为通过虚继承的方式，实现父类，不同子类的实现不同；即override。\n\n静态多态：在编译期决定的多态\n\n> 静态多态分为：非参数化多态和参数化多态\n> \n> > 非参数化多态：函数重载，运算符重载；即overload\n> > \n> > 参数化多态：把类型做出参数的多态，泛型编程',normalizedContent:'首先，简单的认知一下类：c++不同于c的一种自定义类型的方式。\n\n类（class） 是 c++ 和 c 的最重要区别，c++ 的早期命名就是 c with class。\n\n类的存在给c++ 带来了面向对象，封装、继承、多态为类的三大特性。\n\n在学习class的具体使用方式前，我们必须先对面向对象的核心概念有大致的认知。大家可以通过：\n\n面向对象的核心概念：https://blog.addai.cn/pages/9ac8f7\n\n做一下概要认知，后面再通过代码理解。\n\n\n# 类的封装\n\n定义： 将抽象出的 数据、行为 进行有机结合；隐藏细节，指对外提供特定功能的接口 的动作\n\n封装可以分级向外提供访问权限：public、protected、private。\n\n要完成封装，需要做两件事：\n\n 1. 从实体猫中抽象 出我们需要的猫的行为和属性。\n\n 2. 将抽象的结果，转换为代码：类\n\n\n# 抽象\n\n定义: 从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程。 衡量特征是否为本质特征，要看编程的目的。\n\n举例：我们想看关注一群猫吃的动作\n\n这时我们的抽象：\n\n\n\n当我们只关注猫的吃这个动作时，猫的其他属性和动作对我们而言就没有意义了。\n\n\n# 类\n\n定义：类是抽象化后的成果。\n\n一般形式：\n\nclass 类名称\n{\npublic:\n  公开的行为定义[函数定义]\nprotected:\n  保护的行为定义[函数定义]\nprivate:\n  私有的行为定义[函数定义]\npublic:\n  公开的属性定义[变量定义]\nprotected:\n  保护的属性定义[变量定义]\nprivate:\n  私有的属性定义[变量定义]\n};  // 一定注意这里有一个`;`，实际编码中常见的错误；会导致一些无法预知的编译错误。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n关键字解读：\n\n> class：类定义关键字\n> \n> public、protected、private ：限定函数、属性的使用范围的关键字， 范围 public > protected > private\n> \n> 封装时范围说明：\n> \n> public：类内部可以访问、子类可访问、类外部可访问\n> \n> protected：类内部可以访问、子类可访问\n> \n> private：类内部可以访问\n> \n> 如果 类 声明时未使用范围的关键字进行标注 函数、属性； 默认为 private\n> \n> public、protected、private在继承上的使用，呆呆 会在下面 见继承中讲解\n\n例：上面的猫的抽象得到类\n\nclass cat   // 声明一个类\n{\npublic:\n void eat()\n {\n  cout << "猫:" << num << " 在吃鱼 " << endl;\n }\npublic:\n int num;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 对象\n\n定义：类的实例化结果就是对象。\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass cat\n{\npublic:\n void eat()\n {\n  cout << "猫:" << num << " 在吃鱼 " << endl;\n }\npublic:\n int num;\n};\n\nint main(int argc, char* argv[])\n{\n cat cat;    // 声明一个对象\n cat.num = 1;\n cat.eat();\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n> 猫:1 在吃鱼\n\n\n# this指针\n\nthis指针是类的成员函数的一个隐藏参数，处于形参链表的第一位;它指向当前类对象。\n\n例：\n\nclass cat\n{\npublic:\n void eat()\n {\n  cout << "猫:" << this->num << " 在吃鱼 " << endl;\n }\npublic:\n int num;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 构造函数 & 析构函数\n\n构造和析构是类中两个重要的概念；\n\n构造函数 ：用于初始化类对象，在对象初始化（new 或 直接对象创建）时调用。 析构函数 ：用于对象资源释放，在对象释放（delete 或 出作用域时对象直接释放）时调用。\n\n一般形式：\n\nclass classname\n{\npublic:\n  classname(参数列表) // 函数名 必须同类名\n    : 初始化列表      // 在初始化列表阶段，对象内存还没建立完成；this是不存在的\n  {\n    函数体            // this 可使用\n  }\n\n  ~ classname()      // 函数名 必须同类名; 同时 在前面加上 `~`\n  {\n    函数体            // this 可使用\n  }\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass cat\n{\npublic:\n cat(int num)\n  : m_num(num)\n {\n  cout << "猫: " << this->m_num << " 出生了" << endl;\n }\n\n ~cat()\n {\n  cout << "猫: " << this->m_num << " 嗝屁了" << endl;\n }\n\n void eat()\n {\n  cout << "猫: " << this->m_num << " 在吃鱼 " << endl;\n }\npublic:\n int m_num;\n};\n\nint main(int argc, char* argv[])\n{\n { // 添加作用域，让 cat析构\n  cat cat(1);\n  cat.eat();\n }\n\n cat *pcat = new cat(2);\n pcat->eat();\n delete pcat;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n结果：\n\n> 猫: 1 出生了\n> \n> 猫: 1 在吃鱼\n> \n> 猫: 1 嗝屁了\n> \n> 猫: 2 出生了\n> \n> 猫: 2 在吃鱼\n> \n> 猫: 2 嗝屁了\n\n\n# 类的继承\n\n定义： 描述父子类的关系，子类继承于父类；子类就是父类的一种特例，子类拥有父类的所有信息\n\n继承的方式一般有：public、protected、private\n\n一般形式：\n\nclass 子类 : public\\protected\\private 父类\n{\n 类实现;\n};\n\n\n1\n2\n3\n4\n\n\n关键词解释：\n\n> public、protected、private ：限定函数、属性的使用范围的关键字， 范围 public > protected > private\n> \n> 继承时时范围说明：\n> \n> 访问方式       public             protected   private\n> 子类访问父类     public、protected   public      无权限\n> 子类对象访问父类   public             无权限         无权限\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass pet\n{\npublic:\n pet(int num)\n  : m_num(num)\n {\n  cout << "宠物: " << this->getnum() << " 出生了" << endl;\n }\n\n ~pet()\n {\n  cout << "宠物: " << this->getnum() << " 嗝屁了" << endl;\n }\n\n void eat()\n {\n  cout << "宠物: " << this->m_num << " 在吃食物 " << endl;\n }\n\nprotected:\n int getnum()\n {\n  return m_num;\n }\n\nprivate:\n int m_num;\n};\n\n\nclass cat : public pet\n{\npublic:\n cat(int num)\n  : pet(num)\n {\n  cout << "猫: " << this->getnum() << " 出生了" << endl;\n }\n\n ~cat()\n {\n  cout << "猫: " << getnum() << " 嗝屁了" << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n { // 添加作用域，让 cat析构\n  cat cat(1);\n  cat.eat();\n }\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n结果：\n\n> 宠物: 1 出生了\n> \n> 猫: 1 出生了\n> \n> 宠物: 1 在吃食物\n> \n> 猫: 1 嗝屁了\n> \n> 宠物: 1 嗝屁了\n\n\n# 类的多态\n\n定义： 为不同数据类型的实体提供统一接口，并表现出不同的行为。多态是针对行为（函数）的知识\n\n一般认为多态有 ：重载(overload)、隐藏(hide)、覆盖(override) 三种情况\n\n呆呆这里还没有讲到内存结构，大家可能还不能很好的理解；这一节建议大家：一要看代码，二要自己写demo体会 后面将内存结构时，相信可以让大家豁然开朗\n\n\n# 重载（overload）\n\n定义：\n\n> 条件1： 同一个类中\n> \n> 条件2： 相同函数名\n> \n> 条件3： 参数不同(参数类型，或参数个数)\n> \n> 结果： 函数调用由传入参数决定\n\n例：\n\nclass cat\n{\npublic:\n cat(int num)\n  : m_num(num)\n {\n  cout << "猫: " << this->m_num << " 出生了" << endl;\n }\n\n ~cat()\n {\n  cout << "猫: " << this->m_num << " 嗝屁了" << endl;\n }\n\n void eat(int weight)\n {\n  cout << "(int)猫: " << this->m_num << " 吃了 " << weight << " kg 鱼 " << endl;\n }\n\n void eat(double weight)\n {\n  cout << "(double)猫: " << this->m_num << " 吃了 " << weight << " kg 鱼 " << endl;\n }\n\npublic:\n int m_num;\n};\n\nint main(int argc, char* argv[])\n{\n cat* pcat = new cat(2);\n pcat->eat(1);\n pcat->eat(1.3);\n delete pcat;\n\n return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n这里呆呆两次调用了eat方法，只是传入参数的类型不同；对应的结果也不相同。\n\n结果：\n\n> 猫: 2 出生了\n> \n> (int)猫: 2 吃了 1 kg 鱼\n> \n> (double)猫: 2 吃了 1.3 kg 鱼\n> \n> 猫: 2 嗝屁了\n\n这里可能会有疑问：如果是函数名、参数相同，返回值不同会是什么情况？\n\n呆呆这里需要提醒大家：在一个类中，c++类中不能声明两个 函数名和参数都相同的函数。\n\n\n# 隐藏 （hide）\n\n定义： 隐藏是子类对父类的一种覆盖隐藏的行为，对象是 同名的标识符（函数和属性）； 如果子类中存在和父类相同的标识符，且不构成覆盖（override），则是隐藏。\n\n# 属性隐藏\n\n> 条件1： 两个类呈 父子关系； class a 继承 class b\n> \n> 条件1： a、b 中存在同名属性： attitude\n> \n> 使用： 使用class a 创建一个对象，赋值给a类型的变量； 使用attitude\n> \n> 结果： 使用的是 a 中的 属性\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass pet\n{\npublic:\n pet(int num)\n  : m_num(num) {}\n\n ~pet() { }\n\npublic:\n int m_num;\n};\n\n\nclass cat : public pet\n{\npublic:\n cat(int num)\n  : pet(num)   // 父类的m_num 赋值为num\n  , m_num(100) // 子类的m_num 赋值为 100\n { }\n\n ~cat() { }\n\npublic:\n int m_num;\n};\n\nint main(int argc, char* argv[])\n{\n cat* pcat = new cat(2);  // 创建 cat对象赋值给 cat变量\n cout << pcat->m_num << endl;// 输出cat变量的m_num\n delete pcat;\n\n pet* ppet = new cat(2);  // 创建 cat对象赋值给 pet变量\n cout << ppet->m_num << endl;// 输出pet变量的m_num\n delete ppet;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n结果：\n\n> 100\n> \n> 2\n\n这里可以发现，父子类的属性都是存在内存中的；我们可以分别使用父子类的变量，去访问他们的属性\n\n# 行为隐藏（函数隐藏）\n\n> 条件1： 两个类呈 父子关系； class a 继承 class b\n> \n> 条件2： a、b 中存在同名函数： fun\n> \n> 条件3： a、b中的fun不呈覆盖逻辑\n> \n> 使用： 使用class a 创建一个对象，赋值给a类型的变量； 使用fun\n> \n> 结果： 使用的是 a 中的 函数\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass pet\n{\npublic:\n void eat() // 定义eat函数\n {\n  cout << "pet eat!!!" << endl;\n }\n};\n\n\nclass cat : public pet\n{\npublic:\n void eat(int num) // 子类声明了同名eat函数，就会隐藏父类eat\n {\n  cout << "cat eat!!!" << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n cat* pcat = new cat();\n // pcat->eat(); // eat() 函数被隐藏，无法被调用\n pcat->eat(1);\n delete pcat;\n\n pet* ppet = new cat();\n ppet->eat();\n delete ppet;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n结果：\n\n> cat eat!!!\n> \n> pet eat!!!\n\n\n# 覆盖 （override）\n\n定义：\n\n> 条件1： 两个类呈 父子关系； class a 继承 class b\n> \n> 条件2： a、b中存在函数 fun（fun_a、fun_b）：函数名、函数参数完全相同，返回值相同 或 为父子关系（fun_a 的返回值 是 fun_b的返回值的子类）\n> \n> 条件3： class b 的 函数 有virtual修饰符\n> \n> 使用： 使用class a 创建一个对象，赋值给b类型的变量； 调用 fun\n> \n> 结果： 调用结果为 class a 定义的 fun_a\n\n这里用virtual标识的函数，又称 虚函数\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass pet\n{\npublic:\n pet(int num)\n  : m_num(num) {}\n\n // 需要注意的是：类成员中存在一个虚函数，那析构函数一定要是虚函数\n // 这是一个编程习惯，后续有机会；再讲解\n virtual ~pet() { } \n // 父类的 virtual 是必须的\n virtual void eat()\n {\n  cout << "宠物: " << this->m_num << " 在吃食物 " << endl;\n }\n\nprotected:\n int m_num;\n};\n\nclass cat : public pet\n{\npublic:\n cat(int num)\n  : pet(num) { }\n\n ~cat() { }\n // 子类的 virtual 和 override 关键字可以省略； \n // virtual: 添加上增加可读性\n // override: 添加上可以帮助编译器做编译器检查\n virtual void eat() override\n {\n  cout << "猫: " << this->m_num << " 在吃食物 " << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n // 这里使用 cat 类 创建一个 pet类型 的 变量 pcat\n pet* pcat = new cat(2);\n pcat->eat();\n delete pcat;\n\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n虽然 pcat类型是pet，但是它的内存中存储的是 cat类的对象；这时由于覆盖的特性，调用的是cat类的函数\n\n结果：\n\n> 猫: 2 在吃食物\n\n\n# 综述\n\n重载（overload）：描述的是一个类的同名函数使用规则\n\n隐藏（hide）：描述的是父子类的同名函数，同名属性的使用规则\n\n覆盖（override）：描述的是父子类的虚函数使用规则\n\n呆呆在这里提醒：在正式的编程生产时，函数的隐藏（hide）特性是不被提倡的；\n\n> 即：子类不要有和父类相同名称的函数；\n> \n> > 解决方案：\n> > \n> >  1. 业务意义相同使用父类\n> > \n> >  2. 业务意义不相同，重命名；子类单独实现\n\n这会干扰编程设计，一个对象在不同的变量状态下，可能行为结果不同\n\n\n# 扩展认知\n\n多态还可以分为：\n\n变量多态：基础类型变量可以被赋值基础类型对象，也可以被赋值派生类型对象。\n\n函数多态：相同的函数调用（函数名和实参数表），传递给一个对象变量a，可以有不同的行为。行为由变量a的类型决定。\n\n也可以分为：\n\n动态多态：在运行期决定的多态，主要为通过虚继承的方式，实现父类，不同子类的实现不同；即override。\n\n静态多态：在编译期决定的多态\n\n> 静态多态分为：非参数化多态和参数化多态\n> \n> > 非参数化多态：函数重载，运算符重载；即overload\n> > \n> > 参数化多态：把类型做出参数的多态，泛型编程',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"C++抽象类接口",frontmatter:{title:"C++抽象类接口",date:"2023-02-02T15:51:42.000Z",permalink:"/pages/269843/",categories:["C++","基础语法"],tags:["接口","纯虚函数","C++接口"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/7.C++%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%8E%A5%E5%8F%A3.html",relativePath:"编程语言--C++/10.基础/7.C++抽象类接口.md",key:"v-0195be44",path:"/pages/269843/",headers:[{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:34},{level:2,title:"纯虚函数",slug:"纯虚函数",normalizedTitle:"纯虚函数",charIndex:104},{level:2,title:"C++的接口",slug:"c-的接口",normalizedTitle:"c++的接口",charIndex:95}],excerpt:'<p>呆呆上一章讲了<a href="https://blog.addai.cn/pages/a8b12f" target="_blank" rel="noopener noreferrer">封装、继承、多态<OutboundLink/></a>， 这里讲一个C++从别处借来的概念：<strong>接口</strong></p>\n<p>C++没有为接口定义其独特的关键字，但随着<strong>面向接口编程</strong>的提出，<strong>设计模式</strong>的推广；接口也成了一个编程中很重要的概念</p>\n<p>C++的接口是借用纯虚函数实现的，下面我们来了解一下C++的接口实现</p>\n<p><em>设计模式：大家有兴趣可以看看呆呆的另一个系列文章；<a href="https://blog.addai.cn/design/GoF/" target="_blank" rel="noopener noreferrer">设计模式<OutboundLink/></a></em></p>\n',headersStr:"接口 纯虚函数 C++的接口",content:'呆呆上一章讲了封装、继承、多态， 这里讲一个C++从别处借来的概念：接口\n\nC++没有为接口定义其独特的关键字，但随着面向接口编程的提出，设计模式的推广；接口也成了一个编程中很重要的概念\n\nC++的接口是借用纯虚函数实现的，下面我们来了解一下C++的接口实现\n\n设计模式：大家有兴趣可以看看呆呆的另一个系列文章；设计模式\n\n\n# 接口\n\n接口定义\n\n硬件类接口：指同一计算机不同功能层之间的通信规则称为接口\n\n软件类接口：指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。\n\n来自 百度百科\n\n由上可以发现：接口只定义规则，不能创建对象实现业务。\n\n呆呆对接口的理解\n\n对外：一个协议，用于和程序的其他部分通信; 告知程序的其他部分，这里的功能有什么\n\n对内：一个规则，用于告知所有的子类功能要做什么\n\n来自 呆呆\n\n\n# 纯虚函数\n\n一般形式：\n\nclass 类名\n{\n范围修饰符:\n virtual 返回值 函数名(参数列表) = 0; // 纯虚函数\n\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n如上：\n\n类中 一个函数 符合： 有 virtual修饰符、有“=0”、无函数实现体； 就是纯虚函数\n\n如果一个类中有纯虚函数，那么这个类就无法事例化\n\n\n# C++的接口\n\n依据接口的定义，可以用C++纯虚函数来完成：C++中接口的定义\n\n定义\n\n严格定义：如果一个类中的函数都是纯虚函数，这个类就是接口类\n\n宽松定义：如果一个类中的函数存在纯虚函数，这个类就是接口类\n\n相对而言，呆呆更偏向使用严格定义；这样能更好的使用面向接口编程的概念。宽松定义，更多的可能是对已有复杂代码的一种妥协。\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// 定义一个 Pet 接口\nclass Pet\n{\npublic:\n virtual ~Pet() {} // 虚析构 是必须的，防止内存泄漏\n virtual void eat() = 0; // 纯虚函数\n};\n\n// 实现一个Cat\nclass Cat : public Pet\n{\npublic:\n virtual void eat() override // 子类声明了同名eat函数，就会隐藏父类eat\n {\n  cout << "Cat eat!!!" << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n Pet* pPet = new Cat();\n pPet->eat();\n delete pPet;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n结果：\n\n> Cat eat!!!',normalizedContent:'呆呆上一章讲了封装、继承、多态， 这里讲一个c++从别处借来的概念：接口\n\nc++没有为接口定义其独特的关键字，但随着面向接口编程的提出，设计模式的推广；接口也成了一个编程中很重要的概念\n\nc++的接口是借用纯虚函数实现的，下面我们来了解一下c++的接口实现\n\n设计模式：大家有兴趣可以看看呆呆的另一个系列文章；设计模式\n\n\n# 接口\n\n接口定义\n\n硬件类接口：指同一计算机不同功能层之间的通信规则称为接口\n\n软件类接口：指对协定进行定义的引用类型。其他类型实现接口，以保证它们支持某些操作。接口指定必须由类提供的成员或实现它的其他接口。与类相似，接口可以包含方法、属性、索引器和事件作为成员。\n\n来自 百度百科\n\n由上可以发现：接口只定义规则，不能创建对象实现业务。\n\n呆呆对接口的理解\n\n对外：一个协议，用于和程序的其他部分通信; 告知程序的其他部分，这里的功能有什么\n\n对内：一个规则，用于告知所有的子类功能要做什么\n\n来自 呆呆\n\n\n# 纯虚函数\n\n一般形式：\n\nclass 类名\n{\n范围修饰符:\n virtual 返回值 函数名(参数列表) = 0; // 纯虚函数\n\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n如上：\n\n类中 一个函数 符合： 有 virtual修饰符、有“=0”、无函数实现体； 就是纯虚函数\n\n如果一个类中有纯虚函数，那么这个类就无法事例化\n\n\n# c++的接口\n\n依据接口的定义，可以用c++纯虚函数来完成：c++中接口的定义\n\n定义\n\n严格定义：如果一个类中的函数都是纯虚函数，这个类就是接口类\n\n宽松定义：如果一个类中的函数存在纯虚函数，这个类就是接口类\n\n相对而言，呆呆更偏向使用严格定义；这样能更好的使用面向接口编程的概念。宽松定义，更多的可能是对已有复杂代码的一种妥协。\n\n例：\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\n// 定义一个 pet 接口\nclass pet\n{\npublic:\n virtual ~pet() {} // 虚析构 是必须的，防止内存泄漏\n virtual void eat() = 0; // 纯虚函数\n};\n\n// 实现一个cat\nclass cat : public pet\n{\npublic:\n virtual void eat() override // 子类声明了同名eat函数，就会隐藏父类eat\n {\n  cout << "cat eat!!!" << endl;\n }\n};\n\nint main(int argc, char* argv[])\n{\n pet* ppet = new cat();\n ppet->eat();\n delete ppet;\n return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n结果：\n\n> cat eat!!!',charsets:{cjk:!0},lastUpdated:"2023/04/09, 15:45:01",lastUpdatedTimestamp:1681026301e3},{title:"C++头文件",frontmatter:{title:"C++头文件",date:"2023-02-14T15:51:59.000Z",permalink:"/pages/a79d76/",categories:["C++","基础语法"],tags:["头文件"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/8.C++%E5%A4%B4%E6%96%87%E4%BB%B6.html",relativePath:"编程语言--C++/10.基础/8.C++头文件.md",key:"v-336f3fe8",path:"/pages/a79d76/",headers:[{level:2,title:"头文件的作用",slug:"头文件的作用",normalizedTitle:"头文件的作用",charIndex:2},{level:3,title:"加强类型检查，提高类型安全性",slug:"加强类型检查-提高类型安全性",normalizedTitle:"加强类型检查，提高类型安全性",charIndex:217},{level:3,title:"减少公用代码的重复书写，提高编程效率",slug:"减少公用代码的重复书写-提高编程效率",normalizedTitle:"减少公用代码的重复书写，提高编程效率",charIndex:1e3},{level:3,title:"提供保密和代码重用的手段",slug:"提供保密和代码重用的手段",normalizedTitle:"提供保密和代码重用的手段",charIndex:1106},{level:2,title:"头文件的用法",slug:"头文件的用法",normalizedTitle:"头文件的用法",charIndex:1244},{level:3,title:"头文件的内容",slug:"头文件的内容",normalizedTitle:"头文件的内容",charIndex:1255},{level:3,title:"使用系统提供的头文件",slug:"使用系统提供的头文件",normalizedTitle:"使用系统提供的头文件",charIndex:1408},{level:3,title:"避免头文件被重复包含",slug:"避免头文件被重复包含",normalizedTitle:"避免头文件被重复包含",charIndex:2195},{level:2,title:"常用c++头文件",slug:"常用c-头文件",normalizedTitle:"常用c++头文件",charIndex:3527}],headersStr:"头文件的作用 加强类型检查，提高类型安全性 减少公用代码的重复书写，提高编程效率 提供保密和代码重用的手段 头文件的用法 头文件的内容 使用系统提供的头文件 避免头文件被重复包含 常用c++头文件",content:"# 头文件的作用\n\nC/C++ 编译采用分离编译模式。在一个项目中，有多个源文件存在，但是它们总会有一些相同的内容，比如 用户自定义类型、全局变量、全局函数的声明等。将这些内容抽取出来放到头文件中，提供给各个源文件包含，就可以避免相同内容的重复书写，提高编程效率和代码安全性。\n\n所以，设立头文件的主要目的是：提供全局变量、全局函数的声明或公用数据类型的定义，从而实现分离编译和代码复用。\n\n概括地说，头文件有如下三个作用：\n\n\n# 加强类型检查，提高类型安全性\n\n使用头文件，可有效地保证自定义类型的一致性。虽然，在语法上，同一个数据类型（如一个 class）在不同的源文件中书写多次是允许的，程序员认为他们是同一个自定义类型，但是，由于数据类型不具有外部连接特性，编译器并不关心该类型的多个版本之间是否一致，这样有可能会导致逻辑错误的发生。考察如下程序。\n\n//source1.cpp\n#include <iostream>\n\nclass A {\nprivate:\n\tchar num;\npublic:\n\tA();\n\tvoid show();\n};\n\nvoid A::show(){ std::cout<<num<<std::endl;}\n\nvoid see(A& a){a.show();}\n//end source1.cpp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n//source2.cpp\n#include <iostream>\n\nclass A {\nprivate:\n\tint num;\npublic:\n\tA(){num=5;};\n\tvoid show();\n};\n\nvoid see(A& a);\n\nint main() {\n\tA a;\n\tsee(a);\n}\n//end source2.cpp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这个程序能够顺利通过编译并正确的运行，在构成项目的两个源文件中，对class A的定义出现了一点小小的不一致。两个源文件中，成员变量num一个是char类型，一个是int类型，这就导致输出了一个特殊的字符。\n\n如果将 class A 的定义放到一个头文件中，用到class A的源文件都包含这个头文件，可以绝对保证数据类型的一致性和安全性。\n\n\n# 减少公用代码的重复书写，提高编程效率\n\n程序开发过程中，对某些数据类型或者接口进行修改是在所难免的，使用头文件，只需要修改头文件中的内容，就可以保证修改在所有源文件中生效，从而避免了繁琐易错的重复修改。\n\n\n# 提供保密和代码重用的手段\n\n头文件也是 C++ 代码重用机制中不可缺少的一种手段，在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制库即可。用户只需要按照头文件的接口声明来调用库函数，而不必关心接口的具体实现，编译器会从库中连接相应的实现代码。\n\n\n# 头文件的用法\n\n\n# 头文件的内容\n\n头文件包含的是多个源文件的公用内容，因此，全局函数原型声明、全局变量声明、自定义宏和类型等应该放在头文件中。规范的头文件允许被多个源文件包含而不会引发编译错误，所以全局变量的定义、外部变量的定义、全局函数的定义、在类体之外的类成员函数的定义等只能出现一次的内容不应该放在头文件中。\n\n\n# 使用系统提供的头文件\n\nC 语言提供的头文件都是以 .h 结尾的，如标准库头文件 stdio.h 等。C++ 语言最初的目的是成为一个“更好的 C”，所以 C++ 沿用了 C 头文件的命名习惯，将头文件后面加上 .h 标志。随着 C++ 语言的发展，C++ 加入了全新的标准库，为了避免与 C 发生冲突，C++ 引入了名字空间来避免名称冲突，也去掉了头文件的 .h 后缀。于是，在一段时间里，很多头文件有两个版本，一个以 .h 结尾，而另一则不是，如iostream.h（位于全局名字空间）和 iostream（位于名字空间 std）。程序员编写程序也有不同的选择，很多 C++ 源程序以这样的语句开始：\n\n#include <iostream.h>\n\n\n1\n\n\n而另一些，则以这样的两条语句开始：\n\n#include <iostream>\nusing namespace std;\n\n\n1\n2\n\n\n这种现象有些混乱，于是 C++ 标准委员会规定，旧 C 头文件（如 stdio.h）和 C++ 中新的 C 头文件（如 cstdio）继续使用，但是旧的 C++ 头文件（如 iostream.h）已被废弃，一律采用 C++ 新标准规定的头文件（如 iostream）。另外，在包含系统头文件的时候，应该使用尖括号（<>）而不是双引号（“”）。\n\n例如应该这样包含头文件 iostream：\n\n#include <iostream>\n\n\n1\n\n\n而不是这样：\n\n#include “iostream”\n\n\n1\n\n\n双引号“”用来包含自定义的头文件，用它来包含系统头文件是一种不良的编程习惯。原因是编译器遇到双引号包裹的头文件默认为用户自定义头文件，从项目目录下查找，查找不到才会到系统目录中查找，如果存在与系统头文件同名的用户自定义头文件，则会出现不符合预期的错误。\n\n\n# 避免头文件被重复包含\n\nC++ 中，如全局变量的定义、全局函数的定义等在项目中只能出现一次。有的可以出现多次，但在一个源文件中只能出现一次，如class的定义等，还有的在一个源文件中可以出现多次，如函数声明等。由于事先无法无法确定头文件的内容，应该避免在一个源文件中对同一头文件包含多次，以免引起重定义错误。考察如下程序。\n\n// header1.h\nclass A {\n\tint num;\npublic:\n\tA();\n\tvoid show();\n};\n// end header1.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// header2.h\n#include “header1.h”\nclass B {\n\tA a;\npublic:\n    void disp();\n};\n// end header2.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// main.cpp\n#include <iostream>\n#include “header1.h”\n#include “header2.h”\nA::A() {\n    num=5;\n}\nvoid A::show(){std::cout<<num<<std::endl;}\nint main() {\n\tA a;\n\ta.show();\n}\n// end main.cpp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个程序无法通过编译，原因是 class A 在源文件 main.cpp 中被定义了两次，这是由于头文件 header2.h 包含了 header.1，在源文件 main.cpp 包含了 header2.h，也包含了 header1.h，这就导致 header1.h 在main.cpp 中被包含了两次，也就造成了 class A 重复定义。\n\n一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入：\n\n#ifndef HEADER_NAME\n#define HEADER_NAME\n\n\n1\n2\n\n\n在头文件的结尾加上：\n\n#endif\n\n\n1\n\n\nHEADER_NAME 可以为任意内容，只要能够唯一标识当前头文件即可，建议使用头文件的名称。将这些条件编译预处理指令加入上面的示例程序中的两个头文件，问题即可解决。此外，也可以使用#paragma once预处理指令来实现，但这种方法并非所有编译器都支持，考虑到代码的可移植性，建议使用条件编译预处理指令。\n\n阅读以上示例代码，需要注意以下几点：\n\n（1）条件编译指令#ifndef HEADER_NAME和#endif的意思是：如果条件编译标志 HEADER_NAME 没有定义的话，则编译 #ifndef 和 #endif 之间的程序段，否则就忽略它。头文件 header1.h 只要被包含一次，条件编译标志宏 HEADER_NAME 就会被定义，这样就不会被再次包含\n\n（2）iostream 是标准库中的头文件，所以被包含时使用尖括号 <>，而 header1.h 和 header2.h 是用户自定义的头文件，被包含时使用双引号\n\n\n# 常用c++头文件\n\n#include <algorithm>//STL通用算法 \n#include <bitset> //STL位集容器 \n#include <cctype> //字符处理 \n#include <cerrno> //定义错误码 \n#include <clocale> //定义本地化函数 \n#include <cmath> //定义数学函数 \n#include <complex>//复数类 \n#include <cstdio> //定义输入输出函数 \n#include <cstdlib> //定义杂项函数内存分配函数 \n#include <cstring> //字符串处理 \n#include <ctime> //定义关于时间的函数 \n#include <deque> //STL双端队列容器 \n#include <exception> //异常处理类 \n#include <fstream> //文件输入或者输出 \n#include <functional>// STL定义运算函数(代替运算符) \n#include <limits> //定义各种数据类型最值常量 \n#include <list> //STL线性列表容器 \n#include <map> //STL映射容器 \n#include <iomanip>// 参数化输入输出 \n#include <ios>//基本输入输出支持 \n#include <iosfwd> //输入输出系统使用的前置声明 \n#include <iostream> //数据流输入数据流输出 \n#include <istream> //基本输入流 \n#include <ostream> //基本输出流 \n#include <queue> //STL队列送容器 \n#include <set> //STL集合容器 \n#include <sstream> //基于字符串的流 \n#include <stack> //STL堆栈容器 \n#include <stdexcept> //标准异常类 \n#include <streambuf> //底层输入输出支持 \n#include <string> //字符串类 \n#include <utility> //STL通用模板类 \n#include <vector>//STL动态数组容器 \n#include <cwchar>//宽字符处理及输入或者输出 \n#include <cwctype> //宽字符分类\n\n//C99\n#include <complex.h> //复数处理 \n#include <fenv.h> //浮点环境 \n#include <inttypes.h> //整数格式转换 \n#include <stdbool.h> //布尔环境 \n#include <stdint.h> //整数环境 \n#include <tgmath.h> //通用类型数学宏\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n参见网址：\n\nhttps://blog.csdn.net/K346K346/article/details/48877773\n\nhttps://blog.csdn.net/m0_55104619/article/details/127296602",normalizedContent:"# 头文件的作用\n\nc/c++ 编译采用分离编译模式。在一个项目中，有多个源文件存在，但是它们总会有一些相同的内容，比如 用户自定义类型、全局变量、全局函数的声明等。将这些内容抽取出来放到头文件中，提供给各个源文件包含，就可以避免相同内容的重复书写，提高编程效率和代码安全性。\n\n所以，设立头文件的主要目的是：提供全局变量、全局函数的声明或公用数据类型的定义，从而实现分离编译和代码复用。\n\n概括地说，头文件有如下三个作用：\n\n\n# 加强类型检查，提高类型安全性\n\n使用头文件，可有效地保证自定义类型的一致性。虽然，在语法上，同一个数据类型（如一个 class）在不同的源文件中书写多次是允许的，程序员认为他们是同一个自定义类型，但是，由于数据类型不具有外部连接特性，编译器并不关心该类型的多个版本之间是否一致，这样有可能会导致逻辑错误的发生。考察如下程序。\n\n//source1.cpp\n#include <iostream>\n\nclass a {\nprivate:\n\tchar num;\npublic:\n\ta();\n\tvoid show();\n};\n\nvoid a::show(){ std::cout<<num<<std::endl;}\n\nvoid see(a& a){a.show();}\n//end source1.cpp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n//source2.cpp\n#include <iostream>\n\nclass a {\nprivate:\n\tint num;\npublic:\n\ta(){num=5;};\n\tvoid show();\n};\n\nvoid see(a& a);\n\nint main() {\n\ta a;\n\tsee(a);\n}\n//end source2.cpp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这个程序能够顺利通过编译并正确的运行，在构成项目的两个源文件中，对class a的定义出现了一点小小的不一致。两个源文件中，成员变量num一个是char类型，一个是int类型，这就导致输出了一个特殊的字符。\n\n如果将 class a 的定义放到一个头文件中，用到class a的源文件都包含这个头文件，可以绝对保证数据类型的一致性和安全性。\n\n\n# 减少公用代码的重复书写，提高编程效率\n\n程序开发过程中，对某些数据类型或者接口进行修改是在所难免的，使用头文件，只需要修改头文件中的内容，就可以保证修改在所有源文件中生效，从而避免了繁琐易错的重复修改。\n\n\n# 提供保密和代码重用的手段\n\n头文件也是 c++ 代码重用机制中不可缺少的一种手段，在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制库即可。用户只需要按照头文件的接口声明来调用库函数，而不必关心接口的具体实现，编译器会从库中连接相应的实现代码。\n\n\n# 头文件的用法\n\n\n# 头文件的内容\n\n头文件包含的是多个源文件的公用内容，因此，全局函数原型声明、全局变量声明、自定义宏和类型等应该放在头文件中。规范的头文件允许被多个源文件包含而不会引发编译错误，所以全局变量的定义、外部变量的定义、全局函数的定义、在类体之外的类成员函数的定义等只能出现一次的内容不应该放在头文件中。\n\n\n# 使用系统提供的头文件\n\nc 语言提供的头文件都是以 .h 结尾的，如标准库头文件 stdio.h 等。c++ 语言最初的目的是成为一个“更好的 c”，所以 c++ 沿用了 c 头文件的命名习惯，将头文件后面加上 .h 标志。随着 c++ 语言的发展，c++ 加入了全新的标准库，为了避免与 c 发生冲突，c++ 引入了名字空间来避免名称冲突，也去掉了头文件的 .h 后缀。于是，在一段时间里，很多头文件有两个版本，一个以 .h 结尾，而另一则不是，如iostream.h（位于全局名字空间）和 iostream（位于名字空间 std）。程序员编写程序也有不同的选择，很多 c++ 源程序以这样的语句开始：\n\n#include <iostream.h>\n\n\n1\n\n\n而另一些，则以这样的两条语句开始：\n\n#include <iostream>\nusing namespace std;\n\n\n1\n2\n\n\n这种现象有些混乱，于是 c++ 标准委员会规定，旧 c 头文件（如 stdio.h）和 c++ 中新的 c 头文件（如 cstdio）继续使用，但是旧的 c++ 头文件（如 iostream.h）已被废弃，一律采用 c++ 新标准规定的头文件（如 iostream）。另外，在包含系统头文件的时候，应该使用尖括号（<>）而不是双引号（“”）。\n\n例如应该这样包含头文件 iostream：\n\n#include <iostream>\n\n\n1\n\n\n而不是这样：\n\n#include “iostream”\n\n\n1\n\n\n双引号“”用来包含自定义的头文件，用它来包含系统头文件是一种不良的编程习惯。原因是编译器遇到双引号包裹的头文件默认为用户自定义头文件，从项目目录下查找，查找不到才会到系统目录中查找，如果存在与系统头文件同名的用户自定义头文件，则会出现不符合预期的错误。\n\n\n# 避免头文件被重复包含\n\nc++ 中，如全局变量的定义、全局函数的定义等在项目中只能出现一次。有的可以出现多次，但在一个源文件中只能出现一次，如class的定义等，还有的在一个源文件中可以出现多次，如函数声明等。由于事先无法无法确定头文件的内容，应该避免在一个源文件中对同一头文件包含多次，以免引起重定义错误。考察如下程序。\n\n// header1.h\nclass a {\n\tint num;\npublic:\n\ta();\n\tvoid show();\n};\n// end header1.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// header2.h\n#include “header1.h”\nclass b {\n\ta a;\npublic:\n    void disp();\n};\n// end header2.h\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n// main.cpp\n#include <iostream>\n#include “header1.h”\n#include “header2.h”\na::a() {\n    num=5;\n}\nvoid a::show(){std::cout<<num<<std::endl;}\nint main() {\n\ta a;\n\ta.show();\n}\n// end main.cpp\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个程序无法通过编译，原因是 class a 在源文件 main.cpp 中被定义了两次，这是由于头文件 header2.h 包含了 header.1，在源文件 main.cpp 包含了 header2.h，也包含了 header1.h，这就导致 header1.h 在main.cpp 中被包含了两次，也就造成了 class a 重复定义。\n\n一个头文件被别的源文件重复包含是经常发生的，如何避免某个头文件被重复包含呢？利用条件编译轻松解决。在头文件的开始加入：\n\n#ifndef header_name\n#define header_name\n\n\n1\n2\n\n\n在头文件的结尾加上：\n\n#endif\n\n\n1\n\n\nheader_name 可以为任意内容，只要能够唯一标识当前头文件即可，建议使用头文件的名称。将这些条件编译预处理指令加入上面的示例程序中的两个头文件，问题即可解决。此外，也可以使用#paragma once预处理指令来实现，但这种方法并非所有编译器都支持，考虑到代码的可移植性，建议使用条件编译预处理指令。\n\n阅读以上示例代码，需要注意以下几点：\n\n（1）条件编译指令#ifndef header_name和#endif的意思是：如果条件编译标志 header_name 没有定义的话，则编译 #ifndef 和 #endif 之间的程序段，否则就忽略它。头文件 header1.h 只要被包含一次，条件编译标志宏 header_name 就会被定义，这样就不会被再次包含\n\n（2）iostream 是标准库中的头文件，所以被包含时使用尖括号 <>，而 header1.h 和 header2.h 是用户自定义的头文件，被包含时使用双引号\n\n\n# 常用c++头文件\n\n#include <algorithm>//stl通用算法 \n#include <bitset> //stl位集容器 \n#include <cctype> //字符处理 \n#include <cerrno> //定义错误码 \n#include <clocale> //定义本地化函数 \n#include <cmath> //定义数学函数 \n#include <complex>//复数类 \n#include <cstdio> //定义输入输出函数 \n#include <cstdlib> //定义杂项函数内存分配函数 \n#include <cstring> //字符串处理 \n#include <ctime> //定义关于时间的函数 \n#include <deque> //stl双端队列容器 \n#include <exception> //异常处理类 \n#include <fstream> //文件输入或者输出 \n#include <functional>// stl定义运算函数(代替运算符) \n#include <limits> //定义各种数据类型最值常量 \n#include <list> //stl线性列表容器 \n#include <map> //stl映射容器 \n#include <iomanip>// 参数化输入输出 \n#include <ios>//基本输入输出支持 \n#include <iosfwd> //输入输出系统使用的前置声明 \n#include <iostream> //数据流输入数据流输出 \n#include <istream> //基本输入流 \n#include <ostream> //基本输出流 \n#include <queue> //stl队列送容器 \n#include <set> //stl集合容器 \n#include <sstream> //基于字符串的流 \n#include <stack> //stl堆栈容器 \n#include <stdexcept> //标准异常类 \n#include <streambuf> //底层输入输出支持 \n#include <string> //字符串类 \n#include <utility> //stl通用模板类 \n#include <vector>//stl动态数组容器 \n#include <cwchar>//宽字符处理及输入或者输出 \n#include <cwctype> //宽字符分类\n\n//c99\n#include <complex.h> //复数处理 \n#include <fenv.h> //浮点环境 \n#include <inttypes.h> //整数格式转换 \n#include <stdbool.h> //布尔环境 \n#include <stdint.h> //整数环境 \n#include <tgmath.h> //通用类型数学宏\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n参见网址：\n\nhttps://blog.csdn.net/k346k346/article/details/48877773\n\nhttps://blog.csdn.net/m0_55104619/article/details/127296602",charsets:{cjk:!0},lastUpdated:"2023/04/09, 15:45:01",lastUpdatedTimestamp:1681026301e3},{title:"C++枚举和枚举类",frontmatter:{title:"C++枚举和枚举类",date:"2023-02-01T17:15:08.000Z",permalink:"/pages/8d1751/",categories:["C++","基础语法"],tags:["枚举","枚举类"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/10.%E5%9F%BA%E7%A1%80/9.C++%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB.html",relativePath:"编程语言--C++/10.基础/9.C++枚举和枚举类.md",key:"v-69e80c93",path:"/pages/8d1751/",headers:[{level:2,title:"enum 不限范围的枚举类型",slug:"enum-不限范围的枚举类型",normalizedTitle:"enum 不限范围的枚举类型",charIndex:142},{level:3,title:"局限",slug:"局限",normalizedTitle:"局限",charIndex:1562},{level:2,title:"enum class",slug:"enum-class",normalizedTitle:"enum class",charIndex:114}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">枚举</p>\n<p>定义：枚举（enumeration）是一个自定义类型的方式。</p>\n<p>作用：限定变量的取值范围为数个明确命名的常量（枚举项（enumerator））。</p>\n</div>\n<p>关键字：</p>\n<p>c++11 之前 <strong>enum</strong></p>\n<p>c++11 之后 <strong>enum</strong>, <strong>enum class</strong>, <strong>enum struct</strong></p>\n',headersStr:"enum 不限范围的枚举类型 局限 enum class",content:'枚举\n\n定义：枚举（enumeration）是一个自定义类型的方式。\n\n作用：限定变量的取值范围为数个明确命名的常量（枚举项（enumerator））。\n\n关键字：\n\nc++11 之前 enum\n\nc++11 之后 enum, enum class, enum struct\n\n\n# enum 不限范围的枚举类型\n\n一般形式1：\n\nenum 类型名 // 【类型名】 为新的数据类型；\n{\n  类型1,         // 【类型1】为符号常量，默认从0开始; 【类型1】= 0\n  类型2 = 常量表达式,    // 符号常量，也可以被表达式赋值； 【类型2】= 2\n  类型3          // 符号常量的值是顺延的；   【类型3】= 3\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n例：定义weekday 并使用\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nenum Weekday\n{\n  Mon,\n  Tues,\n  Wed,\n  Thur,\n  Fri,\n  Sat,\n  Sun\n};\n\nclass Cat\n{\npublic:\n void eat(Weekday day)\n {\n    switch (day)\n    {\n    case Mon:\n      cout << "This is Mon， I want fish;" << endl;\n      break;\n    case 1:\n      cout << "This is Tues， I want fish;" << endl;\n      break;\n    case Wed:\n      cout << "This is Wed， I want fish;" << endl;\n      break;\n    case Thur:\n      cout << "This is Thur， I want fish;" << endl;\n      break;\n    case Fri:\n      cout << "This is Fri， I want fish;" << endl;\n      break;\n    default:\n      cout << "I want fish, everyday!" << endl;\n      break;\n    }\n }\n};\n\nint main(int argc, char* argv[])\n{\n  Cat oCat;\n  oCat.eat(0);\n \n  oCat.eat(Weekday::Tues);\n \n  Weekday oDay1 = Wed;\n  oCat.eat(oDay1);\n \n  Weekday& oDay2 = oDay1;\n  oDay2 = Thur;\n  oCat.eat(oDay2);\n \n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n结果：\n\n> This is Mon， I want fish;\n> \n> This is Tues， I want fish;\n> \n> This is Wed， I want fish;\n> \n> This is Thur， I want fish;\n\n\n# 局限\n\n1、 enum的枚举类型是 C++98版本就引入的，呆呆之前说过 C++有作用域的概念，但在这里有点小特殊；我们发现可以在 main 函数中直接使用 Mon。\n\n这就意味着：枚举的声明已经突破了作用域的范围；一旦定义了枚举就无法定义同名类，同名变量。\n\n2、 隐式转换问题，由上代码事例可发现；枚举 和 int 可以无障碍的隐式转换；这可能让一些笔误逃过编译器的探查，导致一些未知的问题。\n\nps: 并不是每个编译器都可以正常的隐式转换，如果使用新版编译器，可减少对应错误\n\n\n# enum class\n\nenum class 是 C++11 提出的，可完美解决以上问题\n\n一般形式：\n\nenum class 类型名 // 【类型名】 为新的数据类型；\n{\n  类型1,         // 【类型1】为符号常量，默认从0开始; 【类型1】= 0\n  类型2 = 常量表达式,    // 符号常量，也可以被表达式赋值； 【类型2】= 2\n  类型3          // 符号常量的值是顺延的；   【类型3】= 3\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n例：\n\nenum class Weekday\n{\n  Mon,\n  Tues,\n  Wed,\n  Thur,\n  Fri,\n  Sat,\n  Sun\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于使用了 class 关键字，所以做类似其他类一样做前置申明\n\n总结，枚举类有以下3个优点：\n\n笔记\n\n1、降低命名空间污染\n\n2、避免发生隐式转换\n\n3、可以前置声明',normalizedContent:'枚举\n\n定义：枚举（enumeration）是一个自定义类型的方式。\n\n作用：限定变量的取值范围为数个明确命名的常量（枚举项（enumerator））。\n\n关键字：\n\nc++11 之前 enum\n\nc++11 之后 enum, enum class, enum struct\n\n\n# enum 不限范围的枚举类型\n\n一般形式1：\n\nenum 类型名 // 【类型名】 为新的数据类型；\n{\n  类型1,         // 【类型1】为符号常量，默认从0开始; 【类型1】= 0\n  类型2 = 常量表达式,    // 符号常量，也可以被表达式赋值； 【类型2】= 2\n  类型3          // 符号常量的值是顺延的；   【类型3】= 3\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n例：定义weekday 并使用\n\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nenum weekday\n{\n  mon,\n  tues,\n  wed,\n  thur,\n  fri,\n  sat,\n  sun\n};\n\nclass cat\n{\npublic:\n void eat(weekday day)\n {\n    switch (day)\n    {\n    case mon:\n      cout << "this is mon， i want fish;" << endl;\n      break;\n    case 1:\n      cout << "this is tues， i want fish;" << endl;\n      break;\n    case wed:\n      cout << "this is wed， i want fish;" << endl;\n      break;\n    case thur:\n      cout << "this is thur， i want fish;" << endl;\n      break;\n    case fri:\n      cout << "this is fri， i want fish;" << endl;\n      break;\n    default:\n      cout << "i want fish, everyday!" << endl;\n      break;\n    }\n }\n};\n\nint main(int argc, char* argv[])\n{\n  cat ocat;\n  ocat.eat(0);\n \n  ocat.eat(weekday::tues);\n \n  weekday oday1 = wed;\n  ocat.eat(oday1);\n \n  weekday& oday2 = oday1;\n  oday2 = thur;\n  ocat.eat(oday2);\n \n  return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n结果：\n\n> this is mon， i want fish;\n> \n> this is tues， i want fish;\n> \n> this is wed， i want fish;\n> \n> this is thur， i want fish;\n\n\n# 局限\n\n1、 enum的枚举类型是 c++98版本就引入的，呆呆之前说过 c++有作用域的概念，但在这里有点小特殊；我们发现可以在 main 函数中直接使用 mon。\n\n这就意味着：枚举的声明已经突破了作用域的范围；一旦定义了枚举就无法定义同名类，同名变量。\n\n2、 隐式转换问题，由上代码事例可发现；枚举 和 int 可以无障碍的隐式转换；这可能让一些笔误逃过编译器的探查，导致一些未知的问题。\n\nps: 并不是每个编译器都可以正常的隐式转换，如果使用新版编译器，可减少对应错误\n\n\n# enum class\n\nenum class 是 c++11 提出的，可完美解决以上问题\n\n一般形式：\n\nenum class 类型名 // 【类型名】 为新的数据类型；\n{\n  类型1,         // 【类型1】为符号常量，默认从0开始; 【类型1】= 0\n  类型2 = 常量表达式,    // 符号常量，也可以被表达式赋值； 【类型2】= 2\n  类型3          // 符号常量的值是顺延的；   【类型3】= 3\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n例：\n\nenum class weekday\n{\n  mon,\n  tues,\n  wed,\n  thur,\n  fri,\n  sat,\n  sun\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由于使用了 class 关键字，所以做类似其他类一样做前置申明\n\n总结，枚举类有以下3个优点：\n\n笔记\n\n1、降低命名空间污染\n\n2、避免发生隐式转换\n\n3、可以前置声明',charsets:{cjk:!0},lastUpdated:"2023/04/09, 15:45:01",lastUpdatedTimestamp:1681026301e3},{title:"深入理解：C++内存分配",frontmatter:{title:"深入理解：C++内存分配",date:"2023-01-08T23:07:46.000Z",permalink:"/pages/f2ea1e/",categories:["C++"],tags:["内存分配"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/20.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/10.%E8%AF%A6%E8%A7%A3%EF%BC%9AC++%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html",relativePath:"编程语言--C++/20.深入理解/10.详解：C++内存分配.md",key:"v-1211eca2",path:"/pages/f2ea1e/",headers:[{level:2,title:"什么是内存模型",slug:"什么是内存模型",normalizedTitle:"什么是内存模型",charIndex:111},{level:2,title:"内存的分类",slug:"内存的分类",normalizedTitle:"内存的分类",charIndex:235},{level:2,title:"各分区例程",slug:"各分区例程",normalizedTitle:"各分区例程",charIndex:924},{level:3,title:"全局/静态存储区",slug:"全局-静态存储区",normalizedTitle:"全局/静态存储区",charIndex:293},{level:3,title:"常量区",slug:"常量区",normalizedTitle:"常量区",charIndex:170},{level:3,title:"栈（Stack）区域",slug:"栈-stack-区域",normalizedTitle:"栈（stack）区域",charIndex:4685},{level:3,title:"堆（Heap）区域",slug:"堆-heap-区域",normalizedTitle:"堆（heap）区域",charIndex:7042},{level:3,title:"堆和栈的区别",slug:"堆和栈的区别",normalizedTitle:"堆和栈的区别",charIndex:7223},{level:3,title:"堆和自由存储区的区别",slug:"堆和自由存储区的区别",normalizedTitle:"堆和自由存储区的区别",charIndex:7520},{level:3,title:"malloc/free和new/delete的区别",slug:"malloc-free和new-delete的区别",normalizedTitle:"malloc/free和new/delete的区别",charIndex:7561},{level:3,title:"C++中new/delete的工作过程",slug:"c-中new-delete的工作过程",normalizedTitle:"c++中new/delete的工作过程",charIndex:7828},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:8557}],excerpt:"<p>程序一般都是在内存中跑的，这章主要讲c++程序运行时的内存分配问题。</p>\n<p>讲解包括：内存申请使用的关键字、各种变量在内存中的位置、程序代码在内存中的位置。</p>\n<p>这篇会从网络中多篇文档中汲取能量，如果未能罗列引用望海涵</p>\n",headersStr:"什么是内存模型 内存的分类 各分区例程 全局/静态存储区 常量区 栈（Stack）区域 堆（Heap）区域 堆和栈的区别 堆和自由存储区的区别 malloc/free和new/delete的区别 C++中new/delete的工作过程 参考文档",content:'程序一般都是在内存中跑的，这章主要讲c++程序运行时的内存分配问题。\n\n讲解包括：内存申请使用的关键字、各种变量在内存中的位置、程序代码在内存中的位置。\n\n这篇会从网络中多篇文档中汲取能量，如果未能罗列引用望海涵\n\n\n# 什么是内存模型\n\n内存模型就是一种语言它独特的管理者一套程序的机制\n\nC语言会将内存区域划分成堆、栈、静态全局变量区、常量区；\n\nC++则分为堆、栈、自由存储区、全局/静态变量区、常量存储区；\n\n划分的目的是为了能够方便编译器的管理和运行\n\n\n# 内存的分类\n\n分类标准      分区数量\n两大分区      代码区、数据区\n四大分区      代码区、全局区（全局/静态存储区）、栈区、堆区\nc语言分区     堆、栈、静态全局变量区、常量区\nc++语言分区   堆、栈、自由存储区、全局/静态变量区、常量存储区\n\n内存模型根据生命周期的不同分区 自由存储区、动态区、静态区 我们就按照C++语言的内存划分区域来讲解内存管理机制\n\n\n\n文本段（ELF）： 主要用于存放我们编写的代码，但是不是按照代码文本的形式存放，而是将代码文本编译成二进制代码，存放的是二进制代码，在编译时就已经确定这个区域存放的内容是什么了，并且这个区域是只读区域\n\nDATA段： 这个区域主要用于存放编译阶段（非运行阶段时）就能确定的数据，也就是初始化的静态变量、全局变量和常量，这个区域是可读可写的。这也就是我们通常说的静态存储区\n\nBSS段： 这个区域存放的是未曾初始化的静态变量、全局变量，但是不会存放常量，因为常量在定义的时候就一定会赋值了。未初始化的全局变量和静态变量，编译器在编译阶段都会将其默认为0\n\nHEAP（堆）： 这个区域实在运行时使用的，主要是用来存放程序员分配和释放内存，程序结束时操作系统会对其进行回收，（程序员分配内存像malloc、free、new、delete）都是在这个区域进行的\n\nSTACK（栈）： 存放函数的参数值和局部变量，这个区域的数据是由编译器来自己分配和释放的，只要执行完这个函数，那么这些参数值和变量都会被释放掉\n\n内核空间（env）环境变量： 这个区域是系统内部的区域，我们是不可编辑的\n\n\n# 各分区例程\n\n\n# 全局/静态存储区\n\n这个区域有两个段，分别是 BSS段 和 DATA段 ，均存放着全局变量和静态变量（包括全局静态变量和局部静态变量）\n\n其中 BSS存放的是程序员编写的未初始化的 全局变量 和 静态变量 而DATA存放已经初始化的全局变量、静态变量和常量。\n\n这其中C和C++的BSS还有区别，区别就是：C中的BSS段分为高地址和低地址，高地址是存放全局变量，低地址是存放静态未初始化\n\n#include<iostream>\nusing namespace std;\n\n/*定义全局变量*/\nint serven_1;                       // 定义未初始化的全局变量\nint serven_2 = 2;                   // 定义初始化的全局变量\n\nstatic int serven_3;                // 定义未初始化的静态变量\nstatic int serven_4 = 4;            // 定义初始化的静态变量\n\nint main(int argc, char *argv[])\n{\n    cout<<"BSS:"<<endl;\n    cout<<"The address of serven_1:"<<&serven_1<<", The data of serven_1:"<<serven_1<<endl;\n    cout<<"The address of serven_3:"<<&serven_3<<", The data of serven_3:"<<serven_3<<endl;\n\n    cout<<"DATA:"<<endl;\n    cout<<"The address of serven_2:"<<&serven_2<<", The data of serven_2:"<<serven_2<<endl;\n    cout<<"The address of serven_4:"<<&serven_4<<", The data of serven_4:"<<serven_4<<endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n运行结果：\n\nBSS:\nThe address of serven_1:00007FF7F3C2E180, The data of serven_1:0\nThe address of serven_3:00007FF7F3C2E184, The data of serven_3:0\nDATA:\nThe address of serven_2:00007FF7F3C2E000, The data of serven_2:2\nThe address of serven_4:00007FF7F3C2E004, The data of serven_4:4\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果分析： 程序定义了两个全局变量 serven_1 和 serven_2 ，两个静态变量 serven_3 和 serven_4 ，其中 serven_2 和 serven_4 是初始化的，所以 serven_1 和 serven_3 是存放在 BSS段 ，并且编译器会将这两个未初始化的变量默认初始化为 0 ；而 serven_2 和 serven_4 这两个变量是初始化的，存放在 DATA段\n\n\n# 常量区\n\n上面说到常量是存放在DATA段区域的，下面我们来看一下例子：\n\n#include<iostream>\nusing namespace std;\n\n/*定于全局常量*/\nconst char* serven_5 ="serven";\n\nint main(int argc, char *argv[])\n{\n    const char* serven_6 ="serven";\n    char * serven_7 = "serven";\n    char * serven_8 = serven_7;\n    char s[]="serven";\n    char s2[]="serven";\n    s[1]=\'1\';\n    *s=\'1\';\n    cout<<"The address of serven_5:"<<&serven_5<<", The data of serven_5:"<<serven_5<<endl;\n    cout<<"The address of serven_6:"<<&serven_6<<", The data of serven_6:"<<serven_6<<endl;\n    cout<<"The address of serven_7:"<<&serven_7<<", The data of serven_7:"<<serven_7<<endl;\n    cout<<"The address of serven_8:"<<&serven_8<<", The data of serven_8:"<<serven_8<<endl;\n\n    cout<<"The address of s:"<<s<<", The data of s:"<<s<<endl;\n    cout<<"The address of s2:"<<s2<<", The data of s2:"<<s2<<endl;\n\n    printf("The Pointer of serven_5 :%p\\n",serven_5);\n    printf("The Pointer of serven_6 :%p\\n",serven_6);\n    printf("The Pointer of serven_7 :%p\\n",serven_7);\n    printf("The Pointer of serven_8 :%p\\n",serven_8);\n    printf("The Pointer of s :%p\\n",s);\n    printf("The Pointer of s2 :%p\\n",s2);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nRelease 运行结果：\n\nThe address of serven_5:00007FF6558F5008, The data of serven_5:serven\nThe address of serven_6:00000096D82FFE60, The data of serven_6:serven\nThe address of serven_7:00000096D82FFE68, The data of serven_7:serven\nThe address of serven_8:00000096D82FFE70, The data of serven_8:serven\nThe address of s:11rven, The data of s:11rven\nThe address of s2:serven, The data of s2:serven\nThe Pointer of serven_5 :00007FF6558F32B0\nThe Pointer of serven_6 :00007FF6558F32B0\nThe Pointer of serven_7 :00007FF6558F32B0\nThe Pointer of serven_8 :00007FF6558F32B0\nThe Pointer of s :00000096D82FFE78\nThe Pointer of s2 :00000096D82FFE80\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里需要注意的是上面的结果是release的输出，debug的结果并不一定相同。\n\n结果解析：\n\n变量 serven_5 是常量，存储在 DATA段 区域， serven_6 是局部的常量、 serven_7 和 serven_8 是局部的变量指针，他们都是指向一个常量 “serven”，这个常量存储在常量区的，也就是存储在DATA区域，可以看到在后面打印serven_5~serven_8的时候的地址都是一样的，都是存储在DATA区域。\n\n而 s 和 s2 是局部变量，存储在栈区域，可以看到代码中打印出来的指针都是在栈区域里面。\n\n总结就是： s 和 s2 是定义在局部函数里面的变量，所以存放在栈区域，serven_6 ~ serven_8 是定义在局部里面的指针，指向的是常量，所以指向的常量存放在DATA区域，而指针本身存放在栈中\n\n\n# 栈（Stack）区域\n\n栈区域是编译器自动根据变量进行分配的，不是由程序员进行开辟的，所以编译器即会自动分配也会将其释放，这个区域主要存放函数的参数值、局部变量、形参等等。\n\n#include<iostream>\nusing namespace std;\n\nvoid TEST(int ser_x, int ser_y, int ser_z){\n    int serven_9 = 9;\n    int serven_10 = 10;\n    int serven_11 = 11;\n    printf("The Pointer of ser_x is: %p\\n",&ser_x);\n    printf("The Pointer of ser_y is: %p\\n",&ser_y);\n    printf("The Pointer of ser_z is: %p\\n",&ser_z);\n    printf("The Pointer of serven_9(TEST) is: %p\\n",&serven_9);\n    printf("The Pointer of serven_10(TEST) is: %p\\n",&serven_10);\n    printf("The Pointer of serven_11(TEST) is: %p\\n",&serven_11);\n}\n\nint main(int argc, char *argv[])\n{\n    int serven_9 = 9;\n    int serven_10 = 10;\n    int serven_11 = 11;\n\n    printf("The Pointer of serven_9(MAIN) is: %p\\n",&serven_9);\n    printf("The Pointer of serven_10(MAIN) is: %p\\n",&serven_10);\n    printf("The Pointer of serven_11(MAIN) is: %p\\n",&serven_11);\n    TEST(serven_9, serven_10,serven_11);\n\n    int serven_12 = 12;\n    printf("The Pointer of serven_12 is: %p\\n",&serven_12);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nDebug 运行结果：\n\nThe Pointer of serven_9(MAIN) is: 0000002338fff9ac\nThe Pointer of serven_10(MAIN) is: 0000002338fff9a8\nThe Pointer of serven_11(MAIN) is: 0000002338fff9a4\nThe Pointer of ser_x is: 0000002338fff980\nThe Pointer of ser_y is: 0000002338fff988\nThe Pointer of ser_z is: 0000002338fff990\nThe Pointer of serven_9(TEST) is: 0000002338fff96c\nThe Pointer of serven_10(TEST) is: 0000002338fff968\nThe Pointer of serven_11(TEST) is: 0000002338fff964\nThe Pointer of serven_12(MAIN) is: 0000002338fff9a0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里注意：release版本，对局部变量有优化，结果就不同了\n\n结果解析： 首先我们先来看一下这个图，是内存管理机制里面的栈，可以看到main函数中定义的变量serven_9 ~ serven_11分别入栈，而且入栈的顺序是从高地址到低地址，每个变量占用4个字节，所以地址相差也就是4个字节\n\n然后就是形参入栈，形参入栈顺序是从右往左入栈，所以ser_z~ser_x的地址也是依次递减的\n\n最后就是TEST函数里面的局部变量，将局部变量serven_9 ~ serven_11依次入栈，并且地址也是一次递减\n\n而且可以看到serven_12的地址和serven_11是隔壁，由此可以看出，栈的先进后出，也就是调用完函数TEST后会把局部变量serven_11（TEST）~serven_9（TEST）、serv_x~ser_z全部出栈，然后再将serven_12入栈。\n\n\n\n但是，我们可以发现了定义serven_11之后的调用函数，函数的形参入栈的地址与serven_11定义时的地址相差很远，大概有三个字节，这三个字节中有一个是serven_11，那么多出来两个字节是什么呢？\n\n这是因为在调用函数的时候会进行一些操作：\n\n首先我们需要了解几个概念：栈帧、寄存器esp、寄存器ebp\n\n栈帧:每个函数有自己的栈帧，栈帧中维持着所需要的各种信息（包括参数、返回地址、参数个数、其它） 寄存器esp: 保存当前栈帧的栈顶 寄存器ebp: 保存当前栈帧的栈底\n\n那么函数在栈入参时候的结构为：\n\n函数的局部变量：（ebp）最右参数->中间参数->最左参数->返回地址->运行时参数（esp）；\n\n\n# 堆（Heap）区域\n\n这个区域是由程序员来进行分配内存和释放内存用的，当我们使用malloc/free、new/delete（这是在自由存储区上分配和释放的，某种意义上来说呢，起始自由存储区是堆的一个子集）。\n\n在这里要注意的是，我们申请了空间内存一定要释放，如果没有释放那就会导致内存的泄露，后果很严重！！！你遇到过的电脑蓝屏也许就是内存泄漏引起的。\n\n\n# 堆和栈的区别\n\n比较类别   堆                           栈\n管理方式   由程序员分配和释放                   编译器自动管理\n空间大小   最大可达4GB                     空间有限\n产生碎片   会造成空间碎片                     不会\n生长方向   向上生长（低地址-高地址）               向下生长（高地址-低地址）\n分配方式   malloc、new、calloc、realloc   编译器管理\n分配效率   低                           高\n\n\n# 堆和自由存储区的区别\n\n自由存储区其实上是一个逻辑概念\n\n堆是物理概念。\n\n\n# malloc/free和new/delete的区别\n\n（1）new、delete是C++中的操作符，而malloc和free是标准库函数。操作符可以在类的内部重载，malloc/free不行，唯一的关联只是在默认情况下new/delete调用malloc/free\n\n（2）malloc/free(只是分配内存，不能执行构造函数，不能执行析构函数)，new/free。\n\n（3）new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。\n\n\n# C++中new/delete的工作过程\n\n申请的是普通的内置类型的空间：\n\n（1）调用 C++标准库中 operator new函数，传入大小。（如果申请的是0byte则强制转化成1byte）\n\n（2）申请相对应的空间，如果没有足够的空间或其他问题且没有定义_new_hanlder，那么会抛出bad_alloc的异常并结束程序,如果定义了_new_hanlder回调函数，那么会一直不停的调用这个函数直到问题被解决为止\n\n（3）返回申请到的内存的首地址.\n\n申请的是类空间：\n\n（1）如果是申请的是0byte，强制转换为1byte\n\n（2）申请相对应的空间，如果没有足够的空间或其他问题且没有定义_new_hanlder，那么会抛出bad_alloc的异常并结束程序\n\n（3）如果定义了_new_hanlder回调函数，那么会一直不停的调用这个函数直到问题被解决为止。\n\n（4）如果这个类没有定义任何构造函数，析构函数，且编译器没有合成，那么下面的步骤跟申请普通的内置类型是一样的。\n\n（5）如果有构造函数或者析构函数，那么会调用一个库函数，具体什么库函数依编译器不同而不同，这个库函数会回调类的构造函数。\n\n（6）如果在构造函数中发生异常，那么会释放刚刚申请的空间并返回异常\n\n（7）返回申请到的内存的首地址\n\ndelete 与new相反，会先调用析构函数再去释放内存（delete 实际调用 operator delete）\n\noperator new[]的形参是 sizeof(T)*N+4就是总大小加上一个4(用来保存个数);空间中前四个字节保存填充长度。然后执行N次operator new\n\noperator delete[] 类似；\n\n\n# 参考文档\n\nhttps://zhuanlan.zhihu.com/p/434850899\n\nhttps://blog.csdn.net/weixin_43340455/article/details/124786128',normalizedContent:'程序一般都是在内存中跑的，这章主要讲c++程序运行时的内存分配问题。\n\n讲解包括：内存申请使用的关键字、各种变量在内存中的位置、程序代码在内存中的位置。\n\n这篇会从网络中多篇文档中汲取能量，如果未能罗列引用望海涵\n\n\n# 什么是内存模型\n\n内存模型就是一种语言它独特的管理者一套程序的机制\n\nc语言会将内存区域划分成堆、栈、静态全局变量区、常量区；\n\nc++则分为堆、栈、自由存储区、全局/静态变量区、常量存储区；\n\n划分的目的是为了能够方便编译器的管理和运行\n\n\n# 内存的分类\n\n分类标准      分区数量\n两大分区      代码区、数据区\n四大分区      代码区、全局区（全局/静态存储区）、栈区、堆区\nc语言分区     堆、栈、静态全局变量区、常量区\nc++语言分区   堆、栈、自由存储区、全局/静态变量区、常量存储区\n\n内存模型根据生命周期的不同分区 自由存储区、动态区、静态区 我们就按照c++语言的内存划分区域来讲解内存管理机制\n\n\n\n文本段（elf）： 主要用于存放我们编写的代码，但是不是按照代码文本的形式存放，而是将代码文本编译成二进制代码，存放的是二进制代码，在编译时就已经确定这个区域存放的内容是什么了，并且这个区域是只读区域\n\ndata段： 这个区域主要用于存放编译阶段（非运行阶段时）就能确定的数据，也就是初始化的静态变量、全局变量和常量，这个区域是可读可写的。这也就是我们通常说的静态存储区\n\nbss段： 这个区域存放的是未曾初始化的静态变量、全局变量，但是不会存放常量，因为常量在定义的时候就一定会赋值了。未初始化的全局变量和静态变量，编译器在编译阶段都会将其默认为0\n\nheap（堆）： 这个区域实在运行时使用的，主要是用来存放程序员分配和释放内存，程序结束时操作系统会对其进行回收，（程序员分配内存像malloc、free、new、delete）都是在这个区域进行的\n\nstack（栈）： 存放函数的参数值和局部变量，这个区域的数据是由编译器来自己分配和释放的，只要执行完这个函数，那么这些参数值和变量都会被释放掉\n\n内核空间（env）环境变量： 这个区域是系统内部的区域，我们是不可编辑的\n\n\n# 各分区例程\n\n\n# 全局/静态存储区\n\n这个区域有两个段，分别是 bss段 和 data段 ，均存放着全局变量和静态变量（包括全局静态变量和局部静态变量）\n\n其中 bss存放的是程序员编写的未初始化的 全局变量 和 静态变量 而data存放已经初始化的全局变量、静态变量和常量。\n\n这其中c和c++的bss还有区别，区别就是：c中的bss段分为高地址和低地址，高地址是存放全局变量，低地址是存放静态未初始化\n\n#include<iostream>\nusing namespace std;\n\n/*定义全局变量*/\nint serven_1;                       // 定义未初始化的全局变量\nint serven_2 = 2;                   // 定义初始化的全局变量\n\nstatic int serven_3;                // 定义未初始化的静态变量\nstatic int serven_4 = 4;            // 定义初始化的静态变量\n\nint main(int argc, char *argv[])\n{\n    cout<<"bss:"<<endl;\n    cout<<"the address of serven_1:"<<&serven_1<<", the data of serven_1:"<<serven_1<<endl;\n    cout<<"the address of serven_3:"<<&serven_3<<", the data of serven_3:"<<serven_3<<endl;\n\n    cout<<"data:"<<endl;\n    cout<<"the address of serven_2:"<<&serven_2<<", the data of serven_2:"<<serven_2<<endl;\n    cout<<"the address of serven_4:"<<&serven_4<<", the data of serven_4:"<<serven_4<<endl;\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n运行结果：\n\nbss:\nthe address of serven_1:00007ff7f3c2e180, the data of serven_1:0\nthe address of serven_3:00007ff7f3c2e184, the data of serven_3:0\ndata:\nthe address of serven_2:00007ff7f3c2e000, the data of serven_2:2\nthe address of serven_4:00007ff7f3c2e004, the data of serven_4:4\n\n\n1\n2\n3\n4\n5\n6\n\n\n结果分析： 程序定义了两个全局变量 serven_1 和 serven_2 ，两个静态变量 serven_3 和 serven_4 ，其中 serven_2 和 serven_4 是初始化的，所以 serven_1 和 serven_3 是存放在 bss段 ，并且编译器会将这两个未初始化的变量默认初始化为 0 ；而 serven_2 和 serven_4 这两个变量是初始化的，存放在 data段\n\n\n# 常量区\n\n上面说到常量是存放在data段区域的，下面我们来看一下例子：\n\n#include<iostream>\nusing namespace std;\n\n/*定于全局常量*/\nconst char* serven_5 ="serven";\n\nint main(int argc, char *argv[])\n{\n    const char* serven_6 ="serven";\n    char * serven_7 = "serven";\n    char * serven_8 = serven_7;\n    char s[]="serven";\n    char s2[]="serven";\n    s[1]=\'1\';\n    *s=\'1\';\n    cout<<"the address of serven_5:"<<&serven_5<<", the data of serven_5:"<<serven_5<<endl;\n    cout<<"the address of serven_6:"<<&serven_6<<", the data of serven_6:"<<serven_6<<endl;\n    cout<<"the address of serven_7:"<<&serven_7<<", the data of serven_7:"<<serven_7<<endl;\n    cout<<"the address of serven_8:"<<&serven_8<<", the data of serven_8:"<<serven_8<<endl;\n\n    cout<<"the address of s:"<<s<<", the data of s:"<<s<<endl;\n    cout<<"the address of s2:"<<s2<<", the data of s2:"<<s2<<endl;\n\n    printf("the pointer of serven_5 :%p\\n",serven_5);\n    printf("the pointer of serven_6 :%p\\n",serven_6);\n    printf("the pointer of serven_7 :%p\\n",serven_7);\n    printf("the pointer of serven_8 :%p\\n",serven_8);\n    printf("the pointer of s :%p\\n",s);\n    printf("the pointer of s2 :%p\\n",s2);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nrelease 运行结果：\n\nthe address of serven_5:00007ff6558f5008, the data of serven_5:serven\nthe address of serven_6:00000096d82ffe60, the data of serven_6:serven\nthe address of serven_7:00000096d82ffe68, the data of serven_7:serven\nthe address of serven_8:00000096d82ffe70, the data of serven_8:serven\nthe address of s:11rven, the data of s:11rven\nthe address of s2:serven, the data of s2:serven\nthe pointer of serven_5 :00007ff6558f32b0\nthe pointer of serven_6 :00007ff6558f32b0\nthe pointer of serven_7 :00007ff6558f32b0\nthe pointer of serven_8 :00007ff6558f32b0\nthe pointer of s :00000096d82ffe78\nthe pointer of s2 :00000096d82ffe80\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这里需要注意的是上面的结果是release的输出，debug的结果并不一定相同。\n\n结果解析：\n\n变量 serven_5 是常量，存储在 data段 区域， serven_6 是局部的常量、 serven_7 和 serven_8 是局部的变量指针，他们都是指向一个常量 “serven”，这个常量存储在常量区的，也就是存储在data区域，可以看到在后面打印serven_5~serven_8的时候的地址都是一样的，都是存储在data区域。\n\n而 s 和 s2 是局部变量，存储在栈区域，可以看到代码中打印出来的指针都是在栈区域里面。\n\n总结就是： s 和 s2 是定义在局部函数里面的变量，所以存放在栈区域，serven_6 ~ serven_8 是定义在局部里面的指针，指向的是常量，所以指向的常量存放在data区域，而指针本身存放在栈中\n\n\n# 栈（stack）区域\n\n栈区域是编译器自动根据变量进行分配的，不是由程序员进行开辟的，所以编译器即会自动分配也会将其释放，这个区域主要存放函数的参数值、局部变量、形参等等。\n\n#include<iostream>\nusing namespace std;\n\nvoid test(int ser_x, int ser_y, int ser_z){\n    int serven_9 = 9;\n    int serven_10 = 10;\n    int serven_11 = 11;\n    printf("the pointer of ser_x is: %p\\n",&ser_x);\n    printf("the pointer of ser_y is: %p\\n",&ser_y);\n    printf("the pointer of ser_z is: %p\\n",&ser_z);\n    printf("the pointer of serven_9(test) is: %p\\n",&serven_9);\n    printf("the pointer of serven_10(test) is: %p\\n",&serven_10);\n    printf("the pointer of serven_11(test) is: %p\\n",&serven_11);\n}\n\nint main(int argc, char *argv[])\n{\n    int serven_9 = 9;\n    int serven_10 = 10;\n    int serven_11 = 11;\n\n    printf("the pointer of serven_9(main) is: %p\\n",&serven_9);\n    printf("the pointer of serven_10(main) is: %p\\n",&serven_10);\n    printf("the pointer of serven_11(main) is: %p\\n",&serven_11);\n    test(serven_9, serven_10,serven_11);\n\n    int serven_12 = 12;\n    printf("the pointer of serven_12 is: %p\\n",&serven_12);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ndebug 运行结果：\n\nthe pointer of serven_9(main) is: 0000002338fff9ac\nthe pointer of serven_10(main) is: 0000002338fff9a8\nthe pointer of serven_11(main) is: 0000002338fff9a4\nthe pointer of ser_x is: 0000002338fff980\nthe pointer of ser_y is: 0000002338fff988\nthe pointer of ser_z is: 0000002338fff990\nthe pointer of serven_9(test) is: 0000002338fff96c\nthe pointer of serven_10(test) is: 0000002338fff968\nthe pointer of serven_11(test) is: 0000002338fff964\nthe pointer of serven_12(main) is: 0000002338fff9a0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里注意：release版本，对局部变量有优化，结果就不同了\n\n结果解析： 首先我们先来看一下这个图，是内存管理机制里面的栈，可以看到main函数中定义的变量serven_9 ~ serven_11分别入栈，而且入栈的顺序是从高地址到低地址，每个变量占用4个字节，所以地址相差也就是4个字节\n\n然后就是形参入栈，形参入栈顺序是从右往左入栈，所以ser_z~ser_x的地址也是依次递减的\n\n最后就是test函数里面的局部变量，将局部变量serven_9 ~ serven_11依次入栈，并且地址也是一次递减\n\n而且可以看到serven_12的地址和serven_11是隔壁，由此可以看出，栈的先进后出，也就是调用完函数test后会把局部变量serven_11（test）~serven_9（test）、serv_x~ser_z全部出栈，然后再将serven_12入栈。\n\n\n\n但是，我们可以发现了定义serven_11之后的调用函数，函数的形参入栈的地址与serven_11定义时的地址相差很远，大概有三个字节，这三个字节中有一个是serven_11，那么多出来两个字节是什么呢？\n\n这是因为在调用函数的时候会进行一些操作：\n\n首先我们需要了解几个概念：栈帧、寄存器esp、寄存器ebp\n\n栈帧:每个函数有自己的栈帧，栈帧中维持着所需要的各种信息（包括参数、返回地址、参数个数、其它） 寄存器esp: 保存当前栈帧的栈顶 寄存器ebp: 保存当前栈帧的栈底\n\n那么函数在栈入参时候的结构为：\n\n函数的局部变量：（ebp）最右参数->中间参数->最左参数->返回地址->运行时参数（esp）；\n\n\n# 堆（heap）区域\n\n这个区域是由程序员来进行分配内存和释放内存用的，当我们使用malloc/free、new/delete（这是在自由存储区上分配和释放的，某种意义上来说呢，起始自由存储区是堆的一个子集）。\n\n在这里要注意的是，我们申请了空间内存一定要释放，如果没有释放那就会导致内存的泄露，后果很严重！！！你遇到过的电脑蓝屏也许就是内存泄漏引起的。\n\n\n# 堆和栈的区别\n\n比较类别   堆                           栈\n管理方式   由程序员分配和释放                   编译器自动管理\n空间大小   最大可达4gb                     空间有限\n产生碎片   会造成空间碎片                     不会\n生长方向   向上生长（低地址-高地址）               向下生长（高地址-低地址）\n分配方式   malloc、new、calloc、realloc   编译器管理\n分配效率   低                           高\n\n\n# 堆和自由存储区的区别\n\n自由存储区其实上是一个逻辑概念\n\n堆是物理概念。\n\n\n# malloc/free和new/delete的区别\n\n（1）new、delete是c++中的操作符，而malloc和free是标准库函数。操作符可以在类的内部重载，malloc/free不行，唯一的关联只是在默认情况下new/delete调用malloc/free\n\n（2）malloc/free(只是分配内存，不能执行构造函数，不能执行析构函数)，new/free。\n\n（3）new返回的是指定类型的指针，并且可以自动计算所申请内存的大小。而 malloc需要我们计算申请内存的大小，并且在返回时强行转换为实际类型的指针。\n\n\n# c++中new/delete的工作过程\n\n申请的是普通的内置类型的空间：\n\n（1）调用 c++标准库中 operator new函数，传入大小。（如果申请的是0byte则强制转化成1byte）\n\n（2）申请相对应的空间，如果没有足够的空间或其他问题且没有定义_new_hanlder，那么会抛出bad_alloc的异常并结束程序,如果定义了_new_hanlder回调函数，那么会一直不停的调用这个函数直到问题被解决为止\n\n（3）返回申请到的内存的首地址.\n\n申请的是类空间：\n\n（1）如果是申请的是0byte，强制转换为1byte\n\n（2）申请相对应的空间，如果没有足够的空间或其他问题且没有定义_new_hanlder，那么会抛出bad_alloc的异常并结束程序\n\n（3）如果定义了_new_hanlder回调函数，那么会一直不停的调用这个函数直到问题被解决为止。\n\n（4）如果这个类没有定义任何构造函数，析构函数，且编译器没有合成，那么下面的步骤跟申请普通的内置类型是一样的。\n\n（5）如果有构造函数或者析构函数，那么会调用一个库函数，具体什么库函数依编译器不同而不同，这个库函数会回调类的构造函数。\n\n（6）如果在构造函数中发生异常，那么会释放刚刚申请的空间并返回异常\n\n（7）返回申请到的内存的首地址\n\ndelete 与new相反，会先调用析构函数再去释放内存（delete 实际调用 operator delete）\n\noperator new[]的形参是 sizeof(t)*n+4就是总大小加上一个4(用来保存个数);空间中前四个字节保存填充长度。然后执行n次operator new\n\noperator delete[] 类似；\n\n\n# 参考文档\n\nhttps://zhuanlan.zhihu.com/p/434850899\n\nhttps://blog.csdn.net/weixin_43340455/article/details/124786128',charsets:{cjk:!0},lastUpdated:"2023/04/11, 22:32:26",lastUpdatedTimestamp:1681223546e3},{title:"深入理解：变量、引用、指针",frontmatter:{title:"深入理解：变量、引用、指针",date:"2022-12-25T19:40:44.000Z",permalink:"/pages/f95db2/",categories:["C++"],tags:["变量"]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/20.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/20.%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E5%BC%95%E7%94%A8%E3%80%81%E6%8C%87%E9%92%88.html",relativePath:"编程语言--C++/20.深入理解/20.详解：变量、引用、指针.md",key:"v-c70d9778",path:"/pages/f95db2/",headers:[{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:2},{level:3,title:"vs编译器汇编",slug:"vs编译器汇编",normalizedTitle:"vs编译器汇编",charIndex:192},{level:3,title:"gcc编译器汇编",slug:"gcc编译器汇编",normalizedTitle:"gcc编译器汇编",charIndex:1086},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1752},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:1794},{level:2,title:"指针",slug:"指针",normalizedTitle:"指针",charIndex:902}],excerpt:'<h2 id="变量"><a class="header-anchor" href="#变量">#</a> 变量</h2>\n<p>变量是程序中一个重要的概念。</p>\n<p>在了解概念前先，看一段简单的程序。</p>\n\x3c!--beforebegin--\x3e<div class="language-cpp line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-cpp"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">{</span>\n\t<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\t<span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>程序的结果也很明了：</p>\n\x3c!--beforebegin--\x3e<div class="language-cpp line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-cpp"><code>c 为 <span class="token number">1</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>问题：变量a、b、c是以什么样的形式存在于程序中的嗯？</p>\n',headersStr:"变量 vs编译器汇编 gcc编译器汇编 总结 引用 指针",content:"# 变量\n\n变量是程序中一个重要的概念。\n\n在了解概念前先，看一段简单的程序。\n\nint a = 0;\nint main(int argc, char* argv[])\n{\n\tint b = 1;\n\tint c = a + b;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n程序的结果也很明了：\n\nc 为 1\n\n\n1\n\n\n问题：变量a、b、c是以什么样的形式存在于程序中的嗯？\n\n\n# vs编译器汇编\n\n这里是win32的x86汇编：\n\n--- E:\\github\\githubDemo\\C++相关\\104_变量\\main.cpp ---------------------------------\nint a = 0;\nint main()\n{\n00F61470  push        ebp  \n00F61471  mov         ebp,esp  \n00F61473  sub         esp,8  \n\tint b = 1;\n00F61476  mov         dword ptr [b],1  \n\tint c = a + b;\n00F6147D  mov         eax,dword ptr [a (0F69138h)]  \n00F61482  add         eax,dword ptr [b]  \n00F61485  mov         dword ptr [c],eax  \n}\n00F61488  xor         eax,eax  \n00F6148A  mov         esp,ebp  \n00F6148C  pop         ebp  \n00F6148D  ret  \n--- 无源文件 -----------------------------------------------------------------------\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这里主要关注mov和ptr，mov是汇编中的数据传输指令；ptr为pointer（指针）的缩写。\n\n\tint b = 1;\n00F61476  mov         dword ptr [b],1   \n\n\n1\n2\n\n\n这里的汇编的意思就是，给内存地址等于 “b寄存器的值” 得位置 存上值 1\n\n明显b是我们的变量。Vs编译器上，我们看到似乎存在一个寄存器b。\n\n即程序运行时存在一个名为变量名的地址位置， 可大致直接理解为一个寄存器。\n\n\n# gcc编译器汇编\n\nubuntu64位汇编：gcc编译器\n\n\nmain():\n\n0x0000555555555129  endbr64  \n0x000055555555512d  push   %rbp \n0x000055555555512e  mov    %rsp,%rbp \n0x0000555555555131  movl   $0x1,-0x8(%rbp) \n0x0000555555555138  mov    0x2ed6(%rip),%edx        # 0x555555558014 <a> \n0x000055555555513e  mov    -0x8(%rbp),%eax \n0x0000555555555141  add    %edx,%eax \n0x0000555555555143  mov    %eax,-0x4(%rbp) \n0x0000555555555146  mov    $0x0,%eax \n0x000055555555514b  pop    %rbp \n0x000055555555514c  ret   \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在这里我们看到： 对于栈变量（b、c），我们是直接使用其在栈中的相对地址位置。 对于全局变量（a），程序是提前分配了一个地址位置，我们也是直接操作的地址。\n\n可见在gcc编译器中，变量只存在于程序的代码编程阶段；在编译器中就会转换为地址，不在存在。这也是我们常用的理解方式。\n\n\n# 总结\n\n综上，变量在c++程序中只存在于代码编辑阶段；在程序中表现为地址。\n\n\n# 引用\n\n\n# 指针",normalizedContent:"# 变量\n\n变量是程序中一个重要的概念。\n\n在了解概念前先，看一段简单的程序。\n\nint a = 0;\nint main(int argc, char* argv[])\n{\n\tint b = 1;\n\tint c = a + b;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n程序的结果也很明了：\n\nc 为 1\n\n\n1\n\n\n问题：变量a、b、c是以什么样的形式存在于程序中的嗯？\n\n\n# vs编译器汇编\n\n这里是win32的x86汇编：\n\n--- e:\\github\\githubdemo\\c++相关\\104_变量\\main.cpp ---------------------------------\nint a = 0;\nint main()\n{\n00f61470  push        ebp  \n00f61471  mov         ebp,esp  \n00f61473  sub         esp,8  \n\tint b = 1;\n00f61476  mov         dword ptr [b],1  \n\tint c = a + b;\n00f6147d  mov         eax,dword ptr [a (0f69138h)]  \n00f61482  add         eax,dword ptr [b]  \n00f61485  mov         dword ptr [c],eax  \n}\n00f61488  xor         eax,eax  \n00f6148a  mov         esp,ebp  \n00f6148c  pop         ebp  \n00f6148d  ret  \n--- 无源文件 -----------------------------------------------------------------------\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这里主要关注mov和ptr，mov是汇编中的数据传输指令；ptr为pointer（指针）的缩写。\n\n\tint b = 1;\n00f61476  mov         dword ptr [b],1   \n\n\n1\n2\n\n\n这里的汇编的意思就是，给内存地址等于 “b寄存器的值” 得位置 存上值 1\n\n明显b是我们的变量。vs编译器上，我们看到似乎存在一个寄存器b。\n\n即程序运行时存在一个名为变量名的地址位置， 可大致直接理解为一个寄存器。\n\n\n# gcc编译器汇编\n\nubuntu64位汇编：gcc编译器\n\n\nmain():\n\n0x0000555555555129  endbr64  \n0x000055555555512d  push   %rbp \n0x000055555555512e  mov    %rsp,%rbp \n0x0000555555555131  movl   $0x1,-0x8(%rbp) \n0x0000555555555138  mov    0x2ed6(%rip),%edx        # 0x555555558014 <a> \n0x000055555555513e  mov    -0x8(%rbp),%eax \n0x0000555555555141  add    %edx,%eax \n0x0000555555555143  mov    %eax,-0x4(%rbp) \n0x0000555555555146  mov    $0x0,%eax \n0x000055555555514b  pop    %rbp \n0x000055555555514c  ret   \n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n在这里我们看到： 对于栈变量（b、c），我们是直接使用其在栈中的相对地址位置。 对于全局变量（a），程序是提前分配了一个地址位置，我们也是直接操作的地址。\n\n可见在gcc编译器中，变量只存在于程序的代码编程阶段；在编译器中就会转换为地址，不在存在。这也是我们常用的理解方式。\n\n\n# 总结\n\n综上，变量在c++程序中只存在于代码编辑阶段；在程序中表现为地址。\n\n\n# 引用\n\n\n# 指针",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"C++类的默认函数",frontmatter:{title:"C++类的默认函数",date:"2023-01-08T23:07:46.000Z",permalink:"/pages/f2ea1f/",categories:["C++"],tags:["构造","析构","拷贝构造",null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/20.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/30.%E8%AF%A6%E8%A7%A3%EF%BC%9AC++%E7%B1%BB%E7%9A%84%E9%BB%98%E8%AE%A4%E5%87%BD%E6%95%B0.html",relativePath:"编程语言--C++/20.深入理解/30.详解：C++类的默认函数.md",key:"v-47e65f80",path:"/pages/f2ea1f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"深入理解：继承和虚表",frontmatter:{title:"深入理解：继承和虚表",date:"2023-01-30T08:37:43.000Z",permalink:"/pages/9516e1/",categories:["C++","理解和使用"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--C++/20.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/50.%E8%AF%A6%E8%A7%A3%EF%BC%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E8%A1%A8.html",relativePath:"编程语言--C++/20.深入理解/50.详解：继承和虚表.md",key:"v-3ec0a222",path:"/pages/9516e1/",headersStr:null,content:"请期待！😁😁😁",normalizedContent:"请期待！😁😁😁",charsets:{cjk:!0},lastUpdated:"2023/03/08, 23:58:46",lastUpdatedTimestamp:1678291126e3},{title:"Java基础语法",frontmatter:{title:"Java基础语法",date:"2022-05-04T19:36:07.000Z",permalink:"/pages/740f83/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/10.Java%E5%9F%BA%E7%A1%80.html",relativePath:"编程语言--Java/10.Java基础.md",key:"v-f9ea29ee",path:"/pages/740f83/",headers:[{level:2,title:"认识JDK和JRE",slug:"认识jdk和jre",normalizedTitle:"认识jdk和jre",charIndex:2},{level:2,title:"基础语法",slug:"基础语法",normalizedTitle:"基础语法",charIndex:213},{level:3,title:"命名规则",slug:"命名规则",normalizedTitle:"命名规则",charIndex:222},{level:3,title:"基本类型",slug:"基本类型",normalizedTitle:"基本类型",charIndex:499},{level:3,title:"类",slug:"类",normalizedTitle:"类",charIndex:79},{level:3,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:1401},{level:3,title:"this 和super",slug:"this-和super",normalizedTitle:"this 和super",charIndex:4740},{level:2,title:"稍微复杂一些的语法",slug:"稍微复杂一些的语法",normalizedTitle:"稍微复杂一些的语法",charIndex:5135},{level:3,title:"内部类",slug:"内部类",normalizedTitle:"内部类",charIndex:5149},{level:3,title:"匿名内部类",slug:"匿名内部类",normalizedTitle:"匿名内部类",charIndex:6162}],headersStr:"认识JDK和JRE 基础语法 命名规则 基本类型 类 继承 this 和super 稍微复杂一些的语法 内部类 匿名内部类",content:'# 认识JDK和JRE\n\n> JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。 JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。 我们想要运行一个已有的Java程序，那么只需安装 JRE 即可。 我们想要开发一个全新的Java程序，那么必须安装 JDK 。\n\n\n\n\n# 基础语法\n\n\n# 命名规则\n\n> 标识符\n> \n> 指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。\n\n> 命名规则： 硬性要求\n> \n>  * 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。\n>  * 标识符不能以数字开头。\n>  * 标识符不能是关键字。\n\n> 命名规范： 软性建议\n> \n>  * 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。\n>  * 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。\n>  * 变量名规范：全部小写。\n\n\n# 基本类型\n\n8个基本类型\n\n数据类型     关键字          内存占用   取值范围\n字节型      byte         1个字节   -128~127\n短整型      short        2个字节   -32768~32767\n整型       int（默认）      4个字节   -2的31次方~2的31次方-1\n长整型      long         8个字节   -2的63次方~2的63次方-1\n单精度浮点数   float        4个字节   1.4013E-45~3.4028E+38\n双精度浮点数   double（默认）   8个字节   4.9E-324~1.7977E+308\n字符型      char         2个字节   0-65535\n布尔类型     boolean      1个字节   true，false\n\n\n# 类\n\n入口函数为：main函数\n\npublic class HelloWorld {\n    public static void main(String[] args) {\n        System.out.println("Hello World !");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n类中包括 ：静态代码块，构造方法，成员变量、成员方法、类变量、类方法\n\n执行顺序为：\n\n静态代码 > 构造方法 > 成员方法\n\n静态代码 > 类方法\n\n> 静态代码在构造函数 和 本类的main方法之前执行，且只执行一次；可以用做初始化静态数据等工作。\n> \n> PS：main方法可以认为是一个特殊的类方法\n\n默认构造\n\n> 同C++：\n> \n> 如果你不提供构造方法，系统会给出无参数构造方法。\n> \n> 如果你提供了构造方法，系统将不再提供无参数构造方法。\n\n抽象类，抽象方法\n\n> abstract修饰的方法就是抽象方法，抽象方法没有方法体。\n> \n> 如果一个类存在抽象方法，则这个类为抽象类，需要用**abstract **修饰。\n> \n> 抽象类不可以实例化对象，需要一个子类继承这个类，实现所有的抽象方法，才能实例对象。\n\n// abstract修饰的类需要\npublic abstract class Animal {\n\tpublic abstract void run()；\n}\n\npublic class Cat extends Animal {\n    @Override // 标识 方法重写 子类中出现与父类一模一样的方法；（可以用于编译检测）\n    public void run() {\n        System.out.println("Cat eat ... ");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n成员变量的默认值：\n\n       数据类型                      默认值\n基本类型   整数（byte，short，int，long）   0\n       浮点数（float，double）         0.0\n       字符（char）                  \'\\u0000\'\n       布尔（boolean）               false\n引用类型   数组，类，接口                   null\n\nDemo:\n\n$[Person.java]\npublic class Person {\n    // 成员变量\n    private String name;\n    // 类变量\n    public static String nation;\n    // 静态代码块\n    static {\n        System.out.println("Person static !");\n        nation = "中国";\n    }\n    // 类方法\n    public static String getNation() {\n        return nation;\n    }\n    // main方法\n    public static void main(String[] args) {\n        System.out.println("Person main running ... ");\n        Person person = new Person();\n    }\n    // 无参构造\n    public Person() {\n        System.out.println("无参构造");\n    }\n    // 有参构造\n    public Person(String name) {\n        System.out.println("有参构造");\n        this.name = name;\n    }\n    // 成员方法\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n/*\nPerson static !\nPerson main running ... \n无参构造\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\npublic class Demo {\n    public static void main(String[] args) {\n        System.out.println("Demo->main方法执行。。。 ");\n        Person person1 = new Person();\n        Person person2 = new Person("张三", "男", 18);\n    }\n}\n/*\nDemo->main方法执行。。。 \nPerson static !\n中国\n无参构造\n有参构造\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 继承\n\n类继承\n\n> 关键字：extends，Java是单继承的（这点有别C++）。\n\n接口实现\n\n> 关键字： interface（接口）、 implements（实现）\n> \n>  1. 无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。\n>  2. 没有构造方法，不能创建对象。\n>  3. 没有静态代码块。\n\n一个类可是实现多个接口\n\n>  1. 实现所有抽象方法的类才能实例化，如果没没有实例化所有的接口即为抽象类\n>  2. 多个接口存在同一个抽象方法，实现一次即可\n\nclass 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {\n\t// 重写接口中抽象方法【必须】\n\t// 重写接口中默认方法【不重名时可选】\n}\n\n\n1\n2\n3\n4\n\n\n接口之间可以继承\n\n>  1. 一个接口可以继承一个接口，并添加自己的方法\n>  2. 一个接口也可以继承多个接口\n\npublic interface 接口名 extends 接口名1,接口名2,接口名3... {\n}\n\n\n1\n2\n\n\n**默认方法 & 静态方法 **\n\n默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。\n静态方法：使用 static 修饰，供接口直接调用。\npublic interface InterFaceName {\n\tpublic default void method() {\n\t\t// 执行语句\n\t}\n\tpublic static void method2() {\n\t\t// 执行语句\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 私有方法和私有静态方法 私有方法：使用 private 修饰，供 接口中 的默认方法或者静态方法调用。\n\n**类型转换 **\n\n基础类型 ：基础类型之间的转换，如char类型转为int;为强制转换\n\nint a = (int) word\n\n\n1\n\n\n向上转型 ：子类类型向父类类型向上转换的过程 ,如用一个父类引用指向一个子类对象 ；为默认转换\n\n父类类型 变量名 = new 子类类型();\n如：Animal a = new Cat();\n\n\n1\n2\n\n\n向下转型 ：父类类型向子类类型向下转换的过程， 为强制转换\n\n子类类型 变量名 = (子类类型) 父类变量名;\n如:Cat c =(Cat) a;\n\n\n1\n2\n\n\n判断类型\n\n向下转型存在危险；\n\n方式一：\n\n用instanceof 判断类型。\n\n// 基础类型不能这么处理\nif (animal instanceof Cat)\n{\n    Cat c =(Cat) animal;\n}\n\n\n1\n2\n3\n4\n5\n\n\n方式二：\n\n用isInstance 判断\n\nString str = "abcd";\n//自身类.class.isInstance(自身实例或子类实例)  返回true \nSystem.out.println(String.class.isInstance(str)); //true;\n\n\n1\n2\n3\n\n\n方式三：\n\n用isAssignableFrom\n\n![Java内存](Java内存.png)String str = "abcd";\n// 自身类.class.isAssignableFrom(自身类或子类.class)  返回true\nSystem.out.println(String.class.isAssignableFrom(str.getClass())); //true;\n\n\n1\n2\n3\n\n\n\n# this 和super\n\n在Java中我们也会遇到一些问题，如在子类构造中调用父类的构造函数；在子类调用父类的方法；获得当前对象的引用。。\n\n> super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。\n\n用法一：访问成员\n\nthis.成员变量 ‐‐ 本类的\nsuper.成员变量 ‐‐ 父类的\nthis.成员方法名() ‐‐ 本类的\nsuper.成员方法名() ‐‐ 父类的\t\n\n\n1\n2\n3\n4\n\n\n用法二：访问成员\n\nthis(...) ‐‐ 本类的构造方法\nsuper(...) ‐‐ 父类的构造方法\n\n\n1\n2\n\n\n> 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。\n\n\n# 稍微复杂一些的语法\n\n\n# 内部类\n\n将一个类A定义在另一个类B里面，里面的那个类A就称为内部类，B则称为外部类\n\nclass 外部类 {\n\tclass 内部类{\n\t}\n}\n\n\n1\n2\n3\n4\n\n\n访问特点\n\n> 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。\n\n内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和 $ 符号 。\n\n比如，Person$Leg.class\n\npublic class Person {\n\tprivate boolean live;\n\n    public class Leg {\n        public void run() {\n            if (live) {\n                System.out.println("running .... ");\n            } else {\n                System.out.println("dead");\n            }\n        }\n    }\n    public Person() {\n        this.live = true;\n    }\n    public Person(boolean live) {\n        this.live = live;\n    }\n    public boolean isLive() {\n        return live;\n    }\n    public void setLive(boolean live) {\n        this.live = live;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\npublic class Demo {\n    public static void main(String[] args) {\n        Person person = new Person();\n        Person.Leg leg1 = person.new Leg();\n        leg1.run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 匿名内部类\n\n内部类的简化写法。它的本质是一个 **带具体实现的 ** 父类或者父接口的 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类了。\n\n> 要素：\n> \n>  1. 父类 或 父接口\n>  2. 子类实现\n\nnew 父类名或者接口名(){\n    // 方法重写\n    @Override\n    public void method() {\n    // 执行语句\n    }\n};  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npublic interface Eat {\n    public abstract void eat();\n}\npublic class Demo {\n    public static void main(String[] args) {\n        Eat eat = new Eat() {\n            @Override\n            public void eat() {\n                System.out.println("eat fruit");\n            }\n        };\n        eat.eat();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'# 认识jdk和jre\n\n> jre (java runtime environment) ：是java程序的运行时环境，包含 jvm 和运行时所需要的 核心类库 。 jdk (java development kit)：是java程序开发工具包，包含 jre 和开发人员使用的工具。 我们想要运行一个已有的java程序，那么只需安装 jre 即可。 我们想要开发一个全新的java程序，那么必须安装 jdk 。\n\n\n\n\n# 基础语法\n\n\n# 命名规则\n\n> 标识符\n> \n> 指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。\n\n> 命名规则： 硬性要求\n> \n>  * 标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。\n>  * 标识符不能以数字开头。\n>  * 标识符不能是关键字。\n\n> 命名规范： 软性建议\n> \n>  * 类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。\n>  * 方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。\n>  * 变量名规范：全部小写。\n\n\n# 基本类型\n\n8个基本类型\n\n数据类型     关键字          内存占用   取值范围\n字节型      byte         1个字节   -128~127\n短整型      short        2个字节   -32768~32767\n整型       int（默认）      4个字节   -2的31次方~2的31次方-1\n长整型      long         8个字节   -2的63次方~2的63次方-1\n单精度浮点数   float        4个字节   1.4013e-45~3.4028e+38\n双精度浮点数   double（默认）   8个字节   4.9e-324~1.7977e+308\n字符型      char         2个字节   0-65535\n布尔类型     boolean      1个字节   true，false\n\n\n# 类\n\n入口函数为：main函数\n\npublic class helloworld {\n    public static void main(string[] args) {\n        system.out.println("hello world !");\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n类中包括 ：静态代码块，构造方法，成员变量、成员方法、类变量、类方法\n\n执行顺序为：\n\n静态代码 > 构造方法 > 成员方法\n\n静态代码 > 类方法\n\n> 静态代码在构造函数 和 本类的main方法之前执行，且只执行一次；可以用做初始化静态数据等工作。\n> \n> ps：main方法可以认为是一个特殊的类方法\n\n默认构造\n\n> 同c++：\n> \n> 如果你不提供构造方法，系统会给出无参数构造方法。\n> \n> 如果你提供了构造方法，系统将不再提供无参数构造方法。\n\n抽象类，抽象方法\n\n> abstract修饰的方法就是抽象方法，抽象方法没有方法体。\n> \n> 如果一个类存在抽象方法，则这个类为抽象类，需要用**abstract **修饰。\n> \n> 抽象类不可以实例化对象，需要一个子类继承这个类，实现所有的抽象方法，才能实例对象。\n\n// abstract修饰的类需要\npublic abstract class animal {\n\tpublic abstract void run()；\n}\n\npublic class cat extends animal {\n    @override // 标识 方法重写 子类中出现与父类一模一样的方法；（可以用于编译检测）\n    public void run() {\n        system.out.println("cat eat ... ");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n成员变量的默认值：\n\n       数据类型                      默认值\n基本类型   整数（byte，short，int，long）   0\n       浮点数（float，double）         0.0\n       字符（char）                  \'\\u0000\'\n       布尔（boolean）               false\n引用类型   数组，类，接口                   null\n\ndemo:\n\n$[person.java]\npublic class person {\n    // 成员变量\n    private string name;\n    // 类变量\n    public static string nation;\n    // 静态代码块\n    static {\n        system.out.println("person static !");\n        nation = "中国";\n    }\n    // 类方法\n    public static string getnation() {\n        return nation;\n    }\n    // main方法\n    public static void main(string[] args) {\n        system.out.println("person main running ... ");\n        person person = new person();\n    }\n    // 无参构造\n    public person() {\n        system.out.println("无参构造");\n    }\n    // 有参构造\n    public person(string name) {\n        system.out.println("有参构造");\n        this.name = name;\n    }\n    // 成员方法\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n}\n/*\nperson static !\nperson main running ... \n无参构造\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\npublic class demo {\n    public static void main(string[] args) {\n        system.out.println("demo->main方法执行。。。 ");\n        person person1 = new person();\n        person person2 = new person("张三", "男", 18);\n    }\n}\n/*\ndemo->main方法执行。。。 \nperson static !\n中国\n无参构造\n有参构造\n*/\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 继承\n\n类继承\n\n> 关键字：extends，java是单继承的（这点有别c++）。\n\n接口实现\n\n> 关键字： interface（接口）、 implements（实现）\n> \n>  1. 无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。\n>  2. 没有构造方法，不能创建对象。\n>  3. 没有静态代码块。\n\n一个类可是实现多个接口\n\n>  1. 实现所有抽象方法的类才能实例化，如果没没有实例化所有的接口即为抽象类\n>  2. 多个接口存在同一个抽象方法，实现一次即可\n\nclass 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {\n\t// 重写接口中抽象方法【必须】\n\t// 重写接口中默认方法【不重名时可选】\n}\n\n\n1\n2\n3\n4\n\n\n接口之间可以继承\n\n>  1. 一个接口可以继承一个接口，并添加自己的方法\n>  2. 一个接口也可以继承多个接口\n\npublic interface 接口名 extends 接口名1,接口名2,接口名3... {\n}\n\n\n1\n2\n\n\n**默认方法 & 静态方法 **\n\n默认方法：使用 default 修饰，不可省略，供子类调用或者子类重写。\n静态方法：使用 static 修饰，供接口直接调用。\npublic interface interfacename {\n\tpublic default void method() {\n\t\t// 执行语句\n\t}\n\tpublic static void method2() {\n\t\t// 执行语句\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 私有方法和私有静态方法 私有方法：使用 private 修饰，供 接口中 的默认方法或者静态方法调用。\n\n**类型转换 **\n\n基础类型 ：基础类型之间的转换，如char类型转为int;为强制转换\n\nint a = (int) word\n\n\n1\n\n\n向上转型 ：子类类型向父类类型向上转换的过程 ,如用一个父类引用指向一个子类对象 ；为默认转换\n\n父类类型 变量名 = new 子类类型();\n如：animal a = new cat();\n\n\n1\n2\n\n\n向下转型 ：父类类型向子类类型向下转换的过程， 为强制转换\n\n子类类型 变量名 = (子类类型) 父类变量名;\n如:cat c =(cat) a;\n\n\n1\n2\n\n\n判断类型\n\n向下转型存在危险；\n\n方式一：\n\n用instanceof 判断类型。\n\n// 基础类型不能这么处理\nif (animal instanceof cat)\n{\n    cat c =(cat) animal;\n}\n\n\n1\n2\n3\n4\n5\n\n\n方式二：\n\n用isinstance 判断\n\nstring str = "abcd";\n//自身类.class.isinstance(自身实例或子类实例)  返回true \nsystem.out.println(string.class.isinstance(str)); //true;\n\n\n1\n2\n3\n\n\n方式三：\n\n用isassignablefrom\n\n![java内存](java内存.png)string str = "abcd";\n// 自身类.class.isassignablefrom(自身类或子类.class)  返回true\nsystem.out.println(string.class.isassignablefrom(str.getclass())); //true;\n\n\n1\n2\n3\n\n\n\n# this 和super\n\n在java中我们也会遇到一些问题，如在子类构造中调用父类的构造函数；在子类调用父类的方法；获得当前对象的引用。。\n\n> super ：代表父类的存储空间标识(可以理解为父亲的引用)。 this ：代表当前对象的引用(谁调用就代表谁)。\n\n用法一：访问成员\n\nthis.成员变量 ‐‐ 本类的\nsuper.成员变量 ‐‐ 父类的\nthis.成员方法名() ‐‐ 本类的\nsuper.成员方法名() ‐‐ 父类的\t\n\n\n1\n2\n3\n4\n\n\n用法二：访问成员\n\nthis(...) ‐‐ 本类的构造方法\nsuper(...) ‐‐ 父类的构造方法\n\n\n1\n2\n\n\n> 子类的每个构造方法中均有默认的super()，调用父类的空参构造。手动调用父类构造会覆盖默认的super()。 super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。\n\n\n# 稍微复杂一些的语法\n\n\n# 内部类\n\n将一个类a定义在另一个类b里面，里面的那个类a就称为内部类，b则称为外部类\n\nclass 外部类 {\n\tclass 内部类{\n\t}\n}\n\n\n1\n2\n3\n4\n\n\n访问特点\n\n> 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。\n\n内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名 和 $ 符号 。\n\n比如，person$leg.class\n\npublic class person {\n\tprivate boolean live;\n\n    public class leg {\n        public void run() {\n            if (live) {\n                system.out.println("running .... ");\n            } else {\n                system.out.println("dead");\n            }\n        }\n    }\n    public person() {\n        this.live = true;\n    }\n    public person(boolean live) {\n        this.live = live;\n    }\n    public boolean islive() {\n        return live;\n    }\n    public void setlive(boolean live) {\n        this.live = live;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\npublic class demo {\n    public static void main(string[] args) {\n        person person = new person();\n        person.leg leg1 = person.new leg();\n        leg1.run();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 匿名内部类\n\n内部类的简化写法。它的本质是一个 **带具体实现的 ** 父类或者父接口的 匿名的 子类对象。 开发中，最常用到的内部类就是匿名内部类了。\n\n> 要素：\n> \n>  1. 父类 或 父接口\n>  2. 子类实现\n\nnew 父类名或者接口名(){\n    // 方法重写\n    @override\n    public void method() {\n    // 执行语句\n    }\n};  \n\n\n1\n2\n3\n4\n5\n6\n7\n\n\npublic interface eat {\n    public abstract void eat();\n}\npublic class demo {\n    public static void main(string[] args) {\n        eat eat = new eat() {\n            @override\n            public void eat() {\n                system.out.println("eat fruit");\n            }\n        };\n        eat.eat();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"JavaBean",frontmatter:{title:"JavaBean",date:"2022-05-15T01:11:51.000Z",permalink:"/pages/e5b6fe/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/15.JavaBean.html",relativePath:"编程语言--Java/15.JavaBean.md",key:"v-b4f8fe5e",path:"/pages/e5b6fe/",headersStr:null,content:"JavaBean 是 Java语言编写类的一种标准规范。符合 JavaBean 的类，要求类必须是具体的和公共的，并且具有无 参数的构造方法，提供用来操作成员变量的 set 和 get 方法。\n\npublic class ClassName{\n//成员变量\n//构造方法\n//无参构造方法【必须】\n//有参构造方法【建议】\n//成员方法\n//getXxx()\n//setXxx()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",normalizedContent:"javabean 是 java语言编写类的一种标准规范。符合 javabean 的类，要求类必须是具体的和公共的，并且具有无 参数的构造方法，提供用来操作成员变量的 set 和 get 方法。\n\npublic class classname{\n//成员变量\n//构造方法\n//无参构造方法【必须】\n//有参构造方法【建议】\n//成员方法\n//getxxx()\n//setxxx()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"Java容器",frontmatter:{title:"Java容器",date:"2022-05-04T19:36:09.000Z",permalink:"/pages/9a5df1/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/20.Java%E5%AE%B9%E5%99%A8.html",relativePath:"编程语言--Java/20.Java容器.md",key:"v-0af76612",path:"/pages/9a5df1/",headers:[{level:2,title:"1 集合体系结构",slug:"_1-集合体系结构",normalizedTitle:"1 集合体系结构",charIndex:20},{level:2,title:"2 Collection集合概述和基本使用",slug:"_2-collection集合概述和基本使用",normalizedTitle:"2 collection集合概述和基本使用",charIndex:96},{level:2,title:"3 Collection集合的常用方法",slug:"_3-collection集合的常用方法",normalizedTitle:"3 collection集合的常用方法",charIndex:607},{level:2,title:"4 Collection集合的遍历",slug:"_4-collection集合的遍历",normalizedTitle:"4 collection集合的遍历",charIndex:907}],headersStr:"1 集合体系结构 2 Collection集合概述和基本使用 3 Collection集合的常用方法 4 Collection集合的遍历",content:'# Collection 集合\n\n\n# 1 集合体系结构\n\n * 集合类的特点\n   \n   提供一种存储空间可变的存储模型，存储的瓣容量可以随时发生改变\n\n * 集合类的体系图\n\n\n\n\n# 2 Collection集合概述和基本使用\n\n * Collection集合概述\n   \n   * 是单例集合的顶层接口 ,它表示一组对象,这些对象也称为Collection的元素\n   * JDK不提供此接口的任何直接实现,它提供更具体的子接口(如Set和List)实现\n\n * Collection集合基本使用\n\npublic class CollectionDemo {\n    public static void main(String[] args) {\n        //创建collection集合的对象\n        Collection<String> c = new ArrayList<String>();\n        //添加元素：boolean add(E e)\n        c.add("hello");\n        c.add("worid");\n        c.add("java");\n        //输出集合对象\n        System.out.println(c);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3 Collection集合的常用方法\n\n方法名                          说明\nboolean add(E e)             添加元素\nboolean remove(Object o)     从集合中移除指定的元素\nvoid clear()                 清空集合中的元素\nboolean contains(Object o)   判断集合中是否 g 旨定的元素\nboolean isEmpty()            判断集合是否为空\nint size()                   集合的长度,也就是集合中元素的个数\n\n\n# 4 Collection集合的遍历\n\n * 迭代器的介绍\n   \n   * 迭代器,集合的专用\n   * Iterator iterator():返回此集合中元素的迭代器,通过集合的iterator。方法得到\n   * 迭代器是通过集合的iterator。方法得到的,所以我们说它是依赖于集合而存在的\n\n * Collection集合的遍历\n\npublic class IteratorDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        Collection<String> c = new ArrayList<String>();\n        //添加元素\n        c.add("hello");\n        c.add("world");\n        c.add("java");\n        c.add("javaee");\n\n        //Iterator<E> iterator():返回此集合中兀素的迭代器,通过集合的iterator()方法得到\n        Iterator<String> it = c.iterator();\n        //用whi1e循环改进元素的判断和获取\n        while (it.hasNext()) {\n            String s =it.next();\n            System.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',normalizedContent:'# collection 集合\n\n\n# 1 集合体系结构\n\n * 集合类的特点\n   \n   提供一种存储空间可变的存储模型，存储的瓣容量可以随时发生改变\n\n * 集合类的体系图\n\n\n\n\n# 2 collection集合概述和基本使用\n\n * collection集合概述\n   \n   * 是单例集合的顶层接口 ,它表示一组对象,这些对象也称为collection的元素\n   * jdk不提供此接口的任何直接实现,它提供更具体的子接口(如set和list)实现\n\n * collection集合基本使用\n\npublic class collectiondemo {\n    public static void main(string[] args) {\n        //创建collection集合的对象\n        collection<string> c = new arraylist<string>();\n        //添加元素：boolean add(e e)\n        c.add("hello");\n        c.add("worid");\n        c.add("java");\n        //输出集合对象\n        system.out.println(c);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 3 collection集合的常用方法\n\n方法名                          说明\nboolean add(e e)             添加元素\nboolean remove(object o)     从集合中移除指定的元素\nvoid clear()                 清空集合中的元素\nboolean contains(object o)   判断集合中是否 g 旨定的元素\nboolean isempty()            判断集合是否为空\nint size()                   集合的长度,也就是集合中元素的个数\n\n\n# 4 collection集合的遍历\n\n * 迭代器的介绍\n   \n   * 迭代器,集合的专用\n   * iterator iterator():返回此集合中元素的迭代器,通过集合的iterator。方法得到\n   * 迭代器是通过集合的iterator。方法得到的,所以我们说它是依赖于集合而存在的\n\n * collection集合的遍历\n\npublic class iteratordemo {\n    public static void main(string[] args) {\n        //创建集合对象\n        collection<string> c = new arraylist<string>();\n        //添加元素\n        c.add("hello");\n        c.add("world");\n        c.add("java");\n        c.add("javaee");\n\n        //iterator<e> iterator():返回此集合中兀素的迭代器,通过集合的iterator()方法得到\n        iterator<string> it = c.iterator();\n        //用whi1e循环改进元素的判断和获取\n        while (it.hasnext()) {\n            string s =it.next();\n            system.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"泛型和数据结构",frontmatter:{title:"泛型和数据结构",date:"2022-05-04T19:36:12.000Z",permalink:"/pages/5fcd9c/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/30.%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",relativePath:"编程语言--Java/30.泛型和数据结构.md",key:"v-08a4d6f6",path:"/pages/5fcd9c/",headers:[{level:2,title:"1 泛型概述和好处",slug:"_1-泛型概述和好处",normalizedTitle:"1 泛型概述和好处",charIndex:9},{level:2,title:"2 泛型类",slug:"_2-泛型类",normalizedTitle:"2 泛型类",charIndex:514},{level:2,title:"3 泛型方法",slug:"_3-泛型方法",normalizedTitle:"3 泛型方法",charIndex:1555},{level:2,title:"4 泛型接口",slug:"_4-泛型接口",normalizedTitle:"4 泛型接口",charIndex:2179},{level:2,title:"5 类型通配符",slug:"_5-类型通配符",normalizedTitle:"5 类型通配符",charIndex:2751},{level:2,title:"1 可变参数介绍",slug:"_1-可变参数介绍",normalizedTitle:"1 可变参数介绍",charIndex:4060},{level:2,title:"可变参数的使用",slug:"可变参数的使用",normalizedTitle:"可变参数的使用",charIndex:4248},{level:2,title:"1 数据结构之栈和队列",slug:"_1-数据结构之栈和队列",normalizedTitle:"1 数据结构之栈和队列",charIndex:4599},{level:2,title:"2 数据结构之数组和链表",slug:"_2-数据结构之数组和链表",normalizedTitle:"2 数据结构之数组和链表",charIndex:4660}],headersStr:"1 泛型概述和好处 2 泛型类 3 泛型方法 4 泛型接口 5 类型通配符 1 可变参数介绍 可变参数的使用 1 数据结构之栈和队列 2 数据结构之数组和链表",content:'# 泛型\n\n\n# 1 泛型概述和好处\n\n * 泛型概述\n   \n   > 是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型。\n   > \n   > 它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n   > \n   > 一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。\n   > \n   > 那么参数化类型怎么理解呢？\n   > \n   > 顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型。\n   > \n   > 这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口\n\n * 泛型定义格式\n   \n   * <类型>： 指定一种类型的格式。这里的类型可以看成是形参\n   * <类型1,类型2…>：指定多种类型的格式，多种类型之间用逗号隔开。\n   \n   > 这里的类型可以看成是形参将来具体调用时候给定的类型可以看成是实参，\n   > \n   > 并且实参的类型只能是引用数据类型\n\n * 泛型的好处\n   \n   * 把运行时期的问题提前到了编译期间\n   * 避免了强制类型转换\n\n\n# 2 泛型类\n\n * 定义格式\n   \n   修饰符 class 类名<类型> { }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型类\n     \n     public class Generic<T> {\n         private T t;\n     \n         public T getT() {\n             return t;\n         }\n     \n         public void setT(T t) {\n             this.t = t;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     \n   \n   * 测试类\n     \n     public class GenericDemo {\n         public static void main(String[] args) {\n             Generic<String> g1 = new Generic<String>();\n             g1.setT("林青霞");\n             System.out.println(g1.getT());\n     \n             Generic<Integer> g2 = new Generic<Integer>();\n             g2.setT(30);\n             System.out.println(g2.getT());\n     \n             Generic<Boolean> g3 = new Generic<Boolean>();\n             g3.setT(true);\n             System.out.println(g3.getT());\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n\n# 3 泛型方法\n\n * 定义格式\n   \n   修饰符 <类型> 返回值类型 方法名(类型 变量名) { }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型函数\n     \n     public class Generic {\n         public <T> void show(T t) {\n             System.out.println(t);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n   \n   * 测试类\n     \n     public class GenericDemo {\n         public static void main(String[] args) {\n             Generic g = new Generic();\n             g.show("林青霞");\n             g.show(30);\n             g.show(true);\n             g.show(12.34);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n\n# 4 泛型接口\n\n * 定义格式\n   \n   修饰符 interface 接口名<类型> { }\n   \n   \n   1\n   \n\n示例代码\n\n * 泛型接口\n\n  public interface Generic<T> {\n      void show(T t);\n}\n\n\n1\n2\n3\n\n * 接口实现\n\npublic class GenericImpl<T> implements Generic<T>{\n    @Override\n    public void show(T t) {\n        System.out.println(t);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 测试类\n\npublic class GenericDemo {\n    public static void main(String[] args) {\n      Generic<String> g1 = new GenericImpl<String>();\n        g1.show("林青霞");\n\n        Generic<Integer> g2 = neGenericImpl<Integer>();\n        g2.show(30);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5 类型通配符\n\n * 类型通配符的作用\n   \n   * 为了表示各种泛型List的父类，可以使用类型通配符\n\n * 类型通配符的分类\n   \n   * 类型通配符：<?>\n     * List<?>：表示元素类型未知的List，它的元素可以匹配任何的类型\n     * 这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中\n   * 类型通配符上限：<? extends 类型>\n     * List<? extends Number>：它表示的类型是Number或者其子类型\n   * 类型通配符下限：<? super 类型>\n     * List<? super Number>：它表示的类型是Number或者其父类型\n   \n   public class GenericDemo {\n       public static void main(String[] args) {\n           //类型通配符：<?>\n           List<?> list1 = new ArrayList<Object>();\n           List<?> list2 = new ArrayList<Number>();\n           List<?> list3 = new ArrayList<Integer>();\n           System.out.println("--------");\n           //类型通配符上限：<? extends 类型> \n           // List<? extends Number> list4 = new ArrayList<Object>();\n           List<? extends Number> list5 = new ArrayList<Number>();\n           List<? extends Number> list6 = new ArrayList<Integer>();\n           System.out.println("--------");\n           \n           //类型通配符下限：<? super 类型>\n           List<? super Number> list7 = new ArrayList<Object>();\n           List<? super Number> list8 = new ArrayList<Number>();\n           // List<? super Number> list9 = new ArrayList<Integer>();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n\n# 可变参数\n\n\n# 1 可变参数介绍\n\n可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n\n * 可变参数定义格式\n   \n   修饰符 返回值类型 方法名(数据类型… 变量名) { }\n   \n   \n   1\n   \n\n * 可变参数的注意事项\n   \n   * 这里的变量其实是一个数组\n   * 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n\n# 可变参数的使用\n\n * Arrays工具类中有一个静态方法：\n   * public static List asList(T... a)：返回由指定数组支持的固定大小的列表\n   * 返回的集合不能做增删操作，可以做修改操作\n * List接口中有一个静态方法：\n   * public static List of(E... elements)：返回包含任意数量元素的不可变列表\n   * 返回的集合不能做增删改操作\n * Set接口中有一个静态方法：\n   * public static Set of(E... elements) ：返回一个包含任意数量元素的不可变集合\n   * 在给元素的时候，不能给重复的元素\n   * 返回的集合不能做增删操作，没有修改的方法\n\n\n# 数据结构\n\n\n# 1 数据结构之栈和队列\n\n * 栈结构\n   \n   * 先进后出\n\n * 队列结构\n   \n   * 先进先出\n\n\n# 2 数据结构之数组和链表\n\n * 数组结构\n   \n   * 查询快、增删慢\n\n * 队列结构\n   \n   * 查询慢、增删快',normalizedContent:'# 泛型\n\n\n# 1 泛型概述和好处\n\n * 泛型概述\n   \n   > 是jdk5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型。\n   > \n   > 它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。\n   > \n   > 一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。\n   > \n   > 那么参数化类型怎么理解呢？\n   > \n   > 顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型。\n   > \n   > 这种参数类型可以用在类、方法和接口中，分别被称为泛型类、泛型方法、泛型接口\n\n * 泛型定义格式\n   \n   * <类型>： 指定一种类型的格式。这里的类型可以看成是形参\n   * <类型1,类型2…>：指定多种类型的格式，多种类型之间用逗号隔开。\n   \n   > 这里的类型可以看成是形参将来具体调用时候给定的类型可以看成是实参，\n   > \n   > 并且实参的类型只能是引用数据类型\n\n * 泛型的好处\n   \n   * 把运行时期的问题提前到了编译期间\n   * 避免了强制类型转换\n\n\n# 2 泛型类\n\n * 定义格式\n   \n   修饰符 class 类名<类型> { }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型类\n     \n     public class generic<t> {\n         private t t;\n     \n         public t gett() {\n             return t;\n         }\n     \n         public void sett(t t) {\n             this.t = t;\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     \n   \n   * 测试类\n     \n     public class genericdemo {\n         public static void main(string[] args) {\n             generic<string> g1 = new generic<string>();\n             g1.sett("林青霞");\n             system.out.println(g1.gett());\n     \n             generic<integer> g2 = new generic<integer>();\n             g2.sett(30);\n             system.out.println(g2.gett());\n     \n             generic<boolean> g3 = new generic<boolean>();\n             g3.sett(true);\n             system.out.println(g3.gett());\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     10\n     11\n     12\n     13\n     14\n     15\n     \n\n\n# 3 泛型方法\n\n * 定义格式\n   \n   修饰符 <类型> 返回值类型 方法名(类型 变量名) { }\n   \n   \n   1\n   \n\n * 示例代码\n   \n   * 泛型函数\n     \n     public class generic {\n         public <t> void show(t t) {\n             system.out.println(t);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n   \n   * 测试类\n     \n     public class genericdemo {\n         public static void main(string[] args) {\n             generic g = new generic();\n             g.show("林青霞");\n             g.show(30);\n             g.show(true);\n             g.show(12.34);\n         }\n     }\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     7\n     8\n     9\n     \n\n\n# 4 泛型接口\n\n * 定义格式\n   \n   修饰符 interface 接口名<类型> { }\n   \n   \n   1\n   \n\n示例代码\n\n * 泛型接口\n\n  public interface generic<t> {\n      void show(t t);\n}\n\n\n1\n2\n3\n\n * 接口实现\n\npublic class genericimpl<t> implements generic<t>{\n    @override\n    public void show(t t) {\n        system.out.println(t);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 测试类\n\npublic class genericdemo {\n    public static void main(string[] args) {\n      generic<string> g1 = new genericimpl<string>();\n        g1.show("林青霞");\n\n        generic<integer> g2 = negenericimpl<integer>();\n        g2.show(30);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5 类型通配符\n\n * 类型通配符的作用\n   \n   * 为了表示各种泛型list的父类，可以使用类型通配符\n\n * 类型通配符的分类\n   \n   * 类型通配符：<?>\n     * list<?>：表示元素类型未知的list，它的元素可以匹配任何的类型\n     * 这种带通配符的list仅表示它是各种泛型list的父类，并不能把元素添加到其中\n   * 类型通配符上限：<? extends 类型>\n     * list<? extends number>：它表示的类型是number或者其子类型\n   * 类型通配符下限：<? super 类型>\n     * list<? super number>：它表示的类型是number或者其父类型\n   \n   public class genericdemo {\n       public static void main(string[] args) {\n           //类型通配符：<?>\n           list<?> list1 = new arraylist<object>();\n           list<?> list2 = new arraylist<number>();\n           list<?> list3 = new arraylist<integer>();\n           system.out.println("--------");\n           //类型通配符上限：<? extends 类型> \n           // list<? extends number> list4 = new arraylist<object>();\n           list<? extends number> list5 = new arraylist<number>();\n           list<? extends number> list6 = new arraylist<integer>();\n           system.out.println("--------");\n           \n           //类型通配符下限：<? super 类型>\n           list<? super number> list7 = new arraylist<object>();\n           list<? super number> list8 = new arraylist<number>();\n           // list<? super number> list9 = new arraylist<integer>();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   \n\n\n# 可变参数\n\n\n# 1 可变参数介绍\n\n可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了\n\n * 可变参数定义格式\n   \n   修饰符 返回值类型 方法名(数据类型… 变量名) { }\n   \n   \n   1\n   \n\n * 可变参数的注意事项\n   \n   * 这里的变量其实是一个数组\n   * 如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n\n\n# 可变参数的使用\n\n * arrays工具类中有一个静态方法：\n   * public static list aslist(t... a)：返回由指定数组支持的固定大小的列表\n   * 返回的集合不能做增删操作，可以做修改操作\n * list接口中有一个静态方法：\n   * public static list of(e... elements)：返回包含任意数量元素的不可变列表\n   * 返回的集合不能做增删改操作\n * set接口中有一个静态方法：\n   * public static set of(e... elements) ：返回一个包含任意数量元素的不可变集合\n   * 在给元素的时候，不能给重复的元素\n   * 返回的集合不能做增删操作，没有修改的方法\n\n\n# 数据结构\n\n\n# 1 数据结构之栈和队列\n\n * 栈结构\n   \n   * 先进后出\n\n * 队列结构\n   \n   * 先进先出\n\n\n# 2 数据结构之数组和链表\n\n * 数组结构\n   \n   * 查询快、增删慢\n\n * 队列结构\n   \n   * 查询慢、增删快',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"反射：框架设计的灵魂",frontmatter:{title:"反射：框架设计的灵魂",date:"2022-05-15T00:07:31.000Z",permalink:"/pages/e9f877/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/40.JAVA%E5%8F%8D%E5%B0%84.html",relativePath:"编程语言--Java/40.JAVA反射.md",key:"v-517f137a",path:"/pages/e9f877/",headers:[{level:2,title:"框架",slug:"框架",normalizedTitle:"框架",charIndex:2},{level:2,title:"反射",slug:"反射",normalizedTitle:"反射",charIndex:37},{level:2,title:"获取Class对象的方式",slug:"获取class对象的方式",normalizedTitle:"获取class对象的方式",charIndex:119},{level:2,title:"Class对象功能",slug:"class对象功能",normalizedTitle:"class对象功能",charIndex:375},{level:2,title:"Field：成员变量",slug:"field-成员变量",normalizedTitle:"field：成员变量",charIndex:1034},{level:2,title:"Constructor:构造方法",slug:"constructor-构造方法",normalizedTitle:"constructor:构造方法",charIndex:1171},{level:2,title:"Metod：方法对象",slug:"metod-方法对象",normalizedTitle:"metod：方法对象",charIndex:1285}],headersStr:"框架 反射 获取Class对象的方式 Class对象功能 Field：成员变量 Constructor:构造方法 Metod：方法对象",content:'# 框架\n\n半成品软件。可以在框架的基础上进行软件开发，简化编码\n\n\n# 反射\n\n将类的各个组成部分封装为其他对象，这就是反射机制\n\n好处：\n\n 1. 可以在程序运行过程中，操作这些对象。\n 2. 可以解耦，提高程序的可扩展性。\n\n\n# 获取Class对象的方式\n\nClass.forName("全类名")：将字节码文件加载进内存，返回Class对象\n\n> 多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n\n类名.class：通过类名的属性class获取\n\n> 多用于参数的传递\n\n对象.getClass()：getClass()方法在Object类中定义着。\n\n> 多用于对象的获取字节码的方式\n\n结论：\n\n同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取Class对象都是同一个。\n\n\n# Class对象功能\n\n获取成员变量\n\nField[] getFields() ：获取所有public修饰的成员变量\nField getField(String name)   获取指定名称的 public修饰的成员变量\nField[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符\nField getDeclaredField(String name)\n\n\n1\n2\n3\n4\n\n\n获取构造方法\n\nConstructor<?>[] getConstructors()  \nConstructor<T> getConstructor(类<?>... parameterTypes)  \n\nConstructor<T> getDeclaredConstructor(类<?>... parameterTypes)  \nConstructor<?>[] getDeclaredConstructors()\n\n\n1\n2\n3\n4\n5\n\n\n获取成员方法\n\nMethod[] getMethods()  \nMethod getMethod(String name, 类<?>... parameterTypes)  \n\nMethod[] getDeclaredMethods()  \nMethod getDeclaredMethod(String name, 类<?>... parameterTypes)\n\n\n1\n2\n3\n4\n5\n\n\n获取全类名\n\nString getName()  \n\n\n1\n\n\n\n# Field：成员变量\n\n设置值\n\nvoid set(Object obj, Object value)  \n\n\n1\n\n\n获取值\n\nget(Object obj) \n\n\n1\n\n\n忽略访问限修饰符的安全检查\n\nsetAccessible(true):暴力反射\n\n\n1\n\n\n\n# Constructor:构造方法\n\n创建对象：\n\nT newInstance(Object... initargs)\n\n\n1\n\n\n如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法\n\n\n# Metod：方法对象\n\n执行方法：\n\nObject invoke(Object obj, Object... args)\n\n\n1\n\n\n获取方法名称：String getName:获取方法名',normalizedContent:'# 框架\n\n半成品软件。可以在框架的基础上进行软件开发，简化编码\n\n\n# 反射\n\n将类的各个组成部分封装为其他对象，这就是反射机制\n\n好处：\n\n 1. 可以在程序运行过程中，操作这些对象。\n 2. 可以解耦，提高程序的可扩展性。\n\n\n# 获取class对象的方式\n\nclass.forname("全类名")：将字节码文件加载进内存，返回class对象\n\n> 多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n\n类名.class：通过类名的属性class获取\n\n> 多用于参数的传递\n\n对象.getclass()：getclass()方法在object类中定义着。\n\n> 多用于对象的获取字节码的方式\n\n结论：\n\n同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取class对象都是同一个。\n\n\n# class对象功能\n\n获取成员变量\n\nfield[] getfields() ：获取所有public修饰的成员变量\nfield getfield(string name)   获取指定名称的 public修饰的成员变量\nfield[] getdeclaredfields()  获取所有的成员变量，不考虑修饰符\nfield getdeclaredfield(string name)\n\n\n1\n2\n3\n4\n\n\n获取构造方法\n\nconstructor<?>[] getconstructors()  \nconstructor<t> getconstructor(类<?>... parametertypes)  \n\nconstructor<t> getdeclaredconstructor(类<?>... parametertypes)  \nconstructor<?>[] getdeclaredconstructors()\n\n\n1\n2\n3\n4\n5\n\n\n获取成员方法\n\nmethod[] getmethods()  \nmethod getmethod(string name, 类<?>... parametertypes)  \n\nmethod[] getdeclaredmethods()  \nmethod getdeclaredmethod(string name, 类<?>... parametertypes)\n\n\n1\n2\n3\n4\n5\n\n\n获取全类名\n\nstring getname()  \n\n\n1\n\n\n\n# field：成员变量\n\n设置值\n\nvoid set(object obj, object value)  \n\n\n1\n\n\n获取值\n\nget(object obj) \n\n\n1\n\n\n忽略访问限修饰符的安全检查\n\nsetaccessible(true):暴力反射\n\n\n1\n\n\n\n# constructor:构造方法\n\n创建对象：\n\nt newinstance(object... initargs)\n\n\n1\n\n\n如果使用空参数构造方法创建对象，操作可以简化：class对象的newinstance方法\n\n\n# metod：方法对象\n\n执行方法：\n\nobject invoke(object obj, object... args)\n\n\n1\n\n\n获取方法名称：string getname:获取方法名',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"JUnit单元测试",frontmatter:{title:"JUnit单元测试",date:"2022-05-15T01:07:39.000Z",permalink:"/pages/be8065/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/50.JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"编程语言--Java/50.JUnit单元测试.md",key:"v-49e7087f",path:"/pages/be8065/",headers:[{level:2,title:"测试分类",slug:"测试分类",normalizedTitle:"测试分类",charIndex:2},{level:2,title:"Junit使用：白盒测试",slug:"junit使用-白盒测试",normalizedTitle:"junit使用：白盒测试",charIndex:78}],headersStr:"测试分类 Junit使用：白盒测试",content:"# 测试分类\n\n 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。\n\n 2. 白盒测试：需要写代码的。关注程序具体的执行流程。\n\n\n# Junit使用：白盒测试\n\n步骤：\n\n 1. 定义一个测试类(测试用例)\n    * 建议：\n      * 测试类名：被测试的类名Test CalculatorTest\n      * 包名：xxx.xxx.xx.test cn.itcast.test\n 2. 定义测试方法：可以独立运行\n    * 建议：\n      * 方法名：test测试的方法名 testAdd()\n      * 返回值：void\n      * 参数列表：空参\n 3. 给方法加@Test\n 4. 导入junit依赖环境\n\n判定结果：\n\n * 红色：失败\n\n * 绿色：成功\n\n * 一般我们会使用断言操作来处理结果\n   \n   * Assert.assertEquals(期望的结果,运算的结果);\n\n * 补充：\n   \n   * @Before:\n     * 修饰的方法会在测试方法之前被自动执行\n   * @After:\n     * 修饰的方法会在测试方法执行之后自动被执行",normalizedContent:"# 测试分类\n\n 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。\n\n 2. 白盒测试：需要写代码的。关注程序具体的执行流程。\n\n\n# junit使用：白盒测试\n\n步骤：\n\n 1. 定义一个测试类(测试用例)\n    * 建议：\n      * 测试类名：被测试的类名test calculatortest\n      * 包名：xxx.xxx.xx.test cn.itcast.test\n 2. 定义测试方法：可以独立运行\n    * 建议：\n      * 方法名：test测试的方法名 testadd()\n      * 返回值：void\n      * 参数列表：空参\n 3. 给方法加@test\n 4. 导入junit依赖环境\n\n判定结果：\n\n * 红色：失败\n\n * 绿色：成功\n\n * 一般我们会使用断言操作来处理结果\n   \n   * assert.assertequals(期望的结果,运算的结果);\n\n * 补充：\n   \n   * @before:\n     * 修饰的方法会在测试方法之前被自动执行\n   * @after:\n     * 修饰的方法会在测试方法执行之后自动被执行",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"JAVA内存",frontmatter:{title:"JAVA内存",date:"2022-05-15T01:06:35.000Z",permalink:"/pages/8388fc/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/60.JAVA%E5%86%85%E5%AD%98.html",relativePath:"编程语言--Java/60.JAVA内存.md",key:"v-0bc371cd",path:"/pages/8388fc/",headers:[{level:2,title:"内存划分",slug:"内存划分",normalizedTitle:"内存划分",charIndex:2},{level:2,title:"Java8前-内存",slug:"java8前-内存",normalizedTitle:"java8前-内存",charIndex:275},{level:2,title:"Java8后-内存",slug:"java8后-内存",normalizedTitle:"java8后-内存",charIndex:291}],headersStr:"内存划分 Java8前-内存 Java8后-内存",content:"# 内存划分\n\nJava中内存分为5个部分：栈、堆、方法区、本地方法区、寄存器\n\n栈（虚拟机栈）：局部变量，java方法；用完就释放。（java的方法是通过压栈出栈的方执行的）\n\n堆：存储new出来的东西，用完后有垃圾回收器释放。\n\n方法区：主要存 类元数据、常量 等等\n\n本地方法栈：作用同虚拟机栈，提供的是Native方法服务；即提供非Java方法的使用。本地方法可以通过 JNI(Java Native Interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 JVM 相同的能力和权限\n\n寄存器：CPU使用的位置。\n\n\n# Java8前-内存\n\n\n\n\n# Java8后-内存\n\n",normalizedContent:"# 内存划分\n\njava中内存分为5个部分：栈、堆、方法区、本地方法区、寄存器\n\n栈（虚拟机栈）：局部变量，java方法；用完就释放。（java的方法是通过压栈出栈的方执行的）\n\n堆：存储new出来的东西，用完后有垃圾回收器释放。\n\n方法区：主要存 类元数据、常量 等等\n\n本地方法栈：作用同虚拟机栈，提供的是native方法服务；即提供非java方法的使用。本地方法可以通过 jni(java native interface)来访问虚拟机运行时的数据区，甚至可以调用寄存器，具有和 jvm 相同的能力和权限\n\n寄存器：cpu使用的位置。\n\n\n# java8前-内存\n\n\n\n\n# java8后-内存\n\n",charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"Go-HelloWorld",frontmatter:{title:"Go-HelloWorld",date:"2023-03-13T09:09:21.000Z",permalink:"/pages/72b069/",categories:["编程语言-golang"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--golang/1.HelloWorld.html",relativePath:"编程语言--golang/1.HelloWorld.md",key:"v-e04d8192",path:"/pages/72b069/",headers:[{level:2,title:"HelloWold",slug:"hellowold",normalizedTitle:"hellowold",charIndex:2}],headersStr:"HelloWold",content:'# HelloWold\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.Println("Hello, 世界")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# hellowold\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.println("hello, 世界")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0},lastUpdated:"2023/04/09, 15:45:01",lastUpdatedTimestamp:1681026301e3},{title:"Go-基础",frontmatter:{title:"Go-基础",date:"2023-03-13T09:04:50.000Z",permalink:"/pages/10f9a7/",categories:["编程语言-golang"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--golang/2.%E5%9F%BA%E7%A1%80.html",relativePath:"编程语言--golang/2.基础.md",key:"v-265cccf6",path:"/pages/10f9a7/",headers:[{level:2,title:"包",slug:"包",normalizedTitle:"包",charIndex:2},{level:2,title:"导入",slug:"导入",normalizedTitle:"导入",charIndex:45},{level:2,title:"导出名",slug:"导出名",normalizedTitle:"导出名",charIndex:649},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:987},{level:2,title:"函数（续）",slug:"函数-续",normalizedTitle:"函数（续）",charIndex:1238},{level:2,title:"多值返回",slug:"多值返回",normalizedTitle:"多值返回",charIndex:1473},{level:2,title:"命名返回值",slug:"命名返回值",normalizedTitle:"命名返回值",charIndex:1705},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:1040},{level:2,title:"变量的初始化",slug:"变量的初始化",normalizedTitle:"变量的初始化",charIndex:2252},{level:2,title:"短变量声明",slug:"短变量声明",normalizedTitle:"短变量声明",charIndex:2491},{level:2,title:"基本类型",slug:"基本类型",normalizedTitle:"基本类型",charIndex:2772},{level:2,title:"零值",slug:"零值",normalizedTitle:"零值",charIndex:3491},{level:2,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:3737},{level:2,title:"类型推导",slug:"类型推导",normalizedTitle:"类型推导",charIndex:4173},{level:2,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:233},{level:2,title:"数值常量",slug:"数值常量",normalizedTitle:"数值常量",charIndex:4308}],headersStr:"包 导入 导出名 函数 函数（续） 多值返回 命名返回值 变量 变量的初始化 短变量声明 基本类型 零值 类型转换 类型推导 常量 数值常量",content:'# 包\n\n每个 Go 程序都是由包构成的。\n\n程序从 main 包开始运行。\n\n本程序通过导入路径 "fmt" 和 "math/rand" 来使用这两个包。\n\n按照约定，包名与导入路径的最后一个元素一致。例如，"math/rand" 包中的源码均以 package rand 语句开始。\n\n注意： 此程序的运行环境是固定的，因此 rand.Intn 总是会返回相同的数字。 （要得到不同的数字，需为生成器提供不同的种子数，参见 rand.Seed。 练习场中的时间为常量，因此你需要用其它的值作为种子数。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math/rand"\n)\n\nfunc main() {\n\tfmt.Println("My favorite number is", rand.Intn(10))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 导入\n\n此代码用圆括号组合了导入，这是“分组”形式的导入语句。\n\n当然你也可以编写多个导入语句，例如：\n\nimport "fmt"\nimport "math"\n\n\n不过使用分组导入语句是更好的形式。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tfmt.Printf("Now you have %g problems.\\n", math.Sqrt(7))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 导出名\n\n在 Go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，Pizza 就是个已导出名，Pi 也同样，它导出自 math 包。\n\npizza 和 pi 并未以大写字母开头，所以它们是未导出的。\n\n在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。\n\n执行代码，观察错误输出。\n\n然后将 math.pi 改名为 math.Pi 再试着执行一次。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tfmt.Println(math.pi)\n\t// fmt.Println(math.Pi)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 函数\n\n函数可以没有参数或接受多个参数。\n\n在本例中，add 接受两个 int 类型的参数。\n\n注意类型在变量名 之后。\n\n（参考 这篇关于 Go 语法声明的文章了解这种类型声明形式出现的原因。）\n\npackage main\n\nimport "fmt"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 函数（续）\n\n当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n\n在本例中，\n\nx int, y int\n\n\n被缩写为\n\nx, y int\n\n\npackage main\n\nimport "fmt"\n\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.Println(add(42, 13))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 多值返回\n\n函数可以返回任意数量的返回值。\n\nswap 函数返回了两个字符串。\n\npackage main\n\nimport "fmt"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap("hello", "world")\n\tfmt.Println(a, b)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 命名返回值\n\nGo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。\n\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n\npackage main\n\nimport "fmt"\n\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.Println(split(17))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 变量\n\nvar 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。\n\n就像在这个例子中看到的一样，var 语句可以出现在包或函数级别。\n\npackage main\n\nimport "fmt"\n\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.Println(i, c, python, java)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 变量的初始化\n\n变量声明可以包含初始值，每个变量对应一个。\n\n如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\npackage main\n\nimport "fmt"\n\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, "no!"\n\tfmt.Println(i, j, c, python, java)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 短变量声明\n\n在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。\n\n函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, "no!"\n\n\tfmt.Println(i, j, k, c, python, java)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 基本类型\n\nGo 的基本类型有\n\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n\t// 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\n\nint, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math/cmplx"\n)\n\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tfmt.Printf("Type: %T Value: %v\\n", ToBe, ToBe)\n\tfmt.Printf("Type: %T Value: %v\\n", MaxInt, MaxInt)\n\tfmt.Printf("Type: %T Value: %v\\n", z, z)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 零值\n\n没有明确初始值的变量声明会被赋予它们的 零值。\n\n零值是：\n\n数值类型为 0，\n布尔类型为 false，\n字符串为 ""（空字符串）。\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i int\n\tvar f float64\n\tvar b bool\n\tvar s string\n\tfmt.Printf("%v %v %v %q\\n", i, f, b, s)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 类型转换\n\n表达式 T(v) 将值 v 转换为类型 T。\n\n一些关于数值的转换：\n\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n\n\n或者，更加简单的形式：\n\ni := 42\nf := float64(i)\nu := uint(f)\n\n\n与 C 不同的是，Go 在不同类型的项之间赋值时需要显式转换。试着移除例子中 float64 或 uint 的转换看看会发生什么。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tvar x, y int = 3, 4\n\tvar f float64 = math.Sqrt(float64(x*x + y*y))\n\tvar z uint = uint(f)\n\tfmt.Println(x, y, z)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 类型推导\n\n在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\nvar i int\nj := i // j 也是一个 int\n\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：\n\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n\n\n尝试修改示例代码中 v 的初始值，并观察它是如何影响类型的。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tv := 42 // 修改这里！\n\tfmt.Printf("v is of type %T\\n", v)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 常量\n\n常量的声明与变量类似，只不过是使用 const 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 := 语法声明。\n\npackage main\n\nimport "fmt"\n\nconst Pi = 3.14\n\nfunc main() {\n\tconst World = "世界"\n\tfmt.Println("Hello", World)\n\tfmt.Println("Happy", Pi, "Day")\n\n\tconst Truth = true\n\tfmt.Println("Go rules?", Truth)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 数值常量\n\n数值常量是高精度的 值。\n\n一个未指定类型的常量由上下文来决定其类型。\n\n再尝试一下输出 needInt(Big) 吧。\n\n（int 类型最大可以存储一个 64 位的整数，有时会更小。）\n\n（int 可以存放最大64位的整数，根据平台不同有时会更少。）\n\npackage main\n\nimport "fmt"\n\nconst (\n\t// 将 1 左移 100 位来创建一个非常大的数字\n\t// 即这个数的二进制是 1 后面跟着 100 个 0\n\tBig = 1 << 100\n\t// 再往右移 99 位，即 Small = 1 << 1，或者说 Small = 2\n\tSmall = Big >> 99\n)\n\nfunc needInt(x int) int { return x*10 + 1 }\nfunc needFloat(x float64) float64 {\n\treturn x * 0.1\n}\n\nfunc main() {\n\tfmt.Println(needInt(Small))\n\tfmt.Println(needFloat(Small))\n\tfmt.Println(needFloat(Big))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',normalizedContent:'# 包\n\n每个 go 程序都是由包构成的。\n\n程序从 main 包开始运行。\n\n本程序通过导入路径 "fmt" 和 "math/rand" 来使用这两个包。\n\n按照约定，包名与导入路径的最后一个元素一致。例如，"math/rand" 包中的源码均以 package rand 语句开始。\n\n注意： 此程序的运行环境是固定的，因此 rand.intn 总是会返回相同的数字。 （要得到不同的数字，需为生成器提供不同的种子数，参见 rand.seed。 练习场中的时间为常量，因此你需要用其它的值作为种子数。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math/rand"\n)\n\nfunc main() {\n\tfmt.println("my favorite number is", rand.intn(10))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 导入\n\n此代码用圆括号组合了导入，这是“分组”形式的导入语句。\n\n当然你也可以编写多个导入语句，例如：\n\nimport "fmt"\nimport "math"\n\n\n不过使用分组导入语句是更好的形式。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tfmt.printf("now you have %g problems.\\n", math.sqrt(7))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 导出名\n\n在 go 中，如果一个名字以大写字母开头，那么它就是已导出的。例如，pizza 就是个已导出名，pi 也同样，它导出自 math 包。\n\npizza 和 pi 并未以大写字母开头，所以它们是未导出的。\n\n在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问。\n\n执行代码，观察错误输出。\n\n然后将 math.pi 改名为 math.pi 再试着执行一次。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tfmt.println(math.pi)\n\t// fmt.println(math.pi)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 函数\n\n函数可以没有参数或接受多个参数。\n\n在本例中，add 接受两个 int 类型的参数。\n\n注意类型在变量名 之后。\n\n（参考 这篇关于 go 语法声明的文章了解这种类型声明形式出现的原因。）\n\npackage main\n\nimport "fmt"\n\nfunc add(x int, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.println(add(42, 13))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 函数（续）\n\n当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。\n\n在本例中，\n\nx int, y int\n\n\n被缩写为\n\nx, y int\n\n\npackage main\n\nimport "fmt"\n\nfunc add(x, y int) int {\n\treturn x + y\n}\n\nfunc main() {\n\tfmt.println(add(42, 13))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 多值返回\n\n函数可以返回任意数量的返回值。\n\nswap 函数返回了两个字符串。\n\npackage main\n\nimport "fmt"\n\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n\nfunc main() {\n\ta, b := swap("hello", "world")\n\tfmt.println(a, b)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 命名返回值\n\ngo 的返回值可被命名，它们会被视作定义在函数顶部的变量。\n\n返回值的名称应当具有一定的意义，它可以作为文档使用。\n\n没有参数的 return 语句返回已命名的返回值。也就是 直接 返回。\n\n直接返回语句应当仅用在下面这样的短函数中。在长的函数中它们会影响代码的可读性。\n\npackage main\n\nimport "fmt"\n\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\n}\n\nfunc main() {\n\tfmt.println(split(17))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 变量\n\nvar 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后。\n\n就像在这个例子中看到的一样，var 语句可以出现在包或函数级别。\n\npackage main\n\nimport "fmt"\n\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.println(i, c, python, java)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 变量的初始化\n\n变量声明可以包含初始值，每个变量对应一个。\n\n如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\npackage main\n\nimport "fmt"\n\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, "no!"\n\tfmt.println(i, j, c, python, java)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 短变量声明\n\n在函数中，简洁赋值语句 := 可在类型明确的地方代替 var 声明。\n\n函数外的每个语句都必须以关键字开始（var, func 等等），因此 := 结构不能在函数外使用。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, "no!"\n\n\tfmt.println(i, j, k, c, python, java)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 基本类型\n\ngo 的基本类型有\n\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n\t// 表示一个 unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n\n\n本例展示了几种类型的变量。 同导入语句一样，变量声明也可以“分组”成一个语法块。\n\nint, uint 和 uintptr 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽。 当你需要一个整数值时应使用 int 类型，除非你有特殊的理由使用固定大小或无符号的整数类型。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math/cmplx"\n)\n\nvar (\n\ttobe   bool       = false\n\tmaxint uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tfmt.printf("type: %t value: %v\\n", tobe, tobe)\n\tfmt.printf("type: %t value: %v\\n", maxint, maxint)\n\tfmt.printf("type: %t value: %v\\n", z, z)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 零值\n\n没有明确初始值的变量声明会被赋予它们的 零值。\n\n零值是：\n\n数值类型为 0，\n布尔类型为 false，\n字符串为 ""（空字符串）。\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i int\n\tvar f float64\n\tvar b bool\n\tvar s string\n\tfmt.printf("%v %v %v %q\\n", i, f, b, s)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 类型转换\n\n表达式 t(v) 将值 v 转换为类型 t。\n\n一些关于数值的转换：\n\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n\n\n或者，更加简单的形式：\n\ni := 42\nf := float64(i)\nu := uint(f)\n\n\n与 c 不同的是，go 在不同类型的项之间赋值时需要显式转换。试着移除例子中 float64 或 uint 的转换看看会发生什么。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc main() {\n\tvar x, y int = 3, 4\n\tvar f float64 = math.sqrt(float64(x*x + y*y))\n\tvar z uint = uint(f)\n\tfmt.println(x, y, z)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 类型推导\n\n在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\nvar i int\nj := i // j 也是一个 int\n\n\n不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：\n\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n\n\n尝试修改示例代码中 v 的初始值，并观察它是如何影响类型的。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tv := 42 // 修改这里！\n\tfmt.printf("v is of type %t\\n", v)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 常量\n\n常量的声明与变量类似，只不过是使用 const 关键字。\n\n常量可以是字符、字符串、布尔值或数值。\n\n常量不能用 := 语法声明。\n\npackage main\n\nimport "fmt"\n\nconst pi = 3.14\n\nfunc main() {\n\tconst world = "世界"\n\tfmt.println("hello", world)\n\tfmt.println("happy", pi, "day")\n\n\tconst truth = true\n\tfmt.println("go rules?", truth)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 数值常量\n\n数值常量是高精度的 值。\n\n一个未指定类型的常量由上下文来决定其类型。\n\n再尝试一下输出 needint(big) 吧。\n\n（int 类型最大可以存储一个 64 位的整数，有时会更小。）\n\n（int 可以存放最大64位的整数，根据平台不同有时会更少。）\n\npackage main\n\nimport "fmt"\n\nconst (\n\t// 将 1 左移 100 位来创建一个非常大的数字\n\t// 即这个数的二进制是 1 后面跟着 100 个 0\n\tbig = 1 << 100\n\t// 再往右移 99 位，即 small = 1 << 1，或者说 small = 2\n\tsmall = big >> 99\n)\n\nfunc needint(x int) int { return x*10 + 1 }\nfunc needfloat(x float64) float64 {\n\treturn x * 0.1\n}\n\nfunc main() {\n\tfmt.println(needint(small))\n\tfmt.println(needfloat(small))\n\tfmt.println(needfloat(big))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:41:21",lastUpdatedTimestamp:1680709281e3},{title:"Go-控制流",frontmatter:{title:"Go-控制流",date:"2023-03-13T09:05:24.000Z",permalink:"/pages/7f78ce/",categories:["编程语言-golang"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--golang/3.%E6%8E%A7%E5%88%B6%E6%B5%81.html",relativePath:"编程语言--golang/3.控制流.md",key:"v-3318fa93",path:"/pages/7f78ce/",headers:[{level:2,title:"for",slug:"for",normalizedTitle:"for",charIndex:2},{level:2,title:"for（续）",slug:"for-续",normalizedTitle:"for（续）",charIndex:395},{level:2,title:"for 是 Go 中的 “while”",slug:"for-是-go-中的-while",normalizedTitle:"for 是 go 中的 “while”",charIndex:564},{level:2,title:"无限循环",slug:"无限循环",normalizedTitle:"无限循环",charIndex:764},{level:2,title:"if",slug:"if",normalizedTitle:"if",charIndex:866},{level:2,title:"if 的简短语句",slug:"if-的简短语句",normalizedTitle:"if 的简短语句",charIndex:1170},{level:2,title:"if 和 else",slug:"if-和-else",normalizedTitle:"if 和 else",charIndex:1537},{level:2,title:"练习：循环与函数",slug:"练习-循环与函数",normalizedTitle:"练习：循环与函数",charIndex:1987},{level:2,title:"switch",slug:"switch",normalizedTitle:"switch",charIndex:2921},{level:2,title:"switch 的求值顺序",slug:"switch-的求值顺序",normalizedTitle:"switch 的求值顺序",charIndex:3532},{level:2,title:"没有条件的 switch",slug:"没有条件的-switch",normalizedTitle:"没有条件的 switch",charIndex:4088},{level:2,title:"defer",slug:"defer",normalizedTitle:"defer",charIndex:4456},{level:2,title:"defer 栈",slug:"defer-栈",normalizedTitle:"defer 栈",charIndex:4653}],headersStr:"for for（续） for 是 Go 中的 “while” 无限循环 if if 的简短语句 if 和 else 练习：循环与函数 switch switch 的求值顺序 没有条件的 switch defer defer 栈",content:'# for\n\nGo 只有一种循环结构：for 循环。\n\n基本的 for 循环由三部分组成，它们用分号隔开：\n\n初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 false，循环迭代就会终止。\n\n注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 { } 则是必须的。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.Println(sum)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# for（续）\n\n初始化语句和后置语句是可选的。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 1\n\tfor ; sum < 1000; {\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# for 是 Go 中的 “while”\n\n此时你可以去掉分号，因为 C 的 while 在 Go 中叫做 for。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 1\n\tfor sum < 1000 {\n\t\tsum += sum\n\t}\n\tfmt.Println(sum)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 无限循环\n\n如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。\n\npackage main\n\nfunc main() {\n\tfor {\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# if\n\nGo 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc sqrt(x float64) string {\n\tif x < 0 {\n\t\treturn sqrt(-x) + "i"\n\t}\n\treturn fmt.Sprint(math.Sqrt(x))\n}\n\nfunc main() {\n\tfmt.Println(sqrt(2), sqrt(-4))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# if 的简短语句\n\n同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。\n\n该语句声明的变量作用域仅在 if 之内。\n\n（在最后的 return 语句处使用 v 看看。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# if 和 else\n\n在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。\n\n（在 main 的 fmt.Println 调用开始前，两次对 pow 的调用均已执行并返回其各自的结果。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.Printf("%g >= %g\\n", v, lim)\n\t}\n\t// 这里开始就不能使用 v 了\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 练习：循环与函数\n\n为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。\n\n计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：\n\nz -= (zz - x) / (2z) 重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。\n\n在提供的 func Sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 ...）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。\n\n提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：\n\nz := 1.0 z := float64(1) 然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.Sqrt 接近吗？\n\n（注： 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法。 它对很多函数，特别是平方根而言非常有效。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc Sqrt(x float64) (float64, int) {\n\tz := 0.0\n\ty := x / 2\n\ti := 0\n\n\tfor i = 0; math.Abs(z-y) > 0.01; i++ {\n\t\tz = y\n\t\ty -= (z*z - x) / (2 * z)\n\t\tfmt.Println(y, math.Abs(z-y))\n\t}\n\n\treturn z, i\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(20))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# switch\n\nswitch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n\nGo 的 switch 语句类似于 C、C++、Java、JavaScript 和 PHP 中的，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\npackage main\n\nimport (\n\t"fmt"\n\t"runtime"\n)\n\nfunc main() {\n\tfmt.Print("Go runs on ")\n\tswitch os := runtime.GOOS; os {\n\tcase "darwin":\n\t\tfmt.Println("OS X.")\n\tcase "linux":\n\t\tfmt.Println("Linux.")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf("%s.\\n", os)\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# switch 的求值顺序\n\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n\n（例如，\n\nswitch i {\ncase 0:\ncase f():\n}\n\n\n在 i==0 时 f 不会被调用。）\n\n注意： Go 练习场中的时间总是从 2009-11-10 23:00:00 UTC 开始，该值的意义留给读者去发现。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\tfmt.Println("When\'s Saturday?")\n\ttoday := time.Now().Weekday()\n\tswitch time.Saturday {\n\tcase today + 0:\n\t\tfmt.Println("Today.")\n\tcase today + 1:\n\t\tfmt.Println("Tomorrow.")\n\tcase today + 2:\n\t\tfmt.Println("In two days.")\n\tdefault:\n\t\tfmt.Println("Too far away.")\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 没有条件的 switch\n\n没有条件的 switch 同 switch true 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\tt := time.Now()\n\tswitch {\n\tcase t.Hour() < 12:\n\t\tfmt.Println("Good morning!")\n\tcase t.Hour() < 17:\n\t\tfmt.Println("Good afternoon.")\n\tdefault:\n\t\tfmt.Println("Good evening.")\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tdefer fmt.Println("world")\n\n\tfmt.Println("hello")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# defer 栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n更多关于 defer 语句的信息，请阅读此博文。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.Println("counting")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\n\tfmt.Println("done")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',normalizedContent:'# for\n\ngo 只有一种循环结构：for 循环。\n\n基本的 for 循环由三部分组成，它们用分号隔开：\n\n初始化语句：在第一次迭代前执行 条件表达式：在每次迭代前求值 后置语句：在每次迭代的结尾执行 初始化语句通常为一句短变量声明，该变量声明仅在 for 语句的作用域中可见。\n\n一旦条件表达式的布尔值为 false，循环迭代就会终止。\n\n注意：和 c、java、javascript 之类的语言不同，go 的 for 语句后面的三个构成部分外没有小括号， 大括号 { } 则是必须的。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 0\n\tfor i := 0; i < 10; i++ {\n\t\tsum += i\n\t}\n\tfmt.println(sum)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# for（续）\n\n初始化语句和后置语句是可选的。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 1\n\tfor ; sum < 1000; {\n\t\tsum += sum\n\t}\n\tfmt.println(sum)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# for 是 go 中的 “while”\n\n此时你可以去掉分号，因为 c 的 while 在 go 中叫做 for。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tsum := 1\n\tfor sum < 1000 {\n\t\tsum += sum\n\t}\n\tfmt.println(sum)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 无限循环\n\n如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑。\n\npackage main\n\nfunc main() {\n\tfor {\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# if\n\ngo 的 if 语句与 for 循环类似，表达式外无需小括号 ( ) ，而大括号 { } 则是必须的。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc sqrt(x float64) string {\n\tif x < 0 {\n\t\treturn sqrt(-x) + "i"\n\t}\n\treturn fmt.sprint(math.sqrt(x))\n}\n\nfunc main() {\n\tfmt.println(sqrt(2), sqrt(-4))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# if 的简短语句\n\n同 for 一样， if 语句可以在条件表达式前执行一个简单的语句。\n\n该语句声明的变量作用域仅在 if 之内。\n\n（在最后的 return 语句处使用 v 看看。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n\nfunc main() {\n\tfmt.println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# if 和 else\n\n在 if 的简短语句中声明的变量同样可以在任何对应的 else 块中使用。\n\n（在 main 的 fmt.println 调用开始前，两次对 pow 的调用均已执行并返回其各自的结果。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.pow(x, n); v < lim {\n\t\treturn v\n\t} else {\n\t\tfmt.printf("%g >= %g\\n", v, lim)\n\t}\n\t// 这里开始就不能使用 v 了\n\treturn lim\n}\n\nfunc main() {\n\tfmt.println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 练习：循环与函数\n\n为了练习函数与循环，我们来实现一个平方根函数：用牛顿法实现平方根函数。\n\n计算机通常使用循环来计算 x 的平方根。从某个猜测的值 z 开始，我们可以根据 z² 与 x 的近似度来调整 z，产生一个更好的猜测：\n\nz -= (zz - x) / (2z) 重复调整的过程，猜测的结果会越来越精确，得到的答案也会尽可能接近实际的平方根。\n\n在提供的 func sqrt 中实现它。无论输入是什么，对 z 的一个恰当的猜测为 1。 要开始，请重复计算 10 次并随之打印每次的 z 值。观察对于不同的值 x（1、2、3 ...）， 你得到的答案是如何逼近结果的，猜测提升的速度有多快。\n\n提示：用类型转换或浮点数语法来声明并初始化一个浮点数值：\n\nz := 1.0 z := float64(1) 然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数大于还是小于 10。 尝试改变 z 的初始猜测，如 x 或 x/2。你的函数结果与标准库中的 math.sqrt 接近吗？\n\n（注： 如果你对该算法的细节感兴趣，上面的 z² − x 是 z² 到它所要到达的值（即 x）的距离， 除以的 2z 为 z² 的导数，我们通过 z² 的变化速度来改变 z 的调整量。 这种通用方法叫做牛顿法。 它对很多函数，特别是平方根而言非常有效。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc sqrt(x float64) (float64, int) {\n\tz := 0.0\n\ty := x / 2\n\ti := 0\n\n\tfor i = 0; math.abs(z-y) > 0.01; i++ {\n\t\tz = y\n\t\ty -= (z*z - x) / (2 * z)\n\t\tfmt.println(y, math.abs(z-y))\n\t}\n\n\treturn z, i\n}\n\nfunc main() {\n\tfmt.println(sqrt(20))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# switch\n\nswitch 是编写一连串 if - else 语句的简便方法。它运行第一个值等于条件表达式的 case 语句。\n\ngo 的 switch 语句类似于 c、c++、java、javascript 和 php 中的，不过 go 只运行选定的 case，而非之后所有的 case。 实际上，go 自动提供了在这些语言中每个 case 后面所需的 break 语句。 除非以 fallthrough 语句结束，否则分支会自动终止。 go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\npackage main\n\nimport (\n\t"fmt"\n\t"runtime"\n)\n\nfunc main() {\n\tfmt.print("go runs on ")\n\tswitch os := runtime.goos; os {\n\tcase "darwin":\n\t\tfmt.println("os x.")\n\tcase "linux":\n\t\tfmt.println("linux.")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.printf("%s.\\n", os)\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# switch 的求值顺序\n\nswitch 的 case 语句从上到下顺次执行，直到匹配成功时停止。\n\n（例如，\n\nswitch i {\ncase 0:\ncase f():\n}\n\n\n在 i==0 时 f 不会被调用。）\n\n注意： go 练习场中的时间总是从 2009-11-10 23:00:00 utc 开始，该值的意义留给读者去发现。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\tfmt.println("when\'s saturday?")\n\ttoday := time.now().weekday()\n\tswitch time.saturday {\n\tcase today + 0:\n\t\tfmt.println("today.")\n\tcase today + 1:\n\t\tfmt.println("tomorrow.")\n\tcase today + 2:\n\t\tfmt.println("in two days.")\n\tdefault:\n\t\tfmt.println("too far away.")\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 没有条件的 switch\n\n没有条件的 switch 同 switch true 一样。\n\n这种形式能将一长串 if-then-else 写得更加清晰。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\tt := time.now()\n\tswitch {\n\tcase t.hour() < 12:\n\t\tfmt.println("good morning!")\n\tcase t.hour() < 17:\n\t\tfmt.println("good afternoon.")\n\tdefault:\n\t\tfmt.println("good evening.")\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tdefer fmt.println("world")\n\n\tfmt.println("hello")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# defer 栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n更多关于 defer 语句的信息，请阅读此博文。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tfmt.println("counting")\n\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.println(i)\n\t}\n\n\tfmt.println("done")\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n',charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:41:21",lastUpdatedTimestamp:1680709281e3},{title:"Go-更多类型",frontmatter:{title:"Go-更多类型",date:"2023-03-13T09:05:53.000Z",permalink:"/pages/600b2c/",categories:["编程语言-golang"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--golang/4.%E6%9B%B4%E5%A4%9A%E7%B1%BB%E5%9E%8B.html",relativePath:"编程语言--golang/4.更多类型.md",key:"v-42e1da52",path:"/pages/600b2c/",headers:[{level:2,title:"指针",slug:"指针",normalizedTitle:"指针",charIndex:2},{level:2,title:"结构体",slug:"结构体",normalizedTitle:"结构体",charIndex:575},{level:2,title:"结构体字段",slug:"结构体字段",normalizedTitle:"结构体字段",charIndex:773},{level:2,title:"结构体指针",slug:"结构体指针",normalizedTitle:"结构体指针",charIndex:976},{level:2,title:"结构体文法",slug:"结构体文法",normalizedTitle:"结构体文法",charIndex:1292},{level:2,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:1740},{level:2,title:"切片",slug:"切片",normalizedTitle:"切片",charIndex:2171},{level:2,title:"切片就像数组的引用",slug:"切片就像数组的引用",normalizedTitle:"切片就像数组的引用",charIndex:2547},{level:2,title:"切片文法",slug:"切片文法",normalizedTitle:"切片文法",charIndex:3049},{level:2,title:"切片的默认行为",slug:"切片的默认行为",normalizedTitle:"切片的默认行为",charIndex:3672},{level:2,title:"切片的长度与容量",slug:"切片的长度与容量",normalizedTitle:"切片的长度与容量",charIndex:4037},{level:2,title:"nil 切片",slug:"nil-切片",normalizedTitle:"nil 切片",charIndex:4678},{level:2,title:"用 make 创建切片",slug:"用-make-创建切片",normalizedTitle:"用 make 创建切片",charIndex:4910},{level:2,title:"切片的切片",slug:"切片的切片",normalizedTitle:"切片的切片",charIndex:5640},{level:2,title:"向切片追加元素",slug:"向切片追加元素",normalizedTitle:"向切片追加元素",charIndex:6166},{level:2,title:"Range",slug:"range",normalizedTitle:"range",charIndex:6916},{level:2,title:"range（续）",slug:"range-续",normalizedTitle:"range（续）",charIndex:7298},{level:2,title:"练习：切片",slug:"练习-切片",normalizedTitle:"练习：切片",charIndex:7702},{level:2,title:"映射",slug:"映射",normalizedTitle:"映射",charIndex:6945},{level:2,title:"映射的文法",slug:"映射的文法",normalizedTitle:"映射的文法",charIndex:8483},{level:2,title:"映射的文法（续）",slug:"映射的文法-续",normalizedTitle:"映射的文法（续）",charIndex:8875},{level:2,title:"修改映射",slug:"修改映射",normalizedTitle:"修改映射",charIndex:9244},{level:2,title:"练习：映射",slug:"练习-映射",normalizedTitle:"练习：映射",charIndex:9991},{level:2,title:"函数值",slug:"函数值",normalizedTitle:"函数值",charIndex:10322},{level:2,title:"函数的闭包",slug:"函数的闭包",normalizedTitle:"函数的闭包",charIndex:10752},{level:2,title:"练习：斐波纳契闭包",slug:"练习-斐波纳契闭包",normalizedTitle:"练习：斐波纳契闭包",charIndex:11276}],headersStr:"指针 结构体 结构体字段 结构体指针 结构体文法 数组 切片 切片就像数组的引用 切片文法 切片的默认行为 切片的长度与容量 nil 切片 用 make 创建切片 切片的切片 向切片追加元素 Range range（续） 练习：切片 映射 映射的文法 映射的文法（续） 修改映射 练习：映射 函数值 函数的闭包 练习：斐波纳契闭包",content:'# 指针\n\nGo 拥有指针。指针保存了值的内存地址。\n\n类型 *T 是指向 T 类型值的指针。其零值为 nil。\n\nvar p *int\n\n\n& 操作符会生成一个指向其操作数的指针。\n\ni := 42\np = &i\n\n\n* 操作符表示指针指向的底层值。\n\nfmt.Println(*p) // 通过指针 p 读取 i\n*p = 21         // 通过指针 p 设置 i\n\n\n这也就是通常所说的“间接引用”或“重定向”。\n\n与 C 不同，Go 没有指针运算。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.Println(*p) // 通过指针读取 i 的值\n\t*p = 21         // 通过指针设置 i 的值\n\tfmt.Println(i)  // 查看 i 的值\n\n\tp = &j         // 指向 j\n\t*p = *p / 37   // 通过指针对 j 进行除法运算\n\tfmt.Println(j) // 查看 j 的值\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n42\n21\n73\n\n\n1\n2\n3\n\n\n\n# 结构体\n\n一个结构体（struct）就是一组字段（field）。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tfmt.Println(Vertex{1, 2})\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n结果：\n\n{1 2}\n\n\n1\n\n\n\n# 结构体字段\n\n结构体字段使用点号来访问。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tv.X = 4\n\tfmt.Println(v.X)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n结果：\n\n4\n\n\n1\n\n\n\n# 结构体指针\n\n结构体字段可以通过结构体指针来访问。\n\n如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tv := Vertex{1, 2}\n\tp := &v\n\tp.X = 1e9\n\tfmt.Println(v)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果：\n\n{1000000000 2}\n\n\n1\n\n\n\n# 结构体文法\n\n结构体文法通过直接列出字段的值来新分配一个结构体。\n\n使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）\n\n特殊的前缀 & 返回一个指向结构体的指针。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tX, Y int\n}\n\nvar (\n\tv1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体\n\tv2 = Vertex{X: 1}  // Y:0 被隐式地赋予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）\n)\n\nfunc main() {\n\tfmt.Println(v1, p, v2, v3)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结果：\n\n{1 2} &{1 2} {1 0} {0 0}\n\n\n1\n\n\n\n# 数组\n\n类型 [n]T 表示拥有 n 个 T 类型的值的数组。\n\n表达式\n\nvar a [10]int\n\n\n会将变量 a 声明为拥有 10 个整数的数组。\n\n数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，Go 提供了更加便利的方式来使用数组。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar a [2]string\n\ta[0] = "Hello"\n\ta[1] = "World"\n\tfmt.Println(a[0], a[1])\n\tfmt.Println(a)\n\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(primes)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n结果：\n\nHello World\n[Hello World]\n[2 3 5 7 11 13]\n\n\n1\n2\n3\n\n\n\n# 切片\n\n每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n\n类型 []T 表示一个元素类型为 T 的切片。\n\n切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：\n\na[low : high] 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n\n以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素：\n\na[1:4]\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\n\tvar s []int = primes[1:4]\n\tfmt.Println(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结果：\n\n[3 5 7]\n\n\n1\n\n\n\n# 切片就像数组的引用\n\n切片并不存储任何数据，它只是描述了底层数组中的一段。\n\n更改切片的元素会修改其底层数组中对应的元素。\n\n与它共享底层数组的切片都会观测到这些修改。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tnames := [4]string{\n\t\t"John",\n\t\t"Paul",\n\t\t"George",\n\t\t"Ringo",\n\t}\n\tfmt.Println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.Println(a, b)\n\n\tb[0] = "XXX"\n\tfmt.Println(a, b)\n\tfmt.Println(names)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果：\n\n[John Paul George Ringo]\n[John Paul] [Paul George]\n[John XXX] [XXX George]\n[John XXX George Ringo]\n\n\n1\n2\n3\n4\n\n\n\n# 切片文法\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：\n\n[3]bool{true, true, false}\n\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n[]bool{true, true, false}\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tq := []int{2, 3, 5, 7, 11, 13}\n\tfmt.Println(q)\n\n\tr := []bool{true, false, true, true, false, true}\n\tfmt.Println(r)\n\n\ts := []struct {\n\t\ti int\n\t\tb bool\n\t}{\n\t\t{2, true},\n\t\t{3, false},\n\t\t{5, true},\n\t\t{7, true},\n\t\t{11, false},\n\t\t{13, true},\n\t}\n\tfmt.Println(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n结果：\n\n[2 3 5 7 11 13]\n[true false true true false true]\n[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]\n\n\n1\n2\n3\n\n\n\n# 切片的默认行为\n\n在进行切片时，你可以利用它的默认行为来忽略上下界。\n\n切片下界的默认值为 0，上界则是该切片的长度。\n\n对于数组\n\nvar a [10]int\n\n\n来说，以下切片是等价的：\n\na[0:10]\na[:10]\na[0:]\na[:]\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\n\ts = s[1:4]\n\tfmt.Println(s)\n\n\ts = s[:2]\n\tfmt.Println(s)\n\n\ts = s[1:]\n\tfmt.Println(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\n[3 5 7]\n[3 5]\n[5]\n\n\n1\n2\n3\n\n\n\n# 切片的长度与容量\n\n切片拥有 长度 和 容量。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。\n\n切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。\n\n你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s)\n\n\t// 截取切片使其长度为 0\n\ts = s[:0]\n\tprintSlice(s)\n\n\t// 拓展其长度\n\ts = s[:4]\n\tprintSlice(s)\n\n\t// 舍弃前两个值\n\ts = s[2:]\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf("len=%d cap=%d %v\\n", len(s), cap(s), s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n结果：\n\nlen=6 cap=6 [2 3 5 7 11 13]\nlen=0 cap=6 []\nlen=4 cap=6 [2 3 5 7]\nlen=2 cap=4 [5 7]\n\n\n1\n2\n3\n4\n\n\n\n# nil 切片\n\n切片的零值是 nil。\n\nnil 切片的长度和容量为 0 且没有底层数组。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar s []int\n\tfmt.Println(s, len(s), cap(s))\n\tif s == nil {\n\t\tfmt.Println("nil!")\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n[] 0 0\nnil!\n\n\n1\n2\n\n\n\n# 用 make 创建切片\n\n切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。\n\nmake 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\na := make([]int, 5)  // len(a)=5\n\n\n要指定它的容量，需向 make 传入第三个参数：\n\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ta := make([]int, 5)\n\tprintSlice("a", a)\n\n\tb := make([]int, 0, 5)\n\tprintSlice("b", b)\n\n\tc := b[:2]\n\tprintSlice("c", c)\n\n\td := c[2:5]\n\tprintSlice("d", d)\n}\n\nfunc printSlice(s string, x []int) {\n\tfmt.Printf("%s len=%d cap=%d %v\\n",\n\t\ts, len(x), cap(x), x)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\na len=5 cap=5 [0 0 0 0 0]\nb len=0 cap=5 []\nc len=2 cap=5 [0 0]\nd len=3 cap=3 [0 0 0]\n\n\n1\n2\n3\n4\n\n\n\n# 切片的切片\n\n切片可包含任何类型，甚至包括其它的切片。\n\npackage main\n\nimport (\n\t"fmt"\n\t"strings"\n)\n\nfunc main() {\n\t// 创建一个井字板（经典游戏）\n\tboard := [][]string{\n\t\t[]string{"_", "_", "_"},\n\t\t[]string{"_", "_", "_"},\n\t\t[]string{"_", "_", "_"},\n\t}\n\n\t// 两个玩家轮流打上 X 和 O\n\tboard[0][0] = "X"\n\tboard[2][2] = "O"\n\tboard[1][2] = "X"\n\tboard[1][0] = "O"\n\tboard[0][2] = "X"\n\n\tfor i := 0; i < len(board); i++ {\n\t\tfmt.Printf("%s\\n", strings.Join(board[i], " "))\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n结果：\n\nX _ X\nO _ X\n_ _ O\n\n\n1\n2\n3\n\n\n\n# 向切片追加元素\n\n为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。\n\nfunc append(s []T, vs ...T) []T\n\n\nappend 的第一个参数 s 是一个元素类型为 T 的切片，其余类型为 T 的值将会追加到该切片的末尾。\n\nappend 的结果是一个包含原切片所有元素加上新添加元素的切片。\n\n当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n\n（要了解关于切片的更多内容，请阅读文章 Go 切片：用法和本质。）\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar s []int\n\tprintSlice(s)\n\n\t// 添加一个空切片\n\ts = append(s, 0)\n\tprintSlice(s)\n\n\t// 这个切片会按需增长\n\ts = append(s, 1)\n\tprintSlice(s)\n\n\t// 可以一次性添加多个元素\n\ts = append(s, 2, 3, 4)\n\tprintSlice(s)\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf("len=%d cap=%d %v\\n", len(s), cap(s), s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n结果：\n\nlen=0 cap=0 []\nlen=1 cap=1 [0]\nlen=2 cap=2 [0 1]\nlen=5 cap=6 [0 1 2 3 4]\n\n\n1\n2\n3\n4\n\n\n\n# Range\n\nfor 循环的 range 形式可遍历切片或映射。\n\n当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n\npackage main\n\nimport "fmt"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.Printf("2**%d = %d\\n", i, v)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n2**0 = 1\n2**1 = 2\n2**2 = 4\n2**3 = 8\n2**4 = 16\n2**5 = 32\n2**6 = 64\n2**7 = 128\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# range（续）\n\n可以将下标或值赋予 _ 来忽略它。\n\nfor i, _ := range pow\nfor _, value := range pow\n\n\n若你只需要索引，忽略第二个变量即可。\n\nfor i := range pow\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tpow := make([]int, 10)\n\tfor i := range pow {\n\t\tpow[i] = 1 << uint(i) // == 2**i\n\t}\n\tfor _, value := range pow {\n\t\tfmt.Printf("%d\\n", value)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n结果：\n\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 练习：切片\n\n实现 Pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。\n\n图像的选择由你来定。几个有趣的函数包括 (x+y)/2, xy, x^y, xlog(y) 和 x%(y+1)。\n\n（提示：需要使用循环来分配 [][]uint8 中的每个 []uint8；请使用 uint8(intValue) 在类型之间转换；你可能会用到 math 包中的函数。）\n\npackage main\n\nimport "golang.org/x/tour/pic"\n\nfunc Pic(dx, dy int) [][]uint8 {\n}\n\nfunc main() {\n\tpic.Show(Pic)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结果：\n\n\n\n\n# 映射\n\n映射将键映射到值。\n\n映射的零值为 nil 。nil 映射既没有键，也不能添加键。\n\nmake 函数会返回给定类型的映射，并将其初始化备用。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m map[string]Vertex\n\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm["Bell Labs"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m["Bell Labs"])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n{40.68433 -74.39967}\n\n\n1\n\n\n\n# 映射的文法\n\n映射的文法与结构体相似，不过必须有键名。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t"Bell Labs": Vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t"Google": Vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n结果：\n\nmap[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]\n\n\n1\n\n\n\n# 映射的文法（续）\n\n若顶级类型只是一个类型名，你可以在文法的元素中省略它。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tLat, Long float64\n}\n\nvar m = map[string]Vertex{\n\t"Bell Labs": {40.68433, -74.39967},\n\t"Google":    {37.42202, -122.08408},\n}\n\nfunc main() {\n\tfmt.Println(m)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\nmap[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]\n\n\n1\n\n\n\n# 修改映射\n\n在映射 m 中插入或修改元素：\n\nm[key] = elem\n\n\n获取元素：\n\nelem = m[key]\n\n\n删除元素：\n\ndelete(m, key)\n\n\n通过双赋值检测某个键是否存在：\n\nelem, ok = m[key]\n\n\n若 key 在 m 中，ok 为 true ；否则，ok 为 false。\n\n若 key 不在映射中，那么 elem 是该映射元素类型的零值。\n\n同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。\n\n注 ：若 elem 或 ok 还未声明，你可以使用短变量声明：\n\nelem, ok := m[key]\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tm := make(map[string]int)\n\n\tm["Answer"] = 42\n\tfmt.Println("The value:", m["Answer"])\n\n\tm["Answer"] = 48\n\tfmt.Println("The value:", m["Answer"])\n\n\tdelete(m, "Answer")\n\tfmt.Println("The value:", m["Answer"])\n\n\tv, ok := m["Answer"]\n\tfmt.Println("The value:", v, "Present?", ok)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\nThe value: 42\nThe value: 48\nThe value: 0\nThe value: 0 Present? false\n\n\n1\n2\n3\n4\n\n\n\n# 练习：映射\n\n实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败。\n\n你会发现 strings.Fields 很有帮助。\n\npackage main\n\nimport (\n\t"golang.org/x/tour/wc"\n)\n\nfunc WordCount(s string) map[string]int {\n\treturn map[string]int{"x": 1}\n}\n\nfunc main() {\n\twc.Test(WordCount)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n结果：\n\n\n\n\n1\n\n\n\n# 函数值\n\n函数也是值。它们可以像其它值一样传递。\n\n函数值可以用作函数的参数或返回值。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\n\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.Sqrt(x*x + y*y)\n\t}\n\tfmt.Println(hypot(5, 12))\n\n\tfmt.Println(compute(hypot))\n\tfmt.Println(compute(math.Pow))\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n13\n5\n81\n\n\n1\n2\n3\n\n\n\n# 函数的闭包\n\nGo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。\n\n例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。\n\npackage main\n\nimport "fmt"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果：\n\n0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 练习：斐波纳契闭包\n\n让我们用函数做些好玩的事情。\n\n实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。\n\npackage main\n\nimport "fmt"\n\n// 返回一个“返回int的函数”\nfunc fibonacci() func() int {\n  a := 0\n\tb := 0\n\treturn func() int {\n\t\tif (a == 0) && (b == 0) {\n\t\t\tb = 1\n\t\t\treturn a\n\t\t}\n\t\tc := a + b\n\t\ta = b\n\t\tb = c\n\t\treturn a\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(f())\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n结果：\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# 指针\n\ngo 拥有指针。指针保存了值的内存地址。\n\n类型 *t 是指向 t 类型值的指针。其零值为 nil。\n\nvar p *int\n\n\n& 操作符会生成一个指向其操作数的指针。\n\ni := 42\np = &i\n\n\n* 操作符表示指针指向的底层值。\n\nfmt.println(*p) // 通过指针 p 读取 i\n*p = 21         // 通过指针 p 设置 i\n\n\n这也就是通常所说的“间接引用”或“重定向”。\n\n与 c 不同，go 没有指针运算。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ti, j := 42, 2701\n\n\tp := &i         // 指向 i\n\tfmt.println(*p) // 通过指针读取 i 的值\n\t*p = 21         // 通过指针设置 i 的值\n\tfmt.println(i)  // 查看 i 的值\n\n\tp = &j         // 指向 j\n\t*p = *p / 37   // 通过指针对 j 进行除法运算\n\tfmt.println(j) // 查看 j 的值\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n42\n21\n73\n\n\n1\n2\n3\n\n\n\n# 结构体\n\n一个结构体（struct）就是一组字段（field）。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tx int\n\ty int\n}\n\nfunc main() {\n\tfmt.println(vertex{1, 2})\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n结果：\n\n{1 2}\n\n\n1\n\n\n\n# 结构体字段\n\n结构体字段使用点号来访问。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tx int\n\ty int\n}\n\nfunc main() {\n\tv := vertex{1, 2}\n\tv.x = 4\n\tfmt.println(v.x)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n结果：\n\n4\n\n\n1\n\n\n\n# 结构体指针\n\n结构体字段可以通过结构体指针来访问。\n\n如果我们有一个指向结构体的指针 p，那么可以通过 (*p).x 来访问其字段 x。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.x 就可以。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tx int\n\ty int\n}\n\nfunc main() {\n\tv := vertex{1, 2}\n\tp := &v\n\tp.x = 1e9\n\tfmt.println(v)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n结果：\n\n{1000000000 2}\n\n\n1\n\n\n\n# 结构体文法\n\n结构体文法通过直接列出字段的值来新分配一个结构体。\n\n使用 name: 语法可以仅列出部分字段。（字段名的顺序无关。）\n\n特殊的前缀 & 返回一个指向结构体的指针。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tx, y int\n}\n\nvar (\n\tv1 = vertex{1, 2}  // 创建一个 vertex 类型的结构体\n\tv2 = vertex{x: 1}  // y:0 被隐式地赋予\n\tv3 = vertex{}      // x:0 y:0\n\tp  = &vertex{1, 2} // 创建一个 *vertex 类型的结构体（指针）\n)\n\nfunc main() {\n\tfmt.println(v1, p, v2, v3)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结果：\n\n{1 2} &{1 2} {1 0} {0 0}\n\n\n1\n\n\n\n# 数组\n\n类型 [n]t 表示拥有 n 个 t 类型的值的数组。\n\n表达式\n\nvar a [10]int\n\n\n会将变量 a 声明为拥有 10 个整数的数组。\n\n数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，go 提供了更加便利的方式来使用数组。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar a [2]string\n\ta[0] = "hello"\n\ta[1] = "world"\n\tfmt.println(a[0], a[1])\n\tfmt.println(a)\n\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\tfmt.println(primes)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n结果：\n\nhello world\n[hello world]\n[2 3 5 7 11 13]\n\n\n1\n2\n3\n\n\n\n# 切片\n\n每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n\n类型 []t 表示一个元素类型为 t 的切片。\n\n切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：\n\na[low : high] 它会选择一个半开区间，包括第一个元素，但排除最后一个元素。\n\n以下表达式创建了一个切片，它包含 a 中下标从 1 到 3 的元素：\n\na[1:4]\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tprimes := [6]int{2, 3, 5, 7, 11, 13}\n\n\tvar s []int = primes[1:4]\n\tfmt.println(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结果：\n\n[3 5 7]\n\n\n1\n\n\n\n# 切片就像数组的引用\n\n切片并不存储任何数据，它只是描述了底层数组中的一段。\n\n更改切片的元素会修改其底层数组中对应的元素。\n\n与它共享底层数组的切片都会观测到这些修改。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tnames := [4]string{\n\t\t"john",\n\t\t"paul",\n\t\t"george",\n\t\t"ringo",\n\t}\n\tfmt.println(names)\n\n\ta := names[0:2]\n\tb := names[1:3]\n\tfmt.println(a, b)\n\n\tb[0] = "xxx"\n\tfmt.println(a, b)\n\tfmt.println(names)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果：\n\n[john paul george ringo]\n[john paul] [paul george]\n[john xxx] [xxx george]\n[john xxx george ringo]\n\n\n1\n2\n3\n4\n\n\n\n# 切片文法\n\n切片文法类似于没有长度的数组文法。\n\n这是一个数组文法：\n\n[3]bool{true, true, false}\n\n\n下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：\n\n[]bool{true, true, false}\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tq := []int{2, 3, 5, 7, 11, 13}\n\tfmt.println(q)\n\n\tr := []bool{true, false, true, true, false, true}\n\tfmt.println(r)\n\n\ts := []struct {\n\t\ti int\n\t\tb bool\n\t}{\n\t\t{2, true},\n\t\t{3, false},\n\t\t{5, true},\n\t\t{7, true},\n\t\t{11, false},\n\t\t{13, true},\n\t}\n\tfmt.println(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n结果：\n\n[2 3 5 7 11 13]\n[true false true true false true]\n[{2 true} {3 false} {5 true} {7 true} {11 false} {13 true}]\n\n\n1\n2\n3\n\n\n\n# 切片的默认行为\n\n在进行切片时，你可以利用它的默认行为来忽略上下界。\n\n切片下界的默认值为 0，上界则是该切片的长度。\n\n对于数组\n\nvar a [10]int\n\n\n来说，以下切片是等价的：\n\na[0:10]\na[:10]\na[0:]\na[:]\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\n\ts = s[1:4]\n\tfmt.println(s)\n\n\ts = s[:2]\n\tfmt.println(s)\n\n\ts = s[1:]\n\tfmt.println(s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\n[3 5 7]\n[3 5]\n[5]\n\n\n1\n2\n3\n\n\n\n# 切片的长度与容量\n\n切片拥有 长度 和 容量。\n\n切片的长度就是它所包含的元素个数。\n\n切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。\n\n切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。\n\n你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintslice(s)\n\n\t// 截取切片使其长度为 0\n\ts = s[:0]\n\tprintslice(s)\n\n\t// 拓展其长度\n\ts = s[:4]\n\tprintslice(s)\n\n\t// 舍弃前两个值\n\ts = s[2:]\n\tprintslice(s)\n}\n\nfunc printslice(s []int) {\n\tfmt.printf("len=%d cap=%d %v\\n", len(s), cap(s), s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n结果：\n\nlen=6 cap=6 [2 3 5 7 11 13]\nlen=0 cap=6 []\nlen=4 cap=6 [2 3 5 7]\nlen=2 cap=4 [5 7]\n\n\n1\n2\n3\n4\n\n\n\n# nil 切片\n\n切片的零值是 nil。\n\nnil 切片的长度和容量为 0 且没有底层数组。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar s []int\n\tfmt.println(s, len(s), cap(s))\n\tif s == nil {\n\t\tfmt.println("nil!")\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n[] 0 0\nnil!\n\n\n1\n2\n\n\n\n# 用 make 创建切片\n\n切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。\n\nmake 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\na := make([]int, 5)  // len(a)=5\n\n\n要指定它的容量，需向 make 传入第三个参数：\n\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\n\nb = b[:cap(b)] // len(b)=5, cap(b)=5\nb = b[1:]      // len(b)=4, cap(b)=4\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\ta := make([]int, 5)\n\tprintslice("a", a)\n\n\tb := make([]int, 0, 5)\n\tprintslice("b", b)\n\n\tc := b[:2]\n\tprintslice("c", c)\n\n\td := c[2:5]\n\tprintslice("d", d)\n}\n\nfunc printslice(s string, x []int) {\n\tfmt.printf("%s len=%d cap=%d %v\\n",\n\t\ts, len(x), cap(x), x)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\na len=5 cap=5 [0 0 0 0 0]\nb len=0 cap=5 []\nc len=2 cap=5 [0 0]\nd len=3 cap=3 [0 0 0]\n\n\n1\n2\n3\n4\n\n\n\n# 切片的切片\n\n切片可包含任何类型，甚至包括其它的切片。\n\npackage main\n\nimport (\n\t"fmt"\n\t"strings"\n)\n\nfunc main() {\n\t// 创建一个井字板（经典游戏）\n\tboard := [][]string{\n\t\t[]string{"_", "_", "_"},\n\t\t[]string{"_", "_", "_"},\n\t\t[]string{"_", "_", "_"},\n\t}\n\n\t// 两个玩家轮流打上 x 和 o\n\tboard[0][0] = "x"\n\tboard[2][2] = "o"\n\tboard[1][2] = "x"\n\tboard[1][0] = "o"\n\tboard[0][2] = "x"\n\n\tfor i := 0; i < len(board); i++ {\n\t\tfmt.printf("%s\\n", strings.join(board[i], " "))\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n结果：\n\nx _ x\no _ x\n_ _ o\n\n\n1\n2\n3\n\n\n\n# 向切片追加元素\n\n为切片追加新的元素是种常用的操作，为此 go 提供了内建的 append 函数。内建函数的文档对此函数有详细的介绍。\n\nfunc append(s []t, vs ...t) []t\n\n\nappend 的第一个参数 s 是一个元素类型为 t 的切片，其余类型为 t 的值将会追加到该切片的末尾。\n\nappend 的结果是一个包含原切片所有元素加上新添加元素的切片。\n\n当 s 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n\n（要了解关于切片的更多内容，请阅读文章 go 切片：用法和本质。）\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar s []int\n\tprintslice(s)\n\n\t// 添加一个空切片\n\ts = append(s, 0)\n\tprintslice(s)\n\n\t// 这个切片会按需增长\n\ts = append(s, 1)\n\tprintslice(s)\n\n\t// 可以一次性添加多个元素\n\ts = append(s, 2, 3, 4)\n\tprintslice(s)\n}\n\nfunc printslice(s []int) {\n\tfmt.printf("len=%d cap=%d %v\\n", len(s), cap(s), s)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n结果：\n\nlen=0 cap=0 []\nlen=1 cap=1 [0]\nlen=2 cap=2 [0 1]\nlen=5 cap=6 [0 1 2 3 4]\n\n\n1\n2\n3\n4\n\n\n\n# range\n\nfor 循环的 range 形式可遍历切片或映射。\n\n当使用 for 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n\npackage main\n\nimport "fmt"\n\nvar pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfunc main() {\n\tfor i, v := range pow {\n\t\tfmt.printf("2**%d = %d\\n", i, v)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n结果：\n\n2**0 = 1\n2**1 = 2\n2**2 = 4\n2**3 = 8\n2**4 = 16\n2**5 = 32\n2**6 = 64\n2**7 = 128\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# range（续）\n\n可以将下标或值赋予 _ 来忽略它。\n\nfor i, _ := range pow\nfor _, value := range pow\n\n\n若你只需要索引，忽略第二个变量即可。\n\nfor i := range pow\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tpow := make([]int, 10)\n\tfor i := range pow {\n\t\tpow[i] = 1 << uint(i) // == 2**i\n\t}\n\tfor _, value := range pow {\n\t\tfmt.printf("%d\\n", value)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n结果：\n\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 练习：切片\n\n实现 pic。它应当返回一个长度为 dy 的切片，其中每个元素是一个长度为 dx，元素类型为 uint8 的切片。当你运行此程序时，它会将每个整数解释为灰度值（好吧，其实是蓝度值）并显示它所对应的图像。\n\n图像的选择由你来定。几个有趣的函数包括 (x+y)/2, xy, x^y, xlog(y) 和 x%(y+1)。\n\n（提示：需要使用循环来分配 [][]uint8 中的每个 []uint8；请使用 uint8(intvalue) 在类型之间转换；你可能会用到 math 包中的函数。）\n\npackage main\n\nimport "golang.org/x/tour/pic"\n\nfunc pic(dx, dy int) [][]uint8 {\n}\n\nfunc main() {\n\tpic.show(pic)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n结果：\n\n\n\n\n# 映射\n\n映射将键映射到值。\n\n映射的零值为 nil 。nil 映射既没有键，也不能添加键。\n\nmake 函数会返回给定类型的映射，并将其初始化备用。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tlat, long float64\n}\n\nvar m map[string]vertex\n\nfunc main() {\n\tm = make(map[string]vertex)\n\tm["bell labs"] = vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.println(m["bell labs"])\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n{40.68433 -74.39967}\n\n\n1\n\n\n\n# 映射的文法\n\n映射的文法与结构体相似，不过必须有键名。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tlat, long float64\n}\n\nvar m = map[string]vertex{\n\t"bell labs": vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t"google": vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\n\nfunc main() {\n\tfmt.println(m)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n结果：\n\nmap[bell labs:{40.68433 -74.39967} google:{37.42202 -122.08408}]\n\n\n1\n\n\n\n# 映射的文法（续）\n\n若顶级类型只是一个类型名，你可以在文法的元素中省略它。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tlat, long float64\n}\n\nvar m = map[string]vertex{\n\t"bell labs": {40.68433, -74.39967},\n\t"google":    {37.42202, -122.08408},\n}\n\nfunc main() {\n\tfmt.println(m)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n结果：\n\nmap[bell labs:{40.68433 -74.39967} google:{37.42202 -122.08408}]\n\n\n1\n\n\n\n# 修改映射\n\n在映射 m 中插入或修改元素：\n\nm[key] = elem\n\n\n获取元素：\n\nelem = m[key]\n\n\n删除元素：\n\ndelete(m, key)\n\n\n通过双赋值检测某个键是否存在：\n\nelem, ok = m[key]\n\n\n若 key 在 m 中，ok 为 true ；否则，ok 为 false。\n\n若 key 不在映射中，那么 elem 是该映射元素类型的零值。\n\n同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值。\n\n注 ：若 elem 或 ok 还未声明，你可以使用短变量声明：\n\nelem, ok := m[key]\n\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tm := make(map[string]int)\n\n\tm["answer"] = 42\n\tfmt.println("the value:", m["answer"])\n\n\tm["answer"] = 48\n\tfmt.println("the value:", m["answer"])\n\n\tdelete(m, "answer")\n\tfmt.println("the value:", m["answer"])\n\n\tv, ok := m["answer"]\n\tfmt.println("the value:", v, "present?", ok)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\nthe value: 42\nthe value: 48\nthe value: 0\nthe value: 0 present? false\n\n\n1\n2\n3\n4\n\n\n\n# 练习：映射\n\n实现 wordcount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.test 会对此函数执行一系列测试用例，并输出成功还是失败。\n\n你会发现 strings.fields 很有帮助。\n\npackage main\n\nimport (\n\t"golang.org/x/tour/wc"\n)\n\nfunc wordcount(s string) map[string]int {\n\treturn map[string]int{"x": 1}\n}\n\nfunc main() {\n\twc.test(wordcount)\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n结果：\n\n\n\n\n1\n\n\n\n# 函数值\n\n函数也是值。它们可以像其它值一样传递。\n\n函数值可以用作函数的参数或返回值。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\n\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.sqrt(x*x + y*y)\n\t}\n\tfmt.println(hypot(5, 12))\n\n\tfmt.println(compute(hypot))\n\tfmt.println(compute(math.pow))\n}\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n结果：\n\n13\n5\n81\n\n\n1\n2\n3\n\n\n\n# 函数的闭包\n\ngo 函数可以是一个闭包。闭包是一个函数值，它引用了其函数体之外的变量。该函数可以访问并赋予其引用的变量的值，换句话说，该函数被这些变量“绑定”在一起。\n\n例如，函数 adder 返回一个闭包。每个闭包都被绑定在其各自的 sum 变量上。\n\npackage main\n\nimport "fmt"\n\nfunc adder() func(int) int {\n\tsum := 0\n\treturn func(x int) int {\n\t\tsum += x\n\t\treturn sum\n\t}\n}\n\nfunc main() {\n\tpos, neg := adder(), adder()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.println(\n\t\t\tpos(i),\n\t\t\tneg(-2*i),\n\t\t)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果：\n\n0 0\n1 -2\n3 -6\n6 -12\n10 -20\n15 -30\n21 -42\n28 -56\n36 -72\n45 -90\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 练习：斐波纳契闭包\n\n让我们用函数做些好玩的事情。\n\n实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。\n\npackage main\n\nimport "fmt"\n\n// 返回一个“返回int的函数”\nfunc fibonacci() func() int {\n  a := 0\n\tb := 0\n\treturn func() int {\n\t\tif (a == 0) && (b == 0) {\n\t\t\tb = 1\n\t\t\treturn a\n\t\t}\n\t\tc := a + b\n\t\ta = b\n\t\tb = c\n\t\treturn a\n\t}\n}\n\nfunc main() {\n\tf := fibonacci()\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.println(f())\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n结果：\n\n0\n1\n1\n2\n3\n5\n8\n13\n21\n34\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:41:21",lastUpdatedTimestamp:1680709281e3},{title:"Go-方法",frontmatter:{title:"Go-方法",date:"2023-03-13T16:29:20.000Z",permalink:"/pages/7a5364/",categories:["编程语言-golang"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--golang/5.%E6%96%B9%E6%B3%95.html",relativePath:"编程语言--golang/5.方法.md",key:"v-728b9a42",path:"/pages/7a5364/",headers:[{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:2},{level:2,title:"方法即函数",slug:"方法即函数",normalizedTitle:"方法即函数",charIndex:404},{level:2,title:"方法（续）",slug:"方法-续",normalizedTitle:"方法（续）",charIndex:736},{level:2,title:"指针接收者",slug:"指针接收者",normalizedTitle:"指针接收者",charIndex:1209},{level:2,title:"指针与函数",slug:"指针与函数",normalizedTitle:"指针与函数",charIndex:1901},{level:2,title:"方法与指针重定向",slug:"方法与指针重定向",normalizedTitle:"方法与指针重定向",charIndex:2383},{level:2,title:"方法与指针重定向（续）",slug:"方法与指针重定向-续",normalizedTitle:"方法与指针重定向（续）",charIndex:3154},{level:2,title:"选择值或指针作为接收者",slug:"选择值或指针作为接收者",normalizedTitle:"选择值或指针作为接收者",charIndex:3918},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:4666},{level:2,title:"接口与隐式实现",slug:"接口与隐式实现",normalizedTitle:"接口与隐式实现",charIndex:5459},{level:2,title:"接口值",slug:"接口值",normalizedTitle:"接口值",charIndex:5869},{level:2,title:"底层值为 nil 的接口值",slug:"底层值为-nil-的接口值",normalizedTitle:"底层值为 nil 的接口值",charIndex:6551},{level:2,title:"nil 接口值",slug:"nil-接口值",normalizedTitle:"nil 接口值",charIndex:7222},{level:2,title:"空接口",slug:"空接口",normalizedTitle:"空接口",charIndex:7770},{level:2,title:"类型断言",slug:"类型断言",normalizedTitle:"类型断言",charIndex:8201},{level:2,title:"类型选择",slug:"类型选择",normalizedTitle:"类型选择",charIndex:8900},{level:2,title:"Stringer",slug:"stringer",normalizedTitle:"stringer",charIndex:9705},{level:2,title:"练习：Stringer",slug:"练习-stringer",normalizedTitle:"练习：stringer",charIndex:10232},{level:2,title:"错误",slug:"错误",normalizedTitle:"错误",charIndex:2462},{level:2,title:"练习：错误",slug:"练习-错误",normalizedTitle:"练习：错误",charIndex:11943},{level:2,title:"Reader",slug:"reader",normalizedTitle:"reader",charIndex:13078},{level:2,title:"练习：Reader",slug:"练习-reader",normalizedTitle:"练习：reader",charIndex:13686},{level:2,title:"练习：rot13Reader",slug:"练习-rot13reader",normalizedTitle:"练习：rot13reader",charIndex:13942},{level:2,title:"图像",slug:"图像",normalizedTitle:"图像",charIndex:14476}],headersStr:"方法 方法即函数 方法（续） 指针接收者 指针与函数 方法与指针重定向 方法与指针重定向（续） 选择值或指针作为接收者 接口 接口与隐式实现 接口值 底层值为 nil 的接口值 nil 接口值 空接口 类型断言 类型选择 Stringer 练习：Stringer 错误 练习：错误 Reader 练习：Reader 练习：rot13Reader 图像",content:'# 方法\n\nGo 没有类。不过你可以为结构体类型定义方法。\n\n方法就是一类带特殊的 接收者 参数的函数。\n\n方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。\n\n在此例中，Abs 方法拥有一个名为 v，类型为 Vertex 的接收者。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\ta := Vertex{3, 4}\n\tfmt.Println(a.Abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\n5\n\n\n1\n\n\n\n# 方法即函数\n\n记住：方法只是个带接收者参数的函数。\n\n现在这个 Abs 的写法就是个正常的函数，功能并没有什么变化。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(Abs(v))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\n5\n\n\n1\n\n\n\n# 方法（续）\n\n你也可以为非结构体类型声明方法。\n\n在此例中，我们看到了一个带 Abs 方法的数值类型 MyFloat。\n\n你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。\n\n（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := MyFloat(-math.Sqrt2)\n\tfmt.Println(f.Abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n结果：\n\n1.4142135623730951\n\n\n1\n\n\n\n# 指针接收者\n\n你可以为指针接收者声明方法。\n\n这意味着对于某类型 T，接收者的类型可以用 *T 的文法。（此外，T 不能是像 *int 这样的指针。）\n\n例如，这里为 *Vertex 定义了 Scale 方法。\n\n指针接收者的方法可以修改接收者指向的值（就像 Scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。\n\n试着移除第 16 行 Scale 函数声明中的 *，观察此程序的行为如何变化。\n\n若使用值接收者，那么 Scale 方法会对原始 Vertex 值的副本进行操作。（对于函数的其它参数也是如此。）Scale 方法必须用指针接受者来更改 main 函数中声明的 Vertex 的值。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(10)\n\tfmt.Println(v.Abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\n50\n\n\n1\n\n\n\n# 指针与函数\n\n现在我们要把 Abs 和 Scale 方法重写为函数。\n\n同样，我们先试着移除掉第 16 的 *。你能看出为什么程序的行为改变了吗？要怎样做才能让该示例顺利通过编译？\n\n（若你不确定，继续往下看。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc Scale(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tScale(&v, 10)\n\tfmt.Println(Abs(v))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\n50\n\n\n1\n\n\n\n# 方法与指针重定向\n\n比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：\n\nvar v Vertex\nScaleFunc(v, 5)  // 编译错误！\nScaleFunc(&v, 5) // OK\n\n\n而以指针为接收者的方法被调用时，接收者既能为值又能为指针：\n\nvar v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n\n\n对于语句 v.Scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 Scale 方法有一个指针接收者，为方便起见，Go 会将语句 v.Scale(5) 解释为 (&v).Scale(5)。\n\npackage main\n\nimport "fmt"\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc ScaleFunc(v *Vertex, f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tv.Scale(2)\n\tScaleFunc(&v, 10)\n\n\tp := &Vertex{4, 3}\n\tp.Scale(3)\n\tScaleFunc(p, 8)\n\n\tfmt.Println(v, p)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n结果：\n\n{60 80} &{96 72}\n\n\n1\n\n\n\n# 方法与指针重定向（续）\n\n同样的事情也发生在相反的方向。\n\n接受一个值作为参数的函数必须接受一个指定类型的值：\n\nvar v Vertex\nfmt.Println(AbsFunc(v))  // OK\nfmt.Println(AbsFunc(&v)) // 编译错误！\n\n\n而以值为接收者的方法被调用时，接收者既能为值又能为指针：\n\nvar v Vertex\nfmt.Println(v.Abs()) // OK\np := &v\nfmt.Println(p.Abs()) // OK\n\n\n这种情况下，方法调用 p.Abs() 会被解释为 (*p).Abs()。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc AbsFunc(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := Vertex{3, 4}\n\tfmt.Println(v.Abs())\n\tfmt.Println(AbsFunc(v))\n\n\tp := &Vertex{4, 3}\n\tfmt.Println(p.Abs())\n\tfmt.Println(AbsFunc(*p))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n结果：\n\n5\n5\n5\n5\n\n\n1\n2\n3\n4\n\n\n\n# 选择值或指针作为接收者\n\n使用指针接收者的原因有二：\n\n首先，方法能够修改其接收者指向的值。\n\n其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。\n\n在本例中，Scale 和 Abs 接收者的类型为 *Vertex，即便 Abs 并不需要修改其接收者。\n\n通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Scale(f float64) {\n\tv.X = v.X * f\n\tv.Y = v.Y * f\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\nfunc main() {\n\tv := &Vertex{3, 4}\n\tfmt.Printf("Before scaling: %+v, Abs: %v\\n", v, v.Abs())\n\tv.Scale(5)\n\tfmt.Printf("After scaling: %+v, Abs: %v\\n", v, v.Abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n结果：\n\nBefore scaling: &{X:3 Y:4}, Abs: 5\nAfter scaling: &{X:15 Y:20}, Abs: 25\n\n\n1\n2\n\n\n\n# 接口\n\n接口类型 是由一组方法签名定义的集合。\n\n接口类型的变量可以保存任何实现了这些方法的值。\n\n注意: 示例代码的 22 行存在一个错误。由于 Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\n// 接口定义\ntype Abser interface {\n\tAbs() float64\n}\n\nfunc main() {\n\tvar a Abser\n\tf := MyFloat(-math.Sqrt2)\n\tv := Vertex{3, 4}\n\n\ta = f  // a MyFloat 实现了 Abser\n\ta = &v // a *Vertex 实现了 Abser\n\n\t// 下面一行，v 是一个 Vertex（而不是 *Vertex）\n\t// 所以没有实现 Abser。\n\t// a = v\n\n\tfmt.Println(a.Abs())\n}\n\ntype MyFloat float64\n\nfunc (f MyFloat) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype Vertex struct {\n\tX, Y float64\n}\n\nfunc (v *Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 接口与隐式实现\n\n类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。\n\n隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。\n\npackage main\n\nimport "fmt"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\n// 此方法表示类型 T 实现了接口 I，但我们无需显式声明此事。\nfunc (t T) M() {\n\tfmt.Println(t.S)\n}\n\nfunc main() {\n\tvar i I = T{"hello"}\n\ti.M()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 接口值\n\n接口也是值。它们可以像其它值一样传递。\n\n接口值可以用作函数的参数或返回值。\n\n在内部，接口值可以看做包含值和具体类型的元组：\n\n(value, type)\n\n\n接口值保存了一个具体底层类型的具体值。\n\n接口值调用方法时会执行其底层类型的同名方法。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tfmt.Println(t.S)\n}\n\ntype F float64\n\nfunc (f F) M() {\n\tfmt.Println(f)\n}\n\nfunc main() {\n\tvar i I\n\n\ti = &T{"Hello"}\n\tdescribe(i)\n\ti.M()\n\n\ti = F(math.Pi)\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf("(%v, %T)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n结果：\n\n(&{Hello}, *main.T)\nHello\n(3.141592653589793, main.F)\n3.141592653589793\n\n\n1\n2\n3\n4\n\n\n\n# 底层值为 nil 的接口值\n\n即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。\n\n在一些语言中，这会触发一个空指针异常，但在 Go 中通常会写一些方法来优雅地处理它（如本例中的 M 方法）。\n\n注意: 保存了 nil 具体值的接口其自身并不为 nil。\n\npackage main\n\nimport "fmt"\n\ntype I interface {\n\tM()\n}\n\ntype T struct {\n\tS string\n}\n\nfunc (t *T) M() {\n\tif t == nil {\n\t\tfmt.Println("<nil>")\n\t\treturn\n\t}\n\tfmt.Println(t.S) \n}\n\nfunc main() {\n\tvar i I\n\n\tvar t *T // t指针存在，但t指针指向的内存地址不存在； 即t是空指针\n\ti = t\n\tdescribe(i)\n\ti.M()\n\n\ti = &T{"hello"}\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf("(%v, %T)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n结果：\n\n(<nil>, *main.T)\n<nil>\n(&{hello}, *main.T)\nhello\n\n\n1\n2\n3\n4\n\n\n\n# nil 接口值\n\nnil 接口值既不保存值也不保存具体类型。\n\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。\n\npackage main\n\nimport "fmt"\n\ntype I interface {\n\tM()\n}\n\nfunc main() {\n\tvar i I\n\tdescribe(i)\n\ti.M()\n}\n\nfunc describe(i I) {\n\tfmt.Printf("(%v, %T)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n(<nil>, <nil>)\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x482501]\n\ngoroutine 1 [running]:\nmain.main()\n\t/tmp/sandbox323994094/prog.go:12 +0x61\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 空接口\n\n指定了零个方法的接口值被称为 空接口：\n\ninterface{}\n\n\n空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）\n\n空接口被用来处理未知类型的值。例如，fmt.Print 可接受类型为 interface{} 的任意数量的参数。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = "hello"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.Printf("(%v, %T)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结果：\n\n(<nil>, <nil>)\n(42, int)\n(hello, string)\n\n\n1\n2\n3\n\n\n\n# 类型断言\n\n类型断言 提供了访问接口值底层具体值的方式。\n\nt := i.(T)\n\n\n该语句断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t。\n\n若 i 并未保存 T 类型的值，该语句就会触发一个恐慌。\n\n为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n\nt, ok := i.(T)\n\n\n若 i 保存了一个 T，那么 t 将会是其底层值，而 ok 为 true。\n\n否则，ok 将为 false 而 t 将为 T 类型的零值，程序并不会产生恐慌。\n\n请注意这种语法和读取一个映射时的相同之处。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i interface{} = "hello"\n\n\ts := i.(string)\n\tfmt.Println(s)\n\n\ts, ok := i.(string)\n\tfmt.Println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.Println(f, ok)\n\n\tf = i.(float64) // 报错(panic)\n\tfmt.Println(f)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\nhello\nhello true\n0 false\npanic: interface conversion: interface {} is string, not float64\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 类型选择\n\n类型选择 是一种按顺序从几个类型断言中选择分支的结构。\n\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\n\nswitch v := i.(type) {\ncase T:\n\t// v 的类型为 T\ncase S:\n\t// v 的类型为 S\ndefault:\n\t// 没有匹配，v 与 i 的类型相同\n}\n\n\n类型选择中的声明与类型断言 i.(T) 的语法相同，只是具体类型 T 被替换成了关键字 type。\n\n此选择语句判断接口值 i 保存的值类型是 T 还是 S。在 T 或 S 的情况下，变量 v 会分别按 T 或 S 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。\n\npackage main\n\nimport "fmt"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.Printf("Twice %v is %v\\n", v, v*2)\n\tcase string:\n\t\tfmt.Printf("%q is %v bytes long\\n", v, len(v))\n\tdefault:\n\t\tfmt.Printf("I don\'t know about type %T!\\n", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo("hello")\n\tdo(true)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n结果：\n\nTwice 21 is 42\n"hello" is 5 bytes long\nI don\'t know about type bool!\n\n\n1\n2\n3\n\n\n\n# Stringer\n\nfmt 包中定义的 Stringer 是最普遍的接口之一。\n\ntype Stringer interface {\n\tString() string\n}\n\n\nStringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。\n\npackage main\n\nimport "fmt"\n\ntype Person struct {\n\tName string\n\tAge  int\n}\n\nfunc (p Person) String() string {\n\treturn fmt.Sprintf("%v (%v years)", p.Name, p.Age)\n}\n\nfunc main() {\n\ta := Person{"Arthur Dent", 42}\n\tz := Person{"Zaphod Beeblebrox", 9001}\n\tfmt.Println(a, z)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结果：\n\nArthur Dent (42 years) Zaphod Beeblebrox (9001 years)\n\n\n1\n\n\n\n# 练习：Stringer\n\n通过让 IPAddr 类型实现 fmt.Stringer 来打印点号分隔的地址。\n\n例如，IPAddr{1, 2, 3, 4} 应当打印为 "1.2.3.4"。\n\npackage main\n\nimport "fmt"\n\ntype IPAddr [4]byte\n\n// TODO: 给 IPAddr 添加一个 "String() string" 方法\n\nfunc (ip IPAddr) String() string {\n\treturn fmt.Sprintf("%v.%v.%v.%v", ip[0], ip[1], ip[2], ip[3])\n}\n\nfunc main() {\n\thosts := map[string]IPAddr{\n\t\t"loopback":  {127, 0, 0, 1},\n\t\t"googleDNS": {8, 8, 8, 8},\n\t}\n\tfor name, ip := range hosts {\n\t\tfmt.Printf("%v: %v\\n", name, ip)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果：\n\nloopback: 127.0.0.1\ngoogleDNS: 8.8.8.8\n\n\n1\n2\n\n\n\n# 错误\n\nGo 程序使用 error 值来表示错误状态。\n\n与 fmt.Stringer 类似，error 类型是一个内建接口：\n\ntype error interface {\n\tError() string\n}\n\n\n（与 fmt.Stringer 类似，fmt 包在打印值时也会满足 error。）\n\n通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。\n\ni, err := strconv.Atoi("42")\nif err != nil {\n\tfmt.Printf("couldn\'t convert number: %v\\n", err)\n\treturn\n}\nfmt.Println("Converted integer:", i)\n\n\nerror 为 nil 时表示成功；非 nil 的 error 表示失败。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n\t"strconv"\n)\n\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf("at %v, %s",\n\t\te.When, e.What)\n}\n\nfunc run() error {\n\treturn &MyError{\n\t\ttime.Now(),\n\t\t"it didn\'t work",\n\t}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n\t\n\ti, err := strconv.Atoi("4q")\n\tif err != nil {\n\t\tfmt.Printf("couldn\'t convert number: %v\\n", err)\n\t\treturn\n\t}\n\tfmt.Println("Converted integer:", i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n结果：\n\nat 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn\'t work\ncouldn\'t convert number: strconv.Atoi: parsing "4q": invalid syntax\n\n\n1\n2\n\n\n\n# 练习：错误\n\n从之前的练习中复制 Sqrt 函数，修改它使其返回 error 值。\n\nSqrt 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。\n\n创建一个新的类型\n\ntype ErrNegativeSqrt float64\n\n\n并为其实现\n\nfunc (e ErrNegativeSqrt) Error() string\n\n\n方法使其拥有 error 值，通过 ErrNegativeSqrt(-2).Error() 调用该方法应返回 "cannot Sqrt negative number: -2"。\n\n注意: 在 Error 方法内调用 fmt.Sprint(e) 会让程序陷入死循环。可以通过先转换 e 来避免这个问题：fmt.Sprint(float64(e))。这是为什么呢？\n\n修改 Sqrt 函数，使其接受一个负数时，返回 ErrNegativeSqrt 值。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype ErrNegativeSqrt float64\n\nfunc (e ErrNegativeSqrt) Error() string {\n\tif float64(e) < 0 {\n\t\treturn fmt.Sprint("cannot Sqrt negative number:", float64(e))\n\t}\n\treturn ""\n}\n\nfunc Sqrt(x ErrNegativeSqrt) (float64, string) {\n\n\tif x.Error() != "" {\n\t\treturn 0, x.Error()\n\t}\n\n\tz := 0.0\n\ty := float64(x / 2)\n\n\tfor math.Abs(z-y) > 0.01 {\n\t\tz = y\n\t\ty -= (z*z - float64(x)) / (2 * z)\n\t\tfmt.Printf("值： %v, 修改量： %v \\n", y, math.Abs(z-y))\n\t}\n\n\treturn z, ""\n}\n\nfunc main() {\n\tfmt.Println(Sqrt(2))\n\tfmt.Println(Sqrt(-2))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n结果：\n\n1.4166666666666667\n0 cannot Sqrt negative number:-2\n\n\n1\n2\n\n\n\n# Reader\n\nio 包指定了 io.Reader 接口，它表示从数据流的末尾进行读取。\n\nGo 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。\n\nio.Reader 接口有一个 Read 方法：\n\nfunc (T) Read(b []byte) (n int, err error)\n\n\nRead 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.EOF 错误。\n\n示例代码创建了一个 strings.Reader 并以每次 8 字节的速度读取它的输出。\n\npackage main\n\nimport (\n\t"fmt"\n\t"io"\n\t"strings"\n)\n\nfunc main() {\n\tr := strings.NewReader("Hello, Reader!")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.Read(b)\n\t\tfmt.Printf("n = %v err = %v b = %v\\n", n, err, b)\n\t\tfmt.Printf("b[:n] = %q\\n", b[:n])\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 练习：Reader\n\n实现一个 Reader 类型，它产生一个 ASCII 字符 \'A\' 的无限流。\n\npackage main\n\nimport "golang.org/x/tour/reader"\n\ntype MyReader struct{}\n\n// TODO: 给 MyReader 添加一个 Read([]byte) (int, error) 方法\n\nfunc main() {\n\treader.Validate(MyReader{})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 练习：rot13Reader\n\n有种常见的模式是一个 io.Reader 包装另一个 io.Reader，然后通过某种方式修改其数据流。\n\n例如，gzip.NewReader 函数接受一个 io.Reader（已压缩的数据流）并返回一个同样实现了 io.Reader 的 *gzip.Reader（解压后的数据流）。\n\n编写一个实现了 io.Reader 并从另一个 io.Reader 中读取数据的 rot13Reader，通过应用 rot13 代换密码对数据流进行修改。\n\nrot13Reader 类型已经提供。实现 Read 方法以满足 io.Reader。\n\npackage main\n\nimport (\n\t"io"\n\t"os"\n\t"strings"\n)\n\ntype rot13Reader struct {\n\tr io.Reader\n}\n\nfunc main() {\n\ts := strings.NewReader("Lbh penpxrq gur pbqr!")\n\tr := rot13Reader{s}\n\tio.Copy(os.Stdout, &r)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 图像\n\nimage 包定义了 Image 接口：\n\npackage image\n\ntype Image interface {\n\tColorModel() color.Model\n\tBounds() Rectangle\n\tAt(x, y int) color.Color\n}\n\n\n注意: Bounds 方法的返回值 Rectangle 实际上是一个 image.Rectangle，它在 image 包中声明。\n\n（请参阅文档了解全部信息。）\n\ncolor.Color 和 color.Model 类型也是接口，但是通常因为直接使用预定义的实现 image.RGBA 和 image.RGBAModel 而被忽视了。这些接口和类型由 image/color 包定义。\n\npackage main\n\nimport (\n\t"fmt"\n\t"image"\n)\n\nfunc main() {\n\tm := image.NewRGBA(image.Rect(0, 0, 100, 100))\n\tfmt.Println(m.Bounds())\n\tfmt.Println(m.At(0, 0).RGBA())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',normalizedContent:'# 方法\n\ngo 没有类。不过你可以为结构体类型定义方法。\n\n方法就是一类带特殊的 接收者 参数的函数。\n\n方法接收者在它自己的参数列表内，位于 func 关键字和方法名之间。\n\n在此例中，abs 方法拥有一个名为 v，类型为 vertex 的接收者。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc (v vertex) abs() float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc main() {\n\ta := vertex{3, 4}\n\tfmt.println(a.abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\n5\n\n\n1\n\n\n\n# 方法即函数\n\n记住：方法只是个带接收者参数的函数。\n\n现在这个 abs 的写法就是个正常的函数，功能并没有什么变化。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc abs(v vertex) float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc main() {\n\tv := vertex{3, 4}\n\tfmt.println(abs(v))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\n5\n\n\n1\n\n\n\n# 方法（续）\n\n你也可以为非结构体类型声明方法。\n\n在此例中，我们看到了一个带 abs 方法的数值类型 myfloat。\n\n你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。\n\n（译注：就是接收者的类型定义和方法声明必须在同一包内；不能为内建类型声明方法。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype myfloat float64\n\nfunc (f myfloat) abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\nfunc main() {\n\tf := myfloat(-math.sqrt2)\n\tfmt.println(f.abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n结果：\n\n1.4142135623730951\n\n\n1\n\n\n\n# 指针接收者\n\n你可以为指针接收者声明方法。\n\n这意味着对于某类型 t，接收者的类型可以用 *t 的文法。（此外，t 不能是像 *int 这样的指针。）\n\n例如，这里为 *vertex 定义了 scale 方法。\n\n指针接收者的方法可以修改接收者指向的值（就像 scale 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。\n\n试着移除第 16 行 scale 函数声明中的 *，观察此程序的行为如何变化。\n\n若使用值接收者，那么 scale 方法会对原始 vertex 值的副本进行操作。（对于函数的其它参数也是如此。）scale 方法必须用指针接受者来更改 main 函数中声明的 vertex 的值。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc (v vertex) abs() float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc (v *vertex) scale(f float64) {\n\tv.x = v.x * f\n\tv.y = v.y * f\n}\n\nfunc main() {\n\tv := vertex{3, 4}\n\tv.scale(10)\n\tfmt.println(v.abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\n50\n\n\n1\n\n\n\n# 指针与函数\n\n现在我们要把 abs 和 scale 方法重写为函数。\n\n同样，我们先试着移除掉第 16 的 *。你能看出为什么程序的行为改变了吗？要怎样做才能让该示例顺利通过编译？\n\n（若你不确定，继续往下看。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc abs(v vertex) float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc scale(v *vertex, f float64) {\n\tv.x = v.x * f\n\tv.y = v.y * f\n}\n\nfunc main() {\n\tv := vertex{3, 4}\n\tscale(&v, 10)\n\tfmt.println(abs(v))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n结果：\n\n50\n\n\n1\n\n\n\n# 方法与指针重定向\n\n比较前两个程序，你大概会注意到带指针参数的函数必须接受一个指针：\n\nvar v vertex\nscalefunc(v, 5)  // 编译错误！\nscalefunc(&v, 5) // ok\n\n\n而以指针为接收者的方法被调用时，接收者既能为值又能为指针：\n\nvar v vertex\nv.scale(5)  // ok\np := &v\np.scale(10) // ok\n\n\n对于语句 v.scale(5)，即便 v 是个值而非指针，带指针接收者的方法也能被直接调用。 也就是说，由于 scale 方法有一个指针接收者，为方便起见，go 会将语句 v.scale(5) 解释为 (&v).scale(5)。\n\npackage main\n\nimport "fmt"\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc (v *vertex) scale(f float64) {\n\tv.x = v.x * f\n\tv.y = v.y * f\n}\n\nfunc scalefunc(v *vertex, f float64) {\n\tv.x = v.x * f\n\tv.y = v.y * f\n}\n\nfunc main() {\n\tv := vertex{3, 4}\n\tv.scale(2)\n\tscalefunc(&v, 10)\n\n\tp := &vertex{4, 3}\n\tp.scale(3)\n\tscalefunc(p, 8)\n\n\tfmt.println(v, p)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n结果：\n\n{60 80} &{96 72}\n\n\n1\n\n\n\n# 方法与指针重定向（续）\n\n同样的事情也发生在相反的方向。\n\n接受一个值作为参数的函数必须接受一个指定类型的值：\n\nvar v vertex\nfmt.println(absfunc(v))  // ok\nfmt.println(absfunc(&v)) // 编译错误！\n\n\n而以值为接收者的方法被调用时，接收者既能为值又能为指针：\n\nvar v vertex\nfmt.println(v.abs()) // ok\np := &v\nfmt.println(p.abs()) // ok\n\n\n这种情况下，方法调用 p.abs() 会被解释为 (*p).abs()。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc (v vertex) abs() float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc absfunc(v vertex) float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc main() {\n\tv := vertex{3, 4}\n\tfmt.println(v.abs())\n\tfmt.println(absfunc(v))\n\n\tp := &vertex{4, 3}\n\tfmt.println(p.abs())\n\tfmt.println(absfunc(*p))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n结果：\n\n5\n5\n5\n5\n\n\n1\n2\n3\n4\n\n\n\n# 选择值或指针作为接收者\n\n使用指针接收者的原因有二：\n\n首先，方法能够修改其接收者指向的值。\n\n其次，这样可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效。\n\n在本例中，scale 和 abs 接收者的类型为 *vertex，即便 abs 并不需要修改其接收者。\n\n通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。（我们会在接下来几页中明白为什么。）\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc (v *vertex) scale(f float64) {\n\tv.x = v.x * f\n\tv.y = v.y * f\n}\n\nfunc (v *vertex) abs() float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\nfunc main() {\n\tv := &vertex{3, 4}\n\tfmt.printf("before scaling: %+v, abs: %v\\n", v, v.abs())\n\tv.scale(5)\n\tfmt.printf("after scaling: %+v, abs: %v\\n", v, v.abs())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n结果：\n\nbefore scaling: &{x:3 y:4}, abs: 5\nafter scaling: &{x:15 y:20}, abs: 25\n\n\n1\n2\n\n\n\n# 接口\n\n接口类型 是由一组方法签名定义的集合。\n\n接口类型的变量可以保存任何实现了这些方法的值。\n\n注意: 示例代码的 22 行存在一个错误。由于 abs 方法只为 *vertex （指针类型）定义，因此 vertex（值类型）并未实现 abser。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\n// 接口定义\ntype abser interface {\n\tabs() float64\n}\n\nfunc main() {\n\tvar a abser\n\tf := myfloat(-math.sqrt2)\n\tv := vertex{3, 4}\n\n\ta = f  // a myfloat 实现了 abser\n\ta = &v // a *vertex 实现了 abser\n\n\t// 下面一行，v 是一个 vertex（而不是 *vertex）\n\t// 所以没有实现 abser。\n\t// a = v\n\n\tfmt.println(a.abs())\n}\n\ntype myfloat float64\n\nfunc (f myfloat) abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n\ntype vertex struct {\n\tx, y float64\n}\n\nfunc (v *vertex) abs() float64 {\n\treturn math.sqrt(v.x*v.x + v.y*v.y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 接口与隐式实现\n\n类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。\n\n隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。\n\n因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。\n\npackage main\n\nimport "fmt"\n\ntype i interface {\n\tm()\n}\n\ntype t struct {\n\ts string\n}\n\n// 此方法表示类型 t 实现了接口 i，但我们无需显式声明此事。\nfunc (t t) m() {\n\tfmt.println(t.s)\n}\n\nfunc main() {\n\tvar i i = t{"hello"}\n\ti.m()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 接口值\n\n接口也是值。它们可以像其它值一样传递。\n\n接口值可以用作函数的参数或返回值。\n\n在内部，接口值可以看做包含值和具体类型的元组：\n\n(value, type)\n\n\n接口值保存了一个具体底层类型的具体值。\n\n接口值调用方法时会执行其底层类型的同名方法。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype i interface {\n\tm()\n}\n\ntype t struct {\n\ts string\n}\n\nfunc (t *t) m() {\n\tfmt.println(t.s)\n}\n\ntype f float64\n\nfunc (f f) m() {\n\tfmt.println(f)\n}\n\nfunc main() {\n\tvar i i\n\n\ti = &t{"hello"}\n\tdescribe(i)\n\ti.m()\n\n\ti = f(math.pi)\n\tdescribe(i)\n\ti.m()\n}\n\nfunc describe(i i) {\n\tfmt.printf("(%v, %t)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n结果：\n\n(&{hello}, *main.t)\nhello\n(3.141592653589793, main.f)\n3.141592653589793\n\n\n1\n2\n3\n4\n\n\n\n# 底层值为 nil 的接口值\n\n即便接口内的具体值为 nil，方法仍然会被 nil 接收者调用。\n\n在一些语言中，这会触发一个空指针异常，但在 go 中通常会写一些方法来优雅地处理它（如本例中的 m 方法）。\n\n注意: 保存了 nil 具体值的接口其自身并不为 nil。\n\npackage main\n\nimport "fmt"\n\ntype i interface {\n\tm()\n}\n\ntype t struct {\n\ts string\n}\n\nfunc (t *t) m() {\n\tif t == nil {\n\t\tfmt.println("<nil>")\n\t\treturn\n\t}\n\tfmt.println(t.s) \n}\n\nfunc main() {\n\tvar i i\n\n\tvar t *t // t指针存在，但t指针指向的内存地址不存在； 即t是空指针\n\ti = t\n\tdescribe(i)\n\ti.m()\n\n\ti = &t{"hello"}\n\tdescribe(i)\n\ti.m()\n}\n\nfunc describe(i i) {\n\tfmt.printf("(%v, %t)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n结果：\n\n(<nil>, *main.t)\n<nil>\n(&{hello}, *main.t)\nhello\n\n\n1\n2\n3\n4\n\n\n\n# nil 接口值\n\nnil 接口值既不保存值也不保存具体类型。\n\n为 nil 接口调用方法会产生运行时错误，因为接口的元组内并未包含能够指明该调用哪个 具体 方法的类型。\n\npackage main\n\nimport "fmt"\n\ntype i interface {\n\tm()\n}\n\nfunc main() {\n\tvar i i\n\tdescribe(i)\n\ti.m()\n}\n\nfunc describe(i i) {\n\tfmt.printf("(%v, %t)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n结果：\n\n(<nil>, <nil>)\npanic: runtime error: invalid memory address or nil pointer dereference\n[signal sigsegv: segmentation violation code=0x1 addr=0x0 pc=0x482501]\n\ngoroutine 1 [running]:\nmain.main()\n\t/tmp/sandbox323994094/prog.go:12 +0x61\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 空接口\n\n指定了零个方法的接口值被称为 空接口：\n\ninterface{}\n\n\n空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）\n\n空接口被用来处理未知类型的值。例如，fmt.print 可接受类型为 interface{} 的任意数量的参数。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i interface{}\n\tdescribe(i)\n\n\ti = 42\n\tdescribe(i)\n\n\ti = "hello"\n\tdescribe(i)\n}\n\nfunc describe(i interface{}) {\n\tfmt.printf("(%v, %t)\\n", i, i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结果：\n\n(<nil>, <nil>)\n(42, int)\n(hello, string)\n\n\n1\n2\n3\n\n\n\n# 类型断言\n\n类型断言 提供了访问接口值底层具体值的方式。\n\nt := i.(t)\n\n\n该语句断言接口值 i 保存了具体类型 t，并将其底层类型为 t 的值赋予变量 t。\n\n若 i 并未保存 t 类型的值，该语句就会触发一个恐慌。\n\n为了 判断 一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。\n\nt, ok := i.(t)\n\n\n若 i 保存了一个 t，那么 t 将会是其底层值，而 ok 为 true。\n\n否则，ok 将为 false 而 t 将为 t 类型的零值，程序并不会产生恐慌。\n\n请注意这种语法和读取一个映射时的相同之处。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tvar i interface{} = "hello"\n\n\ts := i.(string)\n\tfmt.println(s)\n\n\ts, ok := i.(string)\n\tfmt.println(s, ok)\n\n\tf, ok := i.(float64)\n\tfmt.println(f, ok)\n\n\tf = i.(float64) // 报错(panic)\n\tfmt.println(f)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\nhello\nhello true\n0 false\npanic: interface conversion: interface {} is string, not float64\n\n\n\n1\n2\n3\n4\n5\n\n\n\n# 类型选择\n\n类型选择 是一种按顺序从几个类型断言中选择分支的结构。\n\n类型选择与一般的 switch 语句相似，不过类型选择中的 case 为类型（而非值）， 它们针对给定接口值所存储的值的类型进行比较。\n\nswitch v := i.(type) {\ncase t:\n\t// v 的类型为 t\ncase s:\n\t// v 的类型为 s\ndefault:\n\t// 没有匹配，v 与 i 的类型相同\n}\n\n\n类型选择中的声明与类型断言 i.(t) 的语法相同，只是具体类型 t 被替换成了关键字 type。\n\n此选择语句判断接口值 i 保存的值类型是 t 还是 s。在 t 或 s 的情况下，变量 v 会分别按 t 或 s 类型保存 i 拥有的值。在默认（即没有匹配）的情况下，变量 v 与 i 的接口类型和值相同。\n\npackage main\n\nimport "fmt"\n\nfunc do(i interface{}) {\n\tswitch v := i.(type) {\n\tcase int:\n\t\tfmt.printf("twice %v is %v\\n", v, v*2)\n\tcase string:\n\t\tfmt.printf("%q is %v bytes long\\n", v, len(v))\n\tdefault:\n\t\tfmt.printf("i don\'t know about type %t!\\n", v)\n\t}\n}\n\nfunc main() {\n\tdo(21)\n\tdo("hello")\n\tdo(true)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n结果：\n\ntwice 21 is 42\n"hello" is 5 bytes long\ni don\'t know about type bool!\n\n\n1\n2\n3\n\n\n\n# stringer\n\nfmt 包中定义的 stringer 是最普遍的接口之一。\n\ntype stringer interface {\n\tstring() string\n}\n\n\nstringer 是一个可以用字符串描述自己的类型。fmt 包（还有很多包）都通过此接口来打印值。\n\npackage main\n\nimport "fmt"\n\ntype person struct {\n\tname string\n\tage  int\n}\n\nfunc (p person) string() string {\n\treturn fmt.sprintf("%v (%v years)", p.name, p.age)\n}\n\nfunc main() {\n\ta := person{"arthur dent", 42}\n\tz := person{"zaphod beeblebrox", 9001}\n\tfmt.println(a, z)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n结果：\n\narthur dent (42 years) zaphod beeblebrox (9001 years)\n\n\n1\n\n\n\n# 练习：stringer\n\n通过让 ipaddr 类型实现 fmt.stringer 来打印点号分隔的地址。\n\n例如，ipaddr{1, 2, 3, 4} 应当打印为 "1.2.3.4"。\n\npackage main\n\nimport "fmt"\n\ntype ipaddr [4]byte\n\n// todo: 给 ipaddr 添加一个 "string() string" 方法\n\nfunc (ip ipaddr) string() string {\n\treturn fmt.sprintf("%v.%v.%v.%v", ip[0], ip[1], ip[2], ip[3])\n}\n\nfunc main() {\n\thosts := map[string]ipaddr{\n\t\t"loopback":  {127, 0, 0, 1},\n\t\t"googledns": {8, 8, 8, 8},\n\t}\n\tfor name, ip := range hosts {\n\t\tfmt.printf("%v: %v\\n", name, ip)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n结果：\n\nloopback: 127.0.0.1\ngoogledns: 8.8.8.8\n\n\n1\n2\n\n\n\n# 错误\n\ngo 程序使用 error 值来表示错误状态。\n\n与 fmt.stringer 类似，error 类型是一个内建接口：\n\ntype error interface {\n\terror() string\n}\n\n\n（与 fmt.stringer 类似，fmt 包在打印值时也会满足 error。）\n\n通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil 来进行错误处理。\n\ni, err := strconv.atoi("42")\nif err != nil {\n\tfmt.printf("couldn\'t convert number: %v\\n", err)\n\treturn\n}\nfmt.println("converted integer:", i)\n\n\nerror 为 nil 时表示成功；非 nil 的 error 表示失败。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n\t"strconv"\n)\n\ntype myerror struct {\n\twhen time.time\n\twhat string\n}\n\nfunc (e *myerror) error() string {\n\treturn fmt.sprintf("at %v, %s",\n\t\te.when, e.what)\n}\n\nfunc run() error {\n\treturn &myerror{\n\t\ttime.now(),\n\t\t"it didn\'t work",\n\t}\n}\n\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.println(err)\n\t}\n\t\n\ti, err := strconv.atoi("4q")\n\tif err != nil {\n\t\tfmt.printf("couldn\'t convert number: %v\\n", err)\n\t\treturn\n\t}\n\tfmt.println("converted integer:", i)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n结果：\n\nat 2009-11-10 23:00:00 +0000 utc m=+0.000000001, it didn\'t work\ncouldn\'t convert number: strconv.atoi: parsing "4q": invalid syntax\n\n\n1\n2\n\n\n\n# 练习：错误\n\n从之前的练习中复制 sqrt 函数，修改它使其返回 error 值。\n\nsqrt 接受到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。\n\n创建一个新的类型\n\ntype errnegativesqrt float64\n\n\n并为其实现\n\nfunc (e errnegativesqrt) error() string\n\n\n方法使其拥有 error 值，通过 errnegativesqrt(-2).error() 调用该方法应返回 "cannot sqrt negative number: -2"。\n\n注意: 在 error 方法内调用 fmt.sprint(e) 会让程序陷入死循环。可以通过先转换 e 来避免这个问题：fmt.sprint(float64(e))。这是为什么呢？\n\n修改 sqrt 函数，使其接受一个负数时，返回 errnegativesqrt 值。\n\npackage main\n\nimport (\n\t"fmt"\n\t"math"\n)\n\ntype errnegativesqrt float64\n\nfunc (e errnegativesqrt) error() string {\n\tif float64(e) < 0 {\n\t\treturn fmt.sprint("cannot sqrt negative number:", float64(e))\n\t}\n\treturn ""\n}\n\nfunc sqrt(x errnegativesqrt) (float64, string) {\n\n\tif x.error() != "" {\n\t\treturn 0, x.error()\n\t}\n\n\tz := 0.0\n\ty := float64(x / 2)\n\n\tfor math.abs(z-y) > 0.01 {\n\t\tz = y\n\t\ty -= (z*z - float64(x)) / (2 * z)\n\t\tfmt.printf("值： %v, 修改量： %v \\n", y, math.abs(z-y))\n\t}\n\n\treturn z, ""\n}\n\nfunc main() {\n\tfmt.println(sqrt(2))\n\tfmt.println(sqrt(-2))\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n结果：\n\n1.4166666666666667\n0 cannot sqrt negative number:-2\n\n\n1\n2\n\n\n\n# reader\n\nio 包指定了 io.reader 接口，它表示从数据流的末尾进行读取。\n\ngo 标准库包含了该接口的许多实现，包括文件、网络连接、压缩和加密等等。\n\nio.reader 接口有一个 read 方法：\n\nfunc (t) read(b []byte) (n int, err error)\n\n\nread 用数据填充给定的字节切片并返回填充的字节数和错误值。在遇到数据流的结尾时，它会返回一个 io.eof 错误。\n\n示例代码创建了一个 strings.reader 并以每次 8 字节的速度读取它的输出。\n\npackage main\n\nimport (\n\t"fmt"\n\t"io"\n\t"strings"\n)\n\nfunc main() {\n\tr := strings.newreader("hello, reader!")\n\n\tb := make([]byte, 8)\n\tfor {\n\t\tn, err := r.read(b)\n\t\tfmt.printf("n = %v err = %v b = %v\\n", n, err, b)\n\t\tfmt.printf("b[:n] = %q\\n", b[:n])\n\t\tif err == io.eof {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 练习：reader\n\n实现一个 reader 类型，它产生一个 ascii 字符 \'a\' 的无限流。\n\npackage main\n\nimport "golang.org/x/tour/reader"\n\ntype myreader struct{}\n\n// todo: 给 myreader 添加一个 read([]byte) (int, error) 方法\n\nfunc main() {\n\treader.validate(myreader{})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 练习：rot13reader\n\n有种常见的模式是一个 io.reader 包装另一个 io.reader，然后通过某种方式修改其数据流。\n\n例如，gzip.newreader 函数接受一个 io.reader（已压缩的数据流）并返回一个同样实现了 io.reader 的 *gzip.reader（解压后的数据流）。\n\n编写一个实现了 io.reader 并从另一个 io.reader 中读取数据的 rot13reader，通过应用 rot13 代换密码对数据流进行修改。\n\nrot13reader 类型已经提供。实现 read 方法以满足 io.reader。\n\npackage main\n\nimport (\n\t"io"\n\t"os"\n\t"strings"\n)\n\ntype rot13reader struct {\n\tr io.reader\n}\n\nfunc main() {\n\ts := strings.newreader("lbh penpxrq gur pbqr!")\n\tr := rot13reader{s}\n\tio.copy(os.stdout, &r)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 图像\n\nimage 包定义了 image 接口：\n\npackage image\n\ntype image interface {\n\tcolormodel() color.model\n\tbounds() rectangle\n\tat(x, y int) color.color\n}\n\n\n注意: bounds 方法的返回值 rectangle 实际上是一个 image.rectangle，它在 image 包中声明。\n\n（请参阅文档了解全部信息。）\n\ncolor.color 和 color.model 类型也是接口，但是通常因为直接使用预定义的实现 image.rgba 和 image.rgbamodel 而被忽视了。这些接口和类型由 image/color 包定义。\n\npackage main\n\nimport (\n\t"fmt"\n\t"image"\n)\n\nfunc main() {\n\tm := image.newrgba(image.rect(0, 0, 100, 100))\n\tfmt.println(m.bounds())\n\tfmt.println(m.at(0, 0).rgba())\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n',charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:41:21",lastUpdatedTimestamp:1680709281e3},{title:"Go-并发",frontmatter:{title:"Go-并发",date:"2023-03-16T23:34:29.000Z",permalink:"/pages/0466ae/",categories:["编程语言--golang"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--golang/6.%E5%B9%B6%E5%8F%91.html",relativePath:"编程语言--golang/6.并发.md",key:"v-26c1e7e5",path:"/pages/0466ae/",headers:[{level:2,title:"Go routine",slug:"go-routine",normalizedTitle:"go routine",charIndex:2},{level:2,title:"信道",slug:"信道",normalizedTitle:"信道",charIndex:480},{level:2,title:"带缓冲的信道",slug:"带缓冲的信道",normalizedTitle:"带缓冲的信道",charIndex:1140},{level:2,title:"range 和 close",slug:"range-和-close",normalizedTitle:"range 和 close",charIndex:1446},{level:2,title:"select 语句",slug:"select-语句",normalizedTitle:"select 语句",charIndex:2072},{level:2,title:"默认选择",slug:"默认选择",normalizedTitle:"默认选择",charIndex:2599},{level:2,title:"练习：等价二叉查找树",slug:"练习-等价二叉查找树",normalizedTitle:"练习：等价二叉查找树",charIndex:3160},{level:2,title:"sync.Mutex",slug:"sync-mutex",normalizedTitle:"sync.mutex",charIndex:4002},{level:2,title:"练习：Web 爬虫",slug:"练习-web-爬虫",normalizedTitle:"练习：web 爬虫",charIndex:5062}],headersStr:"Go routine 信道 带缓冲的信道 range 和 close select 语句 默认选择 练习：等价二叉查找树 sync.Mutex 练习：Web 爬虫",content:'# Go routine\n\nGo 程（goroutine）是由 Go 运行时管理的轻量级线程。\n\ngo f(x, y, z)\n\n\n1\n\n\n会启动一个新的 Go 程并执行\n\nf(x, y, z)\n\n\n1\n\n\nf, x, y 和 z 的求值发生在当前的 Go 程中，而 f 的执行发生在新的 Go 程中。\n\nGo 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 Go 中并不经常用到，因为还有其它的办法（见下一页）。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc say(s string) {\n\tfor i := 0; i < 5; i++ {\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\tfmt.Println(s)\n\t}\n}\n\nfunc main() {\n\tgo say("world")\n\tsay("hello")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 信道\n\n信道是带有类型的管道，你可以通过它用信道操作符 <- 来发送或者接收值。\n\nch <- v    // 将 v 发送至信道 ch。\nv := <-ch  // 从 ch 接收值并赋予 v。\n\n\n1\n2\n\n\n（“箭头”就是数据流的方向。）\n\n和映射与切片一样，信道在使用前必须创建：\n\nch := make(chan int)\n\n\n1\n\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。\n\n以下示例对切片中的数进行求和，将任务分配给两个 Go 程。一旦两个 Go 程完成了它们的计算，它就能算出最终的结果。\n\npackage main\n\nimport "fmt"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum // 将和送入 c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := <-c, <-c // 从 c 中接收\n\n\tfmt.Println(x, y, x+y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 带缓冲的信道\n\n信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道：\n\nch := make(chan int, 100)\n\n\n1\n\n\n仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。\n\n修改示例填满缓冲区，然后看看会发生什么。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch <- 1\n\tch <- 2\n\tfmt.Println(<-ch)\n\tfmt.Println(<-ch)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# range 和 close\n\n发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完\n\nv, ok := <-ch\n\n\n1\n\n\n之后 ok 会被设置为 false。\n\n循环 for i := range c 会不断从信道接收值，直到它被关闭。\n\n注意： 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。\n\n还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。\n\npackage main\n\nimport (\n\t"fmt"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.Println(i)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# select 语句\n\nselect 语句使一个 Go 程可以等待多个通信操作。\n\nselect 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n\npackage main\n\nimport "fmt"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.Println("quit")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.Println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 默认选择\n\n当 select 中的其它分支都没有准备好时，default 分支就会执行。\n\n为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：\n\nselect {\ncase i := <-c:\n    // 使用 i\ndefault:\n    // 从 c 中接收会阻塞时执行\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\ttick := time.Tick(100 * time.Millisecond)\n\tboom := time.After(500 * time.Millisecond)\n\tfor {\n\t\tselect {\n\t\tcase <-tick:\n\t\t\tfmt.Println("tick.")\n\t\tcase <-boom:\n\t\t\tfmt.Println("BOOM!")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.Println("    .")\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 练习：等价二叉查找树\n\n不同二叉树的叶节点上可以保存相同的值序列。例如，以下两个二叉树都保存了序列 1，1，2，3，5，8，13。\n\n\n\n在大多数语言中，检查两个二叉树是否保存了相同序列的函数都相当复杂。 我们将使用 Go 的并发和信道来编写一个简单的解法。\n\n本例使用了 tree 包，它定义了类型：\n\ntype Tree struct {\n    Left  *Tree\n    Value int\n    Right *Tree\n}\n\n\n1\n2\n3\n4\n5\n\n\n 1. 实现 Walk 函数。\n\n 2. 测试 Walk 函数。\n\n函数 tree.New(k) 用于构造一个随机结构的已排序二叉查找树，它保存了值 k, 2k, 3k, ..., 10k。\n\n创建一个新的信道 ch 并且对其进行步进：\n\ngo Walk(tree.New(1), ch)\n\n\n1\n\n\n然后从信道中读取并打印 10 个值。应当是数字 1, 2, 3, ..., 10。\n\n 3. 用 Walk 实现 Same 函数来检测 t1 和 t2 是否存储了相同的值。\n\n 4. 测试 Same 函数。\n\nSame(tree.New(1), tree.New(1)) 应当返回 true，而 Same(tree.New(1), tree.New(2)) 应当返回 false。\n\nTree 的文档可在找到。\n\npackage main\n\nimport "golang.org/x/tour/tree"\n\n// Walk 步进 tree t 将所有的值从 tree 发送到 channel ch。\nfunc Walk(t *tree.Tree, ch chan int)\n\n// Same 检测树 t1 和 t2 是否含有相同的值。\nfunc Same(t1, t2 *tree.Tree) bool\n\nfunc main() {\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# sync.Mutex\n\n我们已经看到信道非常适合在各个 Go 程间进行通信。\n\n但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 Go 程能够访问一个共享的变量，从而避免冲突？\n\n这里涉及的概念叫做 互斥（mutualexclusion）* ，我们通常使用 互斥锁（Mutex） 这一数据结构来提供这种机制。\n\nGo 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法：\n\nLock\n\nUnlock\n\n我们可以通过在代码前调用 Lock 方法，在代码后调用 Unlock 方法来保证一段代码的互斥执行。参见 Inc 方法。\n\n我们也可以用 defer 语句来保证互斥锁一定会被解锁。参见 Value 方法。\n\npackage main\n\nimport (\n\t"fmt"\n\t"sync"\n\t"time"\n)\n\n// SafeCounter 的并发使用是安全的。\ntype SafeCounter struct {\n\tv   map[string]int\n\tmux sync.Mutex\n}\n\n// Inc 增加给定 key 的计数器的值。\nfunc (c *SafeCounter) Inc(key string) {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tc.v[key]++\n\tc.mux.Unlock()\n}\n\n// Value 返回给定 key 的计数器的当前值。\nfunc (c *SafeCounter) Value(key string) int {\n\tc.mux.Lock()\n\t// Lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tdefer c.mux.Unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := SafeCounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.Inc("somekey")\n\t}\n\n\ttime.Sleep(time.Second)\n\tfmt.Println(c.Value("somekey"))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 练习：Web 爬虫\n\n在这个练习中，我们将会使用 Go 的并发特性来并行化一个 Web 爬虫。\n\n修改 Crawl 函数来并行地抓取 URL，并且保证不重复。\n\n提示：你可以用一个 map 来缓存已经获取的 URL，但是要注意 map 本身并不是并发安全的！\n\npackage main\n\nimport (\n\t"fmt"\n)\n\ntype Fetcher interface {\n\t// Fetch 返回 URL 的 body 内容，并且将在这个页面上找到的 URL 放到一个 slice 中。\n\tFetch(url string) (body string, urls []string, err error)\n}\n\n// Crawl 使用 fetcher 从某个 URL 开始递归的爬取页面，直到达到最大深度。\nfunc Crawl(url string, depth int, fetcher Fetcher) {\n\t// TODO: 并行的抓取 URL。\n\t// TODO: 不重复抓取页面。\n        // 下面并没有实现上面两种情况：\n\tif depth <= 0 {\n\t\treturn\n\t}\n\tbody, urls, err := fetcher.Fetch(url)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Printf("found: %s %q\\n", url, body)\n\tfor _, u := range urls {\n\t\tCrawl(u, depth-1, fetcher)\n\t}\n\treturn\n}\n\nfunc main() {\n\tCrawl("https://golang.org/", 4, fetcher)\n}\n\n// fakeFetcher 是返回若干结果的 Fetcher。\ntype fakeFetcher map[string]*fakeResult\n\ntype fakeResult struct {\n\tbody string\n\turls []string\n}\n\nfunc (f fakeFetcher) Fetch(url string) (string, []string, error) {\n\tif res, ok := f[url]; ok {\n\t\treturn res.body, res.urls, nil\n\t}\n\treturn "", nil, fmt.Errorf("not found: %s", url)\n}\n\n// fetcher 是填充后的 fakeFetcher。\nvar fetcher = fakeFetcher{\n\t"https://golang.org/": &fakeResult{\n\t\t"The Go Programming Language",\n\t\t[]string{\n\t\t\t"https://golang.org/pkg/",\n\t\t\t"https://golang.org/cmd/",\n\t\t},\n\t},\n\t"https://golang.org/pkg/": &fakeResult{\n\t\t"Packages",\n\t\t[]string{\n\t\t\t"https://golang.org/",\n\t\t\t"https://golang.org/cmd/",\n\t\t\t"https://golang.org/pkg/fmt/",\n\t\t\t"https://golang.org/pkg/os/",\n\t\t},\n\t},\n\t"https://golang.org/pkg/fmt/": &fakeResult{\n\t\t"Package fmt",\n\t\t[]string{\n\t\t\t"https://golang.org/",\n\t\t\t"https://golang.org/pkg/",\n\t\t},\n\t},\n\t"https://golang.org/pkg/os/": &fakeResult{\n\t\t"Package os",\n\t\t[]string{\n\t\t\t"https://golang.org/",\n\t\t\t"https://golang.org/pkg/",\n\t\t},\n\t},\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n',normalizedContent:'# go routine\n\ngo 程（goroutine）是由 go 运行时管理的轻量级线程。\n\ngo f(x, y, z)\n\n\n1\n\n\n会启动一个新的 go 程并执行\n\nf(x, y, z)\n\n\n1\n\n\nf, x, y 和 z 的求值发生在当前的 go 程中，而 f 的执行发生在新的 go 程中。\n\ngo 程在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。sync 包提供了这种能力，不过在 go 中并不经常用到，因为还有其它的办法（见下一页）。\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc say(s string) {\n\tfor i := 0; i < 5; i++ {\n\t\ttime.sleep(100 * time.millisecond)\n\t\tfmt.println(s)\n\t}\n}\n\nfunc main() {\n\tgo say("world")\n\tsay("hello")\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 信道\n\n信道是带有类型的管道，你可以通过它用信道操作符 <- 来发送或者接收值。\n\nch <- v    // 将 v 发送至信道 ch。\nv := <-ch  // 从 ch 接收值并赋予 v。\n\n\n1\n2\n\n\n（“箭头”就是数据流的方向。）\n\n和映射与切片一样，信道在使用前必须创建：\n\nch := make(chan int)\n\n\n1\n\n\n默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 go 程可以在没有显式的锁或竞态变量的情况下进行同步。\n\n以下示例对切片中的数进行求和，将任务分配给两个 go 程。一旦两个 go 程完成了它们的计算，它就能算出最终的结果。\n\npackage main\n\nimport "fmt"\n\nfunc sum(s []int, c chan int) {\n\tsum := 0\n\tfor _, v := range s {\n\t\tsum += v\n\t}\n\tc <- sum // 将和送入 c\n}\n\nfunc main() {\n\ts := []int{7, 2, 8, -9, 4, 0}\n\n\tc := make(chan int)\n\tgo sum(s[:len(s)/2], c)\n\tgo sum(s[len(s)/2:], c)\n\tx, y := <-c, <-c // 从 c 中接收\n\n\tfmt.println(x, y, x+y)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 带缓冲的信道\n\n信道可以是 带缓冲的。将缓冲长度作为第二个参数提供给 make 来初始化一个带缓冲的信道：\n\nch := make(chan int, 100)\n\n\n1\n\n\n仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。\n\n修改示例填满缓冲区，然后看看会发生什么。\n\npackage main\n\nimport "fmt"\n\nfunc main() {\n\tch := make(chan int, 2)\n\tch <- 1\n\tch <- 2\n\tfmt.println(<-ch)\n\tfmt.println(<-ch)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# range 和 close\n\n发送者可通过 close 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完\n\nv, ok := <-ch\n\n\n1\n\n\n之后 ok 会被设置为 false。\n\n循环 for i := range c 会不断从信道接收值，直到它被关闭。\n\n注意： 只有发送者才能关闭信道，而接收者不能。向一个已经关闭的信道发送数据会引发程序恐慌（panic）。\n\n还要注意： 信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 range 循环。\n\npackage main\n\nimport (\n\t"fmt"\n)\n\nfunc fibonacci(n int, c chan int) {\n\tx, y := 0, 1\n\tfor i := 0; i < n; i++ {\n\t\tc <- x\n\t\tx, y = y, x+y\n\t}\n\tclose(c)\n}\n\nfunc main() {\n\tc := make(chan int, 10)\n\tgo fibonacci(cap(c), c)\n\tfor i := range c {\n\t\tfmt.println(i)\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# select 语句\n\nselect 语句使一个 go 程可以等待多个通信操作。\n\nselect 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。\n\npackage main\n\nimport "fmt"\n\nfunc fibonacci(c, quit chan int) {\n\tx, y := 0, 1\n\tfor {\n\t\tselect {\n\t\tcase c <- x:\n\t\t\tx, y = y, x+y\n\t\tcase <-quit:\n\t\t\tfmt.println("quit")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc main() {\n\tc := make(chan int)\n\tquit := make(chan int)\n\tgo func() {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tfmt.println(<-c)\n\t\t}\n\t\tquit <- 0\n\t}()\n\tfibonacci(c, quit)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 默认选择\n\n当 select 中的其它分支都没有准备好时，default 分支就会执行。\n\n为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：\n\nselect {\ncase i := <-c:\n    // 使用 i\ndefault:\n    // 从 c 中接收会阻塞时执行\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\npackage main\n\nimport (\n\t"fmt"\n\t"time"\n)\n\nfunc main() {\n\ttick := time.tick(100 * time.millisecond)\n\tboom := time.after(500 * time.millisecond)\n\tfor {\n\t\tselect {\n\t\tcase <-tick:\n\t\t\tfmt.println("tick.")\n\t\tcase <-boom:\n\t\t\tfmt.println("boom!")\n\t\t\treturn\n\t\tdefault:\n\t\t\tfmt.println("    .")\n\t\t\ttime.sleep(50 * time.millisecond)\n\t\t}\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 练习：等价二叉查找树\n\n不同二叉树的叶节点上可以保存相同的值序列。例如，以下两个二叉树都保存了序列 1，1，2，3，5，8，13。\n\n\n\n在大多数语言中，检查两个二叉树是否保存了相同序列的函数都相当复杂。 我们将使用 go 的并发和信道来编写一个简单的解法。\n\n本例使用了 tree 包，它定义了类型：\n\ntype tree struct {\n    left  *tree\n    value int\n    right *tree\n}\n\n\n1\n2\n3\n4\n5\n\n\n 1. 实现 walk 函数。\n\n 2. 测试 walk 函数。\n\n函数 tree.new(k) 用于构造一个随机结构的已排序二叉查找树，它保存了值 k, 2k, 3k, ..., 10k。\n\n创建一个新的信道 ch 并且对其进行步进：\n\ngo walk(tree.new(1), ch)\n\n\n1\n\n\n然后从信道中读取并打印 10 个值。应当是数字 1, 2, 3, ..., 10。\n\n 3. 用 walk 实现 same 函数来检测 t1 和 t2 是否存储了相同的值。\n\n 4. 测试 same 函数。\n\nsame(tree.new(1), tree.new(1)) 应当返回 true，而 same(tree.new(1), tree.new(2)) 应当返回 false。\n\ntree 的文档可在找到。\n\npackage main\n\nimport "golang.org/x/tour/tree"\n\n// walk 步进 tree t 将所有的值从 tree 发送到 channel ch。\nfunc walk(t *tree.tree, ch chan int)\n\n// same 检测树 t1 和 t2 是否含有相同的值。\nfunc same(t1, t2 *tree.tree) bool\n\nfunc main() {\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# sync.mutex\n\n我们已经看到信道非常适合在各个 go 程间进行通信。\n\n但是如果我们并不需要通信呢？比如说，若我们只是想保证每次只有一个 go 程能够访问一个共享的变量，从而避免冲突？\n\n这里涉及的概念叫做 互斥（mutualexclusion）* ，我们通常使用 互斥锁（mutex） 这一数据结构来提供这种机制。\n\ngo 标准库中提供了 sync.mutex 互斥锁类型及其两个方法：\n\nlock\n\nunlock\n\n我们可以通过在代码前调用 lock 方法，在代码后调用 unlock 方法来保证一段代码的互斥执行。参见 inc 方法。\n\n我们也可以用 defer 语句来保证互斥锁一定会被解锁。参见 value 方法。\n\npackage main\n\nimport (\n\t"fmt"\n\t"sync"\n\t"time"\n)\n\n// safecounter 的并发使用是安全的。\ntype safecounter struct {\n\tv   map[string]int\n\tmux sync.mutex\n}\n\n// inc 增加给定 key 的计数器的值。\nfunc (c *safecounter) inc(key string) {\n\tc.mux.lock()\n\t// lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tc.v[key]++\n\tc.mux.unlock()\n}\n\n// value 返回给定 key 的计数器的当前值。\nfunc (c *safecounter) value(key string) int {\n\tc.mux.lock()\n\t// lock 之后同一时刻只有一个 goroutine 能访问 c.v\n\tdefer c.mux.unlock()\n\treturn c.v[key]\n}\n\nfunc main() {\n\tc := safecounter{v: make(map[string]int)}\n\tfor i := 0; i < 1000; i++ {\n\t\tgo c.inc("somekey")\n\t}\n\n\ttime.sleep(time.second)\n\tfmt.println(c.value("somekey"))\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 练习：web 爬虫\n\n在这个练习中，我们将会使用 go 的并发特性来并行化一个 web 爬虫。\n\n修改 crawl 函数来并行地抓取 url，并且保证不重复。\n\n提示：你可以用一个 map 来缓存已经获取的 url，但是要注意 map 本身并不是并发安全的！\n\npackage main\n\nimport (\n\t"fmt"\n)\n\ntype fetcher interface {\n\t// fetch 返回 url 的 body 内容，并且将在这个页面上找到的 url 放到一个 slice 中。\n\tfetch(url string) (body string, urls []string, err error)\n}\n\n// crawl 使用 fetcher 从某个 url 开始递归的爬取页面，直到达到最大深度。\nfunc crawl(url string, depth int, fetcher fetcher) {\n\t// todo: 并行的抓取 url。\n\t// todo: 不重复抓取页面。\n        // 下面并没有实现上面两种情况：\n\tif depth <= 0 {\n\t\treturn\n\t}\n\tbody, urls, err := fetcher.fetch(url)\n\tif err != nil {\n\t\tfmt.println(err)\n\t\treturn\n\t}\n\tfmt.printf("found: %s %q\\n", url, body)\n\tfor _, u := range urls {\n\t\tcrawl(u, depth-1, fetcher)\n\t}\n\treturn\n}\n\nfunc main() {\n\tcrawl("https://golang.org/", 4, fetcher)\n}\n\n// fakefetcher 是返回若干结果的 fetcher。\ntype fakefetcher map[string]*fakeresult\n\ntype fakeresult struct {\n\tbody string\n\turls []string\n}\n\nfunc (f fakefetcher) fetch(url string) (string, []string, error) {\n\tif res, ok := f[url]; ok {\n\t\treturn res.body, res.urls, nil\n\t}\n\treturn "", nil, fmt.errorf("not found: %s", url)\n}\n\n// fetcher 是填充后的 fakefetcher。\nvar fetcher = fakefetcher{\n\t"https://golang.org/": &fakeresult{\n\t\t"the go programming language",\n\t\t[]string{\n\t\t\t"https://golang.org/pkg/",\n\t\t\t"https://golang.org/cmd/",\n\t\t},\n\t},\n\t"https://golang.org/pkg/": &fakeresult{\n\t\t"packages",\n\t\t[]string{\n\t\t\t"https://golang.org/",\n\t\t\t"https://golang.org/cmd/",\n\t\t\t"https://golang.org/pkg/fmt/",\n\t\t\t"https://golang.org/pkg/os/",\n\t\t},\n\t},\n\t"https://golang.org/pkg/fmt/": &fakeresult{\n\t\t"package fmt",\n\t\t[]string{\n\t\t\t"https://golang.org/",\n\t\t\t"https://golang.org/pkg/",\n\t\t},\n\t},\n\t"https://golang.org/pkg/os/": &fakeresult{\n\t\t"package os",\n\t\t[]string{\n\t\t\t"https://golang.org/",\n\t\t\t"https://golang.org/pkg/",\n\t\t},\n\t},\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n',charsets:{cjk:!0},lastUpdated:"2023/04/05, 23:41:21",lastUpdatedTimestamp:1680709281e3},{title:"设计模式-总览",frontmatter:{title:"设计模式-总览",date:"2022-05-01T22:52:02.000Z",permalink:"/pages/eb366e/",categories:["设计模式"],tags:["设计模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/0.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88.html",relativePath:"软件设计--设计模式/0.设计模式总览.md",key:"v-65fef59e",path:"/pages/eb366e/",headers:[{level:2,title:"7大基本原则",slug:"_7大基本原则",normalizedTitle:"7大基本原则",charIndex:287},{level:2,title:"设计模型分类",slug:"设计模型分类",normalizedTitle:"设计模型分类",charIndex:1150},{level:2,title:"图解设计模式关系",slug:"图解设计模式关系",normalizedTitle:"图解设计模式关系",charIndex:1376},{level:2,title:"语言选择",slug:"语言选择",normalizedTitle:"语言选择",charIndex:1391}],excerpt:"<p>在1994年，由Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 <strong>Design Patterns - Elements of Reusable Object-Oriented Software</strong>的书，这里就是设计模式的起源。</p>\n<p>四位作者合成GOF（四人帮，Gang of Four），他们提出的设计模式主要基于面向对象设计原则。</p>\n<blockquote>\n<p>对接口编程而不是对实现编程。</p>\n<p>优先使用对象组合而不是继承。</p>\n</blockquote>\n<p>总结来说设计模式是前人总结的经验，用于解决开发过程中常见问题的解决公式。</p>\n",headersStr:"7大基本原则 设计模型分类 图解设计模式关系 语言选择",content:"在1994年，由Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software的书，这里就是设计模式的起源。\n\n四位作者合成GOF（四人帮，Gang of Four），他们提出的设计模式主要基于面向对象设计原则。\n\n> 对接口编程而不是对实现编程。\n> \n> 优先使用对象组合而不是继承。\n\n总结来说设计模式是前人总结的经验，用于解决开发过程中常见问题的解决公式。\n\n\n# 7大基本原则\n\n 1. 开闭原则（OCP，Open Close Principle）\n    \n    > 对扩展开放，对修改关闭。\n    > \n    > 在程序需要进行拓展的时候，不能去修改原有的代码，而是实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。\n\n 2. 单一职责原则（SRP，Single Responsibility Principle）\n    \n    > 就一个类而言,应该仅有一个引起它变化的原因；\n    > \n    > 控制类的粒度、将对象解耦、提高内聚性；注重职责，主要约束类（实现和细节）；\n\n 3. 里氏替换原则（LSP，Liskov Substitution Principle）\n    \n    > 任何基类可以出现的地方，子类一定可以出现。\n    > \n    > 阐述继承复用的原则；开闭原则实现方式；子类继承父类时，尽量不要重写父类方法；（不要破坏继承关系）\n\n 4. 依赖倒置原则（DIP，Dependence Inversion Principle）\n    \n    > 接口不应依赖于实现，实现应该依赖于接口。\n    > \n    > 原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n\n 5. 接口隔离原则（ISP，Interface Segregation Principle）\n    \n    > 从子类实现角度，一个子类实现只需要实现那些他需要的接口。\n    > \n    > 所以我们需要对接口进行分组，这样可以降低类之间的耦合度。\n\n 6. 迪米特法则（LoD， Law of Demeter）\n    \n    > 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n 7. 合成复用原则（CRP，Composite Reuse Principle）\n    \n    > 尽量使用合成/聚合的方式，而不是使用继承。\n\n\n# 设计模型分类\n\n创建型：描述对象如何创建，是为了将对象的创建与使用分离。\n\n包括6种：单例、原型、简单工厂、工厂方法、抽象工厂、建造者。\n\n结构型：描述类或对象如何组织成更大结构\n\n包括7种：代理、适配器、桥接、装饰、外观、享元、组合。\n\n行为型：描述类或对象之间如何协作完成任务\n\n包括11种：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。\n\n共24中设计模式，也由把简单工厂摘出来，为23中设计模式。\n\n\n# 图解设计模式关系\n\n\n\n\n# 语言选择\n\n作者为C++开发，所以暂定语言为C++。\n\n在进入正题之前，需要先了解两个概念：接口和抽象类。\n\n定义:\n\n抽象类：用来捕捉子类的通用特性的，不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板；\n\n接口：抽象方法的集合，只是一种形式，接口自身不能做任何事情。\n\n实现：\n\nC++语言中没有为这两个概念提供直接的关键字。但从实现的角度我们却更容易的知道他们的区别。\n\n抽象类：存在纯虚函数的类。\n\n接口：只存在纯虚函数的类。\n\nC++的override关键字为virtual；一个函数使用了virtual代表可以被子类重写，但同时它也应该被实现；这样的函数称为虚函数。\n\n在虚函数的末尾使用 ‘=0’，这个函数就变成的纯虚函数，这时它就不能被实现，只能被子类重写。",normalizedContent:"在1994年，由erich gamma、richard helm、ralph johnson 和 john vlissides 四人合著出版了一本名为 design patterns - elements of reusable object-oriented software的书，这里就是设计模式的起源。\n\n四位作者合成gof（四人帮，gang of four），他们提出的设计模式主要基于面向对象设计原则。\n\n> 对接口编程而不是对实现编程。\n> \n> 优先使用对象组合而不是继承。\n\n总结来说设计模式是前人总结的经验，用于解决开发过程中常见问题的解决公式。\n\n\n# 7大基本原则\n\n 1. 开闭原则（ocp，open close principle）\n    \n    > 对扩展开放，对修改关闭。\n    > \n    > 在程序需要进行拓展的时候，不能去修改原有的代码，而是实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。\n\n 2. 单一职责原则（srp，single responsibility principle）\n    \n    > 就一个类而言,应该仅有一个引起它变化的原因；\n    > \n    > 控制类的粒度、将对象解耦、提高内聚性；注重职责，主要约束类（实现和细节）；\n\n 3. 里氏替换原则（lsp，liskov substitution principle）\n    \n    > 任何基类可以出现的地方，子类一定可以出现。\n    > \n    > 阐述继承复用的原则；开闭原则实现方式；子类继承父类时，尽量不要重写父类方法；（不要破坏继承关系）\n\n 4. 依赖倒置原则（dip，dependence inversion principle）\n    \n    > 接口不应依赖于实现，实现应该依赖于接口。\n    > \n    > 原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。\n\n 5. 接口隔离原则（isp，interface segregation principle）\n    \n    > 从子类实现角度，一个子类实现只需要实现那些他需要的接口。\n    > \n    > 所以我们需要对接口进行分组，这样可以降低类之间的耦合度。\n\n 6. 迪米特法则（lod， law of demeter）\n    \n    > 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。\n\n 7. 合成复用原则（crp，composite reuse principle）\n    \n    > 尽量使用合成/聚合的方式，而不是使用继承。\n\n\n# 设计模型分类\n\n创建型：描述对象如何创建，是为了将对象的创建与使用分离。\n\n包括6种：单例、原型、简单工厂、工厂方法、抽象工厂、建造者。\n\n结构型：描述类或对象如何组织成更大结构\n\n包括7种：代理、适配器、桥接、装饰、外观、享元、组合。\n\n行为型：描述类或对象之间如何协作完成任务\n\n包括11种：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。\n\n共24中设计模式，也由把简单工厂摘出来，为23中设计模式。\n\n\n# 图解设计模式关系\n\n\n\n\n# 语言选择\n\n作者为c++开发，所以暂定语言为c++。\n\n在进入正题之前，需要先了解两个概念：接口和抽象类。\n\n定义:\n\n抽象类：用来捕捉子类的通用特性的，不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板；\n\n接口：抽象方法的集合，只是一种形式，接口自身不能做任何事情。\n\n实现：\n\nc++语言中没有为这两个概念提供直接的关键字。但从实现的角度我们却更容易的知道他们的区别。\n\n抽象类：存在纯虚函数的类。\n\n接口：只存在纯虚函数的类。\n\nc++的override关键字为virtual；一个函数使用了virtual代表可以被子类重写，但同时它也应该被实现；这样的函数称为虚函数。\n\n在虚函数的末尾使用 ‘=0’，这个函数就变成的纯虚函数，这时它就不能被实现，只能被子类重写。",charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"简单工厂",frontmatter:{title:"简单工厂",date:"2022-05-03T18:13:02.000Z",permalink:"/pages/715e9b/",categories:["设计模式"],tags:["简单工厂"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/1.简单工厂模式.md",key:"v-bc657dee",path:"/pages/715e9b/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:101},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:93},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:89},{level:4,title:"代码路径",slug:"代码路径",normalizedTitle:"代码路径",charIndex:2002},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:2031},{level:3,title:"简单工厂的特点：",slug:"简单工厂的特点",normalizedTitle:"简单工厂的特点：",charIndex:2074},{level:3,title:"简单工厂的问题",slug:"简单工厂的问题",normalizedTitle:"简单工厂的问题",charIndex:2186}],excerpt:'<p>选择简单工厂作为第一个篇，因为它几乎是最简单的设计模式。</p>\n<p>这里想一想我们的冰淇淋贩卖机器，客户不需要知道冰淇淋怎么生成，客户只需要按下对应的按钮即可得到他们想要的产品。</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E8%B4%A9%E5%8D%96%E6%9C%BA.webp" alt="冰淇淋自动贩卖机"></p>\n<p>代码如何实现？</p>\n',headersStr:"场景分析 实现 代码 代码路径 使用感悟 简单工厂的特点： 简单工厂的问题",content:'选择简单工厂作为第一个篇，因为它几乎是最简单的设计模式。\n\n这里想一想我们的冰淇淋贩卖机器，客户不需要知道冰淇淋怎么生成，客户只需要按下对应的按钮即可得到他们想要的产品。\n\n\n\n代码如何实现？\n\n\n# 场景分析\n\n这里不需要实现所有的选项。\n\n简化一下：啃得鸡推出冰淇淋产品，共两款。草莓冰淇淋（产品编号1）和香草冰淇淋（产品编号1），要卖给用户；\n\n简单工厂就可以实现贩卖机的功能。\n\n\n# 实现\n\n实现类图为：\n\n\n\n用户不用知道冰淇淋的生产过程；\n\n用户只需要知道：\n\n 1. 要的是冰淇淋 （接口）\n\n 2. 冰淇淋的贩卖机在哪 （工厂）\n\n 3. 冰淇淋的产品列表 （一般会抽象为枚举类型)\n\n\n# 代码\n\n冰淇淋接口和它的实现\n\n// 冰淇淋接口\nclass IceCreamInfterface\n{\npublic:\n    virtual ~IceCreamInfterface() {}\n    virtual void taste() = 0;\n};\n\n// 草莓冰淇淋\nclass StrawberryIceCreamImpl : public IceCreamInfterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("草莓冰淇淋的味道！");\n    }\n};\n\n// 香草冰淇淋\nclass VanillaIceCreamImpl : public IceCreamInfterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("香草冰淇淋的味道！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n冰淇淋工厂和产品列表\n\n\n// 冰淇淋工厂\nclass IceCreamFactory\n{\npublic:\n    // 产品列表\n    enum ProductList\n    {\n        StrawberryIceCream,\n        VanillaIceCream\n    };\n\npublic:\n    static IceCreamInfterface  createIceCream(ProductList productId)\n    {\n        IceCreamInfterface *pProduct = nullptr;\n        switch (productId)\n        {\n        case StrawberryIceCream:\n            pProduct = new StrawberryIceCreamImpl();\n            break;\n        case VanillaIceCream:\n            pProduct = new VanillaIceCreamImpl();\n            break;\n        default:\n            break;\n        }\n        return pProduct;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n客户\n\n\nint main(int argc, char *argv[])\n{\n    // 买个草莓味的冰淇淋\n    IceCreamInfterface *pIceCream1 =\n            IceCreamFactory::createIceCream(IceCreamFactory::StrawberryIceCream);\n    pIceCream1->taste();\n\n    // 买个香草味的冰淇淋\n    IceCreamInfterface *pIceCream2 =\n            IceCreamFactory::createIceCream(IceCreamFactory::VanillaIceCream);\n    pIceCream2->taste();\n\n    delete pIceCream1;\n    delete pIceCream2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 代码路径\n\n设计模式/SimpleFactory\n\n\n# 使用感悟\n\n简单工厂作为创建型设计模式，主要作用也是将对象的创建与使用分离。\n\n\n# 简单工厂的特点：\n\n1. 产品是有限的、已知的。\n2. 工厂类可以直用静态方法，所以可隐藏构造函数（构造函数私有化）\n3. 创建方法理论上只依赖产品列表，所以可以创建各种实例，不限于只一类。（这是一个危险的实现）\n\n\n\n# 简单工厂的问题\n\n1、添加新产品需要修改已经完成的工厂方法。\n\n2、客户需要知道产品列表和功能直接的关系，增加复杂度。',normalizedContent:'选择简单工厂作为第一个篇，因为它几乎是最简单的设计模式。\n\n这里想一想我们的冰淇淋贩卖机器，客户不需要知道冰淇淋怎么生成，客户只需要按下对应的按钮即可得到他们想要的产品。\n\n\n\n代码如何实现？\n\n\n# 场景分析\n\n这里不需要实现所有的选项。\n\n简化一下：啃得鸡推出冰淇淋产品，共两款。草莓冰淇淋（产品编号1）和香草冰淇淋（产品编号1），要卖给用户；\n\n简单工厂就可以实现贩卖机的功能。\n\n\n# 实现\n\n实现类图为：\n\n\n\n用户不用知道冰淇淋的生产过程；\n\n用户只需要知道：\n\n 1. 要的是冰淇淋 （接口）\n\n 2. 冰淇淋的贩卖机在哪 （工厂）\n\n 3. 冰淇淋的产品列表 （一般会抽象为枚举类型)\n\n\n# 代码\n\n冰淇淋接口和它的实现\n\n// 冰淇淋接口\nclass icecreaminfterface\n{\npublic:\n    virtual ~icecreaminfterface() {}\n    virtual void taste() = 0;\n};\n\n// 草莓冰淇淋\nclass strawberryicecreamimpl : public icecreaminfterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("草莓冰淇淋的味道！");\n    }\n};\n\n// 香草冰淇淋\nclass vanillaicecreamimpl : public icecreaminfterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("香草冰淇淋的味道！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n冰淇淋工厂和产品列表\n\n\n// 冰淇淋工厂\nclass icecreamfactory\n{\npublic:\n    // 产品列表\n    enum productlist\n    {\n        strawberryicecream,\n        vanillaicecream\n    };\n\npublic:\n    static icecreaminfterface  createicecream(productlist productid)\n    {\n        icecreaminfterface *pproduct = nullptr;\n        switch (productid)\n        {\n        case strawberryicecream:\n            pproduct = new strawberryicecreamimpl();\n            break;\n        case vanillaicecream:\n            pproduct = new vanillaicecreamimpl();\n            break;\n        default:\n            break;\n        }\n        return pproduct;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n客户\n\n\nint main(int argc, char *argv[])\n{\n    // 买个草莓味的冰淇淋\n    icecreaminfterface *picecream1 =\n            icecreamfactory::createicecream(icecreamfactory::strawberryicecream);\n    picecream1->taste();\n\n    // 买个香草味的冰淇淋\n    icecreaminfterface *picecream2 =\n            icecreamfactory::createicecream(icecreamfactory::vanillaicecream);\n    picecream2->taste();\n\n    delete picecream1;\n    delete picecream2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 代码路径\n\n设计模式/simplefactory\n\n\n# 使用感悟\n\n简单工厂作为创建型设计模式，主要作用也是将对象的创建与使用分离。\n\n\n# 简单工厂的特点：\n\n1. 产品是有限的、已知的。\n2. 工厂类可以直用静态方法，所以可隐藏构造函数（构造函数私有化）\n3. 创建方法理论上只依赖产品列表，所以可以创建各种实例，不限于只一类。（这是一个危险的实现）\n\n\n\n# 简单工厂的问题\n\n1、添加新产品需要修改已经完成的工厂方法。\n\n2、客户需要知道产品列表和功能直接的关系，增加复杂度。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"装饰模式",frontmatter:{title:"装饰模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/c938fe/",categories:["设计模式"],tags:["装饰模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/10.装饰模式.md",key:"v-f74da980",path:"/pages/c938fe/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:33},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:356},{level:3,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:363},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:372},{level:4,title:"代码路径",slug:"代码路径",normalizedTitle:"代码路径",charIndex:1500},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:1525}],excerpt:"<p>想想一下，我现在如果想在冰淇淋里面加坚果、葡萄干怎么办？</p>\n",headersStr:"场景分析 实现 类图 代码 代码路径 使用感悟",content:'想想一下，我现在如果想在冰淇淋里面加坚果、葡萄干怎么办？\n\n\n# 场景分析\n\n当然我们可以在多建几个工厂，穷举每一个类型。\n\n但是也许你也发现了！\n\n我们要的冰淇淋发生了变化，用户其实可以加更多的东西，或者随意搭配。\n\n难道我们还能不断穷举？\n\n即使我们可以，这种穷举也会随着添加种类，枚举的可能性不断增加，工作量是指数级增长的。\n\n装饰器模式是怎么解决这个问题的？\n\n装饰器其实是将每种变化封装为一种装饰，可以这直接附加到原对象上，产生一个新对象。用于解决问题。\n\n如加两次装饰器的小明：【小明】 --到--\x3e 【穿裤子的小明】 --到--\x3e 【穿裤子的戴帽子的小明】\n\n这样装饰器可以自由组合叠加。\n\n装饰模式是给一个现有对象添加新功能，同时有不去改变其结构的方式。它可以动态的给对象增加新的功能。\n\n\n# 实现\n\n\n# 类图\n\n\n\n\n# 代码\n\n基础类:\n\nclass StrawberryIceCreamImpl : public IceCreamInterface\n{\npublic:\n    virtual void taste() override\n    {\n        cout << "草莓味冰淇淋" << endl;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n装饰者基类：\n\nclass IceCreamDecorator : public IceCreamInterface\n{\npublic:\n    IceCreamDecorator(IceCreamInterface *iceCream)\n        : m_pIceCream(iceCream)\n    {\n    }\n    virtual ~IceCreamDecorator()\n    {\n        delete m_pIceCream;\n    }\n\n    virtual void taste() override\n    {\n        if (m_pIceCream)\n        {\n            m_pIceCream->taste();\n        }\n    }\n\nprivate:\n    IceCreamInterface *m_pIceCream;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n装饰者：\n\nclass NutIceCreamDecorator : public IceCreamDecorator\n{\npublic:\n    NutIceCreamDecorator(IceCreamInterface *iceCream)\n        : IceCreamDecorator(iceCream)\n    {\n    }\n\n    virtual void taste() override\n    {\n        std::cout << "带坚果的";\n        IceCreamDecorator::taste();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n客户使用：\n\nint main()\n{\n\tStrawberryIceCreamImpl().taste();\n\tNutIceCreamDecorator(new StrawberryIceCreamImpl()).taste();\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 代码路径\n\n设计模式/Decorator\n\n\n# 使用感悟\n\n使用场景：\n\n不想增加子类（或者需要增加子类的数量比较多）时，想扩展类能力。\n\n优点：\n\n装饰类和被装饰类可以独立发展，而不会相互耦合。\n\n有效的分割核心职责和非核心职责\n\n可动态地扩展一个实现类的功能（【套娃】使用），减少了类的数量\n\n注意点：\n\n装饰模式一般是构造函数中传入被装饰的对象。\n\n装饰模式是的目的是为了给现有对象增强能力，但是不管怎么增强，不会改变对象的本质。（这点很重要，后面会在代理中做比较）\n\n缺点：\n\n多层包装的装饰类，出BUG，要一层一层查。如：游戏角色的装扮，如果一共20层装饰者，工作量大。',normalizedContent:'想想一下，我现在如果想在冰淇淋里面加坚果、葡萄干怎么办？\n\n\n# 场景分析\n\n当然我们可以在多建几个工厂，穷举每一个类型。\n\n但是也许你也发现了！\n\n我们要的冰淇淋发生了变化，用户其实可以加更多的东西，或者随意搭配。\n\n难道我们还能不断穷举？\n\n即使我们可以，这种穷举也会随着添加种类，枚举的可能性不断增加，工作量是指数级增长的。\n\n装饰器模式是怎么解决这个问题的？\n\n装饰器其实是将每种变化封装为一种装饰，可以这直接附加到原对象上，产生一个新对象。用于解决问题。\n\n如加两次装饰器的小明：【小明】 --到--\x3e 【穿裤子的小明】 --到--\x3e 【穿裤子的戴帽子的小明】\n\n这样装饰器可以自由组合叠加。\n\n装饰模式是给一个现有对象添加新功能，同时有不去改变其结构的方式。它可以动态的给对象增加新的功能。\n\n\n# 实现\n\n\n# 类图\n\n\n\n\n# 代码\n\n基础类:\n\nclass strawberryicecreamimpl : public icecreaminterface\n{\npublic:\n    virtual void taste() override\n    {\n        cout << "草莓味冰淇淋" << endl;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n装饰者基类：\n\nclass icecreamdecorator : public icecreaminterface\n{\npublic:\n    icecreamdecorator(icecreaminterface *icecream)\n        : m_picecream(icecream)\n    {\n    }\n    virtual ~icecreamdecorator()\n    {\n        delete m_picecream;\n    }\n\n    virtual void taste() override\n    {\n        if (m_picecream)\n        {\n            m_picecream->taste();\n        }\n    }\n\nprivate:\n    icecreaminterface *m_picecream;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n装饰者：\n\nclass nuticecreamdecorator : public icecreamdecorator\n{\npublic:\n    nuticecreamdecorator(icecreaminterface *icecream)\n        : icecreamdecorator(icecream)\n    {\n    }\n\n    virtual void taste() override\n    {\n        std::cout << "带坚果的";\n        icecreamdecorator::taste();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n客户使用：\n\nint main()\n{\n\tstrawberryicecreamimpl().taste();\n\tnuticecreamdecorator(new strawberryicecreamimpl()).taste();\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 代码路径\n\n设计模式/decorator\n\n\n# 使用感悟\n\n使用场景：\n\n不想增加子类（或者需要增加子类的数量比较多）时，想扩展类能力。\n\n优点：\n\n装饰类和被装饰类可以独立发展，而不会相互耦合。\n\n有效的分割核心职责和非核心职责\n\n可动态地扩展一个实现类的功能（【套娃】使用），减少了类的数量\n\n注意点：\n\n装饰模式一般是构造函数中传入被装饰的对象。\n\n装饰模式是的目的是为了给现有对象增强能力，但是不管怎么增强，不会改变对象的本质。（这点很重要，后面会在代理中做比较）\n\n缺点：\n\n多层包装的装饰类，出bug，要一层一层查。如：游戏角色的装扮，如果一共20层装饰者，工作量大。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"代理模式",frontmatter:{title:"代理模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/4d70d2/",categories:["设计模式"],tags:["代理模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/11.代理模式.md",key:"v-249801bc",path:"/pages/4d70d2/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:64},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:222},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:231},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:932},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:953}],excerpt:"<p>冰淇淋从工厂出来后，一般要经过超市、马路边的小推车等 ，经销代理后，再到达消费者手里；</p>\n<p>那为什么要有这样经销代理嗯？</p>\n",headersStr:"场景分析 实现 代码 代码位置 感悟",content:'冰淇淋从工厂出来后，一般要经过超市、马路边的小推车等 ，经销代理后，再到达消费者手里；\n\n那为什么要有这样经销代理嗯？\n\n\n# 场景分析\n\n这里对于消费者而言，目的就是从获得想要的冰淇淋，但是直接从工厂拿对用户而言不方便。所以有了超市。\n\n超市还不能足够的接近客户，就有了马路边的小推车。\n\n超市是为了消费者服务的，小推车也是为消费者服务的。 代理也是为客户服务的。\n\n当希望使用，但无法直接使用，某个对象时；我们就可以考虑代理模式。\n\n\n# 实现\n\n\n\n\n# 代码\n\n冰淇淋工厂：\n\nclass IceCreamFactory : public IceCreamFactoryIntf\n{\npublic:\n\tIceCreamFactory() {}\n\tvirtual ~IceCreamFactory() {}\n\n\tvirtual void getIceCream()\n\t{\n\t\tcout << "《冰淇淋》！" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n工厂代理：\n\nclass IceCreamFactoryProxy : public IceCreamFactoryIntf\n{\npublic:\n\tIceCreamFactoryProxy() {}\n\tvirtual ~IceCreamFactoryProxy() {}\n\n\tvirtual void getIceCream()\n\t{\n\t\tcout << "加价" << endl;\n\t\tm_oFactory.getIceCream();\n\t}\n\nprivate:\n\tIceCreamFactory m_oFactory;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n客户调用：\n\nint main()\n{\n\tSetConsoleOutputCP(CP_UTF8);\n\tIceCreamFactoryIntf *p = new IceCreamFactoryProxy();\n\tp->getIceCream();\n\n\tdelete p;\n\treturn 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 代码位置\n\n设计模式/Proxy\n\n\n# 感悟\n\n代理模式是一个自由度特别高的模式，也是一个不容易被辨识的模式。\n\n现在去回想：装饰者模式，或者准备在下一章写的桥模式，我们会发现，里面的区别很微妙。\n\n这里来比较装饰者模式 和 代理：\n\n装饰者模式的注重点在于对已有对象的功能增强，特性上可以无限嵌套；\n\n代理注重解决：客户和要使用的对象之间的复杂性，当我们规划了两个实体A和B后，发现A和B之间的调用关系复杂，或者存在业务上不属于A或者B的调用时。\n\n我们就需要代理来处理这部分的复杂性，代理通过添加中间层的方式在A和B之间添加了一层新的扩展封装。\n\nspring aop 是现在比较有名的代理模式实现。',normalizedContent:'冰淇淋从工厂出来后，一般要经过超市、马路边的小推车等 ，经销代理后，再到达消费者手里；\n\n那为什么要有这样经销代理嗯？\n\n\n# 场景分析\n\n这里对于消费者而言，目的就是从获得想要的冰淇淋，但是直接从工厂拿对用户而言不方便。所以有了超市。\n\n超市还不能足够的接近客户，就有了马路边的小推车。\n\n超市是为了消费者服务的，小推车也是为消费者服务的。 代理也是为客户服务的。\n\n当希望使用，但无法直接使用，某个对象时；我们就可以考虑代理模式。\n\n\n# 实现\n\n\n\n\n# 代码\n\n冰淇淋工厂：\n\nclass icecreamfactory : public icecreamfactoryintf\n{\npublic:\n\ticecreamfactory() {}\n\tvirtual ~icecreamfactory() {}\n\n\tvirtual void geticecream()\n\t{\n\t\tcout << "《冰淇淋》！" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n工厂代理：\n\nclass icecreamfactoryproxy : public icecreamfactoryintf\n{\npublic:\n\ticecreamfactoryproxy() {}\n\tvirtual ~icecreamfactoryproxy() {}\n\n\tvirtual void geticecream()\n\t{\n\t\tcout << "加价" << endl;\n\t\tm_ofactory.geticecream();\n\t}\n\nprivate:\n\ticecreamfactory m_ofactory;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n客户调用：\n\nint main()\n{\n\tsetconsoleoutputcp(cp_utf8);\n\ticecreamfactoryintf *p = new icecreamfactoryproxy();\n\tp->geticecream();\n\n\tdelete p;\n\treturn 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 代码位置\n\n设计模式/proxy\n\n\n# 感悟\n\n代理模式是一个自由度特别高的模式，也是一个不容易被辨识的模式。\n\n现在去回想：装饰者模式，或者准备在下一章写的桥模式，我们会发现，里面的区别很微妙。\n\n这里来比较装饰者模式 和 代理：\n\n装饰者模式的注重点在于对已有对象的功能增强，特性上可以无限嵌套；\n\n代理注重解决：客户和要使用的对象之间的复杂性，当我们规划了两个实体a和b后，发现a和b之间的调用关系复杂，或者存在业务上不属于a或者b的调用时。\n\n我们就需要代理来处理这部分的复杂性，代理通过添加中间层的方式在a和b之间添加了一层新的扩展封装。\n\nspring aop 是现在比较有名的代理模式实现。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"桥模式",frontmatter:{title:"桥模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/51f3ea/",categories:["设计模式"],tags:["桥模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E6%A1%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/12.桥模式.md",key:"v-2683afea",path:"/pages/51f3ea/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:158},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:343},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:357},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1966},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:2033}],excerpt:"<p>小商贩多了，也就一味这销售的渠道拓宽了，人们接受了这种商品。 同时也意味着是用<strong>原型</strong>模式做copy的人多了。</p>\n<p>这时为了不被虐币驱逐良币，啃得鸡决定：将工厂独立处理，加大产能，压缩价格，打价格战。</p>\n<p>啃地鸡冰淇淋代工厂产生了！！！！</p>\n<p>各品牌直接把自己的牌子放在啃地鸡，就能拿到自己的产品。问啃地鸡怎么生产？</p>\n",headersStr:"场景分析 实现 代码 代码位置 感悟",content:'小商贩多了，也就一味这销售的渠道拓宽了，人们接受了这种商品。 同时也意味着是用原型模式做copy的人多了。\n\n这时为了不被虐币驱逐良币，啃得鸡决定：将工厂独立处理，加大产能，压缩价格，打价格战。\n\n啃地鸡冰淇淋代工厂产生了！！！！\n\n各品牌直接把自己的牌子放在啃地鸡，就能拿到自己的产品。问啃地鸡怎么生产？\n\n\n# 场景分析\n\n啃地鸡待工厂现在生产的冰淇淋有两个维度属性： 品牌，配方。\n\n我们可以使用继承关系，但是随着 品牌，配方 不断的增加。子类的数量呈快速增加的状态。可能增加一个配方，就需要十多个子类，甚至更多 。\n\n但是，如果采用品牌和配方拆开的生产方式，增加一个配方就是一个配方。\n\n当类中存在多层继承时，如果我们发现基础是按两个不同维度展开时，就应该考虑桥模式。\n\n\n# 实现\n\n类图：\n\n\n\n\n# 代码\n\n品牌：\n\n// 接口：\nclass BrandIntf\n{\npublic:\n    virtual ~BrandIntf() {}\n    virtual void logo() = 0;\n};\n\n// 实现\nclass ABrandImpl : public BrandIntf\n{\npublic:\n    void logo()\n    {\n        cout << "啃得鸡logo";\n    }\n};\n\nclass BBrandImpl : public BrandIntf\n{\npublic:\n    void logo()\n    {\n        cout << "啃得鸭logo";\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n冰淇淋：\n\n// 接口\nclass IceCreamIntf\n{\npublic:\n    virtual ~IceCreamIntf() {}\n    virtual void taste() = 0;\n    virtual void setBrand(BrandIntf *brand) = 0;\n};\n\n// 实现\n\nclass IceCreamImpl\n{\npublic:\n    IceCreamImpl() : m_pBrand(nullptr) {}\n    virtual ~IceCreamImpl()\n    {\n        delete m_pBrand;\n    }\n\n    virtual void taste()\n    {\n        m_pBrand->logo();\n    }\n\n    virtual void setBrand(BrandIntf *brand)\n    {\n        if (m_pBrand == brand)\n            return;\n        if (nullptr != m_pBrand)\n            delete m_pBrand;\n        m_pBrand = brand;\n    }\n\nprivate:\n    BrandIntf *m_pBrand;\n};\n\nclass StrawberryIceCreamImpl : public IceCreamImpl\n{\npublic:\n    virtual void taste()\n    {\n        IceCreamImpl::taste();\n        cout << "草莓冰淇淋！" << endl;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n客户端：\n\nint main()\n{\n    SetConsoleOutputCP(CP_UTF8);\n    StrawberryIceCreamImpl oIceCream1;\n    oIceCream1.setBrand(new ABrandImpl());\n    oIceCream1.taste();\n\n    StrawberryIceCreamImpl oIceCream2;\n    oIceCream2.setBrand(new BBrandImpl());\n    oIceCream2.taste();\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Bridge\n\n\n# 感悟\n\n优点：\n\n1、从两个维度拆分多重基础类，极大的减少了类个数。\n\n2、两个维度可以独立变化，而不影响另一个维度。\n\n缺点：\n\n1、外在使用时会更复杂。\n\n对比代理，装饰者，我们发现这三这外在使用时，有类似的使用方式。\n\n这样对注重点做对比：\n\n代理：增加不属于原对象的功能。\n\n装饰者：对原有功能的增强，增强后还是原有功能。\n\n桥模式：拆分两个维度，以简化原实现。',normalizedContent:'小商贩多了，也就一味这销售的渠道拓宽了，人们接受了这种商品。 同时也意味着是用原型模式做copy的人多了。\n\n这时为了不被虐币驱逐良币，啃得鸡决定：将工厂独立处理，加大产能，压缩价格，打价格战。\n\n啃地鸡冰淇淋代工厂产生了！！！！\n\n各品牌直接把自己的牌子放在啃地鸡，就能拿到自己的产品。问啃地鸡怎么生产？\n\n\n# 场景分析\n\n啃地鸡待工厂现在生产的冰淇淋有两个维度属性： 品牌，配方。\n\n我们可以使用继承关系，但是随着 品牌，配方 不断的增加。子类的数量呈快速增加的状态。可能增加一个配方，就需要十多个子类，甚至更多 。\n\n但是，如果采用品牌和配方拆开的生产方式，增加一个配方就是一个配方。\n\n当类中存在多层继承时，如果我们发现基础是按两个不同维度展开时，就应该考虑桥模式。\n\n\n# 实现\n\n类图：\n\n\n\n\n# 代码\n\n品牌：\n\n// 接口：\nclass brandintf\n{\npublic:\n    virtual ~brandintf() {}\n    virtual void logo() = 0;\n};\n\n// 实现\nclass abrandimpl : public brandintf\n{\npublic:\n    void logo()\n    {\n        cout << "啃得鸡logo";\n    }\n};\n\nclass bbrandimpl : public brandintf\n{\npublic:\n    void logo()\n    {\n        cout << "啃得鸭logo";\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n冰淇淋：\n\n// 接口\nclass icecreamintf\n{\npublic:\n    virtual ~icecreamintf() {}\n    virtual void taste() = 0;\n    virtual void setbrand(brandintf *brand) = 0;\n};\n\n// 实现\n\nclass icecreamimpl\n{\npublic:\n    icecreamimpl() : m_pbrand(nullptr) {}\n    virtual ~icecreamimpl()\n    {\n        delete m_pbrand;\n    }\n\n    virtual void taste()\n    {\n        m_pbrand->logo();\n    }\n\n    virtual void setbrand(brandintf *brand)\n    {\n        if (m_pbrand == brand)\n            return;\n        if (nullptr != m_pbrand)\n            delete m_pbrand;\n        m_pbrand = brand;\n    }\n\nprivate:\n    brandintf *m_pbrand;\n};\n\nclass strawberryicecreamimpl : public icecreamimpl\n{\npublic:\n    virtual void taste()\n    {\n        icecreamimpl::taste();\n        cout << "草莓冰淇淋！" << endl;\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n客户端：\n\nint main()\n{\n    setconsoleoutputcp(cp_utf8);\n    strawberryicecreamimpl oicecream1;\n    oicecream1.setbrand(new abrandimpl());\n    oicecream1.taste();\n\n    strawberryicecreamimpl oicecream2;\n    oicecream2.setbrand(new bbrandimpl());\n    oicecream2.taste();\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/bridge\n\n\n# 感悟\n\n优点：\n\n1、从两个维度拆分多重基础类，极大的减少了类个数。\n\n2、两个维度可以独立变化，而不影响另一个维度。\n\n缺点：\n\n1、外在使用时会更复杂。\n\n对比代理，装饰者，我们发现这三这外在使用时，有类似的使用方式。\n\n这样对注重点做对比：\n\n代理：增加不属于原对象的功能。\n\n装饰者：对原有功能的增强，增强后还是原有功能。\n\n桥模式：拆分两个维度，以简化原实现。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"适配器模型",frontmatter:{title:"适配器模型",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/54282c/",categories:["设计模式"],tags:["适配器模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/13.适配器模式.md",key:"v-5a67b37d",path:"/pages/54282c/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:136},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:320},{level:3,title:"类适配器",slug:"类适配器",normalizedTitle:"类适配器",charIndex:1285},{level:3,title:"对象适配器",slug:"对象适配器",normalizedTitle:"对象适配器",charIndex:1290},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:370},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:2171}],excerpt:"<p>在桥模式这篇中，啃得鸡优化了自己工厂生产模式；使用桥模型，使得冰淇淋口味和品牌（logo）相互独立变化。</p>\n<p>现在小厂家有了一点问题，小厂家A只知道自己需要 草莓和香草两种冰淇淋。不希望知道啃得鸡可以帮助贴多少中品牌。</p>\n<p>问题：小厂家如何更简单的获得自己的产品嗯？</p>\n",headersStr:"场景分析 实现 类适配器 对象适配器 代码 感悟",content:'在桥模式这篇中，啃得鸡优化了自己工厂生产模式；使用桥模型，使得冰淇淋口味和品牌（logo）相互独立变化。\n\n现在小厂家有了一点问题，小厂家A只知道自己需要 草莓和香草两种冰淇淋。不希望知道啃得鸡可以帮助贴多少中品牌。\n\n问题：小厂家如何更简单的获得自己的产品嗯？\n\n\n# 场景分析\n\n对小厂家A而言，只需要草莓和香草两种冰淇淋。\n\n贴自己的logo是默认的，不需要时刻提醒的。\n\n适配器是为了已经适配那些已经稳定的功能，不希望再发生变动的模块；或者我们并无能力改变的，由外部提供的功能。\n\n典型的是对sdk的接入，当我们希望使用某个sdk的功能；但它又不是那么切合时，为了不将程序搞得一团乱麻。\n\n我们通常会考虑使用适配器的方式。\n\n\n# 实现\n\n这里先看下：啃得鸡sdk\n\n\n\nsdk最终通过facade的方式将创建的决定权移交给客户端，代码如下。\n\n#include "BrandImpl.hpp"\n#include "BrandIntf.h"\n#include "IceCreamIntf.h"\n#include "IceCreamImpl.hpp"\n\n\nenum Brand { A, B };\nenum Taste { Strawberry, Vanilla };\n\nclass IceCreamFacade\n{\npublic:\n\tIceCreamIntf* createIceCream(Taste taste, Brand brand)\n\t{\n\t\tIceCreamIntf* pIceCream = nullptr;\n\t\tswitch (taste)\n\t\t{\n\t\tcase Strawberry:\n\t\t\tpIceCream = new StrawberryIceCreamImpl();\n\t\t\tbreak;\n\t\tcase Vanilla:\n\t\t\tpIceCream = new VanillaIceCreamImpl();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpIceCream = new StrawberryIceCreamImpl();\n\t\t}\n\n\t\tswitch (brand)\n\t\t{\n\t\tcase A:\n\t\t\tpIceCream->setBrand(new ABrandImpl());\n\t\t\tbreak;\n\t\tcase B:\n\t\t\tpIceCream->setBrand(new BBrandImpl());\n\t\t\tbreak;\n\t\tdefault:\t\t\t   \n\t\t\tbreak;\n\t\t}\n\t\treturn pIceCream;\n\t}\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n对于品牌方A而已，只希望选择口味；不希望在每个生产环境都选择一下自己是A。\n\n这里是使用适配器的方式，隔离A不希望知道的信息。一般有两种方式：类适配器，对象适配器\n\n\n# 类适配器\n\n通过继承的方式，重写父类函数；以此为client提供更合适的接口。\n\n\n\n#include "sdk/IceCreamFacade.hpp"\n\nclass IceCreamFacadeClassAdapter : public IceCreamFacade\n{\npublic:\n\tIceCreamIntf* createIceCream(Taste taste)\n\t{\n\t\treturn IceCreamFacade::createIceCream(taste, Brand::A);\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 对象适配器\n\n通过对象使用的方式，将需要实际的业务执行对象进行包装。以此为client提供更合适的接口。\n\n\n\nclass IceCreamFacadeObjectAdapter\n{\npublic:\n\tIceCreamFacadeObjectAdapter()\n\t\t: m_pIceCreamFacade(new IceCreamFacade())\n\t{\n\n\t}\n\tvirtual ~IceCreamFacadeObjectAdapter()\n\t{\n\t\tdelete m_pIceCreamFacade;\n\t\tm_pIceCreamFacade = nullptr;\n\t}\n\npublic:\n\tIceCreamIntf* createIceCream(Taste taste)\n\t{\n\t\treturn m_pIceCreamFacade->createIceCream(taste, Brand::A);\n\t}\n\nprivate:\n\tIceCreamFacade* m_pIceCreamFacade;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Adapter\n\n\n# 感悟\n\n1、从上述的可知适配器的本质是为了去处理由于某种原因，不能被修改代码的部分。如果我们可以修改目标代码，不建议使用适配器。\n\n2、上述场景为单向调用场景；在实际的场景中还有很多是两个模块相互使用。同时，他们又是不可以被改动的情况。这时我们需要使用双向适配器。这时主要使用类适配器。\n\n双向适配器：\n\n',normalizedContent:'在桥模式这篇中，啃得鸡优化了自己工厂生产模式；使用桥模型，使得冰淇淋口味和品牌（logo）相互独立变化。\n\n现在小厂家有了一点问题，小厂家a只知道自己需要 草莓和香草两种冰淇淋。不希望知道啃得鸡可以帮助贴多少中品牌。\n\n问题：小厂家如何更简单的获得自己的产品嗯？\n\n\n# 场景分析\n\n对小厂家a而言，只需要草莓和香草两种冰淇淋。\n\n贴自己的logo是默认的，不需要时刻提醒的。\n\n适配器是为了已经适配那些已经稳定的功能，不希望再发生变动的模块；或者我们并无能力改变的，由外部提供的功能。\n\n典型的是对sdk的接入，当我们希望使用某个sdk的功能；但它又不是那么切合时，为了不将程序搞得一团乱麻。\n\n我们通常会考虑使用适配器的方式。\n\n\n# 实现\n\n这里先看下：啃得鸡sdk\n\n\n\nsdk最终通过facade的方式将创建的决定权移交给客户端，代码如下。\n\n#include "brandimpl.hpp"\n#include "brandintf.h"\n#include "icecreamintf.h"\n#include "icecreamimpl.hpp"\n\n\nenum brand { a, b };\nenum taste { strawberry, vanilla };\n\nclass icecreamfacade\n{\npublic:\n\ticecreamintf* createicecream(taste taste, brand brand)\n\t{\n\t\ticecreamintf* picecream = nullptr;\n\t\tswitch (taste)\n\t\t{\n\t\tcase strawberry:\n\t\t\tpicecream = new strawberryicecreamimpl();\n\t\t\tbreak;\n\t\tcase vanilla:\n\t\t\tpicecream = new vanillaicecreamimpl();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpicecream = new strawberryicecreamimpl();\n\t\t}\n\n\t\tswitch (brand)\n\t\t{\n\t\tcase a:\n\t\t\tpicecream->setbrand(new abrandimpl());\n\t\t\tbreak;\n\t\tcase b:\n\t\t\tpicecream->setbrand(new bbrandimpl());\n\t\t\tbreak;\n\t\tdefault:\t\t\t   \n\t\t\tbreak;\n\t\t}\n\t\treturn picecream;\n\t}\n\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n对于品牌方a而已，只希望选择口味；不希望在每个生产环境都选择一下自己是a。\n\n这里是使用适配器的方式，隔离a不希望知道的信息。一般有两种方式：类适配器，对象适配器\n\n\n# 类适配器\n\n通过继承的方式，重写父类函数；以此为client提供更合适的接口。\n\n\n\n#include "sdk/icecreamfacade.hpp"\n\nclass icecreamfacadeclassadapter : public icecreamfacade\n{\npublic:\n\ticecreamintf* createicecream(taste taste)\n\t{\n\t\treturn icecreamfacade::createicecream(taste, brand::a);\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 对象适配器\n\n通过对象使用的方式，将需要实际的业务执行对象进行包装。以此为client提供更合适的接口。\n\n\n\nclass icecreamfacadeobjectadapter\n{\npublic:\n\ticecreamfacadeobjectadapter()\n\t\t: m_picecreamfacade(new icecreamfacade())\n\t{\n\n\t}\n\tvirtual ~icecreamfacadeobjectadapter()\n\t{\n\t\tdelete m_picecreamfacade;\n\t\tm_picecreamfacade = nullptr;\n\t}\n\npublic:\n\ticecreamintf* createicecream(taste taste)\n\t{\n\t\treturn m_picecreamfacade->createicecream(taste, brand::a);\n\t}\n\nprivate:\n\ticecreamfacade* m_picecreamfacade;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/adapter\n\n\n# 感悟\n\n1、从上述的可知适配器的本质是为了去处理由于某种原因，不能被修改代码的部分。如果我们可以修改目标代码，不建议使用适配器。\n\n2、上述场景为单向调用场景；在实际的场景中还有很多是两个模块相互使用。同时，他们又是不可以被改动的情况。这时我们需要使用双向适配器。这时主要使用类适配器。\n\n双向适配器：\n\n',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"迭代器模型",frontmatter:{title:"迭代器模型",date:"2022-06-11T21:22:38.000Z",permalink:"/pages/d6c716/",categories:["设计模式"],tags:["迭代器模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/14.迭代器模式.md",key:"v-74346634",path:"/pages/d6c716/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:74},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:42},{level:3,title:"Aggregate",slug:"aggregate",normalizedTitle:"aggregate",charIndex:194},{level:3,title:"Iterator",slug:"iterator",normalizedTitle:"iterator",charIndex:353},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:2874},{level:2,title:"仓库",slug:"仓库",normalizedTitle:"仓库",charIndex:3343},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:3410}],excerpt:'<p>随着消费观的变化，冰淇淋的无人销售变得很有吸引力。</p>\n<p>现在有一个问题：无人贩卖机怎么实现按顺序依次卖完某种冰淇淋，并在卖完后告知用户？</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82-%E8%B4%A9%E5%8D%96%E6%9C%BA.webp" alt="冰淇淋自动贩卖机"></p>\n',headersStr:"场景分析 实现 Aggregate Iterator main函数 仓库 感悟",content:'随着消费观的变化，冰淇淋的无人销售变得很有吸引力。\n\n现在有一个问题：无人贩卖机怎么实现按顺序依次卖完某种冰淇淋，并在卖完后告知用户？\n\n\n\n\n# 场景分析\n\n这里简化一下规则，假设贩卖机只贩卖一种冰淇淋。\n\n贩卖机的规则：\n\n1、依次售卖，向用户提供冰淇淋。\n\n2、不能直接让用户打开去拿冰淇淋。\n\n3、当冰淇淋销售完，显示无货。\n\n这里，迭代器就比较合适。\n\n\n# 实现\n\n\n\n\n# Aggregate\n\nAggregate接口：\n\ntemplate<class Item>\nclass Aggregate\n{\npublic:\n\tAggregate() {}\n\tvirtual ~Aggregate() {}\n\tvirtual void pushData(Item item) {}\n\tvirtual Iterator<Item>* createIterator() { return nullptr; }\n\tvirtual Item* operator[](int index) { return nullptr; }\n\tvirtual int getSize() { return 0; }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nAggregate接口实现：\n\n#include "Aggregate.h"\n#include <vector>\n#include "ConcreteIterator.h"\n\ntemplate <class Item>\nclass ConcreteAggregate : public Aggregate<Item>\n{\npublic:\n    ConcreteAggregate() {};\n    virtual ~ConcreteAggregate() {};\n\n    virtual void pushData(Item item) override;\n    virtual Iterator<Item>* createIterator() override;\n    virtual Item* operator[](int index);\n    virtual int getSize() override;\nprivate:\n    std::vector<Item> data;\n};\n\ntemplate <class Item>\nvoid ConcreteAggregate<Item>::pushData(Item item)\n{\n    data.push_back(item);\n}\n\ntemplate <class Item>\nIterator<Item>* ConcreteAggregate<Item>::createIterator()\n{\n    return new ConcreteIterator<Item>(this);\n}\n\ntemplate <class Item>\nItem* ConcreteAggregate<Item>::operator[](int index)\n{\n    return &data.at(index);\n}\n\ntemplate <class Item>\nint ConcreteAggregate<Item>::getSize()\n{\n    return data.size();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# Iterator\n\nIterator接口：\n\n#include "Aggregate.h"\ntemplate<class Item>\nclass Iterator\n{\npublic:\n\tIterator() {}\n\tvirtual ~Iterator() {}\n\tvirtual void first() {}\n\tvirtual void next() {}\n\tvirtual Item* curItem() { return nullptr;  }\n\tvirtual bool hasNext() { return false; }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nIterator接口实现：\n\n#include "Iterator.h"\n#include "Aggregate.h"\n\ntemplate<class Item>\nclass ConcreteIterator : public Iterator<Item>\n{\npublic:\n\tConcreteIterator(Aggregate<Item> *a) : aggr(a), cur(0) {}\n\tvirtual ~ConcreteIterator(){}\n\n\tvirtual void first() override;\n    virtual void next() override;\n    virtual Item* curItem() override;\n    virtual bool hasNext() override;\nprivate:\n\tAggregate<Item>* aggr;\n\tint cur;\n};\n\ntemplate<class Item>\nvoid ConcreteIterator<Item>::first()\n{\n    cur = 0;\n}\n\ntemplate<class Item>\nvoid ConcreteIterator<Item>::next()\n{\n    if (cur < aggr->getSize())\n        cur++;\n}\n\ntemplate<class Item>\nItem* ConcreteIterator<Item>::curItem()\n{\n    if (cur < aggr->getSize())\n    {\n        return (*aggr)[cur];\n    }\n    else\n    {\n        return nullptr;\n    }\n}\n\ntemplate<class Item>\nbool ConcreteIterator<Item>::hasNext()\n{\n    return cur >= aggr->getSize();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n    Aggregate<std::string>* aggr = new ConcreteAggregate<std::string>();\n    aggr->pushData("草莓冰淇淋1");\n    aggr->pushData("草莓冰淇淋2");\n    aggr->pushData("香草冰淇淋2");\n    Iterator<std::string>* it = aggr->createIterator();\n\n    for (it->first(); !it->hasNext(); it->next())\n    {\n        std::cout << *it->curItem() << std::endl;\n    }\n    delete it;\n    delete aggr;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 仓库\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Iterator\n\n\n# 感悟\n\n迭代器模式又叫游标模式是一种常见模式，行为型设计模式的一种。几乎每种语言，会实现自己的迭代器。\n\n在代码编程中，常常需要聚合对象来存放一组数据；\n\n迭代器可以依次访问聚合对象内部的各个元素，同时又不暴露聚合对象的内部表示；\n\n一般做业务开发时，并不需要实现迭代器模式；如果需要做公共组件，基础组件时，封装迭代器可能会被使用。',normalizedContent:'随着消费观的变化，冰淇淋的无人销售变得很有吸引力。\n\n现在有一个问题：无人贩卖机怎么实现按顺序依次卖完某种冰淇淋，并在卖完后告知用户？\n\n\n\n\n# 场景分析\n\n这里简化一下规则，假设贩卖机只贩卖一种冰淇淋。\n\n贩卖机的规则：\n\n1、依次售卖，向用户提供冰淇淋。\n\n2、不能直接让用户打开去拿冰淇淋。\n\n3、当冰淇淋销售完，显示无货。\n\n这里，迭代器就比较合适。\n\n\n# 实现\n\n\n\n\n# aggregate\n\naggregate接口：\n\ntemplate<class item>\nclass aggregate\n{\npublic:\n\taggregate() {}\n\tvirtual ~aggregate() {}\n\tvirtual void pushdata(item item) {}\n\tvirtual iterator<item>* createiterator() { return nullptr; }\n\tvirtual item* operator[](int index) { return nullptr; }\n\tvirtual int getsize() { return 0; }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\naggregate接口实现：\n\n#include "aggregate.h"\n#include <vector>\n#include "concreteiterator.h"\n\ntemplate <class item>\nclass concreteaggregate : public aggregate<item>\n{\npublic:\n    concreteaggregate() {};\n    virtual ~concreteaggregate() {};\n\n    virtual void pushdata(item item) override;\n    virtual iterator<item>* createiterator() override;\n    virtual item* operator[](int index);\n    virtual int getsize() override;\nprivate:\n    std::vector<item> data;\n};\n\ntemplate <class item>\nvoid concreteaggregate<item>::pushdata(item item)\n{\n    data.push_back(item);\n}\n\ntemplate <class item>\niterator<item>* concreteaggregate<item>::createiterator()\n{\n    return new concreteiterator<item>(this);\n}\n\ntemplate <class item>\nitem* concreteaggregate<item>::operator[](int index)\n{\n    return &data.at(index);\n}\n\ntemplate <class item>\nint concreteaggregate<item>::getsize()\n{\n    return data.size();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# iterator\n\niterator接口：\n\n#include "aggregate.h"\ntemplate<class item>\nclass iterator\n{\npublic:\n\titerator() {}\n\tvirtual ~iterator() {}\n\tvirtual void first() {}\n\tvirtual void next() {}\n\tvirtual item* curitem() { return nullptr;  }\n\tvirtual bool hasnext() { return false; }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\niterator接口实现：\n\n#include "iterator.h"\n#include "aggregate.h"\n\ntemplate<class item>\nclass concreteiterator : public iterator<item>\n{\npublic:\n\tconcreteiterator(aggregate<item> *a) : aggr(a), cur(0) {}\n\tvirtual ~concreteiterator(){}\n\n\tvirtual void first() override;\n    virtual void next() override;\n    virtual item* curitem() override;\n    virtual bool hasnext() override;\nprivate:\n\taggregate<item>* aggr;\n\tint cur;\n};\n\ntemplate<class item>\nvoid concreteiterator<item>::first()\n{\n    cur = 0;\n}\n\ntemplate<class item>\nvoid concreteiterator<item>::next()\n{\n    if (cur < aggr->getsize())\n        cur++;\n}\n\ntemplate<class item>\nitem* concreteiterator<item>::curitem()\n{\n    if (cur < aggr->getsize())\n    {\n        return (*aggr)[cur];\n    }\n    else\n    {\n        return nullptr;\n    }\n}\n\ntemplate<class item>\nbool concreteiterator<item>::hasnext()\n{\n    return cur >= aggr->getsize();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n    aggregate<std::string>* aggr = new concreteaggregate<std::string>();\n    aggr->pushdata("草莓冰淇淋1");\n    aggr->pushdata("草莓冰淇淋2");\n    aggr->pushdata("香草冰淇淋2");\n    iterator<std::string>* it = aggr->createiterator();\n\n    for (it->first(); !it->hasnext(); it->next())\n    {\n        std::cout << *it->curitem() << std::endl;\n    }\n    delete it;\n    delete aggr;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 仓库\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/iterator\n\n\n# 感悟\n\n迭代器模式又叫游标模式是一种常见模式，行为型设计模式的一种。几乎每种语言，会实现自己的迭代器。\n\n在代码编程中，常常需要聚合对象来存放一组数据；\n\n迭代器可以依次访问聚合对象内部的各个元素，同时又不暴露聚合对象的内部表示；\n\n一般做业务开发时，并不需要实现迭代器模式；如果需要做公共组件，基础组件时，封装迭代器可能会被使用。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"备忘录模型",frontmatter:{title:"备忘录模型",date:"2022-06-11T21:22:58.000Z",permalink:"/pages/918f6b/",categories:["设计模式"],tags:["备忘录模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/15.备忘录模式.md",key:"v-13ace923",path:"/pages/918f6b/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:127},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:234},{level:3,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:241},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:250},{level:2,title:"代码",slug:"代码-2",normalizedTitle:"代码",charIndex:250},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:1843}],excerpt:"<p>前面通过自动贩卖机（迭代器模式），冰淇淋的销售问题变得很好。</p>\n<p>于是啃得鸡研发了一条自动化冰淇淋生成线，可以生成多种口味，多种配方的冰淇淋。</p>\n<p>每种冰淇淋的销量，目前是不确定的。为了减少不必要的浪费，希望可以根据市场变动，动态调整冰淇淋是生产。</p>\n",headersStr:"场景分析 实现 类图 代码 代码 感悟",content:'前面通过自动贩卖机（迭代器模式），冰淇淋的销售问题变得很好。\n\n于是啃得鸡研发了一条自动化冰淇淋生成线，可以生成多种口味，多种配方的冰淇淋。\n\n每种冰淇淋的销量，目前是不确定的。为了减少不必要的浪费，希望可以根据市场变动，动态调整冰淇淋是生产。\n\n\n# 场景分析\n\n一条生成线可以完成所有产品的生产的同时，也意味着产品线的复杂。\n\n这里的冰淇淋生产线是自动化的，为电脑控制；\n\n解决思路为：将各种产品的生产参数进行备份、存档。\n\n当需要的时候就可以一键使用。\n\n\n# 实现\n\n\n# 类图\n\n\n\n\n# 代码\n\nIceFactoryOriginator: 备忘录使用类\n\nclass IceFactoryOriginator\n{\npublic:\n\tIceFactoryOriginator()\n\t\t: m_sflavour("")\n\t\t, m_sDryFruit("") {}\n\n\tvoid setFlavour(string flavour)\n\t{\n\t\tthis->m_sflavour = flavour; \n\t}\n\n\tvoid setDryFruit(string dryFruit) \n\t{\n\t\tthis->m_sDryFruit = dryFruit; \n\t}\n\n\tIceCream* createCream()\n\t{\n\t\tIceCream *pIceCream = new IceCream(m_sflavour, m_sDryFruit);\n\t\treturn pIceCream;\n\t}\n\n\tMemento* createMemento()\n\t{\n\t\treturn new Memento(m_sflavour, m_sDryFruit);\n\t}\n\n\tvoid restoreMemento(Memento* memento) \n\t{\n\t\tm_sflavour = memento->getFlavour();\n\t\tm_sDryFruit = memento->getDryFruit();\n\t}\nprivate:\n\tstring m_sflavour;\n\tstring m_sDryFruit;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nMemento: 备忘录\n\nclass Memento\n{\npublic:\n\tMemento(string flavour, string dryFruit)\n\t\t: m_sflavour(flavour)\n\t\t, m_sDryFruit(dryFruit) {}\n\tstring getFlavour() { return m_sflavour; }\n\tstring getDryFruit() { return m_sDryFruit; }\nprivate:\n\tstring m_sflavour;\n\tstring m_sDryFruit;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nCareTaker: 备忘录管理类\n\nclass CareTaker\n{\npublic:\n\tCareTaker() {}\n\t~CareTaker() \n\t{\n\t\tfor (auto oIterator = m_oMementos.begin(); oIterator != m_oMementos.end(); ++oIterator)\n\t\t{\n\t\t\tdelete *oIterator;\n\t\t}\n\t\tm_oMementos.clear();\n\t}\n\n\tvoid add(Memento* memento) { this->m_oMementos.push_back(memento); }\n\tMemento* get(int index) { return this->m_oMementos[index]; }\n\nprivate:\n\tvector<Memento*> m_oMementos;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Memento\n\n\n# 感悟\n\n备忘录是为系统的运行提供了后悔药；让系统可以在需要的时机，可以回到希望的状态。\n\n常见的应用场景：撤销恢复，游戏存档，数据库事务等。\n\n当一个对象的所有信息都需要进入备忘录，我们可以思考使用 ： 原型模式 + 备忘录模式\n\n通过原型模式的自copy，我们不会丢失任何数据；并可以将 备忘录中 的备忘录使用者和备忘录统一。',normalizedContent:'前面通过自动贩卖机（迭代器模式），冰淇淋的销售问题变得很好。\n\n于是啃得鸡研发了一条自动化冰淇淋生成线，可以生成多种口味，多种配方的冰淇淋。\n\n每种冰淇淋的销量，目前是不确定的。为了减少不必要的浪费，希望可以根据市场变动，动态调整冰淇淋是生产。\n\n\n# 场景分析\n\n一条生成线可以完成所有产品的生产的同时，也意味着产品线的复杂。\n\n这里的冰淇淋生产线是自动化的，为电脑控制；\n\n解决思路为：将各种产品的生产参数进行备份、存档。\n\n当需要的时候就可以一键使用。\n\n\n# 实现\n\n\n# 类图\n\n\n\n\n# 代码\n\nicefactoryoriginator: 备忘录使用类\n\nclass icefactoryoriginator\n{\npublic:\n\ticefactoryoriginator()\n\t\t: m_sflavour("")\n\t\t, m_sdryfruit("") {}\n\n\tvoid setflavour(string flavour)\n\t{\n\t\tthis->m_sflavour = flavour; \n\t}\n\n\tvoid setdryfruit(string dryfruit) \n\t{\n\t\tthis->m_sdryfruit = dryfruit; \n\t}\n\n\ticecream* createcream()\n\t{\n\t\ticecream *picecream = new icecream(m_sflavour, m_sdryfruit);\n\t\treturn picecream;\n\t}\n\n\tmemento* creatememento()\n\t{\n\t\treturn new memento(m_sflavour, m_sdryfruit);\n\t}\n\n\tvoid restorememento(memento* memento) \n\t{\n\t\tm_sflavour = memento->getflavour();\n\t\tm_sdryfruit = memento->getdryfruit();\n\t}\nprivate:\n\tstring m_sflavour;\n\tstring m_sdryfruit;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nmemento: 备忘录\n\nclass memento\n{\npublic:\n\tmemento(string flavour, string dryfruit)\n\t\t: m_sflavour(flavour)\n\t\t, m_sdryfruit(dryfruit) {}\n\tstring getflavour() { return m_sflavour; }\n\tstring getdryfruit() { return m_sdryfruit; }\nprivate:\n\tstring m_sflavour;\n\tstring m_sdryfruit;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\ncaretaker: 备忘录管理类\n\nclass caretaker\n{\npublic:\n\tcaretaker() {}\n\t~caretaker() \n\t{\n\t\tfor (auto oiterator = m_omementos.begin(); oiterator != m_omementos.end(); ++oiterator)\n\t\t{\n\t\t\tdelete *oiterator;\n\t\t}\n\t\tm_omementos.clear();\n\t}\n\n\tvoid add(memento* memento) { this->m_omementos.push_back(memento); }\n\tmemento* get(int index) { return this->m_omementos[index]; }\n\nprivate:\n\tvector<memento*> m_omementos;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/memento\n\n\n# 感悟\n\n备忘录是为系统的运行提供了后悔药；让系统可以在需要的时机，可以回到希望的状态。\n\n常见的应用场景：撤销恢复，游戏存档，数据库事务等。\n\n当一个对象的所有信息都需要进入备忘录，我们可以思考使用 ： 原型模式 + 备忘录模式\n\n通过原型模式的自copy，我们不会丢失任何数据；并可以将 备忘录中 的备忘录使用者和备忘录统一。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"命令模式",frontmatter:{title:"命令模式",date:"2022-07-21T21:23:14.000Z",permalink:"/pages/b2b690/",categories:["设计模式"],tags:["命令模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/16.命令模式.md",key:"v-21d1e650",path:"/pages/b2b690/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:192},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:412},{level:3,title:"main函数（客户端）",slug:"main函数-客户端",normalizedTitle:"main函数（客户端）",charIndex:421},{level:2,title:"接受者",slug:"接受者",normalizedTitle:"接受者",charIndex:443},{level:3,title:"命令",slug:"命令",normalizedTitle:"命令",charIndex:386},{level:3,title:"调用者",slug:"调用者",normalizedTitle:"调用者",charIndex:450},{level:2,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:2819},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:2885}],excerpt:"<p>上一篇备忘录模式，通过对生产参数的备份、存档；解决了自动化冰淇淋生产线 切换生产模式的问题。</p>\n<p>但技术员小啃💂 最近过的并不开心，工厂的单子在不断的变化；生产线的生产环境总是需要调整。</p>\n<p>生产线的控制随主体一起在工厂，技术员小啃不得不呆在工厂里随时待命；他已经两个月没有回家。</p>\n<p>小啃非常希望自己有一个遥控器，可以随时发布指令；一键改变生产线的生产环境就能变成想要的状态。</p>\n",headersStr:"场景分析 实现 main函数（客户端） 接受者 命令 调用者 代码 感悟",content:'上一篇备忘录模式，通过对生产参数的备份、存档；解决了自动化冰淇淋生产线 切换生产模式的问题。\n\n但技术员小啃💂 最近过的并不开心，工厂的单子在不断的变化；生产线的生产环境总是需要调整。\n\n生产线的控制随主体一起在工厂，技术员小啃不得不呆在工厂里随时待命；他已经两个月没有回家。\n\n小啃非常希望自己有一个遥控器，可以随时发布指令；一键改变生产线的生产环境就能变成想要的状态。\n\n\n# 场景分析\n\n在这个场景里有两个角色：技术员小啃、生产线。\n\n技术员小啃是使用者，生产线是被使用者； 由于技术员小啃必须呆在生产线上才能操作生产线，及使用者和被使用者直接耦合。\n\n正常情况下，使用者和被使用者之间是耦合关系的；但这里希望是使用者和被使用者之间不直接产生关系。\n\n为了达到这一目的，如小啃所愿；引入第三个角色：遥控指令\n\n这样构成了，新的调用关系:\n\n> 使用者（小啃）-> 命令（遥控器指令）-> 被使用者（生产线）\n\n\n# 实现\n\n\n\n\n# main函数（客户端）\n\n具体的命令、命令的接受者、命令的调用者。都是在客户端创建。\n\nint main(int argc, char* argv[])\n{\n\tInvoker oInvoker;\n\tIceFactoryReceiver oIceFactoryReceiver;\n\n\tStrawberryCommand oStrawberryCommand(&oIceFactoryReceiver);\n\toInvoker.setCommand(&oStrawberryCommand);\n\toInvoker.executeCommand();\n\toIceFactoryReceiver.createCream().taste();\n\n\tVanillalceCommand oVanillalceCommand(&oIceFactoryReceiver);\n\toInvoker.setCommand(&oVanillalceCommand);\n\toInvoker.executeCommand();\n\toIceFactoryReceiver.createCream().taste();\n\t\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接受者\n\n业务的具体实现者；这里是冰淇淋生成线。\n\nclass IceFactoryReceiver\n{\npublic:\n\tIceFactoryReceiver()\n\t\t: m_sflavour("")\n\t\t, m_sDryFruit("") {}\n\n\tvoid setFlavour(string flavour)\n\t{\n\t\tthis->m_sflavour = flavour; \n\t}\n\n\tvoid setDryFruit(string dryFruit) \n\t{\n\t\tthis->m_sDryFruit = dryFruit; \n\t}\n\n\tIceCream createCream()\n\t{\n\t\treturn IceCream(m_sflavour, m_sDryFruit);\n\t}\n\nprivate:\n\tstring m_sflavour;\n\tstring m_sDryFruit;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 命令\n\n这里将草莓、香草两种冰淇淋的生产，封装为命令。可以发现命令中是拿着命令执行的对象实例的。\n\nclass Command\n{\npublic:\n\t~Command() {}\n\tvirtual void execute() = 0;\n};\n\n// 草莓味命令\nclass StrawberryCommand : public Command\n{\npublic:\n\tStrawberryCommand(IceFactoryReceiver* iceFactoryReceiver)\n\t\t: m_pIceFactoryReceiver(iceFactoryReceiver) {}\n\n\t~StrawberryCommand() { m_pIceFactoryReceiver = nullptr; }\n\n\tvirtual void execute()\n\t{\n\t\tm_pIceFactoryReceiver->setDryFruit("瓜子");\n\t\tm_pIceFactoryReceiver->setFlavour("草莓");\n\t}\nprivate:\n\tIceFactoryReceiver* m_pIceFactoryReceiver;\n};\n\n// 香草味命令\nclass VanillalceCommand : public Command\n{\npublic:\n\tVanillalceCommand(IceFactoryReceiver* iceFactoryReceiver)\n\t\t: m_pIceFactoryReceiver(iceFactoryReceiver) {}\n\n\t~VanillalceCommand() { m_pIceFactoryReceiver = nullptr; }\n\tvirtual void execute()\n\t{\n\t\tm_pIceFactoryReceiver->setDryFruit("榛子");\n\t\tm_pIceFactoryReceiver->setFlavour("香草");\n\t}\nprivate:\n\tIceFactoryReceiver* m_pIceFactoryReceiver;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 调用者\n\n调用者负责命令的调用，提供命令统一调用的封装。\n\nclass Invoker\n{\npublic:\n\tInvoker() : m_pCommand(nullptr) {}\n\t~Invoker() {}\n\n\tvoid setCommand(Command *command)\n\t{\n\t\tm_pCommand = command;\n\t}\n\n\tvoid executeCommand()\n\t{\n\t\tm_pCommand->execute();\n\t}\n\nprivate:\n\tCommand * m_pCommand;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Command\n\n\n# 感悟\n\n命令模式主要实现了调用者和接受者之间的解构。\n\n场景1： 1、调用者在一些不知道接受者的情况，或不能操作调用者的情况。\n\neg: 界面上有多个按钮控件，分别实现不同的业务功能。\n\n一般界面控制使用一些公共组件；界面控件不知道具体业务使用类，且我们不能操作界面控件的内部实现。\n\n场景2： 1、调用者和接受者执行的生命周期不同；接受者执行时，调用者已经被释放。\n\neg: 数据库系统的撤销、恢复、更新。\n\n数据库根据命令进行撤销、恢复、更新；数据库系统的需要根据自身情况完成数据维护。如果调用者一直等等数据库的返回，可能导致阻塞。同时调用者也不可能提供 撤销、恢复 需要的状态，命令+备忘录可以很好的满足这里的需求。\n\n同策略模式的区别：\n\n简单类别：\n\n命令模式是处理将不同的事情用同一种方式去统一调用，策略模式是处理同一件事情的不同处理方式。\n\n命令模式：命令实例中自己拿着接收者实例。所以命令可操作的对象其实不拘束为一个对象，甚至可以不局限为同一类对象。\n\n策略模式：策略实例无接受者实例，是对一件事的不同做法。',normalizedContent:'上一篇备忘录模式，通过对生产参数的备份、存档；解决了自动化冰淇淋生产线 切换生产模式的问题。\n\n但技术员小啃💂 最近过的并不开心，工厂的单子在不断的变化；生产线的生产环境总是需要调整。\n\n生产线的控制随主体一起在工厂，技术员小啃不得不呆在工厂里随时待命；他已经两个月没有回家。\n\n小啃非常希望自己有一个遥控器，可以随时发布指令；一键改变生产线的生产环境就能变成想要的状态。\n\n\n# 场景分析\n\n在这个场景里有两个角色：技术员小啃、生产线。\n\n技术员小啃是使用者，生产线是被使用者； 由于技术员小啃必须呆在生产线上才能操作生产线，及使用者和被使用者直接耦合。\n\n正常情况下，使用者和被使用者之间是耦合关系的；但这里希望是使用者和被使用者之间不直接产生关系。\n\n为了达到这一目的，如小啃所愿；引入第三个角色：遥控指令\n\n这样构成了，新的调用关系:\n\n> 使用者（小啃）-> 命令（遥控器指令）-> 被使用者（生产线）\n\n\n# 实现\n\n\n\n\n# main函数（客户端）\n\n具体的命令、命令的接受者、命令的调用者。都是在客户端创建。\n\nint main(int argc, char* argv[])\n{\n\tinvoker oinvoker;\n\ticefactoryreceiver oicefactoryreceiver;\n\n\tstrawberrycommand ostrawberrycommand(&oicefactoryreceiver);\n\toinvoker.setcommand(&ostrawberrycommand);\n\toinvoker.executecommand();\n\toicefactoryreceiver.createcream().taste();\n\n\tvanillalcecommand ovanillalcecommand(&oicefactoryreceiver);\n\toinvoker.setcommand(&ovanillalcecommand);\n\toinvoker.executecommand();\n\toicefactoryreceiver.createcream().taste();\n\t\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接受者\n\n业务的具体实现者；这里是冰淇淋生成线。\n\nclass icefactoryreceiver\n{\npublic:\n\ticefactoryreceiver()\n\t\t: m_sflavour("")\n\t\t, m_sdryfruit("") {}\n\n\tvoid setflavour(string flavour)\n\t{\n\t\tthis->m_sflavour = flavour; \n\t}\n\n\tvoid setdryfruit(string dryfruit) \n\t{\n\t\tthis->m_sdryfruit = dryfruit; \n\t}\n\n\ticecream createcream()\n\t{\n\t\treturn icecream(m_sflavour, m_sdryfruit);\n\t}\n\nprivate:\n\tstring m_sflavour;\n\tstring m_sdryfruit;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 命令\n\n这里将草莓、香草两种冰淇淋的生产，封装为命令。可以发现命令中是拿着命令执行的对象实例的。\n\nclass command\n{\npublic:\n\t~command() {}\n\tvirtual void execute() = 0;\n};\n\n// 草莓味命令\nclass strawberrycommand : public command\n{\npublic:\n\tstrawberrycommand(icefactoryreceiver* icefactoryreceiver)\n\t\t: m_picefactoryreceiver(icefactoryreceiver) {}\n\n\t~strawberrycommand() { m_picefactoryreceiver = nullptr; }\n\n\tvirtual void execute()\n\t{\n\t\tm_picefactoryreceiver->setdryfruit("瓜子");\n\t\tm_picefactoryreceiver->setflavour("草莓");\n\t}\nprivate:\n\ticefactoryreceiver* m_picefactoryreceiver;\n};\n\n// 香草味命令\nclass vanillalcecommand : public command\n{\npublic:\n\tvanillalcecommand(icefactoryreceiver* icefactoryreceiver)\n\t\t: m_picefactoryreceiver(icefactoryreceiver) {}\n\n\t~vanillalcecommand() { m_picefactoryreceiver = nullptr; }\n\tvirtual void execute()\n\t{\n\t\tm_picefactoryreceiver->setdryfruit("榛子");\n\t\tm_picefactoryreceiver->setflavour("香草");\n\t}\nprivate:\n\ticefactoryreceiver* m_picefactoryreceiver;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 调用者\n\n调用者负责命令的调用，提供命令统一调用的封装。\n\nclass invoker\n{\npublic:\n\tinvoker() : m_pcommand(nullptr) {}\n\t~invoker() {}\n\n\tvoid setcommand(command *command)\n\t{\n\t\tm_pcommand = command;\n\t}\n\n\tvoid executecommand()\n\t{\n\t\tm_pcommand->execute();\n\t}\n\nprivate:\n\tcommand * m_pcommand;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/command\n\n\n# 感悟\n\n命令模式主要实现了调用者和接受者之间的解构。\n\n场景1： 1、调用者在一些不知道接受者的情况，或不能操作调用者的情况。\n\neg: 界面上有多个按钮控件，分别实现不同的业务功能。\n\n一般界面控制使用一些公共组件；界面控件不知道具体业务使用类，且我们不能操作界面控件的内部实现。\n\n场景2： 1、调用者和接受者执行的生命周期不同；接受者执行时，调用者已经被释放。\n\neg: 数据库系统的撤销、恢复、更新。\n\n数据库根据命令进行撤销、恢复、更新；数据库系统的需要根据自身情况完成数据维护。如果调用者一直等等数据库的返回，可能导致阻塞。同时调用者也不可能提供 撤销、恢复 需要的状态，命令+备忘录可以很好的满足这里的需求。\n\n同策略模式的区别：\n\n简单类别：\n\n命令模式是处理将不同的事情用同一种方式去统一调用，策略模式是处理同一件事情的不同处理方式。\n\n命令模式：命令实例中自己拿着接收者实例。所以命令可操作的对象其实不拘束为一个对象，甚至可以不局限为同一类对象。\n\n策略模式：策略实例无接受者实例，是对一件事的不同做法。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"组合模型",frontmatter:{title:"组合模型",date:"2022-07-23T21:23:44.000Z",permalink:"/pages/135e7e/",categories:["设计模式"],tags:["组合模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/17.组合模式.md",key:"v-75466e3a",path:"/pages/135e7e/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:165},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:64},{level:3,title:"接口Component",slug:"接口component",normalizedTitle:"接口component",charIndex:450},{level:3,title:"叶子 Leaf",slug:"叶子-leaf",normalizedTitle:"叶子 leaf",charIndex:1085},{level:3,title:"一般节点：Composite",slug:"一般节点-composite",normalizedTitle:"一般节点：composite",charIndex:1360},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:2514},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:2968},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:3038},{level:3,title:"关于接口定义",slug:"关于接口定义",normalizedTitle:"关于接口定义",charIndex:3180}],excerpt:"<p>上篇我们使用命令模式，帮助生产员小啃💂更好的生活。</p>\n<p>啃得鸡的生产线通过引入自动生产线，产量激增；但销售线并没办法通过科技爆炸实现销售的激增。</p>\n<p>所以啃得鸡决定，把部分商品通过让利的方式给到经销商销售；走薄利多销的方式消化产能。</p>\n<p>大经销商，也通过让利的方式将商品给到小经销商;最终给到消费者手中。</p>\n<p>代码上怎么实现？</p>\n",headersStr:"场景分析 实现 接口Component 叶子 Leaf 一般节点：Composite main函数 代码位置 感悟 关于接口定义",content:'上篇我们使用命令模式，帮助生产员小啃💂更好的生活。\n\n啃得鸡的生产线通过引入自动生产线，产量激增；但销售线并没办法通过科技爆炸实现销售的激增。\n\n所以啃得鸡决定，把部分商品通过让利的方式给到经销商销售；走薄利多销的方式消化产能。\n\n大经销商，也通过让利的方式将商品给到小经销商;最终给到消费者手中。\n\n代码上怎么实现？\n\n\n# 场景分析\n\n这里可以看到\n\n> 啃得鸡厂家，对应有N个大经销商 大经销商，对应有N个小经销商 ... 小经销商，对应N个零售商 零售商，对应N个顾客\n\n可以发现在整个销售链是一个树状结构：\n\n厂家 -> n大经销商 -> ... -> n零售商 -> n顾客\n\n厂家扮演了【提供商】，顾客扮演了【消费者】; 其他都同时扮演了两个角色：【消费者】、【提供商】；\n\n在销售的整个链条中，每一层都只关注自己上下游，对其他的并不多过问。\n\n如果将【消费者】、【提供商】抽提为接口就是一个行为 buy; 同时实现类做父子结构嵌套，即完成整个链条的表述。\n\n\n# 实现\n\n\n\n\n# 接口Component\n\nclass Component\n{\npublic:\n\texplicit Component(string key) : m_sKey(key) , m_pParent(nullptr) {}\n\tvirtual ~Component() {}\npublic:\n\tvirtual void add(string key, Component* component) {}\n\tvirtual void remove(string key) {}\n\tvirtual Component* getParent(){ return m_pParent; }\n\tvirtual void setParent(Component* component) { m_pParent = component; }\n\tvirtual Component* getChild() { return nullptr; }\n\tvirtual void refresh() {}\npublic:\n\tvirtual int buy(int num) { return 0; }\n\tvirtual int needNum() { return 0;  }\n\nprotected:\n\tstring m_sKey;\n\tComponent* m_pParent;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 叶子 Leaf\n\nclass Leaf : public Component\n{\npublic:\n\texplicit Leaf(string key) : Component(key) {}\npublic:\n\tint buy(int num)\n\t{\n\t\tcout << m_sKey << "购买了" << num << "根雪糕！" << endl;\n\t\treturn 0;\n\t}\n\n\tint needNum()\n\t{\n\t\treturn 1;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 一般节点：Composite\n\nclass Composite : public Component\n{\npublic:\n\tComposite(string key) \n\t\t: Component(key)\n\t\t, m_nNeedNum(0)\n\t{\n\t}\n\n\tvirtual ~Composite()\n\t{\n\t\tm_oChildren.clear();\n\t}\n\npublic:\n\tvoid add(Component* component)\n\t{\n\t\tm_oChildren.push_back(component);\n\t\tcomponent->setParent(this);\n\t\trefresh();\n\t}\n\n\tvoid remove(int index)\n\t{\n\t\tm_oChildren.erase(m_oChildren.begin() + index);\n\t\trefresh();\n\t}\n\n\tComponent* getChild(int index)\n\t{ \n\t\treturn m_oChildren[index];\n\t}\n\n\tvoid refresh() \n\t{\n\t\tm_nNeedNum = 0;\n\t\tfor each (auto var in m_oChildren)\n\t\t{\n\t\t\tm_nNeedNum += var->needNum();\n\t\t}\n\t\tif (nullptr != getParent())\n\t\t{\n\t\t\tgetParent()->refresh();\n\t\t}\n\t}\npublic:\n\tint buy(int num)\n\t{\n\t\tcout << m_sKey << "进货" << num << "根雪糕！" << endl;\n\t\tfor each (auto var in m_oChildren)\n\t\t{\n\t\t\tnum -= var->needNum();\n\t\t\tvar->buy(var->needNum()) ;\n\t\t}\n\t\treturn num;\n\t}\n\n\tint needNum()\n\t{\n\t\treturn m_nNeedNum;\n\t}\n\nprivate:\n\tint m_nNeedNum;\n\tvector<Component*> m_oChildren;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tComposite oComposite("厂家");\n\tComposite oComposite1("代理商");\n\tComposite oComposite2("零售商1");\n\tComposite oComposite3("零售商2");\n\tLeaf oLeaf1("顾客小王");\n\tLeaf oLeaf2("顾客小李");\n\n\toComposite.add(&oComposite1);\n\toComposite1.add(&oComposite2);\n\toComposite1.add(&oComposite3);\n\toComposite2.add(&oLeaf1);\n\toComposite3.add(&oLeaf2);\n\n\toComposite.buy(2);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Component\n\n\n# 感悟\n\n组合模式又叫 “部分整体模式”，这个名字可以更好的表达这个模式想要解决的问题。\n\n及：事物的 部分和整体具有高度相似性。\n\n在组合模式中，每个节点的类定义中，都可以继续包含一组和自己相同的对象；\n\n叶子节点的定义不是必须，但叶子节点一般是必然存在的（数据是有限的）。\n\n\n# 关于接口定义\n\n本案例中接口的定义除了唯一的业务接口为 buy外，还包含对节点的操作：add，remove，getChild, getParent等非业务功能定义；\n\n这意味着，可以客户端可以统一的操作叶子节点和根节点，这种方式也叫透明组合模式；\n\n这种方式也意味着一个问题，客户端在叶子节点调用 add ，remove等操作导致失败；但客户端不知道，具有一定的安全性问题。\n\n于是为了解决这个问题，又发明出一个安全组合模式\n\n\n\n这里接口将不存在add ，remove等操作，客户端需要明确知道当前节点的类型才能做对应操作。',normalizedContent:'上篇我们使用命令模式，帮助生产员小啃💂更好的生活。\n\n啃得鸡的生产线通过引入自动生产线，产量激增；但销售线并没办法通过科技爆炸实现销售的激增。\n\n所以啃得鸡决定，把部分商品通过让利的方式给到经销商销售；走薄利多销的方式消化产能。\n\n大经销商，也通过让利的方式将商品给到小经销商;最终给到消费者手中。\n\n代码上怎么实现？\n\n\n# 场景分析\n\n这里可以看到\n\n> 啃得鸡厂家，对应有n个大经销商 大经销商，对应有n个小经销商 ... 小经销商，对应n个零售商 零售商，对应n个顾客\n\n可以发现在整个销售链是一个树状结构：\n\n厂家 -> n大经销商 -> ... -> n零售商 -> n顾客\n\n厂家扮演了【提供商】，顾客扮演了【消费者】; 其他都同时扮演了两个角色：【消费者】、【提供商】；\n\n在销售的整个链条中，每一层都只关注自己上下游，对其他的并不多过问。\n\n如果将【消费者】、【提供商】抽提为接口就是一个行为 buy; 同时实现类做父子结构嵌套，即完成整个链条的表述。\n\n\n# 实现\n\n\n\n\n# 接口component\n\nclass component\n{\npublic:\n\texplicit component(string key) : m_skey(key) , m_pparent(nullptr) {}\n\tvirtual ~component() {}\npublic:\n\tvirtual void add(string key, component* component) {}\n\tvirtual void remove(string key) {}\n\tvirtual component* getparent(){ return m_pparent; }\n\tvirtual void setparent(component* component) { m_pparent = component; }\n\tvirtual component* getchild() { return nullptr; }\n\tvirtual void refresh() {}\npublic:\n\tvirtual int buy(int num) { return 0; }\n\tvirtual int neednum() { return 0;  }\n\nprotected:\n\tstring m_skey;\n\tcomponent* m_pparent;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 叶子 leaf\n\nclass leaf : public component\n{\npublic:\n\texplicit leaf(string key) : component(key) {}\npublic:\n\tint buy(int num)\n\t{\n\t\tcout << m_skey << "购买了" << num << "根雪糕！" << endl;\n\t\treturn 0;\n\t}\n\n\tint neednum()\n\t{\n\t\treturn 1;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 一般节点：composite\n\nclass composite : public component\n{\npublic:\n\tcomposite(string key) \n\t\t: component(key)\n\t\t, m_nneednum(0)\n\t{\n\t}\n\n\tvirtual ~composite()\n\t{\n\t\tm_ochildren.clear();\n\t}\n\npublic:\n\tvoid add(component* component)\n\t{\n\t\tm_ochildren.push_back(component);\n\t\tcomponent->setparent(this);\n\t\trefresh();\n\t}\n\n\tvoid remove(int index)\n\t{\n\t\tm_ochildren.erase(m_ochildren.begin() + index);\n\t\trefresh();\n\t}\n\n\tcomponent* getchild(int index)\n\t{ \n\t\treturn m_ochildren[index];\n\t}\n\n\tvoid refresh() \n\t{\n\t\tm_nneednum = 0;\n\t\tfor each (auto var in m_ochildren)\n\t\t{\n\t\t\tm_nneednum += var->neednum();\n\t\t}\n\t\tif (nullptr != getparent())\n\t\t{\n\t\t\tgetparent()->refresh();\n\t\t}\n\t}\npublic:\n\tint buy(int num)\n\t{\n\t\tcout << m_skey << "进货" << num << "根雪糕！" << endl;\n\t\tfor each (auto var in m_ochildren)\n\t\t{\n\t\t\tnum -= var->neednum();\n\t\t\tvar->buy(var->neednum()) ;\n\t\t}\n\t\treturn num;\n\t}\n\n\tint neednum()\n\t{\n\t\treturn m_nneednum;\n\t}\n\nprivate:\n\tint m_nneednum;\n\tvector<component*> m_ochildren;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tcomposite ocomposite("厂家");\n\tcomposite ocomposite1("代理商");\n\tcomposite ocomposite2("零售商1");\n\tcomposite ocomposite3("零售商2");\n\tleaf oleaf1("顾客小王");\n\tleaf oleaf2("顾客小李");\n\n\tocomposite.add(&ocomposite1);\n\tocomposite1.add(&ocomposite2);\n\tocomposite1.add(&ocomposite3);\n\tocomposite2.add(&oleaf1);\n\tocomposite3.add(&oleaf2);\n\n\tocomposite.buy(2);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/component\n\n\n# 感悟\n\n组合模式又叫 “部分整体模式”，这个名字可以更好的表达这个模式想要解决的问题。\n\n及：事物的 部分和整体具有高度相似性。\n\n在组合模式中，每个节点的类定义中，都可以继续包含一组和自己相同的对象；\n\n叶子节点的定义不是必须，但叶子节点一般是必然存在的（数据是有限的）。\n\n\n# 关于接口定义\n\n本案例中接口的定义除了唯一的业务接口为 buy外，还包含对节点的操作：add，remove，getchild, getparent等非业务功能定义；\n\n这意味着，可以客户端可以统一的操作叶子节点和根节点，这种方式也叫透明组合模式；\n\n这种方式也意味着一个问题，客户端在叶子节点调用 add ，remove等操作导致失败；但客户端不知道，具有一定的安全性问题。\n\n于是为了解决这个问题，又发明出一个安全组合模式\n\n\n\n这里接口将不存在add ，remove等操作，客户端需要明确知道当前节点的类型才能做对应操作。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"职责链模式",frontmatter:{title:"职责链模式",date:"2022-07-28T21:24:12.000Z",permalink:"/pages/88b3b0/",categories:["设计模式"],tags:["职责链模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/18.职责链模式.md",key:"v-3edde552",path:"/pages/88b3b0/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:197},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:438},{level:3,title:"接口Handler",slug:"接口handler",normalizedTitle:"接口handler",charIndex:537},{level:3,title:"接口Request",slug:"接口request",normalizedTitle:"接口request",charIndex:984},{level:3,title:"具体处理类",slug:"具体处理类",normalizedTitle:"具体处理类",charIndex:1334},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:2214},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:2671},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:2753},{level:3,title:"可改进项",slug:"可改进项",normalizedTitle:"可改进项",charIndex:2760},{level:3,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:2943}],excerpt:"<p>通过大小经销商、零售商， 我们重要将雪糕顺利的搬运到客户手中；但现在又出状况了，客户小明并不开心，因为他有冤无处说，不知道和谁说。</p>\n<p>事情是这样的，小明下班去买他最喜欢草莓雪糕，发现只有最后一根了；但拿到手发现，雪糕有点化了；好人小明心想最后一根了就将就一下。</p>\n<p>结果等打开发现，草莓雪糕包装里面，居然是让他过敏的香草雪糕 😩</p>\n<p>这让小明很沮丧，小明想要反馈情况，当不知道找谁合适。</p>\n",headersStr:"场景分析 实现 接口Handler 接口Request 具体处理类 main函数 代码位置 感悟 可改进项 用法",content:'通过大小经销商、零售商， 我们重要将雪糕顺利的搬运到客户手中；但现在又出状况了，客户小明并不开心，因为他有冤无处说，不知道和谁说。\n\n事情是这样的，小明下班去买他最喜欢草莓雪糕，发现只有最后一根了；但拿到手发现，雪糕有点化了；好人小明心想最后一根了就将就一下。\n\n结果等打开发现，草莓雪糕包装里面，居然是让他过敏的香草雪糕 😩\n\n这让小明很沮丧，小明想要反馈情况，当不知道找谁合适。\n\n\n# 场景分析\n\n这里分析一下小明遇到了的问题、问题的解决方、问题的解决办法：\n\n问题            解决方           解决办法\n草莓雪糕只有一根了     零售商           及时补充雪糕\n雪糕有点化了        整个运输线，包括零售商   提高冷链能力\n草莓雪糕里装了香草雪糕   厂家            提供监管能力\n\n这里如果小明希望能完整的反馈整个问题，需要知道所有的负责人的联系方式，并逐一将对应的问题反馈。\n\n这对小明而已是困难的，甚至不可实现的；比如，中间的某个经销商就是小明无法联系上的。\n\n这里如果厂家如果可以建立完整的反馈链条，小明就可以直接将自己所有的反馈交给零售商；从而让整个雪糕供给系统活动反馈。\n\n\n# 实现\n\n\n\n\n# 接口Handler\n\n定义了处理的接口模式\n\nclass Handler\n{\npublic:\n\tHandler* getNext() { return next; }\n\tvoid setNext(Handler* handler) { next = handler; }\n\n\tvoid handleRequest(Request* request)\n\t{\n\t\tbool handled = false;\n\t\tthis->handle(request, handled);\n\t\tif (!handled)\n\t\t{\n\t\t\tgetNext()->handleRequest(request);\n\t\t}\n\t}\n\n\tvirtual void handle(Request* request, bool& handled) = 0;\nprivate:\n\tHandler* next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 接口Request\n\nclass Request\n{\npublic:\n\tRequest(RequestType type, string message)\n\t\t: m_Type(type)\n\t\t, m_sMessage(message)\n\t{\n\n\t}\n\n\tRequestType getType()\n\t{\n\t\treturn m_Type;\n\t}\n\n\tstring getMessage()\n\t{\n\t\treturn m_sMessage;\n\t}\n\nprivate:\n\tRequestType m_Type;\n\tstring m_sMessage;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 具体处理类\n\n// 零售商\nclass RetailerHandler : public Handler\n{\npublic:\n\tvirtual void handle(Request* request, bool& handled)\n\t{\n\t\tif (request->getType() == RequestType::retaile)\n\t\t{\n\t\t\tcout << "零售商处理问题：" << request->getMessage() << endl;\n\t\t\thandled = true;\n\t\t}\n\t}\n};\n\n// 经销商\nclass DealerHandler : public Handler\n{\npublic:\n\tvirtual void handle(Request* request, bool& handled)\n\t{\n\t\tif (request->getType() == RequestType::dealer)\n\t\t{\n\t\t\tcout << "经销商处理问题：" << request->getMessage() << endl;\n\t\t\thandled = true;\n\t\t}\n\t}\n};\n\n// 厂家\nclass FactoryHandler : public Handler\n{\npublic:\n\tvirtual void handle(Request* request, bool& handled)\n\t{\n\t\tif (request->getType() == RequestType::factory)\n\t\t{\n\t\t\tcout << "厂家处理问题：" << request->getMessage() << endl;\n\t\t\thandled = true;\n\t\t}\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# main函数\n\n这里的main\n\nint main(int argc, char* argv[])\n{\n\tRetailerHandler oHandler1;\n\tDealerHandler oHandler2;\n\tFactoryHandler oHandler3;\n\n\toHandler1.setNext(&oHandler2);\n\toHandler2.setNext(&oHandler3);\n\n\tRequest oRequest1(RequestType::retaile, "雪糕只有一个了");\n\toHandler1.handleRequest(&oRequest1);\n\n\tRequest oRequest2(RequestType::factory, "草莓雪糕袋装了香草雪糕");\n\toHandler1.handleRequest(&oRequest2);\n\n\treturn 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/ChainOfResponsibility\n\n\n# 感悟\n\n\n# 可改进项\n\n这里的Request定义不是应该特别良好的方式。 RequestType 的存在虽然可以明确定义Request的类型，但也导致了发送方，需要知道更多想信息。导致耦合的加深，这并不符合职责链去分离 发送方 和 接收方的初衷。\n\n如果在实际使用中希望通过 RequestType 做明确的划分，可以考虑再做一层封装，做Request的标准生产函数。\n\n\n# 用法\n\n当前的职责链使用了：\n\n纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。\n\n但是小明的问题里还有一个是: 雪糕有点化了,这里用纯的职责链模式就不能胜任。及需要：\n\n不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。\n\n总的来说：职责链模式 是为了 分离 发送方 和 接收方； 所以需要在设计时，也尽可能减少耦合。',normalizedContent:'通过大小经销商、零售商， 我们重要将雪糕顺利的搬运到客户手中；但现在又出状况了，客户小明并不开心，因为他有冤无处说，不知道和谁说。\n\n事情是这样的，小明下班去买他最喜欢草莓雪糕，发现只有最后一根了；但拿到手发现，雪糕有点化了；好人小明心想最后一根了就将就一下。\n\n结果等打开发现，草莓雪糕包装里面，居然是让他过敏的香草雪糕 😩\n\n这让小明很沮丧，小明想要反馈情况，当不知道找谁合适。\n\n\n# 场景分析\n\n这里分析一下小明遇到了的问题、问题的解决方、问题的解决办法：\n\n问题            解决方           解决办法\n草莓雪糕只有一根了     零售商           及时补充雪糕\n雪糕有点化了        整个运输线，包括零售商   提高冷链能力\n草莓雪糕里装了香草雪糕   厂家            提供监管能力\n\n这里如果小明希望能完整的反馈整个问题，需要知道所有的负责人的联系方式，并逐一将对应的问题反馈。\n\n这对小明而已是困难的，甚至不可实现的；比如，中间的某个经销商就是小明无法联系上的。\n\n这里如果厂家如果可以建立完整的反馈链条，小明就可以直接将自己所有的反馈交给零售商；从而让整个雪糕供给系统活动反馈。\n\n\n# 实现\n\n\n\n\n# 接口handler\n\n定义了处理的接口模式\n\nclass handler\n{\npublic:\n\thandler* getnext() { return next; }\n\tvoid setnext(handler* handler) { next = handler; }\n\n\tvoid handlerequest(request* request)\n\t{\n\t\tbool handled = false;\n\t\tthis->handle(request, handled);\n\t\tif (!handled)\n\t\t{\n\t\t\tgetnext()->handlerequest(request);\n\t\t}\n\t}\n\n\tvirtual void handle(request* request, bool& handled) = 0;\nprivate:\n\thandler* next;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 接口request\n\nclass request\n{\npublic:\n\trequest(requesttype type, string message)\n\t\t: m_type(type)\n\t\t, m_smessage(message)\n\t{\n\n\t}\n\n\trequesttype gettype()\n\t{\n\t\treturn m_type;\n\t}\n\n\tstring getmessage()\n\t{\n\t\treturn m_smessage;\n\t}\n\nprivate:\n\trequesttype m_type;\n\tstring m_smessage;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 具体处理类\n\n// 零售商\nclass retailerhandler : public handler\n{\npublic:\n\tvirtual void handle(request* request, bool& handled)\n\t{\n\t\tif (request->gettype() == requesttype::retaile)\n\t\t{\n\t\t\tcout << "零售商处理问题：" << request->getmessage() << endl;\n\t\t\thandled = true;\n\t\t}\n\t}\n};\n\n// 经销商\nclass dealerhandler : public handler\n{\npublic:\n\tvirtual void handle(request* request, bool& handled)\n\t{\n\t\tif (request->gettype() == requesttype::dealer)\n\t\t{\n\t\t\tcout << "经销商处理问题：" << request->getmessage() << endl;\n\t\t\thandled = true;\n\t\t}\n\t}\n};\n\n// 厂家\nclass factoryhandler : public handler\n{\npublic:\n\tvirtual void handle(request* request, bool& handled)\n\t{\n\t\tif (request->gettype() == requesttype::factory)\n\t\t{\n\t\t\tcout << "厂家处理问题：" << request->getmessage() << endl;\n\t\t\thandled = true;\n\t\t}\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# main函数\n\n这里的main\n\nint main(int argc, char* argv[])\n{\n\tretailerhandler ohandler1;\n\tdealerhandler ohandler2;\n\tfactoryhandler ohandler3;\n\n\tohandler1.setnext(&ohandler2);\n\tohandler2.setnext(&ohandler3);\n\n\trequest orequest1(requesttype::retaile, "雪糕只有一个了");\n\tohandler1.handlerequest(&orequest1);\n\n\trequest orequest2(requesttype::factory, "草莓雪糕袋装了香草雪糕");\n\tohandler1.handlerequest(&orequest2);\n\n\treturn 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/chainofresponsibility\n\n\n# 感悟\n\n\n# 可改进项\n\n这里的request定义不是应该特别良好的方式。 requesttype 的存在虽然可以明确定义request的类型，但也导致了发送方，需要知道更多想信息。导致耦合的加深，这并不符合职责链去分离 发送方 和 接收方的初衷。\n\n如果在实际使用中希望通过 requesttype 做明确的划分，可以考虑再做一层封装，做request的标准生产函数。\n\n\n# 用法\n\n当前的职责链使用了：\n\n纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。\n\n但是小明的问题里还有一个是: 雪糕有点化了,这里用纯的职责链模式就不能胜任。及需要：\n\n不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。\n\n总的来说：职责链模式 是为了 分离 发送方 和 接收方； 所以需要在设计时，也尽可能减少耦合。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"访问者模式",frontmatter:{title:"访问者模式",date:"2022-08-01T21:24:45.000Z",permalink:"/pages/d342b4/",categories:["设计模式"],tags:["访问者模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/19.访问者模式.md",key:"v-f8a4b682",path:"/pages/d342b4/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:305},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:383},{level:3,title:"element接口",slug:"element接口",normalizedTitle:"element接口",charIndex:392},{level:3,title:"visitor接口",slug:"visitor接口",normalizedTitle:"visitor接口",charIndex:566},{level:3,title:"ObjectStructure",slug:"objectstructure",normalizedTitle:"objectstructure",charIndex:830},{level:3,title:"element的实现类",slug:"element的实现类",normalizedTitle:"element的实现类",charIndex:1475},{level:3,title:"visitor的实现类",slug:"visitor的实现类",normalizedTitle:"visitor的实现类",charIndex:1994},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:3158},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:3585},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:3653},{level:3,title:"关于双分派（dispatch）",slug:"关于双分派-dispatch",normalizedTitle:"关于双分派（dispatch）",charIndex:3784}],excerpt:"<p>不知不觉，夏天已经过去；雪糕的效率开始下滑，但是厂房、机器投入了那么多。</p>\n<p>啃得鸡开会统一意见：</p>\n<p>从各个方面开发雪糕的剩余价值，来增加销量。</p>\n<p>吃货小玉提出：吃是雪糕的精髓</p>\n<blockquote>\n<p>雪糕：雪糕三吃，油炸雪糕、雪糕饼干、雪糕薯条</p>\n<p>雪糕棍：平平无奇的雪糕棍</p>\n<p>包装： 印吃货教程</p>\n</blockquote>\n<p>神奇小明提出：集邮才是乐趣</p>\n<blockquote>\n<p>雪糕：当然还是吃</p>\n<p>雪糕棍：做手工，以挖掘大家对雪糕的消费。</p>\n<p>包装： 印手工制作教程</p>\n</blockquote>\n<p>善良小芳提出：用爱拯救世界</p>\n<blockquote>\n<p>雪糕：当然还是吃</p>\n<p>雪糕棍：印个电话号码，便于举报</p>\n<p>包装： 在雪糕包装上印走失儿童的照片、地址信息、父母信息等。</p>\n</blockquote>\n",headersStr:"场景分析 实现 element接口 visitor接口 ObjectStructure element的实现类 visitor的实现类 main函数 代码位置 感悟 关于双分派（dispatch）",content:'不知不觉，夏天已经过去；雪糕的效率开始下滑，但是厂房、机器投入了那么多。\n\n啃得鸡开会统一意见：\n\n从各个方面开发雪糕的剩余价值，来增加销量。\n\n吃货小玉提出：吃是雪糕的精髓\n\n> 雪糕：雪糕三吃，油炸雪糕、雪糕饼干、雪糕薯条\n> \n> 雪糕棍：平平无奇的雪糕棍\n> \n> 包装： 印吃货教程\n\n神奇小明提出：集邮才是乐趣\n\n> 雪糕：当然还是吃\n> \n> 雪糕棍：做手工，以挖掘大家对雪糕的消费。\n> \n> 包装： 印手工制作教程\n\n善良小芳提出：用爱拯救世界\n\n> 雪糕：当然还是吃\n> \n> 雪糕棍：印个电话号码，便于举报\n> \n> 包装： 在雪糕包装上印走失儿童的照片、地址信息、父母信息等。\n\n\n# 场景分析\n\n这里厂家并没有改变自己是生产雪糕这个本质，而是尝试改变大众对雪糕的认知；挖掘新的使用办法。\n\n雪糕主体并没有变化，但使用方式发生变化；\n\n\n# 实现\n\n\n\n\n# element接口\n\n定义雪糕组成部分的接口，这里注意 Visitor 可以使用声明，而无需引用。\n\nclass IceCreamPart\n{\npublic:\n\tvirtual ~IceCreamPart() {}\n\tvirtual void accept(Visitor *visitor) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# visitor接口\n\n定义雪糕组成部分的访问方式的接口，这里注意 Body、Stick、Package 可以使用声明，而无需引用。\n\nclass Visitor\n{\npublic:\n\tvirtual ~Visitor() {}\n\n\tvirtual void visitor(Body* body) = 0;\n\tvirtual void visitor(Stick* body) = 0;\n\tvirtual void visitor(Package* body) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# ObjectStructure\n\n这里的ObjectStructure 就是雪糕这个主体，他的组成是稳定的，及资源稳定； 雪糕的各个部分可以通过\n\nclass IceCream\n{\npublic:\n\tIceCream() {}\n\t~IceCream() \n\t{\n\t\tfor each (auto item in IceCreamPartList)\n\t\t{\n\t\t\tdelete item;\n\t\t}\n\t\tIceCreamPartList.clear();\n\t}\n\n\tvoid accept(Visitor* vistor)\n\t{\n\t\tfor each (auto item in IceCreamPartList)\n\t\t{\n\t\t\titem->accept(vistor);\n\t\t}\n\t}\n\n\tvoid add(IceCreamPart* part) \n\t{\n\t\tIceCreamPartList.push_back(part);\n\t}\n\n\tvoid remove(IceCreamPart* part)\n\t{\n\t\tIceCreamPartList.remove(part);\n\t}\n\nprivate:\n\tlist<IceCreamPart*> IceCreamPartList;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# element的实现类\n\n定义了各个组成部分的实现\n\n// 雪糕体\nclass Body : public IceCreamPart\n{\npublic:\n\tvirtual void accept(Visitor *visitor) override\n\t{\n\t\tvisitor->visitor(this);\n\t}\n};\n\n// 雪糕棍\nclass Stick : public IceCreamPart\n{\npublic:\n\tvirtual void accept(Visitor* visitor) override \n\t{\n\t\tvisitor->visitor(this);\n\t}\n};\n\n// 雪糕包装\nclass Package : public IceCreamPart\n{\npublic:\n\tvirtual void accept(Visitor* visitor) override\n\t{\n\t\tvisitor->visitor(this);\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# visitor的实现类\n\n定义了给个部分的不同实现方式\n\n// 小玉\nclass XiaoYuVisitor : public Visitor\n{\npublic:\n\tvirtual void visitor(Body* body) override\n\t{\n\t\tcout << "小玉：把雪糕做出油炸雪糕！" << endl;\n\t}\n\n\tvirtual void visitor(Stick* body) override \n\t{\n\t\tcout << "小玉：雪糕棍，可以送给小明！" << endl;\n\t}\n\n\tvirtual void visitor(Package* body) override \n\t{\n\t\tcout << "小玉：雪糕包装当然印菜品了！" << endl;\n\t}\n};\n// 小明\nclass XiaoMingVisitor : public Visitor\n{\npublic:\n\tvirtual void visitor(Body* body) override \n\t{\n\t\tcout << "小明：雪糕还是吃了吧" << endl;\n\t}\n\n\tvirtual void visitor(Stick* body) override\n\t{\n\t\tcout << "小明：雪糕棍可以做一艘船！" << endl;\n\t}\n\n\tvirtual void visitor(Package* body) override \n\t{\n\t\tcout << "小明：雪糕包装可以教人怎么做船。" << endl;\n\t}\n};\n// 小芳\nclass XiaoFangVisitor : public Visitor\n{\npublic:\n\tvirtual void visitor(Body* body) override \n\t{\n\t\tcout << "小芳：雪糕还是吃了吧" << endl;\n\t}\n\n\tvirtual void visitor(Stick* body) override\n\t{\n\t\tcout << "小芳：雪糕棍可以印上电话" << endl;\n\t}\n\n\tvirtual void visitor(Package* body) override\n\t{\n\t\tcout << "小芳：雪糕包装印上走失儿童的信息，希望他们早日回家！" << endl;\n\t}\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# main函数\n\nint main(int argc, char *argv[])\n{\n    IceCream oIceCream;\n    oIceCream.add(new Body());\n    oIceCream.add(new Stick());\n    oIceCream.add(new Package());\n\n    XiaoYuVisitor oXiaoYu;\n    oIceCream.accept(&oXiaoYu);\n\n    XiaoMingVisitor oXiaoMing;\n    oIceCream.accept(&oXiaoMing);\n\n    XiaoFangVisitor oXiaoFang;\n    oIceCream.accept(&oXiaoFang);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Visitor\n\n\n# 感悟\n\n再一次观察访问者模式的类图：\n\n优点： 增加一个visitor的实现类，影响很小。\n\n缺点： 增加一个element的实现类，影响较大。\n\n访问者模式有利于支持资源结构稳定，使用方式变化的场景；如资源为内部结构，不可直接操作；这时需要添加方法；\n\n\n# 关于双分派（dispatch）\n\n从代码调用顺序来理解这个概念是比较合适的。\n\n\n\n分派1：visitor通过运行时，找到时候执行的子类；这是一次动态分派。\n\n分派2：子类通过overload重载，找到时候的函数；这也是一次动态分派。\n\n两次动态单分派组成了一次动态双分派。',normalizedContent:'不知不觉，夏天已经过去；雪糕的效率开始下滑，但是厂房、机器投入了那么多。\n\n啃得鸡开会统一意见：\n\n从各个方面开发雪糕的剩余价值，来增加销量。\n\n吃货小玉提出：吃是雪糕的精髓\n\n> 雪糕：雪糕三吃，油炸雪糕、雪糕饼干、雪糕薯条\n> \n> 雪糕棍：平平无奇的雪糕棍\n> \n> 包装： 印吃货教程\n\n神奇小明提出：集邮才是乐趣\n\n> 雪糕：当然还是吃\n> \n> 雪糕棍：做手工，以挖掘大家对雪糕的消费。\n> \n> 包装： 印手工制作教程\n\n善良小芳提出：用爱拯救世界\n\n> 雪糕：当然还是吃\n> \n> 雪糕棍：印个电话号码，便于举报\n> \n> 包装： 在雪糕包装上印走失儿童的照片、地址信息、父母信息等。\n\n\n# 场景分析\n\n这里厂家并没有改变自己是生产雪糕这个本质，而是尝试改变大众对雪糕的认知；挖掘新的使用办法。\n\n雪糕主体并没有变化，但使用方式发生变化；\n\n\n# 实现\n\n\n\n\n# element接口\n\n定义雪糕组成部分的接口，这里注意 visitor 可以使用声明，而无需引用。\n\nclass icecreampart\n{\npublic:\n\tvirtual ~icecreampart() {}\n\tvirtual void accept(visitor *visitor) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# visitor接口\n\n定义雪糕组成部分的访问方式的接口，这里注意 body、stick、package 可以使用声明，而无需引用。\n\nclass visitor\n{\npublic:\n\tvirtual ~visitor() {}\n\n\tvirtual void visitor(body* body) = 0;\n\tvirtual void visitor(stick* body) = 0;\n\tvirtual void visitor(package* body) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# objectstructure\n\n这里的objectstructure 就是雪糕这个主体，他的组成是稳定的，及资源稳定； 雪糕的各个部分可以通过\n\nclass icecream\n{\npublic:\n\ticecream() {}\n\t~icecream() \n\t{\n\t\tfor each (auto item in icecreampartlist)\n\t\t{\n\t\t\tdelete item;\n\t\t}\n\t\ticecreampartlist.clear();\n\t}\n\n\tvoid accept(visitor* vistor)\n\t{\n\t\tfor each (auto item in icecreampartlist)\n\t\t{\n\t\t\titem->accept(vistor);\n\t\t}\n\t}\n\n\tvoid add(icecreampart* part) \n\t{\n\t\ticecreampartlist.push_back(part);\n\t}\n\n\tvoid remove(icecreampart* part)\n\t{\n\t\ticecreampartlist.remove(part);\n\t}\n\nprivate:\n\tlist<icecreampart*> icecreampartlist;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# element的实现类\n\n定义了各个组成部分的实现\n\n// 雪糕体\nclass body : public icecreampart\n{\npublic:\n\tvirtual void accept(visitor *visitor) override\n\t{\n\t\tvisitor->visitor(this);\n\t}\n};\n\n// 雪糕棍\nclass stick : public icecreampart\n{\npublic:\n\tvirtual void accept(visitor* visitor) override \n\t{\n\t\tvisitor->visitor(this);\n\t}\n};\n\n// 雪糕包装\nclass package : public icecreampart\n{\npublic:\n\tvirtual void accept(visitor* visitor) override\n\t{\n\t\tvisitor->visitor(this);\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# visitor的实现类\n\n定义了给个部分的不同实现方式\n\n// 小玉\nclass xiaoyuvisitor : public visitor\n{\npublic:\n\tvirtual void visitor(body* body) override\n\t{\n\t\tcout << "小玉：把雪糕做出油炸雪糕！" << endl;\n\t}\n\n\tvirtual void visitor(stick* body) override \n\t{\n\t\tcout << "小玉：雪糕棍，可以送给小明！" << endl;\n\t}\n\n\tvirtual void visitor(package* body) override \n\t{\n\t\tcout << "小玉：雪糕包装当然印菜品了！" << endl;\n\t}\n};\n// 小明\nclass xiaomingvisitor : public visitor\n{\npublic:\n\tvirtual void visitor(body* body) override \n\t{\n\t\tcout << "小明：雪糕还是吃了吧" << endl;\n\t}\n\n\tvirtual void visitor(stick* body) override\n\t{\n\t\tcout << "小明：雪糕棍可以做一艘船！" << endl;\n\t}\n\n\tvirtual void visitor(package* body) override \n\t{\n\t\tcout << "小明：雪糕包装可以教人怎么做船。" << endl;\n\t}\n};\n// 小芳\nclass xiaofangvisitor : public visitor\n{\npublic:\n\tvirtual void visitor(body* body) override \n\t{\n\t\tcout << "小芳：雪糕还是吃了吧" << endl;\n\t}\n\n\tvirtual void visitor(stick* body) override\n\t{\n\t\tcout << "小芳：雪糕棍可以印上电话" << endl;\n\t}\n\n\tvirtual void visitor(package* body) override\n\t{\n\t\tcout << "小芳：雪糕包装印上走失儿童的信息，希望他们早日回家！" << endl;\n\t}\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# main函数\n\nint main(int argc, char *argv[])\n{\n    icecream oicecream;\n    oicecream.add(new body());\n    oicecream.add(new stick());\n    oicecream.add(new package());\n\n    xiaoyuvisitor oxiaoyu;\n    oicecream.accept(&oxiaoyu);\n\n    xiaomingvisitor oxiaoming;\n    oicecream.accept(&oxiaoming);\n\n    xiaofangvisitor oxiaofang;\n    oicecream.accept(&oxiaofang);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/visitor\n\n\n# 感悟\n\n再一次观察访问者模式的类图：\n\n优点： 增加一个visitor的实现类，影响很小。\n\n缺点： 增加一个element的实现类，影响较大。\n\n访问者模式有利于支持资源结构稳定，使用方式变化的场景；如资源为内部结构，不可直接操作；这时需要添加方法；\n\n\n# 关于双分派（dispatch）\n\n从代码调用顺序来理解这个概念是比较合适的。\n\n\n\n分派1：visitor通过运行时，找到时候执行的子类；这是一次动态分派。\n\n分派2：子类通过overload重载，找到时候的函数；这也是一次动态分派。\n\n两次动态单分派组成了一次动态双分派。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"工厂模式",frontmatter:{title:"工厂模式",date:"2022-05-03T18:20:28.000Z",permalink:"/pages/3726e2/",categories:["设计模式"],tags:["设计模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/2.工厂模式.md",key:"v-38966624",path:"/pages/3726e2/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:129},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:121},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:117},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:2194},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:2223}],excerpt:'<p>经过大家的努力，啃得鸡的草莓冰淇淋和香草冰淇淋销量不错。</p>\n<p>准备继续贩售新的冰淇淋产品，发现每次生产新产品时，都要对之前的工厂（简单工厂）进行改造。</p>\n<p>啃得鸡害怕会影响产品品质，希望设计一个发布新产品不会影响原产品生产的工厂。</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%81%E6%B0%B4%E7%BA%BF.webp" alt="工厂模式-流水线"></p>\n<p>代码如何实现？</p>\n',headersStr:"场景分析 实现 代码 代码位置 使用感悟",content:'经过大家的努力，啃得鸡的草莓冰淇淋和香草冰淇淋销量不错。\n\n准备继续贩售新的冰淇淋产品，发现每次生产新产品时，都要对之前的工厂（简单工厂）进行改造。\n\n啃得鸡害怕会影响产品品质，希望设计一个发布新产品不会影响原产品生产的工厂。\n\n\n\n代码如何实现？\n\n\n# 场景分析\n\n让我们再想一想冰淇淋工厂的流水线吧；如何再不影响一个流水线的情况下，再多出一种产品嗯？\n\n造一条新的流水线去生产新产品！\n\n程序就是好，造流水线没那么花钱。\n\n\n# 实现\n\n实现类图：\n\n\n\n这时我们发现如果需要我们有了一个新冰淇淋（产品），那么我们就安排一个新的生产线（工厂）。再也不会影响原了的冰淇淋生产情况了。\n\n\n# 代码\n\n冰淇淋：\n\n// 冰淇淋接口\nclass IceCreamInterface\n{\npublic:\n    virtual ~IceCreamInterface() {}\n    virtual void taste() = 0;\n};\n\n// 草莓冰淇淋\nclass StrawberryIceCreamImpl : public IceCreamInterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("草莓冰淇淋的味道！");\n    }\n};\n\n// 香草冰淇淋\nclass VanillaIceCreamImpl : public IceCreamInterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("香草冰淇淋的味道！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n冰淇淋工厂：\n\n// 冰淇淋工厂接口\nclass IceCreamFactoryInterface\n{\npublic:\n    virtual ~IceCreamFactoryInterface() {}\n    virtual IceCreamInterface * createIceCream() = 0;\n};\n// 草莓冰淇淋工厂\nclass StrawberryIceCreamFactory : public IceCreamFactoryInterface\n{\npublic:\n    StrawberryIceCreamFactory() {}\n    IceCreamInterface * createIceCream()\n    {\n        return new StrawberryIceCreamImpl();\n    }\n};\n// 香草冰淇淋工厂\nclass VanillaIceCreamFactory : public IceCreamFactoryInterface\n{\npublic:\n    VanillaIceCreamFactory() {}\n    IceCreamInterface * createIceCream()\n    {\n        return new VanillaIceCreamImpl();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n客户端：\n\nint main(int argc, char *argv[])\n{\n    IceCreamFactoryInterface* pStrawberryIceCreamFactory =\n            new StrawberryIceCreamFactory();\n\n    IceCreamFactoryInterface* pVanillaIceCreamFactory =\n            new VanillaIceCreamFactory();\n\n    IceCreamInterface* pStrawberryIceCream = pStrawberryIceCreamFactory->createIceCream();\n    IceCreamInterface* pVanillaIceCream = pVanillaIceCreamFactory->createIceCream();\n\n    pStrawberryIceCream->taste();\n    pVanillaIceCream->taste();\n\n    delete pStrawberryIceCreamFactory;\n    delete pVanillaIceCreamFactory;\n    delete pStrawberryIceCream;\n    delete pVanillaIceCream;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 代码位置\n\n设计模式/FactoryMethod\n\n\n# 使用感悟\n\n这里我们解决了简单工厂存在的问题，符合开闭原则的增加产品生产；\n\n但是我们同时引入了新的问题，客户端使用起来很麻烦，对应到现实就是本来一个客户去一个工厂能满足所有的需求，现在客户想要同时买到两种冰淇淋就需要跑两个场；\n\n所有现在我们需一个超市，或者小卖部？\n\n特点/优点：\n\n1、工厂类可以不实例化，使用静态工厂类。\n\n2、延时创建，使用类再不确定是否要创建产品时，可以通过拿着产品的工厂方法。再需要时再创建。 实现延时创建。\n\n问题：\n\n1、随着产品的增加，工厂也不断的增加，可能造成对象的爆发。\n\n2、客户需要关注每个工厂的不同才能获得想要的产品，可能增加维护成本。\n\n思考：\n\n什么是产品，什么是工厂？\n\n由于产品和工厂两个名称的迷惑性，我们可能会下意识的把他们对应到某个实体的映射。（这当然是初学时最快的理解方式）\n\n但产品和工厂的概念中，产品指的是类；类可以是事物，关系等的抽象。',normalizedContent:'经过大家的努力，啃得鸡的草莓冰淇淋和香草冰淇淋销量不错。\n\n准备继续贩售新的冰淇淋产品，发现每次生产新产品时，都要对之前的工厂（简单工厂）进行改造。\n\n啃得鸡害怕会影响产品品质，希望设计一个发布新产品不会影响原产品生产的工厂。\n\n\n\n代码如何实现？\n\n\n# 场景分析\n\n让我们再想一想冰淇淋工厂的流水线吧；如何再不影响一个流水线的情况下，再多出一种产品嗯？\n\n造一条新的流水线去生产新产品！\n\n程序就是好，造流水线没那么花钱。\n\n\n# 实现\n\n实现类图：\n\n\n\n这时我们发现如果需要我们有了一个新冰淇淋（产品），那么我们就安排一个新的生产线（工厂）。再也不会影响原了的冰淇淋生产情况了。\n\n\n# 代码\n\n冰淇淋：\n\n// 冰淇淋接口\nclass icecreaminterface\n{\npublic:\n    virtual ~icecreaminterface() {}\n    virtual void taste() = 0;\n};\n\n// 草莓冰淇淋\nclass strawberryicecreamimpl : public icecreaminterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("草莓冰淇淋的味道！");\n    }\n};\n\n// 香草冰淇淋\nclass vanillaicecreamimpl : public icecreaminterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("香草冰淇淋的味道！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n冰淇淋工厂：\n\n// 冰淇淋工厂接口\nclass icecreamfactoryinterface\n{\npublic:\n    virtual ~icecreamfactoryinterface() {}\n    virtual icecreaminterface * createicecream() = 0;\n};\n// 草莓冰淇淋工厂\nclass strawberryicecreamfactory : public icecreamfactoryinterface\n{\npublic:\n    strawberryicecreamfactory() {}\n    icecreaminterface * createicecream()\n    {\n        return new strawberryicecreamimpl();\n    }\n};\n// 香草冰淇淋工厂\nclass vanillaicecreamfactory : public icecreamfactoryinterface\n{\npublic:\n    vanillaicecreamfactory() {}\n    icecreaminterface * createicecream()\n    {\n        return new vanillaicecreamimpl();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n客户端：\n\nint main(int argc, char *argv[])\n{\n    icecreamfactoryinterface* pstrawberryicecreamfactory =\n            new strawberryicecreamfactory();\n\n    icecreamfactoryinterface* pvanillaicecreamfactory =\n            new vanillaicecreamfactory();\n\n    icecreaminterface* pstrawberryicecream = pstrawberryicecreamfactory->createicecream();\n    icecreaminterface* pvanillaicecream = pvanillaicecreamfactory->createicecream();\n\n    pstrawberryicecream->taste();\n    pvanillaicecream->taste();\n\n    delete pstrawberryicecreamfactory;\n    delete pvanillaicecreamfactory;\n    delete pstrawberryicecream;\n    delete pvanillaicecream;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 代码位置\n\n设计模式/factorymethod\n\n\n# 使用感悟\n\n这里我们解决了简单工厂存在的问题，符合开闭原则的增加产品生产；\n\n但是我们同时引入了新的问题，客户端使用起来很麻烦，对应到现实就是本来一个客户去一个工厂能满足所有的需求，现在客户想要同时买到两种冰淇淋就需要跑两个场；\n\n所有现在我们需一个超市，或者小卖部？\n\n特点/优点：\n\n1、工厂类可以不实例化，使用静态工厂类。\n\n2、延时创建，使用类再不确定是否要创建产品时，可以通过拿着产品的工厂方法。再需要时再创建。 实现延时创建。\n\n问题：\n\n1、随着产品的增加，工厂也不断的增加，可能造成对象的爆发。\n\n2、客户需要关注每个工厂的不同才能获得想要的产品，可能增加维护成本。\n\n思考：\n\n什么是产品，什么是工厂？\n\n由于产品和工厂两个名称的迷惑性，我们可能会下意识的把他们对应到某个实体的映射。（这当然是初学时最快的理解方式）\n\n但产品和工厂的概念中，产品指的是类；类可以是事物，关系等的抽象。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"解释器模式",frontmatter:{title:"解释器模式",date:"2022-08-31T21:25:36.000Z",permalink:"/pages/ff0ba9/",categories:["设计模式"],tags:["解释器模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/20.解释器模式.md",key:"v-75d595a3",path:"/pages/ff0ba9/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:149},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:426},{level:3,title:"抽象表达式",slug:"抽象表达式",normalizedTitle:"抽象表达式",charIndex:489},{level:3,title:"终止符表达式",slug:"终止符表达式",normalizedTitle:"终止符表达式",charIndex:895},{level:3,title:"非终止符表达式——单目运算",slug:"非终止符表达式-单目运算",normalizedTitle:"非终止符表达式——单目运算",charIndex:1169},{level:3,title:"非终止符表达式——双目运算",slug:"非终止符表达式-双目运算",normalizedTitle:"非终止符表达式——双目运算",charIndex:1591},{level:3,title:"环境上下文",slug:"环境上下文",normalizedTitle:"环境上下文",charIndex:443},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:2373},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:2736},{level:2,title:"思考解答",slug:"思考解答",normalizedTitle:"思考解答",charIndex:2808},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:3031}],excerpt:"<p>上篇讲到用访问者模式，解决 吃货小玉、神奇小明、善良小芳提出的建议。</p>\n<p>这里生产部门却犯了难，包装的信息太过复杂：</p>\n<blockquote>\n<p>包装： 印手工制作教程</p>\n<p>包装： 印吃货教程</p>\n<p>包装： 在雪糕包装上印走失儿童的照片、地址信息、父母信息等。</p>\n</blockquote>\n<p>生产部分希望可以用统一的方式进行处理。</p>\n",headersStr:"场景分析 实现 抽象表达式 终止符表达式 非终止符表达式——单目运算 非终止符表达式——双目运算 环境上下文 main函数 代码位置 思考解答 感悟",content:'上篇讲到用访问者模式，解决 吃货小玉、神奇小明、善良小芳提出的建议。\n\n这里生产部门却犯了难，包装的信息太过复杂：\n\n> 包装： 印手工制作教程\n> \n> 包装： 印吃货教程\n> \n> 包装： 在雪糕包装上印走失儿童的照片、地址信息、父母信息等。\n\n生产部分希望可以用统一的方式进行处理。\n\n\n# 场景分析\n\n如果包装信息是一个固定格式：如 图片 + 介绍\n\n那么可以简单的定义一个数据结构，并循环容器，即可。\n\n当前场景，不同雪糕对信息的要求不同；如手工部分 可能是成品图，加制作视频链接，加广告语。 丢失儿童部分，可能是 儿童照片，基本信息，家人基本信息。\n\n同时，不同的走失儿童，信息的组成可能也不同。所以希望设计一种方式可以方便的设置信息的组成，通过简单的关键字组合。即可完成信息的组成。\n\n如：\n\n> img "手工图片位置" + weblink "网络位置"\n> \n> img "儿童图片" + phone "123456789"\n\n\n# 实现\n\n\n\n> Context: 环境上下文，存放表达式解析过程中需要的信息\n> \n> AbstractExpression 抽象表达式：定义表达式的一般能力\n> \n> TerminalExpression: 终结符表达式，用来实现文法中和终结符相关的解释操作，不再包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子对象，可以有多种终结符解释器。\n> \n> NonTerminalExpression: 非终结符表达式,用来实现文法中和非终结符相关的解释操作，通常一个解释器对应一个语法规则，可以包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的组合对象，可以有多种非终结符解释器。\n\n\n# 抽象表达式\n\nclass AbstractExpression\n{\npublic:\n\tvirtual ~AbstractExpression() {}\n\tvirtual string interprete(Context &ctx) = 0;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 终止符表达式\n\nclass ValueExpression : public AbstractExpression\n{\npublic:\n\tValueExpression(string key) \n\t\t: m_key(key)\n\t{\n\t}\n\n\tvirtual string interprete(Context &ctx) override\n\t{\n\t\treturn ctx.lookup(m_key);\n\t}\nprivate:\n\tstring m_key;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 非终止符表达式——单目运算\n\n图片解析：\n\nclass ImgExpression : public AbstractExpression\n{\npublic:\n\tImgExpression(AbstractExpression * expr)\n\t\t: m_Expr(expr)\n\t{\n\t}\n\n\tvirtual ~ImgExpression()\n\t{\n\t\tdelete m_Expr;\n\t\tm_Expr = nullptr;\n\t}\n\n\tvirtual string interprete(Context& ctx) override\n\t{\n\t\treturn "解析图片：" + m_Expr->interprete(ctx);\n\t}\n\nprivate:\n\tAbstractExpression* m_Expr;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 非终止符表达式——双目运算\n\n加 运算：\n\nclass PlusOperation : public AbstractExpression\n{\npublic:\n\tPlusOperation(AbstractExpression* e1, AbstractExpression* e2)\n\t\t: m_e1(e1), m_e2(e2)\n\t{\n\t}\n\n\tvirtual ~PlusOperation()\n\t{\n\t\tdelete m_e1;\n\t\tdelete m_e2;\n\t}\n\n\tvirtual string interprete(Context& ctx) override\n\t{\n\t\treturn m_e1->interprete(ctx) + " and " + m_e2->interprete(ctx);\n\t}\n\nprivate:\n\tAbstractExpression* m_e1;\n\tAbstractExpression* m_e2;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 环境上下文\n\nclass Context\n{\npublic:\n\tvoid assign(string key, string value)\n\t{\n\t\tm_oContextMap.insert({ key, value });           \n\t}\n\n\tstring lookup(string key)\n\t{\n\t\treturn m_oContextMap.at(key);\n\t}\n\nprotected:\n\tmap<string, string> m_oContextMap;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# main函数\n\nint main(int argc, char *argv[])\n{\n    Context oContext;\n    oContext.assign("Img", "img王小二照片");\n    oContext.assign("p", "13579");\n\n    PlusOperation oPlus1(new ImgExpression(new ValueExpression("Img")), new PhoneExpression(new ValueExpression("p")));\n\n    cout << oPlus1.interprete(oContext);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行结果：\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Interpreter\n\n\n# 思考解答\n\n以上代码完成了简单的解释器模式，但main函数的使用方式会让人感觉不那么舒适。\n\n我们希望的形式：\n\n输入：一个表达式\n\n> 如： img "手工图片位置" + weblink "网络位置" img "儿童图片" + phone "123456789"\n\n输出： 对应的表达式，所表达的含义。\n\n这些其实是只需要两步： 1、拆解表达式，中缀表达式 改为 后缀表达式 2、压栈求值\n\n这是数据结构相关的知识，这里就不详细说明。\n\n\n# 感悟\n\n解释器模式，其实是用代码实现了一个简版的 “语言”； 以解决发生频率很高，但规则可明细的场景。\n\n一般来说我们不太可能使用解释器模式，笔者目前为止，还没没有在项目中切实的需要过它。\n\n优点：\n\n良好的扩展性，可以不断定义新的表达式来实现新的业务。\n\n缺点：\n\n容易引起类膨胀，需要较强的类管理能力。',normalizedContent:'上篇讲到用访问者模式，解决 吃货小玉、神奇小明、善良小芳提出的建议。\n\n这里生产部门却犯了难，包装的信息太过复杂：\n\n> 包装： 印手工制作教程\n> \n> 包装： 印吃货教程\n> \n> 包装： 在雪糕包装上印走失儿童的照片、地址信息、父母信息等。\n\n生产部分希望可以用统一的方式进行处理。\n\n\n# 场景分析\n\n如果包装信息是一个固定格式：如 图片 + 介绍\n\n那么可以简单的定义一个数据结构，并循环容器，即可。\n\n当前场景，不同雪糕对信息的要求不同；如手工部分 可能是成品图，加制作视频链接，加广告语。 丢失儿童部分，可能是 儿童照片，基本信息，家人基本信息。\n\n同时，不同的走失儿童，信息的组成可能也不同。所以希望设计一种方式可以方便的设置信息的组成，通过简单的关键字组合。即可完成信息的组成。\n\n如：\n\n> img "手工图片位置" + weblink "网络位置"\n> \n> img "儿童图片" + phone "123456789"\n\n\n# 实现\n\n\n\n> context: 环境上下文，存放表达式解析过程中需要的信息\n> \n> abstractexpression 抽象表达式：定义表达式的一般能力\n> \n> terminalexpression: 终结符表达式，用来实现文法中和终结符相关的解释操作，不再包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子对象，可以有多种终结符解释器。\n> \n> nonterminalexpression: 非终结符表达式,用来实现文法中和非终结符相关的解释操作，通常一个解释器对应一个语法规则，可以包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的组合对象，可以有多种非终结符解释器。\n\n\n# 抽象表达式\n\nclass abstractexpression\n{\npublic:\n\tvirtual ~abstractexpression() {}\n\tvirtual string interprete(context &ctx) = 0;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 终止符表达式\n\nclass valueexpression : public abstractexpression\n{\npublic:\n\tvalueexpression(string key) \n\t\t: m_key(key)\n\t{\n\t}\n\n\tvirtual string interprete(context &ctx) override\n\t{\n\t\treturn ctx.lookup(m_key);\n\t}\nprivate:\n\tstring m_key;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 非终止符表达式——单目运算\n\n图片解析：\n\nclass imgexpression : public abstractexpression\n{\npublic:\n\timgexpression(abstractexpression * expr)\n\t\t: m_expr(expr)\n\t{\n\t}\n\n\tvirtual ~imgexpression()\n\t{\n\t\tdelete m_expr;\n\t\tm_expr = nullptr;\n\t}\n\n\tvirtual string interprete(context& ctx) override\n\t{\n\t\treturn "解析图片：" + m_expr->interprete(ctx);\n\t}\n\nprivate:\n\tabstractexpression* m_expr;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 非终止符表达式——双目运算\n\n加 运算：\n\nclass plusoperation : public abstractexpression\n{\npublic:\n\tplusoperation(abstractexpression* e1, abstractexpression* e2)\n\t\t: m_e1(e1), m_e2(e2)\n\t{\n\t}\n\n\tvirtual ~plusoperation()\n\t{\n\t\tdelete m_e1;\n\t\tdelete m_e2;\n\t}\n\n\tvirtual string interprete(context& ctx) override\n\t{\n\t\treturn m_e1->interprete(ctx) + " and " + m_e2->interprete(ctx);\n\t}\n\nprivate:\n\tabstractexpression* m_e1;\n\tabstractexpression* m_e2;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 环境上下文\n\nclass context\n{\npublic:\n\tvoid assign(string key, string value)\n\t{\n\t\tm_ocontextmap.insert({ key, value });           \n\t}\n\n\tstring lookup(string key)\n\t{\n\t\treturn m_ocontextmap.at(key);\n\t}\n\nprotected:\n\tmap<string, string> m_ocontextmap;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# main函数\n\nint main(int argc, char *argv[])\n{\n    context ocontext;\n    ocontext.assign("img", "img王小二照片");\n    ocontext.assign("p", "13579");\n\n    plusoperation oplus1(new imgexpression(new valueexpression("img")), new phoneexpression(new valueexpression("p")));\n\n    cout << oplus1.interprete(ocontext);\n\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n运行结果：\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/interpreter\n\n\n# 思考解答\n\n以上代码完成了简单的解释器模式，但main函数的使用方式会让人感觉不那么舒适。\n\n我们希望的形式：\n\n输入：一个表达式\n\n> 如： img "手工图片位置" + weblink "网络位置" img "儿童图片" + phone "123456789"\n\n输出： 对应的表达式，所表达的含义。\n\n这些其实是只需要两步： 1、拆解表达式，中缀表达式 改为 后缀表达式 2、压栈求值\n\n这是数据结构相关的知识，这里就不详细说明。\n\n\n# 感悟\n\n解释器模式，其实是用代码实现了一个简版的 “语言”； 以解决发生频率很高，但规则可明细的场景。\n\n一般来说我们不太可能使用解释器模式，笔者目前为止，还没没有在项目中切实的需要过它。\n\n优点：\n\n良好的扩展性，可以不断定义新的表达式来实现新的业务。\n\n缺点：\n\n容易引起类膨胀，需要较强的类管理能力。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"中介者模式",frontmatter:{title:"中介者模式",date:"2022-09-02T21:26:14.000Z",permalink:"/pages/37df0f/",categories:["设计模式"],tags:["中介者模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/21.中介者模式.md",key:"v-7b8e7334",path:"/pages/37df0f/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:200},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:269},{level:3,title:"接口类",slug:"接口类",normalizedTitle:"接口类",charIndex:278},{level:3,title:"接口实现",slug:"接口实现",normalizedTitle:"接口实现",charIndex:910},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:2396},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:2842},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:2910}],excerpt:'<p>经过 吃货小玉、神奇小明、善良小芳 的idea，和大家的共同努力，啃得鸡公司蒸蒸日上。 公司以吃货小玉、神奇小明、善良小芳 为主力成立了产品形象部。</p>\n<p>现在公司一共有： 生产部、技术研发部、采购部、人事部、产品形象部</p>\n<p>大家的沟通状态是这样的：</p>\n<p><img src="https://cdn.addai.cn/blog/202208312025837.png" alt="部门沟通"></p>\n<p>常常一件事需要沟通多个部门才能完成，大家又要完成当前的工作，又要推动沟通；导致工作效率极慢。</p>\n<p>现在需要解决当前的复杂沟通状态，怎么处理？</p>\n',headersStr:"场景分析 实现 接口类 接口实现 main函数 代码位置 感悟",content:'经过 吃货小玉、神奇小明、善良小芳 的idea，和大家的共同努力，啃得鸡公司蒸蒸日上。 公司以吃货小玉、神奇小明、善良小芳 为主力成立了产品形象部。\n\n现在公司一共有： 生产部、技术研发部、采购部、人事部、产品形象部\n\n大家的沟通状态是这样的：\n\n\n\n常常一件事需要沟通多个部门才能完成，大家又要完成当前的工作，又要推动沟通；导致工作效率极慢。\n\n现在需要解决当前的复杂沟通状态，怎么处理？\n\n\n# 场景分析\n\n如果要解决当前的复杂状态，需要引入一个中间人；以管理各个部分人员之间的沟通；一般在公司里以ERP系统的方式存在。\n\n\n\n\n# 实现\n\n\n\n\n# 接口类\n\n中介者：\n\nclass Mediator\n{\npublic:\n\tvirtual ~Mediator() {}\n\tvirtual void regist(Collegue* collegue) = 0;\n\tvirtual void sendMessage(string message, Collegue* collegue) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同事接口：\n\nclass Collegue\n{\npublic:\n\tCollegue()\n\t\t: m_pMediator(nullptr)\n\t{\n\t}\n\n\tvirtual ~Collegue() \n\t{\n\t\tm_pMediator = nullptr;\n\t}\n\n\tvoid setMediator(Mediator* mediator)\n\t{\n\t\tif (mediator != m_pMediator)\n\t\t\tm_pMediator = mediator;\n\t}\n\n\tvirtual void sendMessage(string message) = 0;\n\tvirtual void getMessage(string message) = 0;\n\nprotected:\n\tMediator* m_pMediator;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 接口实现\n\n中介者实现：\n\nclass ERPMediator : public Mediator\n{\npublic:\n\tvirtual void regist(Collegue* collegue) override\n\t{\n\t\tm_oCollegues.push_back(collegue);\n\t}\n\n\tvirtual void sendMessage(string message, Collegue* collegue) override\n\t{\n\t\tfor each (auto var in m_oCollegues)\n\t\t{\n\t\t\tif (var != collegue)\n\t\t\t{\n\t\t\t\tvar->getMessage(message);\n\t\t\t}\n\t\t}\n\t}\n\nprivate:\n\tlist<Collegue*> m_oCollegues;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n同事接口实现：\n\n// 生产部员工\nclass ProductionColleague : public Collegue\n{\npublic:\n\tProductionColleague(string name)\n\t\t: Collegue()\n\t{\n\n\t}\n\n\tvoid sendMessage(string message) override\n\t{\n\t\tcout << "【生产部】" << name << " 发送消息：" << endl;\n\t\tcout << message << endl;\n\t\tm_pMediator->sendMessage(message, this);\n\t}\n\n\tvoid getMessage(string message) override\n\t{\n\t\tcout << "【生产部】" << name << " 收到消息：" << endl;\n\t\tcout << message << endl;\n\t}\n\nprivate:\n\tstring name;\n};\n\n// 人事部员工\nclass PersonnelColleague : public Collegue\n{\npublic:\n\tPersonnelColleague(string name)\n\t\t: Collegue()\n\t{\n\n\t}\n\n\tvoid sendMessage(string message) override\n\t{\n\t\tcout << "【人事部】" << name << " 发送消息：" << endl;\n\t\tcout << message << endl;\n\t\tm_pMediator->sendMessage(message, this);\n\t}\n\n\tvoid getMessage(string message) override\n\t{\n\t\tcout << "【人事部】" << name << " 收到消息：" << endl;\n\t\tcout << message << endl;\n\t}\n\nprivate:\n\tstring name;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tERPMediator oERPMediator;\n\n\tPersonnelColleague oXiaoFang("小芳");\n\toXiaoFang.setMediator(&oERPMediator);\n\n\tProductionColleague oXiaoLi("小李");\n\toXiaoLi.setMediator(&oERPMediator);\n\n\toERPMediator.regist(&oXiaoLi);\n\toERPMediator.regist(&oXiaoFang);\n\n\toXiaoFang.sendMessage("中秋不放假了， 大家多加班！！！");\n\n\toXiaoLi.sendMessage("生产个妹，罢工！！！");\n\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Meditor\n\n\n# 感悟\n\n中介者模式是一个不太常用模式，主体思想是将网状关系，转变为星形关系。\n\n将网状关系的复杂性，收容到一个类中；\n\n这使得其他类变得简单，同时也有中介者类复杂化的代价。',normalizedContent:'经过 吃货小玉、神奇小明、善良小芳 的idea，和大家的共同努力，啃得鸡公司蒸蒸日上。 公司以吃货小玉、神奇小明、善良小芳 为主力成立了产品形象部。\n\n现在公司一共有： 生产部、技术研发部、采购部、人事部、产品形象部\n\n大家的沟通状态是这样的：\n\n\n\n常常一件事需要沟通多个部门才能完成，大家又要完成当前的工作，又要推动沟通；导致工作效率极慢。\n\n现在需要解决当前的复杂沟通状态，怎么处理？\n\n\n# 场景分析\n\n如果要解决当前的复杂状态，需要引入一个中间人；以管理各个部分人员之间的沟通；一般在公司里以erp系统的方式存在。\n\n\n\n\n# 实现\n\n\n\n\n# 接口类\n\n中介者：\n\nclass mediator\n{\npublic:\n\tvirtual ~mediator() {}\n\tvirtual void regist(collegue* collegue) = 0;\n\tvirtual void sendmessage(string message, collegue* collegue) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n同事接口：\n\nclass collegue\n{\npublic:\n\tcollegue()\n\t\t: m_pmediator(nullptr)\n\t{\n\t}\n\n\tvirtual ~collegue() \n\t{\n\t\tm_pmediator = nullptr;\n\t}\n\n\tvoid setmediator(mediator* mediator)\n\t{\n\t\tif (mediator != m_pmediator)\n\t\t\tm_pmediator = mediator;\n\t}\n\n\tvirtual void sendmessage(string message) = 0;\n\tvirtual void getmessage(string message) = 0;\n\nprotected:\n\tmediator* m_pmediator;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 接口实现\n\n中介者实现：\n\nclass erpmediator : public mediator\n{\npublic:\n\tvirtual void regist(collegue* collegue) override\n\t{\n\t\tm_ocollegues.push_back(collegue);\n\t}\n\n\tvirtual void sendmessage(string message, collegue* collegue) override\n\t{\n\t\tfor each (auto var in m_ocollegues)\n\t\t{\n\t\t\tif (var != collegue)\n\t\t\t{\n\t\t\t\tvar->getmessage(message);\n\t\t\t}\n\t\t}\n\t}\n\nprivate:\n\tlist<collegue*> m_ocollegues;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n同事接口实现：\n\n// 生产部员工\nclass productioncolleague : public collegue\n{\npublic:\n\tproductioncolleague(string name)\n\t\t: collegue()\n\t{\n\n\t}\n\n\tvoid sendmessage(string message) override\n\t{\n\t\tcout << "【生产部】" << name << " 发送消息：" << endl;\n\t\tcout << message << endl;\n\t\tm_pmediator->sendmessage(message, this);\n\t}\n\n\tvoid getmessage(string message) override\n\t{\n\t\tcout << "【生产部】" << name << " 收到消息：" << endl;\n\t\tcout << message << endl;\n\t}\n\nprivate:\n\tstring name;\n};\n\n// 人事部员工\nclass personnelcolleague : public collegue\n{\npublic:\n\tpersonnelcolleague(string name)\n\t\t: collegue()\n\t{\n\n\t}\n\n\tvoid sendmessage(string message) override\n\t{\n\t\tcout << "【人事部】" << name << " 发送消息：" << endl;\n\t\tcout << message << endl;\n\t\tm_pmediator->sendmessage(message, this);\n\t}\n\n\tvoid getmessage(string message) override\n\t{\n\t\tcout << "【人事部】" << name << " 收到消息：" << endl;\n\t\tcout << message << endl;\n\t}\n\nprivate:\n\tstring name;\n};\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\terpmediator oerpmediator;\n\n\tpersonnelcolleague oxiaofang("小芳");\n\toxiaofang.setmediator(&oerpmediator);\n\n\tproductioncolleague oxiaoli("小李");\n\toxiaoli.setmediator(&oerpmediator);\n\n\toerpmediator.regist(&oxiaoli);\n\toerpmediator.regist(&oxiaofang);\n\n\toxiaofang.sendmessage("中秋不放假了， 大家多加班！！！");\n\n\toxiaoli.sendmessage("生产个妹，罢工！！！");\n\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n结果：\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/meditor\n\n\n# 感悟\n\n中介者模式是一个不太常用模式，主体思想是将网状关系，转变为星形关系。\n\n将网状关系的复杂性，收容到一个类中；\n\n这使得其他类变得简单，同时也有中介者类复杂化的代价。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"观察者模式",frontmatter:{title:"观察者模式",date:"2022-09-05T21:26:35.000Z",permalink:"/pages/7cdad8/",categories:["设计模式"],tags:["观察者模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/22.观察者模式.md",key:"v-009cee4b",path:"/pages/7cdad8/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:94},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:242},{level:3,title:"接口类",slug:"接口类",normalizedTitle:"接口类",charIndex:251},{level:3,title:"实现类",slug:"实现类",normalizedTitle:"实现类",charIndex:713},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:1320},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1584},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:1653}],excerpt:"<p>上篇通过EAP（中介者），完成了各部门间的沟通混乱的问题。\n有些部门的工作情况需要有别的部门的工作结果觉得。\n事例：\n公司希望做0库存挤压，这时需要生产部门可以随时响应销售情况。</p>\n",headersStr:"场景分析 实现 接口类 实现类 main函数 代码位置 感悟",content:'上篇通过EAP（中介者），完成了各部门间的沟通混乱的问题。 有些部门的工作情况需要有别的部门的工作结果觉得。 事例： 公司希望做0库存挤压，这时需要生产部门可以随时响应销售情况。\n\n\n# 场景分析\n\n这里的场景是 生产部门对 销售部门的随时响应，不不是销售部门有什么事就可以指派生产部门。\n\n而是说明，在某一个生产部门需要的关注的点上要及时的通知生产部门，以便生产部门可以及时的做出调整。\n\n这里的提示是针对销售的业务做的提示； 生产部门的响应也是基于生产的业务上做出调整。\n\n\n# 实现\n\n\n\n\n# 接口类\n\n观察者接口：\n\nclass AddObServer\n{\npublic:\n\t~AddObServer() {}\n\n\tvirtual void doAdd(int number) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n观察者管理类接口：\n\nclass Subject\n{\npublic:\n\tSubject() {}\n\t~Subject() {}\n\t\n\tvoid addObServer(AddObServer* observer)\n\t{\n\t\tm_oAddObServer.push_back(observer);\n\t}\n\n\tvoid removeObServer(AddObServer* observer)\n\t{\n\t\tm_oAddObServer.remove(observer);\n\t}\n\nprotected:\n\tlist<AddObServer*> m_oAddObServer;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 实现类\n\n观察者接口实现：\n\nclass MarketingDepartment : public Subject\n{\npublic:\n\tMarketingDepartment()\n\t\t: Subject() {}\n\n\t~ MarketingDepartment() {}\n\n\tvoid sell(int number)\n\t{\n\t\tcout << "市场部买了 " << number << " 根冰棍！" << endl;\n\t\tfor (auto var : m_oAddObServer)\n\t\t{\n\t\t\tvar->doAdd(number);\n\t\t}\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n观察者管理类接口实现：\n\nclass ProductDepartment : public AddObServer\n{\npublic:\n\tProductDepartment()\n\t\t: AddObServer() {}\n\n\t~ProductDepartment() {}\n\n\tvirtual void doAdd(int number) override\n\t{\n\t\tcout << "生产部门：准备生产 " << number << " 根冰棍。" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tMarketingDepartment oMarketingDepartment;\n\tProductDepartment oProductDepartment;\n\n\toMarketingDepartment.addObServer(&oProductDepartment);\n\n\toMarketingDepartment.sell(2);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n运行结果：\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Observer\n\n\n# 感悟\n\n观察者模式是一个常见的设计模式。\n\n优点： 1、建立了触发机制，为了解决一些响应式的业务流。\n\n2、调用者和被调用者进行了抽象解耦，调用者将不知情自己将调用什么。\n\n当有业务需要用【每当...... 就.....】 描述时，可以考虑使用观察者模式。\n\n如果不希望调用者被阻塞，可以才有异步模式执行触发器。\n\n局限： 1、需要避免循环调用 观察者模式也是一个需要谨慎使用的模式，由于观察者模式的响应式触发；导致难以在代码中追查到完整的业务流。\n\n试想如果一个业务完全有触发器堆砌的程序，整个程序的业务就处于：A触发B，B触发C，C触发...的链式触发中。 当多个业务链有交叉时，如何让复杂业务不做循环调用这种简单要求也会变成世纪难题。\n\n2、一个事件上挂的触发器太多，可能导致原来代码的效率下降。\n\n3、观察者无法知道需要观察对象的状态，需要提供额外的能力实现。',normalizedContent:'上篇通过eap（中介者），完成了各部门间的沟通混乱的问题。 有些部门的工作情况需要有别的部门的工作结果觉得。 事例： 公司希望做0库存挤压，这时需要生产部门可以随时响应销售情况。\n\n\n# 场景分析\n\n这里的场景是 生产部门对 销售部门的随时响应，不不是销售部门有什么事就可以指派生产部门。\n\n而是说明，在某一个生产部门需要的关注的点上要及时的通知生产部门，以便生产部门可以及时的做出调整。\n\n这里的提示是针对销售的业务做的提示； 生产部门的响应也是基于生产的业务上做出调整。\n\n\n# 实现\n\n\n\n\n# 接口类\n\n观察者接口：\n\nclass addobserver\n{\npublic:\n\t~addobserver() {}\n\n\tvirtual void doadd(int number) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n观察者管理类接口：\n\nclass subject\n{\npublic:\n\tsubject() {}\n\t~subject() {}\n\t\n\tvoid addobserver(addobserver* observer)\n\t{\n\t\tm_oaddobserver.push_back(observer);\n\t}\n\n\tvoid removeobserver(addobserver* observer)\n\t{\n\t\tm_oaddobserver.remove(observer);\n\t}\n\nprotected:\n\tlist<addobserver*> m_oaddobserver;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 实现类\n\n观察者接口实现：\n\nclass marketingdepartment : public subject\n{\npublic:\n\tmarketingdepartment()\n\t\t: subject() {}\n\n\t~ marketingdepartment() {}\n\n\tvoid sell(int number)\n\t{\n\t\tcout << "市场部买了 " << number << " 根冰棍！" << endl;\n\t\tfor (auto var : m_oaddobserver)\n\t\t{\n\t\t\tvar->doadd(number);\n\t\t}\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n观察者管理类接口实现：\n\nclass productdepartment : public addobserver\n{\npublic:\n\tproductdepartment()\n\t\t: addobserver() {}\n\n\t~productdepartment() {}\n\n\tvirtual void doadd(int number) override\n\t{\n\t\tcout << "生产部门：准备生产 " << number << " 根冰棍。" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tmarketingdepartment omarketingdepartment;\n\tproductdepartment oproductdepartment;\n\n\tomarketingdepartment.addobserver(&oproductdepartment);\n\n\tomarketingdepartment.sell(2);\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n运行结果：\n\n\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/observer\n\n\n# 感悟\n\n观察者模式是一个常见的设计模式。\n\n优点： 1、建立了触发机制，为了解决一些响应式的业务流。\n\n2、调用者和被调用者进行了抽象解耦，调用者将不知情自己将调用什么。\n\n当有业务需要用【每当...... 就.....】 描述时，可以考虑使用观察者模式。\n\n如果不希望调用者被阻塞，可以才有异步模式执行触发器。\n\n局限： 1、需要避免循环调用 观察者模式也是一个需要谨慎使用的模式，由于观察者模式的响应式触发；导致难以在代码中追查到完整的业务流。\n\n试想如果一个业务完全有触发器堆砌的程序，整个程序的业务就处于：a触发b，b触发c，c触发...的链式触发中。 当多个业务链有交叉时，如何让复杂业务不做循环调用这种简单要求也会变成世纪难题。\n\n2、一个事件上挂的触发器太多，可能导致原来代码的效率下降。\n\n3、观察者无法知道需要观察对象的状态，需要提供额外的能力实现。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"状态模式",frontmatter:{title:"状态模式",date:"2022-09-14T21:27:22.000Z",permalink:"/pages/d841b1/",categories:["设计模式"],tags:["状态模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/23.状态模式.md",key:"v-7614b482",path:"/pages/d841b1/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:119},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:299},{level:3,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:308},{level:3,title:"上下文",slug:"上下文",normalizedTitle:"上下文",charIndex:411},{level:3,title:"接口实现",slug:"接口实现",normalizedTitle:"接口实现",charIndex:938},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:1400},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1791},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:1857}],excerpt:"<p>春去秋来，岁月如梭，又过了几天；随着市场变化，啃得鸡公司准备研发一款跨时代的产品：盒装冰淇淋。并且决定随着时间变化不断推出新的产品，已持续维持市场竞争力。</p>\n<p>鉴于之前的自动化流水线已经产能过剩，希望可以利用过剩产能；以减少投入。</p>\n",headersStr:"场景分析 实现 接口 上下文 接口实现 main函数 代码位置 感悟",content:'春去秋来，岁月如梭，又过了几天；随着市场变化，啃得鸡公司准备研发一款跨时代的产品：盒装冰淇淋。并且决定随着时间变化不断推出新的产品，已持续维持市场竞争力。\n\n鉴于之前的自动化流水线已经产能过剩，希望可以利用过剩产能；以减少投入。\n\n\n# 场景分析\n\n这里做一个思考：冰淇淋流水线在做冰棍或是盒装冰淇淋时，只需要在需要在组装打包环节使用不同的方式。\n\n这时我们可以建不同的两个打包组装模块： 冰棍打包模块、盒装冰淇淋打包模块\n\n这两个模块都对流水线中的半成品进行打包组装，并传递给下一个模块。\n\n流水线可以通过动态的切换不同的模块完成不同的生产任务，而不用停止整个生产线，已做生产状态调整。\n\n\n# 实现\n\n\n\n\n# 接口\n\nclass State\n{\npublic:\n\tvirtual ~State() {}\n\n\tvirtual void doPackage() = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 上下文\n\nclass ProductContext\n{\npublic:\n\tProductContext()\n\t\t: m_pState(nullptr)\n\t{\n\t}\n\n\t~ProductContext()\n\t{\n\t\tm_pState = nullptr;\n\t}\n\n\tvoid setState(State* state)\n\t{\n\t\tif (m_pState != state)\n\t\t\tm_pState = state;\n\t}\n\n\tvoid doProduct()\n\t{\n\t\tif (nullptr == m_pState)\n\t\t{\n\t\t\tcout << "请设置生成状态!" << endl;\n\t\t\treturn;\n\t\t}\n\t\tcout << "温度维持系统启动：" << endl;\n\t\tcout << "原料进入...." << endl;\n\t\tm_pState->doPackage();\n\t}\nprivate:\n\tState* m_pState;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 接口实现\n\nclass IceCreamState : public State\n{\npublic:\n\tIceCreamState()\n\t\t: State()\n\t{}\n\n\tvirtual ~IceCreamState() {}\n\n\tvirtual void doPackage() override\n\t{\n\t\tcout << "包装为 普通冰淇淋！" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nclass BoxIceCreamState : public State\n{\npublic:\n\tBoxIceCreamState()\n\t\t: State()\n\t{}\n\n\tvirtual ~BoxIceCreamState() {}\n\n\tvirtual void doPackage() override\n\t{\n\t\tcout << "包装为 普通冰淇淋！" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tProductContext oProductContext;\n\toProductContext.doProduct();\n\n\tBoxIceCreamState oBoxIceCreamState;\n\toProductContext.setState(&oBoxIceCreamState);\n\toProductContext.doProduct();\n\n\tIceCreamState oIceCreamState;\n\toProductContext.setState(&oIceCreamState);\n\toProductContext.doProduct();\n\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/State\n\n\n# 感悟\n\n状态模式是解决：当对象的行为随着对象的属性变化而变化的情况，采用的方式是将不同的行为进行封装。\n\n什么时候需要状态模式： 当面类中代码中存在大量if判断，并且if判断的业务条件相同。\n\n优点： 1、将于特定的条件相关的代码集中到一个类里面，有力的减少了if判断；且利用对一个业务统一修改。\n\n2、无需修改上下文即可引入新的状态。\n\n缺点：\n\n1、状态模式需要上下文环境类有良好的设计，对设计要求较高。',normalizedContent:'春去秋来，岁月如梭，又过了几天；随着市场变化，啃得鸡公司准备研发一款跨时代的产品：盒装冰淇淋。并且决定随着时间变化不断推出新的产品，已持续维持市场竞争力。\n\n鉴于之前的自动化流水线已经产能过剩，希望可以利用过剩产能；以减少投入。\n\n\n# 场景分析\n\n这里做一个思考：冰淇淋流水线在做冰棍或是盒装冰淇淋时，只需要在需要在组装打包环节使用不同的方式。\n\n这时我们可以建不同的两个打包组装模块： 冰棍打包模块、盒装冰淇淋打包模块\n\n这两个模块都对流水线中的半成品进行打包组装，并传递给下一个模块。\n\n流水线可以通过动态的切换不同的模块完成不同的生产任务，而不用停止整个生产线，已做生产状态调整。\n\n\n# 实现\n\n\n\n\n# 接口\n\nclass state\n{\npublic:\n\tvirtual ~state() {}\n\n\tvirtual void dopackage() = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 上下文\n\nclass productcontext\n{\npublic:\n\tproductcontext()\n\t\t: m_pstate(nullptr)\n\t{\n\t}\n\n\t~productcontext()\n\t{\n\t\tm_pstate = nullptr;\n\t}\n\n\tvoid setstate(state* state)\n\t{\n\t\tif (m_pstate != state)\n\t\t\tm_pstate = state;\n\t}\n\n\tvoid doproduct()\n\t{\n\t\tif (nullptr == m_pstate)\n\t\t{\n\t\t\tcout << "请设置生成状态!" << endl;\n\t\t\treturn;\n\t\t}\n\t\tcout << "温度维持系统启动：" << endl;\n\t\tcout << "原料进入...." << endl;\n\t\tm_pstate->dopackage();\n\t}\nprivate:\n\tstate* m_pstate;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 接口实现\n\nclass icecreamstate : public state\n{\npublic:\n\ticecreamstate()\n\t\t: state()\n\t{}\n\n\tvirtual ~icecreamstate() {}\n\n\tvirtual void dopackage() override\n\t{\n\t\tcout << "包装为 普通冰淇淋！" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nclass boxicecreamstate : public state\n{\npublic:\n\tboxicecreamstate()\n\t\t: state()\n\t{}\n\n\tvirtual ~boxicecreamstate() {}\n\n\tvirtual void dopackage() override\n\t{\n\t\tcout << "包装为 普通冰淇淋！" << endl;\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# main函数\n\nint main(int argc, char* argv[])\n{\n\tproductcontext oproductcontext;\n\toproductcontext.doproduct();\n\n\tboxicecreamstate oboxicecreamstate;\n\toproductcontext.setstate(&oboxicecreamstate);\n\toproductcontext.doproduct();\n\n\ticecreamstate oicecreamstate;\n\toproductcontext.setstate(&oicecreamstate);\n\toproductcontext.doproduct();\n\n\treturn 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/state\n\n\n# 感悟\n\n状态模式是解决：当对象的行为随着对象的属性变化而变化的情况，采用的方式是将不同的行为进行封装。\n\n什么时候需要状态模式： 当面类中代码中存在大量if判断，并且if判断的业务条件相同。\n\n优点： 1、将于特定的条件相关的代码集中到一个类里面，有力的减少了if判断；且利用对一个业务统一修改。\n\n2、无需修改上下文即可引入新的状态。\n\n缺点：\n\n1、状态模式需要上下文环境类有良好的设计，对设计要求较高。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"建造者模式",frontmatter:{title:"建造者模式",date:"2022-09-14T21:27:22.000Z",permalink:"/pages/d741b1/",categories:["设计模式"],tags:["建造者模式"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/24.建造者模式.md",key:"v-0d84c87d",path:"/pages/d741b1/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:240},{level:2,title:"标准实现",slug:"标准实现",normalizedTitle:"标准实现",charIndex:324},{level:3,title:"需要生产的产品",slug:"需要生产的产品",normalizedTitle:"需要生产的产品",charIndex:335},{level:3,title:"接口类",slug:"接口类",normalizedTitle:"接口类",charIndex:1308},{level:3,title:"实现类",slug:"实现类",normalizedTitle:"实现类",charIndex:1810},{level:3,title:"指挥者",slug:"指挥者",normalizedTitle:"指挥者",charIndex:2143},{level:3,title:"main函数",slug:"main函数",normalizedTitle:"main函数",charIndex:2429},{level:2,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:2703},{level:2,title:"感悟",slug:"感悟",normalizedTitle:"感悟",charIndex:2771},{level:3,title:"简化建造者实现类",slug:"简化建造者实现类",normalizedTitle:"简化建造者实现类",charIndex:2984},{level:3,title:"简化建造者main函数",slug:"简化建造者main函数",normalizedTitle:"简化建造者main函数",charIndex:4817}],excerpt:"<p>随着盒装冰淇淋越来越好卖，啃得鸡的信心越来越高。老板要得做一个大号的盒装冰淇淋 --&gt; 冰淇淋蛋糕。</p>\n<p>领导一句话，生产部门跑断腿。</p>\n<p>分析发现：</p>\n<blockquote>\n<p>冰淇淋蛋糕的组成有</p>\n<p>必选项：蛋糕坯层、冰淇淋层</p>\n<p>可选项：水果装饰、巧克力碎装饰、冰淇淋裱花装饰</p>\n</blockquote>\n<p>产品部准备生产的产品有：【草莓 冰淇淋裱花蛋糕】、【抹茶 巧克力碎蛋糕】</p>\n<p>原本的冰淇淋生产线完全不能适应，需要新的生产线。</p>\n<p>老板觉得啃得鸡商标的溢价肯定能赚的盆满钵满；于是不经同意，还不计投入。</p>\n",headersStr:"场景分析 标准实现 需要生产的产品 接口类 实现类 指挥者 main函数 代码位置 感悟 简化建造者实现类 简化建造者main函数",content:'随着盒装冰淇淋越来越好卖，啃得鸡的信心越来越高。老板要得做一个大号的盒装冰淇淋 --\x3e 冰淇淋蛋糕。\n\n领导一句话，生产部门跑断腿。\n\n分析发现：\n\n> 冰淇淋蛋糕的组成有\n> \n> 必选项：蛋糕坯层、冰淇淋层\n> \n> 可选项：水果装饰、巧克力碎装饰、冰淇淋裱花装饰\n\n产品部准备生产的产品有：【草莓 冰淇淋裱花蛋糕】、【抹茶 巧克力碎蛋糕】\n\n原本的冰淇淋生产线完全不能适应，需要新的生产线。\n\n老板觉得啃得鸡商标的溢价肯定能赚的盆满钵满；于是不经同意，还不计投入。\n\n\n# 场景分析\n\n这里不同于之前的冰棍模式在于，这里的产品的工艺是繁琐的。\n\n这里代码重点要维护的复杂度，是产品的生产过程；而产品的结果都是冰淇淋蛋糕这个单一概念。\n\n\n# 标准实现\n\n\n\n\n# 需要生产的产品\n\nclass IceCreamCake\n{\npublic:\n\tIceCreamCake(string cakeBillet, string IceCream)\n\t\t: m_cakeBillet(cakeBillet), m_IceCream(IceCream)\n\t\t, m_fruit(""), m_chocolate(""), m_decoration("")\n\t{\n\t}\n\t~IceCreamCake() {}\n\n\tvoid taste()\n\t{\n\t\tif (m_fruit != "")\n\t\t\tcout << m_fruit << "的 ";\n\t\tif (m_chocolate != "")\n\t\t\tcout << m_chocolate << "的 ";\n\t\tif (m_decoration != "")\n\t\t\tcout << m_decoration << "的 ";\n\t\tcout << m_cakeBillet << "的 " << m_IceCream << "的 " << "蛋糕";\n\t}\n\n\tvoid setFruit(string fruit)\n\t{\n\t\tm_fruit = fruit;\n\t}\n\n\tvoid setChocolate(string chocolate)\n\t{\n\t\tm_chocolate = chocolate;\n\t}\n\n\tvoid setDecoration(string decoration)\n\t{\n\t\tm_decoration = decoration;\n\t}\n\nprivate:\n\tstring m_cakeBillet;// 必选项： 蛋糕坯层\n\tstring m_IceCream;\t// 必选项： 冰淇淋层\n\tstring m_fruit;\t\t// 可选项：水果装饰\n\tstring m_chocolate;\t// 可选项：巧克力碎装饰\n\tstring m_decoration;// 可选项：冰淇淋裱花装饰\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 接口类\n\nclass Builder\n{\npublic:\n\tBuilder(string cakeBillet, string IceCream)\n\t\t: m_pIceCreamCake(new IceCreamCake(cakeBillet, IceCream))\n\t{\n\t}\n\n\tvirtual ~Builder() \n\t{\n\t\tdelete m_pIceCreamCake;\n\t\tm_pIceCreamCake = nullptr;\n\t}\n\n\tIceCreamCake* getProduct()\n\t{\n\t\treturn m_pIceCreamCake;\n\t}\n\n\tvirtual void setFruit() {}\n\tvirtual void setChocolate() {}\n\tvirtual void setDecoration() {}\n\t\nprotected:\n\tIceCreamCake* m_pIceCreamCake;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 实现类\n\nclass ChocolateCakeBuilder : public Builder\n{\npublic:\n\tChocolateCakeBuilder(string cakeBillet, string IceCream)\n\t\t: Builder(cakeBillet, IceCream)\n\t{\n\t}\n\n\tvirtual ~ChocolateCakeBuilder()\n\t{\n\t}\n\n\tvirtual void setChocolate()override\n\t{\n\t\tm_pIceCreamCake->setChocolate("巧克力");\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 指挥者\n\nclass Director\n{\npublic:\n\tDirector(Builder *builder)\n\t\t: m_pBuilder(builder)\n\t{\n\t}\n\n\tvoid makeCake()\n\t{\n\t\tm_pBuilder->setFruit();\n\t\tm_pBuilder->setChocolate();\n\t\tm_pBuilder->setDecoration();\n\t}\n\nprivate:\n\tBuilder* m_pBuilder;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# main函数\n\nint main(int argc, char *argv[])\n{\n    ChocolateCakeBuilder oBuilder("可可蛋糕坯", "奶油冰淇淋");\n    Director oDirector(&oBuilder);\n    oDirector.makeCake();\n    IceCreamCake *pCake = oBuilder.getProduct();\n    pCake->taste();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/Builder\n\n\n# 感悟\n\n作用： 建造者是为了将对应的构造和对象的使用分离；\n\n主要应对复杂的创建场景，如 参数不固定，参数见相互影响 等。\n\n条件定义： 一般当一个类的构成超过4个参数，且部分参数可有可无时，就认为这个类的构造已经足够复杂；可以考虑使用建造者模式，来代替多个构造函数的定义。\n\n问题： 有时，我们只有一个类的构造十分复杂；使用建造者模式就导致类膨胀的厉害。\n\n这时我们可以考虑使用 局部类，来实现 简化的建造者模式。\n\n\n# 简化建造者实现类\n\nclass IceCreamCake\n{\npublic:\n\tclass Builder\n\t{\n\tpublic:\n\t\tBuilder(string cakeBillet, string IceCream)\n\t\t\t: m_cakeBillet(cakeBillet), m_IceCream(IceCream) , m_fruit(""), m_chocolate(""), m_decoration("")\n\t\t{}\n\t\t~Builder() {}\n\n\t\tBuilder& setFruit(string fruit)\n\t\t{\n\t\t\tthis->m_fruit = fruit;\n\t\t\treturn *this;\n\t\t}\n\n\t\tBuilder& setChocolate(string chocolate)\n\t\t{\n\t\t\tthis->m_chocolate = chocolate;\n\t\t\treturn *this;\n\t\t}\n\n\t\tBuilder& setDecoration(string decoration)\n\t\t{\n\t\t\tthis->m_decoration = decoration;\n\t\t\treturn *this;\n\t\t}\n\n\t\tIceCreamCake* builer()\n\t\t{\n\t\t\treturn new IceCreamCake(this);\n\t\t}\n\n\tprivate:\n\t\tstring m_cakeBillet;// 必选项： 蛋糕坯层\n\t\tstring m_IceCream;\t// 必选项： 冰淇淋层\n\t\tstring m_fruit;\t\t// 可选项：水果装饰\n\t\tstring m_chocolate;\t// 可选项：巧克力碎装饰\n\t\tstring m_decoration;// 可选项：冰淇淋裱花装饰\n\t\tfriend class IceCreamCake;\n\t};\npublic:\n\t~IceCreamCake() {}\n\n\tvoid taste()\n\t{\n\t\tif (m_fruit != "")\n\t\t\tcout << m_fruit << "的 ";\n\t\tif (m_chocolate != "")\n\t\t\tcout << m_chocolate << "的 ";\n\t\tif (m_decoration != "")\n\t\t\tcout << m_decoration << "的 ";\n\t\tcout << m_cakeBillet << "的 " << m_IceCream << "的 " << "蛋糕";\n\t}\nprivate:\n\tIceCreamCake(Builder* builder)\n\t\t: m_cakeBillet(""), m_IceCream(""), m_fruit(""), m_chocolate(""), m_decoration("")\n\t{\n\t\tthis->m_cakeBillet = builder->m_cakeBillet;\n\t\tthis->m_IceCream = builder->m_IceCream;\n\t\tthis->m_fruit = builder->m_fruit;\n\t\tthis->m_chocolate = builder->m_chocolate;\n\t\tthis->m_decoration = builder->m_decoration;\n\t}\n\nprivate:\n\tstring m_cakeBillet;// 必选项： 蛋糕坯层\n\tstring m_IceCream;\t// 必选项： 冰淇淋层\n\tstring m_fruit;\t\t// 可选项：水果装饰\n\tstring m_chocolate;\t// 可选项：巧克力碎装饰\n\tstring m_decoration;// 可选项：冰淇淋裱花装饰\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n\n# 简化建造者main函数\n\nint main(int argc, char *argv[])\n{\n    IceCreamCake* pIceCreamCake = IceCreamCake::Builder("可可蛋糕坯", "奶油冰淇淋")\n        .setChocolate("巧克力")\n        .builer();\n    pIceCreamCake->taste();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n运行结果：\n\n这里我们简化了，指挥者 和 接口类； 同时使用 局部类的方式，将建筑者类至于产品类内部。这样有效的减少了类的膨胀。',normalizedContent:'随着盒装冰淇淋越来越好卖，啃得鸡的信心越来越高。老板要得做一个大号的盒装冰淇淋 --\x3e 冰淇淋蛋糕。\n\n领导一句话，生产部门跑断腿。\n\n分析发现：\n\n> 冰淇淋蛋糕的组成有\n> \n> 必选项：蛋糕坯层、冰淇淋层\n> \n> 可选项：水果装饰、巧克力碎装饰、冰淇淋裱花装饰\n\n产品部准备生产的产品有：【草莓 冰淇淋裱花蛋糕】、【抹茶 巧克力碎蛋糕】\n\n原本的冰淇淋生产线完全不能适应，需要新的生产线。\n\n老板觉得啃得鸡商标的溢价肯定能赚的盆满钵满；于是不经同意，还不计投入。\n\n\n# 场景分析\n\n这里不同于之前的冰棍模式在于，这里的产品的工艺是繁琐的。\n\n这里代码重点要维护的复杂度，是产品的生产过程；而产品的结果都是冰淇淋蛋糕这个单一概念。\n\n\n# 标准实现\n\n\n\n\n# 需要生产的产品\n\nclass icecreamcake\n{\npublic:\n\ticecreamcake(string cakebillet, string icecream)\n\t\t: m_cakebillet(cakebillet), m_icecream(icecream)\n\t\t, m_fruit(""), m_chocolate(""), m_decoration("")\n\t{\n\t}\n\t~icecreamcake() {}\n\n\tvoid taste()\n\t{\n\t\tif (m_fruit != "")\n\t\t\tcout << m_fruit << "的 ";\n\t\tif (m_chocolate != "")\n\t\t\tcout << m_chocolate << "的 ";\n\t\tif (m_decoration != "")\n\t\t\tcout << m_decoration << "的 ";\n\t\tcout << m_cakebillet << "的 " << m_icecream << "的 " << "蛋糕";\n\t}\n\n\tvoid setfruit(string fruit)\n\t{\n\t\tm_fruit = fruit;\n\t}\n\n\tvoid setchocolate(string chocolate)\n\t{\n\t\tm_chocolate = chocolate;\n\t}\n\n\tvoid setdecoration(string decoration)\n\t{\n\t\tm_decoration = decoration;\n\t}\n\nprivate:\n\tstring m_cakebillet;// 必选项： 蛋糕坯层\n\tstring m_icecream;\t// 必选项： 冰淇淋层\n\tstring m_fruit;\t\t// 可选项：水果装饰\n\tstring m_chocolate;\t// 可选项：巧克力碎装饰\n\tstring m_decoration;// 可选项：冰淇淋裱花装饰\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 接口类\n\nclass builder\n{\npublic:\n\tbuilder(string cakebillet, string icecream)\n\t\t: m_picecreamcake(new icecreamcake(cakebillet, icecream))\n\t{\n\t}\n\n\tvirtual ~builder() \n\t{\n\t\tdelete m_picecreamcake;\n\t\tm_picecreamcake = nullptr;\n\t}\n\n\ticecreamcake* getproduct()\n\t{\n\t\treturn m_picecreamcake;\n\t}\n\n\tvirtual void setfruit() {}\n\tvirtual void setchocolate() {}\n\tvirtual void setdecoration() {}\n\t\nprotected:\n\ticecreamcake* m_picecreamcake;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 实现类\n\nclass chocolatecakebuilder : public builder\n{\npublic:\n\tchocolatecakebuilder(string cakebillet, string icecream)\n\t\t: builder(cakebillet, icecream)\n\t{\n\t}\n\n\tvirtual ~chocolatecakebuilder()\n\t{\n\t}\n\n\tvirtual void setchocolate()override\n\t{\n\t\tm_picecreamcake->setchocolate("巧克力");\n\t}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 指挥者\n\nclass director\n{\npublic:\n\tdirector(builder *builder)\n\t\t: m_pbuilder(builder)\n\t{\n\t}\n\n\tvoid makecake()\n\t{\n\t\tm_pbuilder->setfruit();\n\t\tm_pbuilder->setchocolate();\n\t\tm_pbuilder->setdecoration();\n\t}\n\nprivate:\n\tbuilder* m_pbuilder;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# main函数\n\nint main(int argc, char *argv[])\n{\n    chocolatecakebuilder obuilder("可可蛋糕坯", "奶油冰淇淋");\n    director odirector(&obuilder);\n    odirector.makecake();\n    icecreamcake *pcake = obuilder.getproduct();\n    pcake->taste();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n运行结果：\n\n\n# 代码位置\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：设计模式/builder\n\n\n# 感悟\n\n作用： 建造者是为了将对应的构造和对象的使用分离；\n\n主要应对复杂的创建场景，如 参数不固定，参数见相互影响 等。\n\n条件定义： 一般当一个类的构成超过4个参数，且部分参数可有可无时，就认为这个类的构造已经足够复杂；可以考虑使用建造者模式，来代替多个构造函数的定义。\n\n问题： 有时，我们只有一个类的构造十分复杂；使用建造者模式就导致类膨胀的厉害。\n\n这时我们可以考虑使用 局部类，来实现 简化的建造者模式。\n\n\n# 简化建造者实现类\n\nclass icecreamcake\n{\npublic:\n\tclass builder\n\t{\n\tpublic:\n\t\tbuilder(string cakebillet, string icecream)\n\t\t\t: m_cakebillet(cakebillet), m_icecream(icecream) , m_fruit(""), m_chocolate(""), m_decoration("")\n\t\t{}\n\t\t~builder() {}\n\n\t\tbuilder& setfruit(string fruit)\n\t\t{\n\t\t\tthis->m_fruit = fruit;\n\t\t\treturn *this;\n\t\t}\n\n\t\tbuilder& setchocolate(string chocolate)\n\t\t{\n\t\t\tthis->m_chocolate = chocolate;\n\t\t\treturn *this;\n\t\t}\n\n\t\tbuilder& setdecoration(string decoration)\n\t\t{\n\t\t\tthis->m_decoration = decoration;\n\t\t\treturn *this;\n\t\t}\n\n\t\ticecreamcake* builer()\n\t\t{\n\t\t\treturn new icecreamcake(this);\n\t\t}\n\n\tprivate:\n\t\tstring m_cakebillet;// 必选项： 蛋糕坯层\n\t\tstring m_icecream;\t// 必选项： 冰淇淋层\n\t\tstring m_fruit;\t\t// 可选项：水果装饰\n\t\tstring m_chocolate;\t// 可选项：巧克力碎装饰\n\t\tstring m_decoration;// 可选项：冰淇淋裱花装饰\n\t\tfriend class icecreamcake;\n\t};\npublic:\n\t~icecreamcake() {}\n\n\tvoid taste()\n\t{\n\t\tif (m_fruit != "")\n\t\t\tcout << m_fruit << "的 ";\n\t\tif (m_chocolate != "")\n\t\t\tcout << m_chocolate << "的 ";\n\t\tif (m_decoration != "")\n\t\t\tcout << m_decoration << "的 ";\n\t\tcout << m_cakebillet << "的 " << m_icecream << "的 " << "蛋糕";\n\t}\nprivate:\n\ticecreamcake(builder* builder)\n\t\t: m_cakebillet(""), m_icecream(""), m_fruit(""), m_chocolate(""), m_decoration("")\n\t{\n\t\tthis->m_cakebillet = builder->m_cakebillet;\n\t\tthis->m_icecream = builder->m_icecream;\n\t\tthis->m_fruit = builder->m_fruit;\n\t\tthis->m_chocolate = builder->m_chocolate;\n\t\tthis->m_decoration = builder->m_decoration;\n\t}\n\nprivate:\n\tstring m_cakebillet;// 必选项： 蛋糕坯层\n\tstring m_icecream;\t// 必选项： 冰淇淋层\n\tstring m_fruit;\t\t// 可选项：水果装饰\n\tstring m_chocolate;\t// 可选项：巧克力碎装饰\n\tstring m_decoration;// 可选项：冰淇淋裱花装饰\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n\n# 简化建造者main函数\n\nint main(int argc, char *argv[])\n{\n    icecreamcake* picecreamcake = icecreamcake::builder("可可蛋糕坯", "奶油冰淇淋")\n        .setchocolate("巧克力")\n        .builer();\n    picecreamcake->taste();\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n运行结果：\n\n这里我们简化了，指挥者 和 接口类； 同时使用 局部类的方式，将建筑者类至于产品类内部。这样有效的减少了类的膨胀。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"设计模式整体回顾",frontmatter:{title:"设计模式整体回顾",date:"2022-09-22T21:27:22.000Z",permalink:"/pages/d731b1/",categories:["设计模式"],tags:["设计模式","总结"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9B%9E%E9%A1%BE.html",relativePath:"软件设计--设计模式/25.设计模式回顾.md",key:"v-50e76cbf",path:"/pages/d731b1/",headers:[{level:2,title:"创建型",slug:"创建型",normalizedTitle:"创建型",charIndex:66},{level:3,title:"简单工厂",slug:"简单工厂",normalizedTitle:"简单工厂",charIndex:108},{level:3,title:"工厂",slug:"工厂",normalizedTitle:"工厂",charIndex:110},{level:3,title:"抽象工厂",slug:"抽象工厂",normalizedTitle:"抽象工厂",charIndex:118},{level:3,title:"建造者",slug:"建造者",normalizedTitle:"建造者",charIndex:123},{level:3,title:"单列模式",slug:"单列模式",normalizedTitle:"单列模式",charIndex:829},{level:3,title:"原型模式",slug:"原型模式",normalizedTitle:"原型模式",charIndex:1176},{level:2,title:"结构型",slug:"结构型",normalizedTitle:"结构型",charIndex:1412},{level:3,title:"装饰",slug:"装饰",normalizedTitle:"装饰",charIndex:1448},{level:3,title:"代理",slug:"代理",normalizedTitle:"代理",charIndex:1438},{level:3,title:"桥接",slug:"桥接",normalizedTitle:"桥接",charIndex:1445},{level:3,title:"外观",slug:"外观",normalizedTitle:"外观",charIndex:1451},{level:3,title:"享元",slug:"享元",normalizedTitle:"享元",charIndex:1454},{level:3,title:"组合",slug:"组合",normalizedTitle:"组合",charIndex:1324},{level:3,title:"适配器",slug:"适配器",normalizedTitle:"适配器",charIndex:1441},{level:2,title:"行为型",slug:"行为型",normalizedTitle:"行为型",charIndex:2828},{level:3,title:"模板方法",slug:"模板方法",normalizedTitle:"模板方法",charIndex:2857},{level:3,title:"策略",slug:"策略",normalizedTitle:"策略",charIndex:2862},{level:3,title:"命令",slug:"命令",normalizedTitle:"命令",charIndex:2865},{level:3,title:"职责链",slug:"职责链",normalizedTitle:"职责链",charIndex:2868},{level:3,title:"状态",slug:"状态",normalizedTitle:"状态",charIndex:2423},{level:3,title:"观察者",slug:"观察者",normalizedTitle:"观察者",charIndex:2875},{level:3,title:"中介者",slug:"中介者",normalizedTitle:"中介者",charIndex:2879},{level:3,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:2883},{level:3,title:"访问者",slug:"访问者",normalizedTitle:"访问者",charIndex:2887},{level:3,title:"备忘录",slug:"备忘录",normalizedTitle:"备忘录",charIndex:2891},{level:3,title:"解释器",slug:"解释器",normalizedTitle:"解释器",charIndex:2895}],excerpt:"<p>终于写完了经典的23中设计模式，往事不堪回首。</p>\n<p>这篇对这23中做一个总结，以便在后续需要时方便识别哪种是需要的设计模式。</p>\n",headersStr:"创建型 简单工厂 工厂 抽象工厂 建造者 单列模式 原型模式 结构型 装饰 代理 桥接 外观 享元 组合 适配器 行为型 模板方法 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 解释器",content:"终于写完了经典的23中设计模式，往事不堪回首。\n\n这篇对这23中做一个总结，以便在后续需要时方便识别哪种是需要的设计模式。\n\n\n# 创建型\n\n描述对象如何创建，是为了将对象的创建与使用分离。\n\n包括6种：单例、原型、简单工厂、工厂方法、抽象工厂、建造者。\n\n\n# 简单工厂\n\n简单的将对象的创建与使用分离 特点：\n\n 1. 产品是有限的、已知的。\n 2. 工厂类可以直用静态方法，所以可隐藏构造函数（构造函数私有化）\n 3. 创建方法理论上只依赖产品列表，所以可以创建各种实例，不限于只一类。（这是一个危险的实现）\n\n问题:\n\n 1. 添加新产品需要修改已经完成的工厂方法。\n 2. 客户需要知道产品列表和功能直接的关系，增加复杂度。\n\n\n# 工厂\n\n特点/优点：\n\n1、工厂类可以不实例化，使用静态工厂类。\n\n2、延时创建，使用类再不确定是否要创建产品时，可以通过拿着产品的工厂方法。再需要时再创建。 实现延时创建。\n\n问题：\n\n1、随着产品的增加，工厂也不断的增加，可能造成对象的爆发。\n\n2、客户需要关注每个工厂的不同才能获得想要的产品，可能增加维护成本。\n\n\n# 抽象工厂\n\n抽象工厂其实并不是一个复杂概念，其实抽象工厂就是工厂模式的一般现象，工厂模式就是抽象工厂的个例。\n\n特点/优点：\n\n抽象工厂想要新增一个套餐是简单的，但是想要在套餐中新增一个项就比较不友好。\n\n问题：\n\n抽象工厂适用于整套的替换场景中。\n\n\n# 建造者\n\n优点： 建造者是为了将对应的构造和对象的使用分离；\n\n主要应对复杂的创建场景，如 参数不固定，参数见相互影响 等。\n\n条件定义： 一般当一个类的构成超过4个参数，且部分参数可有可无时，就认为这个类的构造已经足够复杂；可以考虑使用建造者模式，来代替多个构造函数的定义。\n\n问题： 有时，我们只有一个类的构造十分复杂；使用建造者模式就导致类膨胀的厉害。\n\n这时我们可以考虑使用 局部类，来实现 简化的建造者模式。\n\n\n# 单列模式\n\n种类     实现                   优点                    缺点\n饿汉单例   1、使用静态区对象，确保只有一份实例   1、多线程，单线程可以用统一的方式处理   1、程序运行时需要加载暂时无用的内存，可能影响效率\n                            2、无加锁，效率高             2、静态对象的初始化由系统决定，如果初始化依赖静态对象，可能导致异常。\n懒汉单例   1、通过判空的方法，确保只有一份实例   1、程序运行时不用加载多余的数据      1、第一次加载可能不够快\n                                                  2、代码相对复杂\n\n\n# 原型模式\n\n原型模式的本质是通过深copy的方式生成对象，不用受构造函数的约束（可不用引入具体头文件）。\n\n优点 / 使用场景：\n\n 1. 性能优化的场景中，当一共从头建造是需要消耗大量资源（如需要大量的IO操作，权限申请等）\n 2. 安全要求场景中，不向外暴露头文件，再一写情况下比较安全。\n\n组合使用方式：\n\n * 可以和工厂模式结合使用，作为工厂模式创建\n\n缺点：\n\n * 对于类中含有容器对象【如组合模式】不够友好\n * 对类中对象由外部传递时，不够友好\n\n\n# 结构型\n\n描述类或对象如何组织成更大结构 包括7种：代理、适配器、桥接、装饰、外观、享元、组合。\n\n\n# 装饰\n\n使用场景：\n\n不想增加子类（或者需要增加子类的数量比较多）时，想扩展类能力。\n\n优点：\n\n装饰类和被装饰类可以独立发展，而不会相互耦合。\n\n有效的分割核心职责和非核心职责\n\n可动态地扩展一个实现类的功能（【套娃】使用），减少了类的数量\n\n注意点：\n\n装饰模式一般是构造函数中传入被装饰的对象。\n\n装饰模式是的目的是为了给现有对象增强能力，但是不管怎么增强，不会改变对象的本质。（这点很重要，后面会在代理中做比较）\n\n缺点：\n\n多层包装的装饰类，出BUG，要一层一层查。如：游戏角色的装扮，如果一共20层装饰者，工作量大。\n\n\n# 代理\n\n代理模式是一个自由度特别高的模式，也是一个不容易被辨识的模式。 场景：\n\n客户和要使用的对象之间的复杂性，当我们规划了两个实体A和B后，发现：\n\n1、A和B之间的调用关系复杂；\n\n2、调用在业务上不属于A或者B的。\n\n我们就需要代理来处理这部分的复杂性，代理通过添加中间层的方式在A和B之间添加了一层新的扩展封装。\n\nspring aop 是现在比较有名的代理模式实现。\n\n\n# 桥接\n\n优点：\n\n1、从两个维度拆分多重基础类，极大的减少了类个数。\n\n2、两个维度可以独立变化，而不影响另一个维度。\n\n缺点：\n\n1、外在使用时会更复杂。\n\n对比代理，装饰者，我们发现这三这外在使用时，有类似的使用方式。\n\n这样对注重点做对比：\n\n代理：增加不属于原对象的功能。\n\n装饰者：对原有功能的增强，增强后还是原有功能。\n\n桥模式：拆分两个维度，以简化原实现。\n\n\n# 外观\n\n外观模式通过提供统一的面板，隐藏了子系统、子模块的具体实现。系统的封装性和易用性得到提升，可以阻止新人对不熟悉模块的错误使用。\n\n同时增加新的接口也需要修改面板，相对而言面板本身容易被影响，扩展性下降。\n\n\n# 享元\n\n享元模式的目的是通过减少对象的创建，来达到减少内存，提供效率的目的；\n\n它设计的重点在于HashMap是使用，我们需要为HashMap找到一个唯一的特征值。\n\nHashMap一般放在享元工厂中管理。\n\n优点： 提高对象复用率，提高效率\n\n适用场景：\n\n 1. 大量相似或相同对象。\n 2. 这些对象占用大量内存，或影响效率。\n 3. 不同对象对外部执行无影响\n\n使用时需要区分 内蕴状态 和 外蕴状态\n\n> 内蕴状态(Internal State)：存储在享元对象内部且不会随环境改变而改变。因此内蕴状态并可以共享。 外蕴状态(External State)：是随环境改变而改变的、不可以共享的状态。\n\n\n# 组合\n\n组合模式又叫 “部分整体模式”，这个名字可以更好的表达这个模式想要解决的问题。\n\n及：事物的 部分和整体具有高度相似性。\n\n在组合模式中，每个节点的类定义中，都可以继续包含一组和自己相同的对象；\n\n叶子节点的定义不是必须，但叶子节点一般是必然存在的（数据是有限的）。\n\n\n# 适配器\n\n1、从上述的可知适配器的本质是为了去处理由于某种原因，不能被修改代码的部分。如果我们可以修改目标代码，不建议使用适配器。\n\n2、上述场景为单向调用场景；在实际的场景中还有很多是两个模块相互使用。同时，他们又是不可以被改动的情况。这时我们需要使用双向适配器。这时主要使用类适配器。\n\n\n# 行为型\n\n描述类或对象之间如何协作完成任务\n\n包括11种：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。\n\n\n# 模板方法\n\n如果行为的模板是相同的，可以用父类封装行为的框架；子类扩展可变的部分。\n\n优点： 1、更好的代码复用性；2、父类封装控制，子类实现细节；实现更可控\n\n缺点： 1、类的增加，导致实现更复杂\n\n\n# 策略\n\n策略模式的本质是对算法的封装，使算法的使用者和算法本身可以自由变化。\n\n优点： 1、扩展性好；2、可以自由切换策略，对象复用性高\n\n缺点： 所有算法都需要暴露给客户段，维护成本变高\n\n可以考虑结合简单工厂，对策略本身也进行一层封装；减少暴露。\n\n\n# 命令\n\n命令模式主要实现了调用者和接受者之间的解构。\n\n场景1： 1、调用者在一些不知道接受者的情况，或不能操作调用者的情况。\n\neg: 界面上有多个按钮控件，分别实现不同的业务功能。\n\n一般界面控制使用一些公共组件；界面控件不知道具体业务使用类，且我们不能操作界面控件的内部实现。\n\n场景2： 1、调用者和接受者执行的生命周期不同；接受者执行时，调用者已经被释放。\n\neg: 数据库系统的撤销、恢复、更新。\n\n数据库根据命令进行撤销、恢复、更新；数据库系统的需要根据自身情况完成数据维护。如果调用者一直等等数据库的返回，可能导致阻塞。同时调用者也不可能提供 撤销、恢复 需要的状态，命令+备忘录可以很好的满足这里的需求。\n\n同策略模式的区别：\n\n简单类别：\n\n命令模式是处理将不同的事情用同一种方式去统一调用，策略模式是处理同一件事情的不同处理方式。\n\n命令模式：命令实例中自己拿着接收者实例。所以命令可操作的对象其实不拘束为一个对象，甚至可以不局限为同一类对象。\n\n策略模式：策略实例无接受者实例，是对一件事的不同做法。\n\n\n# 职责链\n\n职责链模式 是为了 分离 发送方 和 接收方； 所以需要在设计时，也尽可能减少耦合。\n\n纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。\n\n但是小明的问题里还有一个是: 雪糕有点化了,这里用纯的职责链模式就不能胜任。及需要：\n\n不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。\n\n\n# 状态\n\n状态模式是解决：当对象的行为随着对象的属性变化而变化的情况，采用的方式是将不同的行为进行封装。\n\n什么时候需要状态模式： 当面类中代码中存在大量if判断，并且if判断的业务条件相同。\n\n优点： 1、将于特定的条件相关的代码集中到一个类里面，有力的减少了if判断；且利用对一个业务统一修改。\n\n2、无需修改上下文即可引入新的状态。\n\n缺点：\n\n1、状态模式需要上下文环境类有良好的设计，对设计要求较高。\n\n\n# 观察者\n\n优点： 1、建立了触发机制，为了解决一些响应式的业务流。\n\n2、调用者和被调用者进行了抽象解耦，调用者将不知情自己将调用什么。\n\n当有业务需要用【每当...... 就.....】 描述时，可以考虑使用观察者模式。\n\n如果不希望调用者被阻塞，可以才有异步模式执行触发器。\n\n局限： 1、需要避免循环调用 观察者模式也是一个需要谨慎使用的模式，由于观察者模式的响应式触发；导致难以在代码中追查到完整的业务流。\n\n试想如果一个业务完全有触发器堆砌的程序，整个程序的业务就处于：A触发B，B触发C，C触发...的链式触发中。 当多个业务链有交叉时，如何让复杂业务不做循环调用这种简单要求也会变成世纪难题。\n\n2、一个事件上挂的触发器太多，可能导致原来代码的效率下降。\n\n3、观察者无法知道需要观察对象的状态，需要提供额外的能力实现。\n\n\n# 中介者\n\n中介者模式是一个不太常用模式，主体思想是将网状关系，转变为星形关系。\n\n将网状关系的复杂性，收容到一个类中；\n\n这使得其他类变得简单，同时也有中介者类复杂化的代价。\n\n\n# 迭代器\n\n迭代器模式又叫游标模式是一种常见模式，行为型设计模式的一种。几乎每种语言，会实现自己的迭代器。\n\n在代码编程中，常常需要聚合对象来存放一组数据；\n\n迭代器可以依次访问聚合对象内部的各个元素，同时又不暴露聚合对象的内部表示；\n\n一般做业务开发时，并不需要实现迭代器模式；如果需要做公共组件，基础组件时，封装迭代器可能会被使用。\n\n\n# 访问者\n\n访问者模式有利于支持资源结构稳定，使用方式变化的场景；如资源为内部结构，不可直接操作；这时需要添加方法；\n\n优点： 增加一个功能的实现类，影响很小。\n\n缺点： 增加一个资源的实现类，影响较大。\n\n\n# 备忘录\n\n备忘录是为系统的运行提供了后悔药；让系统可以在需要的时机，可以回到希望的状态。\n\n常见的应用场景：撤销恢复，游戏存档，数据库事务等。\n\n当一个对象的所有信息都需要进入备忘录，我们可以思考使用 ： 原型模式 + 备忘录模式\n\n通过原型模式的自copy，我们不会丢失任何数据；并可以将 备忘录中 的备忘录使用者和备忘录统一。\n\n\n# 解释器\n\n解决发生频率很高，但规则可明细的场景。\n\n优点：\n\n良好的扩展性，可以不断定义新的表达式来实现新的业务。\n\n缺点：\n\n容易引起类膨胀，需要较强的类管理能力。",normalizedContent:"终于写完了经典的23中设计模式，往事不堪回首。\n\n这篇对这23中做一个总结，以便在后续需要时方便识别哪种是需要的设计模式。\n\n\n# 创建型\n\n描述对象如何创建，是为了将对象的创建与使用分离。\n\n包括6种：单例、原型、简单工厂、工厂方法、抽象工厂、建造者。\n\n\n# 简单工厂\n\n简单的将对象的创建与使用分离 特点：\n\n 1. 产品是有限的、已知的。\n 2. 工厂类可以直用静态方法，所以可隐藏构造函数（构造函数私有化）\n 3. 创建方法理论上只依赖产品列表，所以可以创建各种实例，不限于只一类。（这是一个危险的实现）\n\n问题:\n\n 1. 添加新产品需要修改已经完成的工厂方法。\n 2. 客户需要知道产品列表和功能直接的关系，增加复杂度。\n\n\n# 工厂\n\n特点/优点：\n\n1、工厂类可以不实例化，使用静态工厂类。\n\n2、延时创建，使用类再不确定是否要创建产品时，可以通过拿着产品的工厂方法。再需要时再创建。 实现延时创建。\n\n问题：\n\n1、随着产品的增加，工厂也不断的增加，可能造成对象的爆发。\n\n2、客户需要关注每个工厂的不同才能获得想要的产品，可能增加维护成本。\n\n\n# 抽象工厂\n\n抽象工厂其实并不是一个复杂概念，其实抽象工厂就是工厂模式的一般现象，工厂模式就是抽象工厂的个例。\n\n特点/优点：\n\n抽象工厂想要新增一个套餐是简单的，但是想要在套餐中新增一个项就比较不友好。\n\n问题：\n\n抽象工厂适用于整套的替换场景中。\n\n\n# 建造者\n\n优点： 建造者是为了将对应的构造和对象的使用分离；\n\n主要应对复杂的创建场景，如 参数不固定，参数见相互影响 等。\n\n条件定义： 一般当一个类的构成超过4个参数，且部分参数可有可无时，就认为这个类的构造已经足够复杂；可以考虑使用建造者模式，来代替多个构造函数的定义。\n\n问题： 有时，我们只有一个类的构造十分复杂；使用建造者模式就导致类膨胀的厉害。\n\n这时我们可以考虑使用 局部类，来实现 简化的建造者模式。\n\n\n# 单列模式\n\n种类     实现                   优点                    缺点\n饿汉单例   1、使用静态区对象，确保只有一份实例   1、多线程，单线程可以用统一的方式处理   1、程序运行时需要加载暂时无用的内存，可能影响效率\n                            2、无加锁，效率高             2、静态对象的初始化由系统决定，如果初始化依赖静态对象，可能导致异常。\n懒汉单例   1、通过判空的方法，确保只有一份实例   1、程序运行时不用加载多余的数据      1、第一次加载可能不够快\n                                                  2、代码相对复杂\n\n\n# 原型模式\n\n原型模式的本质是通过深copy的方式生成对象，不用受构造函数的约束（可不用引入具体头文件）。\n\n优点 / 使用场景：\n\n 1. 性能优化的场景中，当一共从头建造是需要消耗大量资源（如需要大量的io操作，权限申请等）\n 2. 安全要求场景中，不向外暴露头文件，再一写情况下比较安全。\n\n组合使用方式：\n\n * 可以和工厂模式结合使用，作为工厂模式创建\n\n缺点：\n\n * 对于类中含有容器对象【如组合模式】不够友好\n * 对类中对象由外部传递时，不够友好\n\n\n# 结构型\n\n描述类或对象如何组织成更大结构 包括7种：代理、适配器、桥接、装饰、外观、享元、组合。\n\n\n# 装饰\n\n使用场景：\n\n不想增加子类（或者需要增加子类的数量比较多）时，想扩展类能力。\n\n优点：\n\n装饰类和被装饰类可以独立发展，而不会相互耦合。\n\n有效的分割核心职责和非核心职责\n\n可动态地扩展一个实现类的功能（【套娃】使用），减少了类的数量\n\n注意点：\n\n装饰模式一般是构造函数中传入被装饰的对象。\n\n装饰模式是的目的是为了给现有对象增强能力，但是不管怎么增强，不会改变对象的本质。（这点很重要，后面会在代理中做比较）\n\n缺点：\n\n多层包装的装饰类，出bug，要一层一层查。如：游戏角色的装扮，如果一共20层装饰者，工作量大。\n\n\n# 代理\n\n代理模式是一个自由度特别高的模式，也是一个不容易被辨识的模式。 场景：\n\n客户和要使用的对象之间的复杂性，当我们规划了两个实体a和b后，发现：\n\n1、a和b之间的调用关系复杂；\n\n2、调用在业务上不属于a或者b的。\n\n我们就需要代理来处理这部分的复杂性，代理通过添加中间层的方式在a和b之间添加了一层新的扩展封装。\n\nspring aop 是现在比较有名的代理模式实现。\n\n\n# 桥接\n\n优点：\n\n1、从两个维度拆分多重基础类，极大的减少了类个数。\n\n2、两个维度可以独立变化，而不影响另一个维度。\n\n缺点：\n\n1、外在使用时会更复杂。\n\n对比代理，装饰者，我们发现这三这外在使用时，有类似的使用方式。\n\n这样对注重点做对比：\n\n代理：增加不属于原对象的功能。\n\n装饰者：对原有功能的增强，增强后还是原有功能。\n\n桥模式：拆分两个维度，以简化原实现。\n\n\n# 外观\n\n外观模式通过提供统一的面板，隐藏了子系统、子模块的具体实现。系统的封装性和易用性得到提升，可以阻止新人对不熟悉模块的错误使用。\n\n同时增加新的接口也需要修改面板，相对而言面板本身容易被影响，扩展性下降。\n\n\n# 享元\n\n享元模式的目的是通过减少对象的创建，来达到减少内存，提供效率的目的；\n\n它设计的重点在于hashmap是使用，我们需要为hashmap找到一个唯一的特征值。\n\nhashmap一般放在享元工厂中管理。\n\n优点： 提高对象复用率，提高效率\n\n适用场景：\n\n 1. 大量相似或相同对象。\n 2. 这些对象占用大量内存，或影响效率。\n 3. 不同对象对外部执行无影响\n\n使用时需要区分 内蕴状态 和 外蕴状态\n\n> 内蕴状态(internal state)：存储在享元对象内部且不会随环境改变而改变。因此内蕴状态并可以共享。 外蕴状态(external state)：是随环境改变而改变的、不可以共享的状态。\n\n\n# 组合\n\n组合模式又叫 “部分整体模式”，这个名字可以更好的表达这个模式想要解决的问题。\n\n及：事物的 部分和整体具有高度相似性。\n\n在组合模式中，每个节点的类定义中，都可以继续包含一组和自己相同的对象；\n\n叶子节点的定义不是必须，但叶子节点一般是必然存在的（数据是有限的）。\n\n\n# 适配器\n\n1、从上述的可知适配器的本质是为了去处理由于某种原因，不能被修改代码的部分。如果我们可以修改目标代码，不建议使用适配器。\n\n2、上述场景为单向调用场景；在实际的场景中还有很多是两个模块相互使用。同时，他们又是不可以被改动的情况。这时我们需要使用双向适配器。这时主要使用类适配器。\n\n\n# 行为型\n\n描述类或对象之间如何协作完成任务\n\n包括11种：模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器。\n\n\n# 模板方法\n\n如果行为的模板是相同的，可以用父类封装行为的框架；子类扩展可变的部分。\n\n优点： 1、更好的代码复用性；2、父类封装控制，子类实现细节；实现更可控\n\n缺点： 1、类的增加，导致实现更复杂\n\n\n# 策略\n\n策略模式的本质是对算法的封装，使算法的使用者和算法本身可以自由变化。\n\n优点： 1、扩展性好；2、可以自由切换策略，对象复用性高\n\n缺点： 所有算法都需要暴露给客户段，维护成本变高\n\n可以考虑结合简单工厂，对策略本身也进行一层封装；减少暴露。\n\n\n# 命令\n\n命令模式主要实现了调用者和接受者之间的解构。\n\n场景1： 1、调用者在一些不知道接受者的情况，或不能操作调用者的情况。\n\neg: 界面上有多个按钮控件，分别实现不同的业务功能。\n\n一般界面控制使用一些公共组件；界面控件不知道具体业务使用类，且我们不能操作界面控件的内部实现。\n\n场景2： 1、调用者和接受者执行的生命周期不同；接受者执行时，调用者已经被释放。\n\neg: 数据库系统的撤销、恢复、更新。\n\n数据库根据命令进行撤销、恢复、更新；数据库系统的需要根据自身情况完成数据维护。如果调用者一直等等数据库的返回，可能导致阻塞。同时调用者也不可能提供 撤销、恢复 需要的状态，命令+备忘录可以很好的满足这里的需求。\n\n同策略模式的区别：\n\n简单类别：\n\n命令模式是处理将不同的事情用同一种方式去统一调用，策略模式是处理同一件事情的不同处理方式。\n\n命令模式：命令实例中自己拿着接收者实例。所以命令可操作的对象其实不拘束为一个对象，甚至可以不局限为同一类对象。\n\n策略模式：策略实例无接受者实例，是对一件事的不同做法。\n\n\n# 职责链\n\n职责链模式 是为了 分离 发送方 和 接收方； 所以需要在设计时，也尽可能减少耦合。\n\n纯的职责链模式：一个请求必须被某一个处理者对象所接收，且一个具体处理者对某个请求的处理只能采用以下两种行为之一：自己处理（承担责任）；把责任推给下家处理。\n\n但是小明的问题里还有一个是: 雪糕有点化了,这里用纯的职责链模式就不能胜任。及需要：\n\n不纯的职责链模式：允许出现某一个具体处理者对象在承担了请求的一部分责任后又将剩余的责任传给下家的情况，且一个请求可以最终不被任何接收端对象所接收。\n\n\n# 状态\n\n状态模式是解决：当对象的行为随着对象的属性变化而变化的情况，采用的方式是将不同的行为进行封装。\n\n什么时候需要状态模式： 当面类中代码中存在大量if判断，并且if判断的业务条件相同。\n\n优点： 1、将于特定的条件相关的代码集中到一个类里面，有力的减少了if判断；且利用对一个业务统一修改。\n\n2、无需修改上下文即可引入新的状态。\n\n缺点：\n\n1、状态模式需要上下文环境类有良好的设计，对设计要求较高。\n\n\n# 观察者\n\n优点： 1、建立了触发机制，为了解决一些响应式的业务流。\n\n2、调用者和被调用者进行了抽象解耦，调用者将不知情自己将调用什么。\n\n当有业务需要用【每当...... 就.....】 描述时，可以考虑使用观察者模式。\n\n如果不希望调用者被阻塞，可以才有异步模式执行触发器。\n\n局限： 1、需要避免循环调用 观察者模式也是一个需要谨慎使用的模式，由于观察者模式的响应式触发；导致难以在代码中追查到完整的业务流。\n\n试想如果一个业务完全有触发器堆砌的程序，整个程序的业务就处于：a触发b，b触发c，c触发...的链式触发中。 当多个业务链有交叉时，如何让复杂业务不做循环调用这种简单要求也会变成世纪难题。\n\n2、一个事件上挂的触发器太多，可能导致原来代码的效率下降。\n\n3、观察者无法知道需要观察对象的状态，需要提供额外的能力实现。\n\n\n# 中介者\n\n中介者模式是一个不太常用模式，主体思想是将网状关系，转变为星形关系。\n\n将网状关系的复杂性，收容到一个类中；\n\n这使得其他类变得简单，同时也有中介者类复杂化的代价。\n\n\n# 迭代器\n\n迭代器模式又叫游标模式是一种常见模式，行为型设计模式的一种。几乎每种语言，会实现自己的迭代器。\n\n在代码编程中，常常需要聚合对象来存放一组数据；\n\n迭代器可以依次访问聚合对象内部的各个元素，同时又不暴露聚合对象的内部表示；\n\n一般做业务开发时，并不需要实现迭代器模式；如果需要做公共组件，基础组件时，封装迭代器可能会被使用。\n\n\n# 访问者\n\n访问者模式有利于支持资源结构稳定，使用方式变化的场景；如资源为内部结构，不可直接操作；这时需要添加方法；\n\n优点： 增加一个功能的实现类，影响很小。\n\n缺点： 增加一个资源的实现类，影响较大。\n\n\n# 备忘录\n\n备忘录是为系统的运行提供了后悔药；让系统可以在需要的时机，可以回到希望的状态。\n\n常见的应用场景：撤销恢复，游戏存档，数据库事务等。\n\n当一个对象的所有信息都需要进入备忘录，我们可以思考使用 ： 原型模式 + 备忘录模式\n\n通过原型模式的自copy，我们不会丢失任何数据；并可以将 备忘录中 的备忘录使用者和备忘录统一。\n\n\n# 解释器\n\n解决发生频率很高，但规则可明细的场景。\n\n优点：\n\n良好的扩展性，可以不断定义新的表达式来实现新的业务。\n\n缺点：\n\n容易引起类膨胀，需要较强的类管理能力。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"外观（面板）模式",frontmatter:{title:"外观（面板）模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/8f3579/",categories:["设计模式"],tags:["外观模式","面板模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/3.%E5%A4%96%E8%A7%82%EF%BC%88%E9%9D%A2%E6%9D%BF%EF%BC%89%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/3.外观（面板）模式.md",key:"v-8bdb2f3e",path:"/pages/8f3579/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:112},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:163},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:179},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1625},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:1647}],excerpt:'<p>经过上篇的基建，发现：产品的质量已经可控，但是客户太费鞋（毕竟跑一家工厂买一个产品，鞋累啊）。</p>\n<p>如何让用户不那么费鞋嗯？</p>\n<p>供货的问题解决后，下面解决的就是经销的问题，一家可以卖各种商品的小卖部是很有必要的。</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B0%8F%E5%8D%96%E9%83%A8.webp" alt="小卖部"></p>\n',headersStr:"场景分析 实现 代码 代码位置 使用感悟",content:'经过上篇的基建，发现：产品的质量已经可控，但是客户太费鞋（毕竟跑一家工厂买一个产品，鞋累啊）。\n\n如何让用户不那么费鞋嗯？\n\n供货的问题解决后，下面解决的就是经销的问题，一家可以卖各种商品的小卖部是很有必要的。\n\n\n\n\n# 场景分析\n\n小卖部的特性是什么嗯？\n\n小卖部的特性是将所有的功能放到统一位置，以便客户使用。\n\n\n# 实现\n\n实现类图:\n\n\n\n\n# 代码\n\n外观/面板：\n\nclass  IceCreamFactoryFacade\n{\npublic:\n    IceCreamFactoryFacade()\n        : m_pStrawberryIceCreamFactory(new StrawberryIceCreamFactory())\n        , m_pVanillaIceCreamFactory(new VanillaIceCreamFactory()) {}\n\n    ~IceCreamFactoryFacade()\n    {\n        delete m_pStrawberryIceCreamFactory;\n        m_pStrawberryIceCreamFactory = nullptr;\n        delete m_pVanillaIceCreamFactory;\n        m_pVanillaIceCreamFactory = nullptr;\n    }\n\npublic:\n    IceCreamInterface *createStrawberryIceCream()\n    {\n        return m_pStrawberryIceCreamFactory->createIceCream();\n    }\n\n    IceCreamInterface *createVanillaIceCream()\n    {\n        return m_pVanillaIceCreamFactory->createIceCream();\n    }\n\nprivate:\n    IceCreamFactoryInterface *m_pStrawberryIceCreamFactory;\n    IceCreamFactoryInterface *m_pVanillaIceCreamFactory;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n客户端：\n\n#include "IceCreamInterface.h"\n#include "IceCreamFactoryFacade.hpp"\n\nint main(int argc, char *argv[])\n{\n    IceCreamFactoryFacade oIceCreamFactoryFacade;\n    IceCreamInterface* pStrawberryIceCream = oIceCreamFactoryFacade.createStrawberryIceCream();\n    IceCreamInterface* pVanillaIceCream = oIceCreamFactoryFacade.createVanillaIceCream();\n\n    pStrawberryIceCream->taste();\n    pVanillaIceCream->taste();\n\n    delete pStrawberryIceCream;\n    delete pVanillaIceCream;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 代码位置\n\n设计模式/Facade\n\n\n# 使用感悟\n\n在外观模式的帮助下，现在解决了工厂模式带来的使用不便的问题。\n\n对比外观+工厂和简单工厂模式，我们发现：\n\n相同：\n\n1、对使用者隐藏了实现细节\n\n2、提供良好的使用界面\n\n不同：\n\n外观+工厂对新扩展依然有比较好的包容性，但简单工厂相对差一些。\n\n相对的，简单工厂的类实现比较简单，维护更简单。\n\n对应外观模式自身：\n\n外观模式通过提供统一的面板，隐藏了子系统、子模块的具体实现。系统的封装性和易用性得到提升，可以阻止新人对不熟悉模块的错误使用。\n\n同时增加新的接口也需要修改面板，相对而言面板本身容易被影响，扩展性下降。',normalizedContent:'经过上篇的基建，发现：产品的质量已经可控，但是客户太费鞋（毕竟跑一家工厂买一个产品，鞋累啊）。\n\n如何让用户不那么费鞋嗯？\n\n供货的问题解决后，下面解决的就是经销的问题，一家可以卖各种商品的小卖部是很有必要的。\n\n\n\n\n# 场景分析\n\n小卖部的特性是什么嗯？\n\n小卖部的特性是将所有的功能放到统一位置，以便客户使用。\n\n\n# 实现\n\n实现类图:\n\n\n\n\n# 代码\n\n外观/面板：\n\nclass  icecreamfactoryfacade\n{\npublic:\n    icecreamfactoryfacade()\n        : m_pstrawberryicecreamfactory(new strawberryicecreamfactory())\n        , m_pvanillaicecreamfactory(new vanillaicecreamfactory()) {}\n\n    ~icecreamfactoryfacade()\n    {\n        delete m_pstrawberryicecreamfactory;\n        m_pstrawberryicecreamfactory = nullptr;\n        delete m_pvanillaicecreamfactory;\n        m_pvanillaicecreamfactory = nullptr;\n    }\n\npublic:\n    icecreaminterface *createstrawberryicecream()\n    {\n        return m_pstrawberryicecreamfactory->createicecream();\n    }\n\n    icecreaminterface *createvanillaicecream()\n    {\n        return m_pvanillaicecreamfactory->createicecream();\n    }\n\nprivate:\n    icecreamfactoryinterface *m_pstrawberryicecreamfactory;\n    icecreamfactoryinterface *m_pvanillaicecreamfactory;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n客户端：\n\n#include "icecreaminterface.h"\n#include "icecreamfactoryfacade.hpp"\n\nint main(int argc, char *argv[])\n{\n    icecreamfactoryfacade oicecreamfactoryfacade;\n    icecreaminterface* pstrawberryicecream = oicecreamfactoryfacade.createstrawberryicecream();\n    icecreaminterface* pvanillaicecream = oicecreamfactoryfacade.createvanillaicecream();\n\n    pstrawberryicecream->taste();\n    pvanillaicecream->taste();\n\n    delete pstrawberryicecream;\n    delete pvanillaicecream;\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 代码位置\n\n设计模式/facade\n\n\n# 使用感悟\n\n在外观模式的帮助下，现在解决了工厂模式带来的使用不便的问题。\n\n对比外观+工厂和简单工厂模式，我们发现：\n\n相同：\n\n1、对使用者隐藏了实现细节\n\n2、提供良好的使用界面\n\n不同：\n\n外观+工厂对新扩展依然有比较好的包容性，但简单工厂相对差一些。\n\n相对的，简单工厂的类实现比较简单，维护更简单。\n\n对应外观模式自身：\n\n外观模式通过提供统一的面板，隐藏了子系统、子模块的具体实现。系统的封装性和易用性得到提升，可以阻止新人对不熟悉模块的错误使用。\n\n同时增加新的接口也需要修改面板，相对而言面板本身容易被影响，扩展性下降。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"单例模式",frontmatter:{title:"单例模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/8bab8c/",categories:["设计模式"],tags:["单例模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/4.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/4.单例模式.md",key:"v-2aed201f",path:"/pages/8bab8c/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:87},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:180},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:194},{level:4,title:"饿汉单例",slug:"饿汉单例",normalizedTitle:"饿汉单例",charIndex:202},{level:4,title:"懒汉单例",slug:"懒汉单例",normalizedTitle:"懒汉单例",charIndex:207},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:4309},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:4334}],excerpt:'<p>上篇了解了外观模式，解决了客户端找不到需要访问的功能的困扰。</p>\n<p>小卖部是挺好，但是啃得鸡就不干了；我研发的产品，你去卖？ 那我怎么管理服务的标准化（统一提价）。</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%9C%9F%E7%88%B1%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA.webp" alt="真爱只有一个"></p>\n',headersStr:"场景分析 实现 代码 饿汉单例 懒汉单例 代码位置 使用感悟",content:'上篇了解了外观模式，解决了客户端找不到需要访问的功能的困扰。\n\n小卖部是挺好，但是啃得鸡就不干了；我研发的产品，你去卖？ 那我怎么管理服务的标准化（统一提价）。\n\n\n\n\n# 场景分析\n\n小卖部虽好，但如果只有我能开，那就更好了！\n\n单例模式的思路比较简单，就是要求程序运行范围内只有一个对象。\n\n为了这个目的，在不同情况下，需要使用不同的技术来辅助。\n\n\n# 实现\n\n类图：\n\n\n\n\n# 代码\n\n单例分为饿汉单例和懒汉单例，下面分别介绍。\n\n# 饿汉单例\n\n相对来说，饿汉单例更好理解一些。单例的目的是为了保证只有一个对象。所以使用了静态对象进行处理。\n\n同时将类的构造函数，copy构造，赋值构造进行私有化。\n\n这时一个进程中将有且只有一个单例类的对象。\n\n#include "IceCreamFactoryFacadeInterface.h"\n#include "StrawberryIceCreamFactory.hpp"\n#include "VanillaIceCreamFactory.hpp"\n\nclass EagerSingletonFactoryFacade : public IceCreamFactoryFacadeInterface\n{\nprivate:\n    static EagerSingletonFactoryFacade m_oInstance;\nprivate:\n    EagerSingletonFactoryFacade()\n        : m_pStrawberryIceCreamFactory(new StrawberryIceCreamFactory())\n        , m_pVanillaIceCreamFactory(new VanillaIceCreamFactory()) {}\n\n    EagerSingletonFactoryFacade(EagerSingletonFactoryFacade const&);\n    EagerSingletonFactoryFacade& operator=(EagerSingletonFactoryFacade const&);\n\npublic:\n    virtual ~EagerSingletonFactoryFacade() {}\n\n    static IceCreamFactoryFacadeInterface *getInstance()\n    {\n        return &m_oInstance;\n    }\n\npublic:\n    IceCreamInterface *createStrawberryIceCream() override\n    {\n        return m_pStrawberryIceCreamFactory->createIceCream();\n    }\n\n    IceCreamInterface *createVanillaIceCream() override\n    {\n        return m_pVanillaIceCreamFactory->createIceCream();\n    }\nprivate:\n    IceCreamFactoryInterface *m_pStrawberryIceCreamFactory;\n    IceCreamFactoryInterface *m_pVanillaIceCreamFactory;\n};\n\n// 初始化静态变量\nEagerSingletonFactoryFacade EagerSingletonFactoryFacade::m_oInstance;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 懒汉单例\n\n懒汉单例不同于只处在于，在使用时它才会加载。有懒加载的效果。\n\n主要使用判空方式确保对象只生成一次。\n\nPs：实例中使用静态的方式存储指针对象，只是为了方便，这并不是规范。\n\n#include "IceCreamFactoryFacadeInterface.h"\n#include "StrawberryIceCreamFactory.hpp"\n#include "VanillaIceCreamFactory.hpp"\n#include <QMutex>\n#include <QMutexLocker>\n\nclass LazySingletonFactoryFacade : public IceCreamFactoryFacadeInterface\n{\nprivate:\n    static IceCreamFactoryFacadeInterface *m_pInstance;\n    static QMutex s_oMutex;\nprivate:\n    LazySingletonFactoryFacade()\n        : m_pStrawberryIceCreamFactory(new StrawberryIceCreamFactory())\n        , m_pVanillaIceCreamFactory(new VanillaIceCreamFactory()) {}\npublic:\n    virtual ~LazySingletonFactoryFacade() {}\n\n    static void freeInstancel()\n    {\n        if (nullptr != m_pInstance)\n        {\n            delete m_pInstance;\n            m_pInstance = nullptr;\n        }\n    }\n\n    // 对于单线程\n    // 如果当前判断为单进程，我们中需要做简单的判空处理即可\n    static IceCreamFactoryFacadeInterface *getInstance_1()\n    {\n        if (nullptr == m_pInstance)\n        {\n            m_pInstance = new LazySingletonFactoryFacade();\n        }\n        return m_pInstance;\n    }\n\n    // 对于多线程\n    // 对于多线程程序，只做判空不能做到单例的效果，需要加锁\n    // 这是最简单的加锁方式，通常不使用，应为效率不够高\n    static IceCreamFactoryFacadeInterface *getInstance_2()\n    {\n        QMutexLocker oLocker(&s_oMutex);\n        if (nullptr == m_pInstance)\n        {\n            m_pInstance = new LazySingletonFactoryFacade();\n        }\n        return m_pInstance;\n    }\n\n    // 对于多线程 - 双重判空\n    // 对于多线程，同时使用双重判空的方式处理，以提高效率\n    static IceCreamFactoryFacadeInterface *getInstance_3()\n    {\n        if (nullptr == m_pInstance)\n        {\n            QMutexLocker oLocker(&s_oMutex);\n            if (nullptr == m_pInstance)\n            {\n                m_pInstance = new LazySingletonFactoryFacade();\n            }\n        }\n        return m_pInstance;\n    }\n\npublic:\n    IceCreamInterface *createStrawberryIceCream() override\n    {\n        return m_pStrawberryIceCreamFactory->createIceCream();\n    }\n\n    IceCreamInterface *createVanillaIceCream() override\n    {\n        return m_pVanillaIceCreamFactory->createIceCream();\n    }\nprivate:\n    IceCreamFactoryInterface *m_pStrawberryIceCreamFactory;\n    IceCreamFactoryInterface *m_pVanillaIceCreamFactory;\n};\n\n// 初始化静态变量\nIceCreamFactoryFacadeInterface * LazySingletonFactoryFacade::m_pInstance = nullptr;\nQMutex LazySingletonFactoryFacade::s_oMutex(QMutex::Recursive);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n# 代码位置\n\n设计模式/Singleton\n\n\n# 使用感悟\n\n种类     实现                   优点                    缺点\n饿汉单例   1、使用静态区对象，确保只有一份实例   1、多线程，单线程可以用统一的方式处理   1、程序运行时需要加载暂时无用的内存，可能影响效率\n                            2、无加锁，效率高             2、静态对象的初始化由系统决定，如果初始化依赖静态对象，可能导致异常。\n懒汉单例   1、通过判空的方法，确保只有一份实例   1、程序运行时不用加载多余的数据      1、第一次加载可能不够快\n                                                  2、代码相对复杂',normalizedContent:'上篇了解了外观模式，解决了客户端找不到需要访问的功能的困扰。\n\n小卖部是挺好，但是啃得鸡就不干了；我研发的产品，你去卖？ 那我怎么管理服务的标准化（统一提价）。\n\n\n\n\n# 场景分析\n\n小卖部虽好，但如果只有我能开，那就更好了！\n\n单例模式的思路比较简单，就是要求程序运行范围内只有一个对象。\n\n为了这个目的，在不同情况下，需要使用不同的技术来辅助。\n\n\n# 实现\n\n类图：\n\n\n\n\n# 代码\n\n单例分为饿汉单例和懒汉单例，下面分别介绍。\n\n# 饿汉单例\n\n相对来说，饿汉单例更好理解一些。单例的目的是为了保证只有一个对象。所以使用了静态对象进行处理。\n\n同时将类的构造函数，copy构造，赋值构造进行私有化。\n\n这时一个进程中将有且只有一个单例类的对象。\n\n#include "icecreamfactoryfacadeinterface.h"\n#include "strawberryicecreamfactory.hpp"\n#include "vanillaicecreamfactory.hpp"\n\nclass eagersingletonfactoryfacade : public icecreamfactoryfacadeinterface\n{\nprivate:\n    static eagersingletonfactoryfacade m_oinstance;\nprivate:\n    eagersingletonfactoryfacade()\n        : m_pstrawberryicecreamfactory(new strawberryicecreamfactory())\n        , m_pvanillaicecreamfactory(new vanillaicecreamfactory()) {}\n\n    eagersingletonfactoryfacade(eagersingletonfactoryfacade const&);\n    eagersingletonfactoryfacade& operator=(eagersingletonfactoryfacade const&);\n\npublic:\n    virtual ~eagersingletonfactoryfacade() {}\n\n    static icecreamfactoryfacadeinterface *getinstance()\n    {\n        return &m_oinstance;\n    }\n\npublic:\n    icecreaminterface *createstrawberryicecream() override\n    {\n        return m_pstrawberryicecreamfactory->createicecream();\n    }\n\n    icecreaminterface *createvanillaicecream() override\n    {\n        return m_pvanillaicecreamfactory->createicecream();\n    }\nprivate:\n    icecreamfactoryinterface *m_pstrawberryicecreamfactory;\n    icecreamfactoryinterface *m_pvanillaicecreamfactory;\n};\n\n// 初始化静态变量\neagersingletonfactoryfacade eagersingletonfactoryfacade::m_oinstance;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 懒汉单例\n\n懒汉单例不同于只处在于，在使用时它才会加载。有懒加载的效果。\n\n主要使用判空方式确保对象只生成一次。\n\nps：实例中使用静态的方式存储指针对象，只是为了方便，这并不是规范。\n\n#include "icecreamfactoryfacadeinterface.h"\n#include "strawberryicecreamfactory.hpp"\n#include "vanillaicecreamfactory.hpp"\n#include <qmutex>\n#include <qmutexlocker>\n\nclass lazysingletonfactoryfacade : public icecreamfactoryfacadeinterface\n{\nprivate:\n    static icecreamfactoryfacadeinterface *m_pinstance;\n    static qmutex s_omutex;\nprivate:\n    lazysingletonfactoryfacade()\n        : m_pstrawberryicecreamfactory(new strawberryicecreamfactory())\n        , m_pvanillaicecreamfactory(new vanillaicecreamfactory()) {}\npublic:\n    virtual ~lazysingletonfactoryfacade() {}\n\n    static void freeinstancel()\n    {\n        if (nullptr != m_pinstance)\n        {\n            delete m_pinstance;\n            m_pinstance = nullptr;\n        }\n    }\n\n    // 对于单线程\n    // 如果当前判断为单进程，我们中需要做简单的判空处理即可\n    static icecreamfactoryfacadeinterface *getinstance_1()\n    {\n        if (nullptr == m_pinstance)\n        {\n            m_pinstance = new lazysingletonfactoryfacade();\n        }\n        return m_pinstance;\n    }\n\n    // 对于多线程\n    // 对于多线程程序，只做判空不能做到单例的效果，需要加锁\n    // 这是最简单的加锁方式，通常不使用，应为效率不够高\n    static icecreamfactoryfacadeinterface *getinstance_2()\n    {\n        qmutexlocker olocker(&s_omutex);\n        if (nullptr == m_pinstance)\n        {\n            m_pinstance = new lazysingletonfactoryfacade();\n        }\n        return m_pinstance;\n    }\n\n    // 对于多线程 - 双重判空\n    // 对于多线程，同时使用双重判空的方式处理，以提高效率\n    static icecreamfactoryfacadeinterface *getinstance_3()\n    {\n        if (nullptr == m_pinstance)\n        {\n            qmutexlocker olocker(&s_omutex);\n            if (nullptr == m_pinstance)\n            {\n                m_pinstance = new lazysingletonfactoryfacade();\n            }\n        }\n        return m_pinstance;\n    }\n\npublic:\n    icecreaminterface *createstrawberryicecream() override\n    {\n        return m_pstrawberryicecreamfactory->createicecream();\n    }\n\n    icecreaminterface *createvanillaicecream() override\n    {\n        return m_pvanillaicecreamfactory->createicecream();\n    }\nprivate:\n    icecreamfactoryinterface *m_pstrawberryicecreamfactory;\n    icecreamfactoryinterface *m_pvanillaicecreamfactory;\n};\n\n// 初始化静态变量\nicecreamfactoryfacadeinterface * lazysingletonfactoryfacade::m_pinstance = nullptr;\nqmutex lazysingletonfactoryfacade::s_omutex(qmutex::recursive);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n# 代码位置\n\n设计模式/singleton\n\n\n# 使用感悟\n\n种类     实现                   优点                    缺点\n饿汉单例   1、使用静态区对象，确保只有一份实例   1、多线程，单线程可以用统一的方式处理   1、程序运行时需要加载暂时无用的内存，可能影响效率\n                            2、无加锁，效率高             2、静态对象的初始化由系统决定，如果初始化依赖静态对象，可能导致异常。\n懒汉单例   1、通过判空的方法，确保只有一份实例   1、程序运行时不用加载多余的数据      1、第一次加载可能不够快\n                                                  2、代码相对复杂',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"原型模式",frontmatter:{title:"原型模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/e4eef8/",categories:["设计模式"],tags:["原型模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/5.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/5.原型模式.md",key:"v-2cdcd46d",path:"/pages/e4eef8/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:65},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:86},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:235},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:726},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:751}],excerpt:'<p>啃得鸡冰淇淋卖的太好了，别的商家希望也能卖冰淇淋；但是不想自己设计调参。于是clone或者说copy就是一个方案了？</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%86%B0%E6%B7%87%E6%B7%8B.webp" alt="冰淇淋"></p>\n',headersStr:"场景分析 实现 代码 代码位置 使用感悟",content:'啃得鸡冰淇淋卖的太好了，别的商家希望也能卖冰淇淋；但是不想自己设计调参。于是clone或者说copy就是一个方案了？\n\n\n\n\n# 场景分析\n\n客户端可以再不用知道对象的具体实现的情况下，新建一个新的对象。那就是客户端只知道接口定义，也就是说是通过接口访问的。\n\n原型模式指通过【现有对象】 是生成一个新对象，而不需要知道他们所属的类。\n\n\n# 实现\n\n\n\n类图的设计也可以提一个单独的Prototype接口作为所有类的父类，客户端其实需要的是具有业务意义的类。\n\n\n# 代码\n\n接口：\n\n// 冰淇淋接口\nclass IceCreamInterface\n{\npublic:\n    virtual ~IceCreamInterface() {}\n    virtual void taste() = 0;\n    virtual IceCreamInterface *clone() = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实现：\n\n// 草莓冰淇淋\nclass StrawberryIceCreamImpl : public IceCreamInterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("草莓冰淇淋的味道！");\n    }\n\n    IceCreamInterface *clone()\n    {\n        return new StrawberryIceCreamImpl();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 代码位置\n\n设计模式/Prototype\n\n\n# 使用感悟\n\n原型模式的本质是通过深copy的方式生成对象，不用受构造函数的约束（可不用引入具体头文件）。\n\n优点 / 使用场景：\n\n 1. 性能优化的场景中，当一共从头建造是需要消耗大量资源（如需要大量的IO操作，权限申请等）\n 2. 安全要求场景中，不向外暴露头文件，再一写情况下比较安全。\n\n组合使用方式： 可以和工厂模式结合使用，作为工厂模式创建\n\n缺点： 对于类中含有容器对象【如组合模式】不够友好\n\n对类中对象由外部传递时，不够友好',normalizedContent:'啃得鸡冰淇淋卖的太好了，别的商家希望也能卖冰淇淋；但是不想自己设计调参。于是clone或者说copy就是一个方案了？\n\n\n\n\n# 场景分析\n\n客户端可以再不用知道对象的具体实现的情况下，新建一个新的对象。那就是客户端只知道接口定义，也就是说是通过接口访问的。\n\n原型模式指通过【现有对象】 是生成一个新对象，而不需要知道他们所属的类。\n\n\n# 实现\n\n\n\n类图的设计也可以提一个单独的prototype接口作为所有类的父类，客户端其实需要的是具有业务意义的类。\n\n\n# 代码\n\n接口：\n\n// 冰淇淋接口\nclass icecreaminterface\n{\npublic:\n    virtual ~icecreaminterface() {}\n    virtual void taste() = 0;\n    virtual icecreaminterface *clone() = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n实现：\n\n// 草莓冰淇淋\nclass strawberryicecreamimpl : public icecreaminterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("草莓冰淇淋的味道！");\n    }\n\n    icecreaminterface *clone()\n    {\n        return new strawberryicecreamimpl();\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 代码位置\n\n设计模式/prototype\n\n\n# 使用感悟\n\n原型模式的本质是通过深copy的方式生成对象，不用受构造函数的约束（可不用引入具体头文件）。\n\n优点 / 使用场景：\n\n 1. 性能优化的场景中，当一共从头建造是需要消耗大量资源（如需要大量的io操作，权限申请等）\n 2. 安全要求场景中，不向外暴露头文件，再一写情况下比较安全。\n\n组合使用方式： 可以和工厂模式结合使用，作为工厂模式创建\n\n缺点： 对于类中含有容器对象【如组合模式】不够友好\n\n对类中对象由外部传递时，不够友好',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"抽象工厂",frontmatter:{title:"抽象工厂",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/b0b3d1/",categories:["设计模式"],tags:["抽象工厂"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/6.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/6.抽象工厂模式.md",key:"v-3bc566a8",path:"/pages/b0b3d1/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:79},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:182},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:238},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1646},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:1677}],excerpt:'<p>啃得鸡自从产品被抄袭，就很紧张；经过市场部讨论后，希望通过套餐的方式去打动用户。</p>\n<p>套餐：（冰淇淋 + 薯条）</p>\n<p>现再的问题是套餐产品怎么搞嗯？</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%86%B0%E6%B7%87%E6%B7%8B%E8%96%AF%E6%9D%A1.webp" alt="冰淇淋薯条"></p>\n',headersStr:"场景分析 实现 代码 代码位置 使用感悟",content:'啃得鸡自从产品被抄袭，就很紧张；经过市场部讨论后，希望通过套餐的方式去打动用户。\n\n套餐：（冰淇淋 + 薯条）\n\n现再的问题是套餐产品怎么搞嗯？\n\n\n\n\n# 场景分析\n\n不同于我们之前生产的产品，套餐类产品都是由不同的部分去构成，同一部分再不同套餐中不尽相同；不能在一个工厂内生产所有套餐产品。\n\n所以我们需要多个工厂\n\n抽象工厂是生成一系列对象的方法。\n\n\n# 实现\n\n\n\n抽象工厂对比工厂模式，发现工厂是抽象工厂的特例。当抽象工厂的产品只有一种时，就是工厂模式。\n\n\n# 代码\n\n产品1：冰淇淋\n\n// 冰淇淋接口\nclass IceCreamInterface\n{\npublic:\n    virtual ~IceCreamInterface() {}\n    virtual void taste() = 0;\n};\n\n// 香草冰淇淋\nclass VanillaIceCreamImpl : public IceCreamInterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("香草冰淇淋的味道！");\n    }\n};\n\n// 草莓冰淇淋\nclass StrawberryIceCreamImpl : public IceCreamInterface\n{\npublic:\n    virtual void taste() override\n    {\n        qDebug() << QStringLiteral("草莓冰淇淋的味道！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n产品2：薯条\n\nclass ChipsInterface\n{\npublic:\n    virtual ~ChipsInterface() {}\n    virtual void size() = 0;\n};\n\nclass BigChipsImpl : public ChipsInterface\n{\npublic:\n    virtual void size()\n    {\n        qDebug() << "这个大份的薯条！";\n    }\n};\n\nclass LittleChipsImpl : public ChipsInterface\n{\npublic:\n    virtual void size()\n    {\n        qDebug() << "这个小份的薯条！";\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nFactoryProducer:\n\nclass FactoryProducer\n{\npublic:\n    enum Set\n    {\n        Set1,\n        Set2\n    };\n\npublic:\n    FactoryInterface * createSet(Set setNum)\n    {\n        switch (setNum) {\n        case Set1:\n            return new Set1FactoryImpl();\n        case Set2:\n            return new Set2FactoryImpl();\n        default:\n            return nullptr;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 代码位置\n\n设计模式/AbstractFactory\n\n\n# 使用感悟\n\n抽象工厂其实并不是一个复杂概念，其实抽象工厂就是工厂模式的一般现象，工厂模式就是抽象工厂的个例。\n\n抽象工厂想要新增一个套餐是简单的，但是想要在套餐中新增一个项就比较不友好。\n\n抽象工厂适用于整套的替换场景中。',normalizedContent:'啃得鸡自从产品被抄袭，就很紧张；经过市场部讨论后，希望通过套餐的方式去打动用户。\n\n套餐：（冰淇淋 + 薯条）\n\n现再的问题是套餐产品怎么搞嗯？\n\n\n\n\n# 场景分析\n\n不同于我们之前生产的产品，套餐类产品都是由不同的部分去构成，同一部分再不同套餐中不尽相同；不能在一个工厂内生产所有套餐产品。\n\n所以我们需要多个工厂\n\n抽象工厂是生成一系列对象的方法。\n\n\n# 实现\n\n\n\n抽象工厂对比工厂模式，发现工厂是抽象工厂的特例。当抽象工厂的产品只有一种时，就是工厂模式。\n\n\n# 代码\n\n产品1：冰淇淋\n\n// 冰淇淋接口\nclass icecreaminterface\n{\npublic:\n    virtual ~icecreaminterface() {}\n    virtual void taste() = 0;\n};\n\n// 香草冰淇淋\nclass vanillaicecreamimpl : public icecreaminterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("香草冰淇淋的味道！");\n    }\n};\n\n// 草莓冰淇淋\nclass strawberryicecreamimpl : public icecreaminterface\n{\npublic:\n    virtual void taste() override\n    {\n        qdebug() << qstringliteral("草莓冰淇淋的味道！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n产品2：薯条\n\nclass chipsinterface\n{\npublic:\n    virtual ~chipsinterface() {}\n    virtual void size() = 0;\n};\n\nclass bigchipsimpl : public chipsinterface\n{\npublic:\n    virtual void size()\n    {\n        qdebug() << "这个大份的薯条！";\n    }\n};\n\nclass littlechipsimpl : public chipsinterface\n{\npublic:\n    virtual void size()\n    {\n        qdebug() << "这个小份的薯条！";\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nfactoryproducer:\n\nclass factoryproducer\n{\npublic:\n    enum set\n    {\n        set1,\n        set2\n    };\n\npublic:\n    factoryinterface * createset(set setnum)\n    {\n        switch (setnum) {\n        case set1:\n            return new set1factoryimpl();\n        case set2:\n            return new set2factoryimpl();\n        default:\n            return nullptr;\n        }\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# 代码位置\n\n设计模式/abstractfactory\n\n\n# 使用感悟\n\n抽象工厂其实并不是一个复杂概念，其实抽象工厂就是工厂模式的一般现象，工厂模式就是抽象工厂的个例。\n\n抽象工厂想要新增一个套餐是简单的，但是想要在套餐中新增一个项就比较不友好。\n\n抽象工厂适用于整套的替换场景中。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"模板方法",frontmatter:{title:"模板方法",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/dfc73d/",categories:["设计模式"],tags:["模板方法"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/7.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/7.模板方法模式.md",key:"v-8650f030",path:"/pages/dfc73d/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:81},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:218},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:227},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1178},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:1202}],excerpt:'<p>啃得鸡自从通过抽象工厂解决套餐模式后，流量大增；但暂时盈利达到了上限。于是希望节流，发现工厂流程很多重复项，希望可以通过统一生产流程来做到成本优化。</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-%E6%B5%81%E6%B0%B4%E7%BA%BF.webp" alt="流水线"></p>\n',headersStr:"场景分析 实现 代码 代码位置 使用感悟",content:'啃得鸡自从通过抽象工厂解决套餐模式后，流量大增；但暂时盈利达到了上限。于是希望节流，发现工厂流程很多重复项，希望可以通过统一生产流程来做到成本优化。\n\n\n\n\n# 场景分析\n\n简化场景，只生产冰淇淋甜筒。我们发现冰淇淋甜筒就是薄饼筒和冰淇淋球的组合。不同口味的冰淇淋，薄饼筒是不变的，换不同的冰淇淋球。\n\n模板方法是一个你在下意识的情况下就会使用的方法。\n\n模板方法的核心思想就是将流程中的细节（变化的地方）；下放到子类中解决。\n\n\n# 实现\n\n\n\n\n# 代码\n\n模板方法：\n\nclass FactoryTemplate\n{\npublic:\n    virtual ~FactoryTemplate() {}\n    IceCream createIceCream()\n    {\n        IceCream oIceCream;\n        createCone(oIceCream);\n        createIceBall(oIceCream);\n        return oIceCream;\n    }\n\nprotected:\n    void createCone(IceCream &iceCream)\n    {\n        iceCream.setCone();\n    }\n\n    virtual void createIceBall(IceCream &iceCream) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n子类：\n\nclass StrawberryFactory : public FactoryTemplate\n{\npublic:\n    virtual ~StrawberryFactory() {}\nprotected:\n    virtual void createIceBall(IceCream &iceCream)\n    {\n        iceCream.setIceBall(QStringLiteral("草莓"));\n    }\n};\n\nclass VanillaFactory : public FactoryTemplate\n{\npublic:\n    virtual ~VanillaFactory() {}\nprotected:\n    virtual void createIceBall(IceCream &iceCream)\n    {\n        iceCream.setIceBall(QStringLiteral("香草"));\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 代码位置\n\n设计模式/Template\n\n\n# 使用感悟\n\n模板方法的基本思路：\n\n基于继承的情况上，封装不变的部分，扩展可变的部分。\n\n优点：1、更好的代码复用性；2、父类封装控制，子类实现细节；实现更可控\n\n缺点：1、类的增加，导致实现更复杂',normalizedContent:'啃得鸡自从通过抽象工厂解决套餐模式后，流量大增；但暂时盈利达到了上限。于是希望节流，发现工厂流程很多重复项，希望可以通过统一生产流程来做到成本优化。\n\n\n\n\n# 场景分析\n\n简化场景，只生产冰淇淋甜筒。我们发现冰淇淋甜筒就是薄饼筒和冰淇淋球的组合。不同口味的冰淇淋，薄饼筒是不变的，换不同的冰淇淋球。\n\n模板方法是一个你在下意识的情况下就会使用的方法。\n\n模板方法的核心思想就是将流程中的细节（变化的地方）；下放到子类中解决。\n\n\n# 实现\n\n\n\n\n# 代码\n\n模板方法：\n\nclass factorytemplate\n{\npublic:\n    virtual ~factorytemplate() {}\n    icecream createicecream()\n    {\n        icecream oicecream;\n        createcone(oicecream);\n        createiceball(oicecream);\n        return oicecream;\n    }\n\nprotected:\n    void createcone(icecream &icecream)\n    {\n        icecream.setcone();\n    }\n\n    virtual void createiceball(icecream &icecream) = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n子类：\n\nclass strawberryfactory : public factorytemplate\n{\npublic:\n    virtual ~strawberryfactory() {}\nprotected:\n    virtual void createiceball(icecream &icecream)\n    {\n        icecream.seticeball(qstringliteral("草莓"));\n    }\n};\n\nclass vanillafactory : public factorytemplate\n{\npublic:\n    virtual ~vanillafactory() {}\nprotected:\n    virtual void createiceball(icecream &icecream)\n    {\n        icecream.seticeball(qstringliteral("香草"));\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 代码位置\n\n设计模式/template\n\n\n# 使用感悟\n\n模板方法的基本思路：\n\n基于继承的情况上，封装不变的部分，扩展可变的部分。\n\n优点：1、更好的代码复用性；2、父类封装控制，子类实现细节；实现更可控\n\n缺点：1、类的增加，导致实现更复杂',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"策略模式",frontmatter:{title:"策略模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/37ea50/",categories:["设计模式"],tags:["策略模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/8.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/8.策略模式.md",key:"v-9418c160",path:"/pages/37ea50/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:106},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:242},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:251},{level:4,title:"代码位置",slug:"代码位置",normalizedTitle:"代码位置",charIndex:1162},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:1186}],excerpt:'<p>啃得鸡的节流策略很成功，但是节流是有上限的。内卷完了，还是要想想怎么开源。</p>\n<p>于是相到通过促销的方式培养用户习惯。</p>\n<p>现在有两个促销：</p>\n<ol>\n<li>一、三、五  薯条免费</li>\n<li>二、四、六  冰淇淋半价</li>\n</ol>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%89%93%E9%AA%A8%E6%8A%98.webp" alt="打骨折"></p>\n',headersStr:"场景分析 实现 代码 代码位置 使用感悟",content:'啃得鸡的节流策略很成功，但是节流是有上限的。内卷完了，还是要想想怎么开源。\n\n于是相到通过促销的方式培养用户习惯。\n\n现在有两个促销：\n\n 1. 一、三、五 薯条免费\n 2. 二、四、六 冰淇淋半价\n\n\n\n\n# 场景分析\n\n现在我们有两个需要做的策略，需要随着时间的变化，去执行不同的策略。\n\n执行策略的主体的不变的，行为是变化的。\n\n策略模式是对算法的封装，将一组算法和算法作用的数据分开，使算法可以独立变化。\n\n通过抽提共有接口，每个算法单独封装，算法之间可以相互替换。\n\n\n# 实现\n\n\n\n\n# 代码\n\n接口：\n\nclass SaleStrategyInterface\n{\npublic:\n    virtual ~SaleStrategyInterface() {}\n    virtual void promotion() = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n实现：\n\nclass IceCream_halfFareImpl : public SaleStrategyInterface\n{\npublic:\n    virtual void promotion() override\n    {\n        qDebug() << QStringLiteral("冰淇淋半价！");\n    }\n};\n\nclass Chips_freeImpl : public SaleStrategyInterface\n{\npublic:\n    virtual void promotion() override\n    {\n        qDebug() << QStringLiteral("薯条免费！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用:\n\nclass Shop\n{\npublic:\n    Shop():m_pStrategy(nullptr) {}\n    ~Shop() {delete m_pStrategy;}\n    void sell()\n    {\n        m_pStrategy->promotion();\n    }\n\n    void getStrategy(SaleStrategyInterface *strategy)\n    {\n        delete m_pStrategy;\n        m_pStrategy = strategy;\n    }\n\nprivate:\n    SaleStrategyInterface *m_pStrategy;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 代码位置\n\n设计模式/Strategy\n\n\n# 使用感悟\n\n策略模式的本质是对算法的封装，使算法的使用者和算法本身可以自由变化。\n\n优点：1、扩展性好；2、可以自由切换策略，对象复用性高\n\n缺点：所有算法都需要暴露给客户段，维护成本变高\n\n可以考虑结合简单工厂，对策略本身也进行一层封装；减少暴露。',normalizedContent:'啃得鸡的节流策略很成功，但是节流是有上限的。内卷完了，还是要想想怎么开源。\n\n于是相到通过促销的方式培养用户习惯。\n\n现在有两个促销：\n\n 1. 一、三、五 薯条免费\n 2. 二、四、六 冰淇淋半价\n\n\n\n\n# 场景分析\n\n现在我们有两个需要做的策略，需要随着时间的变化，去执行不同的策略。\n\n执行策略的主体的不变的，行为是变化的。\n\n策略模式是对算法的封装，将一组算法和算法作用的数据分开，使算法可以独立变化。\n\n通过抽提共有接口，每个算法单独封装，算法之间可以相互替换。\n\n\n# 实现\n\n\n\n\n# 代码\n\n接口：\n\nclass salestrategyinterface\n{\npublic:\n    virtual ~salestrategyinterface() {}\n    virtual void promotion() = 0;\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n实现：\n\nclass icecream_halffareimpl : public salestrategyinterface\n{\npublic:\n    virtual void promotion() override\n    {\n        qdebug() << qstringliteral("冰淇淋半价！");\n    }\n};\n\nclass chips_freeimpl : public salestrategyinterface\n{\npublic:\n    virtual void promotion() override\n    {\n        qdebug() << qstringliteral("薯条免费！");\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用:\n\nclass shop\n{\npublic:\n    shop():m_pstrategy(nullptr) {}\n    ~shop() {delete m_pstrategy;}\n    void sell()\n    {\n        m_pstrategy->promotion();\n    }\n\n    void getstrategy(salestrategyinterface *strategy)\n    {\n        delete m_pstrategy;\n        m_pstrategy = strategy;\n    }\n\nprivate:\n    salestrategyinterface *m_pstrategy;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 代码位置\n\n设计模式/strategy\n\n\n# 使用感悟\n\n策略模式的本质是对算法的封装，使算法的使用者和算法本身可以自由变化。\n\n优点：1、扩展性好；2、可以自由切换策略，对象复用性高\n\n缺点：所有算法都需要暴露给客户段，维护成本变高\n\n可以考虑结合简单工厂，对策略本身也进行一层封装；减少暴露。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"享元模式",frontmatter:{title:"享元模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/fc67c3/",categories:["设计模式"],tags:["享元模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/9.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html",relativePath:"软件设计--设计模式/9.享元模式.md",key:"v-00827dda",path:"/pages/fc67c3/",headers:[{level:2,title:"场景分析",slug:"场景分析",normalizedTitle:"场景分析",charIndex:52},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:218},{level:3,title:"代码",slug:"代码",normalizedTitle:"代码",charIndex:227},{level:4,title:"代码路径",slug:"代码路径",normalizedTitle:"代码路径",charIndex:1134},{level:2,title:"使用感悟",slug:"使用感悟",normalizedTitle:"使用感悟",charIndex:1159}],excerpt:'<p>啃得鸡通过促销的方式，已经做了一个爆款店铺。现在希望在其他99家点评也使用这样的促销策略。</p>\n<p><img src="https://cdn.addai.cn/blog/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BF%83%E9%94%80.webp" alt="促销"></p>\n',headersStr:"场景分析 实现 代码 代码路径 使用感悟",content:'啃得鸡通过促销的方式，已经做了一个爆款店铺。现在希望在其他99家点评也使用这样的促销策略。\n\n\n\n\n# 场景分析\n\n现在我们有100家店铺需要做促销，促销方案有2种。如果是每个店自己做自己的，就要200个策略对象。\n\n这当然不是我们希望看到的！\n\n我们希望只要建两个策略对象就可以了，100家店铺共用这两个策略对象。\n\n享元模式又叫"蝇量模式"是一种通过减少创建对象的个数，来降低内存,提供效率的方式；是一种结构化的设计模式。\n\n\n# 实现\n\n\n\n\n# 代码\n\n享元工厂\n\nclass FlyweightFactory\n{\npublic:\n    enum StrategyType\n    {\n        IceCream_halfFare,\n        Chips_free\n    };\npublic:\n    ~FlyweightFactory()\n    {\n        qDeleteAll(m_oStrategyMap.values());\n    }\n\n    SaleStrategyInterface* getStrategy(StrategyType type)\n    {\n        if (!m_oStrategyMap.contains(type))\n        {\n            switch (type)\n            {\n            case IceCream_halfFare:\n                m_oStrategyMap.insert(type, new IceCream_halfFareImpl());\n                break;\n            case Chips_free:\n                m_oStrategyMap.insert(type, new Chips_freeImpl());\n                break;\n            default:\n                break;\n            }\n        }\n        return m_oStrategyMap[type];\n    }\n\nprivate:\n    QMap<int, SaleStrategyInterface*> m_oStrategyMap;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 代码路径\n\n设计模式/Flyweight\n\n\n# 使用感悟\n\n享元模式的目的是通过减少对象的创建，来达到减少内存，提供效率的目的；\n\n它设计的重点在于HashMap是使用，我们需要为HashMap找到一个唯一的特征值。\n\nHashMap一般放在享元工厂中管理。\n\n**优点：**提高对象复用率，提高效率\n\n适用场景：\n\n 1. 大量相似或相同对象。\n 2. 这些对象占用大量内存，或影响效率。\n 3. 不同对象对外部执行无影响\n\n进一步思考：\n\n我们之前的实例其实是每种享元对象都最少创建一个，当这些享元对象之间又存在大量相同的数据如何处理？\n\n这时我们需要引入两个概念：\n\n * 内蕴状态(Internal State)：存储在享元对象内部且不会随环境改变而改变。因此内蕴状态并可以共享。\n * 外蕴状态(External State)：是随环境改变而改变的、不可以共享的状态。\n\n为了解决这个问题，我们要为现有的对象抽去共性，即对内蕴状态归类，成为享元对象的基础（私有对象或基类数据）；\n\n外蕴状态由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。\n\n需要保证：外蕴状态与内蕴状态是相互独立的。\n\n实现举例:\n\n通过【P指针】的方式，多个对象共用一段内存属性。这段内存一般为只读属性（外部只提供只读接口，这样可以做多线程安全）。',normalizedContent:'啃得鸡通过促销的方式，已经做了一个爆款店铺。现在希望在其他99家点评也使用这样的促销策略。\n\n\n\n\n# 场景分析\n\n现在我们有100家店铺需要做促销，促销方案有2种。如果是每个店自己做自己的，就要200个策略对象。\n\n这当然不是我们希望看到的！\n\n我们希望只要建两个策略对象就可以了，100家店铺共用这两个策略对象。\n\n享元模式又叫"蝇量模式"是一种通过减少创建对象的个数，来降低内存,提供效率的方式；是一种结构化的设计模式。\n\n\n# 实现\n\n\n\n\n# 代码\n\n享元工厂\n\nclass flyweightfactory\n{\npublic:\n    enum strategytype\n    {\n        icecream_halffare,\n        chips_free\n    };\npublic:\n    ~flyweightfactory()\n    {\n        qdeleteall(m_ostrategymap.values());\n    }\n\n    salestrategyinterface* getstrategy(strategytype type)\n    {\n        if (!m_ostrategymap.contains(type))\n        {\n            switch (type)\n            {\n            case icecream_halffare:\n                m_ostrategymap.insert(type, new icecream_halffareimpl());\n                break;\n            case chips_free:\n                m_ostrategymap.insert(type, new chips_freeimpl());\n                break;\n            default:\n                break;\n            }\n        }\n        return m_ostrategymap[type];\n    }\n\nprivate:\n    qmap<int, salestrategyinterface*> m_ostrategymap;\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n# 代码路径\n\n设计模式/flyweight\n\n\n# 使用感悟\n\n享元模式的目的是通过减少对象的创建，来达到减少内存，提供效率的目的；\n\n它设计的重点在于hashmap是使用，我们需要为hashmap找到一个唯一的特征值。\n\nhashmap一般放在享元工厂中管理。\n\n**优点：**提高对象复用率，提高效率\n\n适用场景：\n\n 1. 大量相似或相同对象。\n 2. 这些对象占用大量内存，或影响效率。\n 3. 不同对象对外部执行无影响\n\n进一步思考：\n\n我们之前的实例其实是每种享元对象都最少创建一个，当这些享元对象之间又存在大量相同的数据如何处理？\n\n这时我们需要引入两个概念：\n\n * 内蕴状态(internal state)：存储在享元对象内部且不会随环境改变而改变。因此内蕴状态并可以共享。\n * 外蕴状态(external state)：是随环境改变而改变的、不可以共享的状态。\n\n为了解决这个问题，我们要为现有的对象抽去共性，即对内蕴状态归类，成为享元对象的基础（私有对象或基类数据）；\n\n外蕴状态由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。\n\n需要保证：外蕴状态与内蕴状态是相互独立的。\n\n实现举例:\n\n通过【p指针】的方式，多个对象共用一段内存属性。这段内存一般为只读属性（外部只提供只读接口，这样可以做多线程安全）。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"OO的世界",frontmatter:{title:"OO的世界",date:"2022-05-04T11:45:37.000Z",permalink:"/pages/3ea3c4/",categories:["面向对象"],tags:["面向对象"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/1.OO%E7%9A%84%E4%B8%96%E7%95%8C.html",relativePath:"软件设计--面向对象/1.OO的世界.md",key:"v-f8b33396",path:"/pages/3ea3c4/",headers:[{level:2,title:"Object Orient",slug:"object-orient",normalizedTitle:"object orient",charIndex:101},{level:2,title:"OOA",slug:"ooa",normalizedTitle:"ooa",charIndex:17},{level:3,title:"分析工具",slug:"分析工具",normalizedTitle:"分析工具",charIndex:275},{level:3,title:"OOA的执行过程",slug:"ooa的执行过程",normalizedTitle:"ooa的执行过程",charIndex:429},{level:3,title:"OOA的产物",slug:"ooa的产物",normalizedTitle:"ooa的产物",charIndex:985},{level:2,title:"OOD",slug:"ood",normalizedTitle:"ood",charIndex:27},{level:3,title:"OOD的主体工作",slug:"ood的主体工作",normalizedTitle:"ood的主体工作",charIndex:1391},{level:2,title:"OOP",slug:"oop",normalizedTitle:"oop",charIndex:37},{level:2,title:"OO的问题",slug:"oo的问题",normalizedTitle:"oo的问题",charIndex:2709}],excerpt:'<h1 id="oo的世界"><a class="header-anchor" href="#oo的世界">#</a> OO的世界</h1>\n<p>OO的整个家族：OOA面向对象分析、OOD面向对象设计、OOP面向对象编程。</p>\n<p>OOA分析产生结果（对象--类的文档），OOD依据OOA的结果进行规范化整理，以被OOP使用。</p>\n',headersStr:"Object Orient OOA 分析工具 OOA的执行过程 OOA的产物 OOD OOD的主体工作 OOP OO的问题",content:"# OO的世界\n\nOO的整个家族：OOA面向对象分析、OOD面向对象设计、OOP面向对象编程。\n\nOOA分析产生结果（对象--类的文档），OOD依据OOA的结果进行规范化整理，以被OOP使用。\n\n\n# Object Orient\n\n面向对象，是通过建立抽象模型，近可能的模拟人类的思维，使软件以一种接近人类认知的方式解决问题。以便开发、维护。\n\n\n# OOA\n\n面向对象分析（Object-oriented analysis），指在系统调查资料的基础上，对OO思路所需要的素材进行归类分析和整理。其实就是对OO进行细化，初步得到属性和方法。\n\n\n# 分析工具\n\n1、功能模型工具：用例图；把系统拆解为一个一个功能。\n\n2、静态模型工具：类图、对象图；通过描述对象——对象属性——对象间 的关系，把系统分解成互相协作的类，描述系统的静态模型。\n\n3、动态模型工具：时序图、协作图、状态图；通过描述在用例中对象的交互，和对象的状态；描述系统的动态行为。\n\n\n# OOA的执行过程\n\nOOA模型由5个层次和5个活动组成，并继续贯穿OOD过程中。\n\n> 5个层次：主题层、对象类层、结构层、属性层、服务层\n> \n> 5个活动：标识对象类、标识结构、定义主题、定义属性、定义服务\n\n5个活动具体指：\n\n标识对象类：对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界总某些事物的信息能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。\n\n标识结构：结构是指问题域的复杂性和连接关系。类成员结构反映了泛华—特化关系，整体-部分结构反映整体和局部之间的关系\n\n定义主题：主题是指事物的总体概貌和总体分析模型\n\n定义属性：属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。\n\n定义服务：服务是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择一个方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。\n\nPS：服务基本等同于函数方法。\n\nOOA里定义了两种对象类之间的结构：分类结构、组装结构\n\n> 分类结构：反映了一般与特殊的关系\n> \n> 组装结构：反映了整体与部分的关系\n\n\n# OOA的产物\n\nOOA的产物即为OOA工具的产物。通过用例图、类图、对象图、时序图、协作图、状态图；描述出的对象结构模型。\n\n\n# OOD\n\n面向对象设计（Object-oriented Design），是OO的中间过渡环节，通过对OOA的产物进行规范化整理，以便可以在OOP中更好的使用。\n\nOOD的目标是管理程序内部各部分的相互依赖。为了达到整个目的，OOD要求：\n\n1、程序分块，每块的规模应该小到可以管理的程度。\n\n2、分别将各个块隐藏在接口（interface）的后面，让他们只能通过接口交流。\n\n> ps：如果对应到设计模型的6大原则，可以近似看作为 ，迪米特原则和依赖倒置。\n\nOOD是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用OOD这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。\n\n\n# OOD的主体工作\n\n1、对象定义规格的求精过程\n\n> 对于OOA所抽象出来的对象-＆-类以及汇集的分析文档，OOD需要有一个根据设计要求整理和求精的过程，使之更能符合OOP的需要。这个整理和求精过程主要有两个方面：\n> \n> 一、是要根据面向对象的概念模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。\n> \n> 二、是进行分类整理，以便于下一步数据库设计和程序处理模块设计的需要。整理的方法主要是进行归类，对类一＆一对象、属性、方法和结构、主题进行归类。\n\n2、数据模型和数据库设计\n\n> 数据模型的设计需要确定类-＆-对象属性的内容、消息连接的方式、系统访问、数据模型的方法等。最后每个对象实例的数据都必须落实到面向对象的库结构模型中。\n\n3、优化\n\n> OOD的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳，优化包括对象和结构的优化、抽象、集成。\n> \n> 对象和结构的模块化表示OOD提供了一种范式，这种范式支持对类和结构的模块化。这种模块符合一般模块化所要求的所有特点，如信息隐蔽性好，内部聚合度强和模块之间耦合度弱等。\n> \n> 集成化使得单个构件有机地结合在一起，相互支持。\n\n具体步骤\n\n 1. 细化重组类\n 2. 细化和实现类之间关系，明确其可见性\n 3. 增加属性，指定属性的类型与可见性\n 4. 分配职责，定义执行每个职责的方法\n 5. 对消息驱动的系统，明确消息传递的方式\n 6. 利用设计模式进行局部设计\n 7. 画出详细的类图和时序图\n\n\n# OOP\n\n面向对象编程（Object Oriented Programming），是一种计算机编程架构；OOP的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。OOP达到了软件工程的三个主要目标：重用性、灵活性和扩展性。OOP=对象+类+继承+多态+消息，其中核心概念是类和对象。\n\n主要概念:\n\n> 抽象性 ： 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。\n> \n> 对象：可以对其做事情的一些东西。一个对象有状态、行为和标识三种属性。\n> \n> 类：一个共享相同结构和行为的对象的集合。\n> \n> 消息传递 ：一个对象调用了另一个对象的方法。\n> \n> 封装 ： 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。封装的基本单位为对象。\n> \n> 多态性 ： 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。\n> \n> 继承性 ：允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。\n> \n> 组件 ： 数据和功能一起在运行着的计算机程序中形成的单元，组件在 OOP 计算机程序中是模块和结构化的基础。\n\n\n# OO的问题\n\nOO是近可能的模拟人类的思维，来解决问题；但是OO是需要自顶向下的整体划分，对于一开始就自底向上的开发系统（如电路设计类依赖设计者熟练的技巧和丰富的经验的开发设计），OO会使得子模块混乱。",normalizedContent:"# oo的世界\n\noo的整个家族：ooa面向对象分析、ood面向对象设计、oop面向对象编程。\n\nooa分析产生结果（对象--类的文档），ood依据ooa的结果进行规范化整理，以被oop使用。\n\n\n# object orient\n\n面向对象，是通过建立抽象模型，近可能的模拟人类的思维，使软件以一种接近人类认知的方式解决问题。以便开发、维护。\n\n\n# ooa\n\n面向对象分析（object-oriented analysis），指在系统调查资料的基础上，对oo思路所需要的素材进行归类分析和整理。其实就是对oo进行细化，初步得到属性和方法。\n\n\n# 分析工具\n\n1、功能模型工具：用例图；把系统拆解为一个一个功能。\n\n2、静态模型工具：类图、对象图；通过描述对象——对象属性——对象间 的关系，把系统分解成互相协作的类，描述系统的静态模型。\n\n3、动态模型工具：时序图、协作图、状态图；通过描述在用例中对象的交互，和对象的状态；描述系统的动态行为。\n\n\n# ooa的执行过程\n\nooa模型由5个层次和5个活动组成，并继续贯穿ood过程中。\n\n> 5个层次：主题层、对象类层、结构层、属性层、服务层\n> \n> 5个活动：标识对象类、标识结构、定义主题、定义属性、定义服务\n\n5个活动具体指：\n\n标识对象类：对象是对数据及其处理方式的抽象，它反映了系统保存和处理现实世界总某些事物的信息能力。类是多个对象的共同属性和方法集合的描述，它包括如何在一个类中建立一个新对象的描述。\n\n标识结构：结构是指问题域的复杂性和连接关系。类成员结构反映了泛华—特化关系，整体-部分结构反映整体和局部之间的关系\n\n定义主题：主题是指事物的总体概貌和总体分析模型\n\n定义属性：属性就是数据元素，可用来描述对象或分类结构的实例，可在图中给出，并在对象的存储中指定。\n\n定义服务：服务是在收到消息后必须进行的一些处理方法：方法要在图中定义，并在对象的存储中指定。对于每个对象和结构来说，那些用来增加、修改、删除和选择一个方法本身都是隐含的（虽然它们是要在对象的存储中定义的，但并不在图上给出），而有些则是显示的。\n\nps：服务基本等同于函数方法。\n\nooa里定义了两种对象类之间的结构：分类结构、组装结构\n\n> 分类结构：反映了一般与特殊的关系\n> \n> 组装结构：反映了整体与部分的关系\n\n\n# ooa的产物\n\nooa的产物即为ooa工具的产物。通过用例图、类图、对象图、时序图、协作图、状态图；描述出的对象结构模型。\n\n\n# ood\n\n面向对象设计（object-oriented design），是oo的中间过渡环节，通过对ooa的产物进行规范化整理，以便可以在oop中更好的使用。\n\nood的目标是管理程序内部各部分的相互依赖。为了达到整个目的，ood要求：\n\n1、程序分块，每块的规模应该小到可以管理的程度。\n\n2、分别将各个块隐藏在接口（interface）的后面，让他们只能通过接口交流。\n\n> ps：如果对应到设计模型的6大原则，可以近似看作为 ，迪米特原则和依赖倒置。\n\nood是一种解决软件问题的设计范式（paradigm），一种抽象的范式。使用ood这种设计范式，我们可以用对象（object）来表现问题领域（problem domain）的实体，每个对象都有相应的状态和行为。\n\n\n# ood的主体工作\n\n1、对象定义规格的求精过程\n\n> 对于ooa所抽象出来的对象-＆-类以及汇集的分析文档，ood需要有一个根据设计要求整理和求精的过程，使之更能符合oop的需要。这个整理和求精过程主要有两个方面：\n> \n> 一、是要根据面向对象的概念模型整理分析所确定的对象结构、属性、方法等内容，改正错误的内容，删去不必要和重复的内容等。\n> \n> 二、是进行分类整理，以便于下一步数据库设计和程序处理模块设计的需要。整理的方法主要是进行归类，对类一＆一对象、属性、方法和结构、主题进行归类。\n\n2、数据模型和数据库设计\n\n> 数据模型的设计需要确定类-＆-对象属性的内容、消息连接的方式、系统访问、数据模型的方法等。最后每个对象实例的数据都必须落实到面向对象的库结构模型中。\n\n3、优化\n\n> ood的优化设计过程是从另一个角度对分析结果和处理业务过程的整理归纳，优化包括对象和结构的优化、抽象、集成。\n> \n> 对象和结构的模块化表示ood提供了一种范式，这种范式支持对类和结构的模块化。这种模块符合一般模块化所要求的所有特点，如信息隐蔽性好，内部聚合度强和模块之间耦合度弱等。\n> \n> 集成化使得单个构件有机地结合在一起，相互支持。\n\n具体步骤\n\n 1. 细化重组类\n 2. 细化和实现类之间关系，明确其可见性\n 3. 增加属性，指定属性的类型与可见性\n 4. 分配职责，定义执行每个职责的方法\n 5. 对消息驱动的系统，明确消息传递的方式\n 6. 利用设计模式进行局部设计\n 7. 画出详细的类图和时序图\n\n\n# oop\n\n面向对象编程（object oriented programming），是一种计算机编程架构；oop的一条基本原则是计算机程序由单个能够起到子程序作用的单元或对象组合而成。oop达到了软件工程的三个主要目标：重用性、灵活性和扩展性。oop=对象+类+继承+多态+消息，其中核心概念是类和对象。\n\n主要概念:\n\n> 抽象性 ： 程序有能力忽略正在处理中信息的某些方面，即对信息主要方面关注的能力。\n> \n> 对象：可以对其做事情的一些东西。一个对象有状态、行为和标识三种属性。\n> \n> 类：一个共享相同结构和行为的对象的集合。\n> \n> 消息传递 ：一个对象调用了另一个对象的方法。\n> \n> 封装 ： 也叫做信息封装：确保组件不会以不可预期的方式改变其它组件的内部状态；只有在那些提供了内部状态改变方法的组件中，才可以访问其内部状态。每类组件都提供了一个与其它组件联系的接口，并规定了其它组件进行调用的方法。封装的基本单位为对象。\n> \n> 多态性 ： 组件的引用和类集会涉及到其它许多不同类型的组件，而且引用组件所产生的结果得依据实际调用的类型。\n> \n> 继承性 ：允许在现存的组件基础上创建子类组件，这统一并增强了多态性和封装性。典型地来说就是用类来对组件进行分组，而且还可以定义新类为现存的类的扩展，这样就可以将类组织成树形或网状结构，这体现了动作的通用性。\n> \n> 组件 ： 数据和功能一起在运行着的计算机程序中形成的单元，组件在 oop 计算机程序中是模块和结构化的基础。\n\n\n# oo的问题\n\noo是近可能的模拟人类的思维，来解决问题；但是oo是需要自顶向下的整体划分，对于一开始就自底向上的开发系统（如电路设计类依赖设计者熟练的技巧和丰富的经验的开发设计），oo会使得子模块混乱。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"面向对象的核心概念",frontmatter:{title:"面向对象的核心概念",date:"2022-05-04T12:01:48.000Z",permalink:"/pages/9ac8f7/",categories:["面向对象"],tags:["面向对象"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5.html",relativePath:"软件设计--面向对象/2.面向对象的核心概念.md",key:"v-b1388684",path:"/pages/9ac8f7/",headers:[{level:2,title:"抽象、对象、类",slug:"抽象、对象、类",normalizedTitle:"抽象、对象、类",charIndex:76},{level:2,title:"封装、继承、多态",slug:"封装、继承、多态",normalizedTitle:"封装、继承、多态",charIndex:21},{level:2,title:"抽象类和接口",slug:"抽象类和接口",normalizedTitle:"抽象类和接口",charIndex:736}],excerpt:'<h1 id="面向对象的核心概念"><a class="header-anchor" href="#面向对象的核心概念">#</a> 面向对象的核心概念</h1>\n<p>抽象、对象，类、封装、继承、多态、接口、抽象类；这些组成了面向对象的基础，如果谈面向对象的程序设计；就要先了解它们。</p>\n',headersStr:"抽象、对象、类 封装、继承、多态 抽象类和接口",content:"# 面向对象的核心概念\n\n抽象、对象，类、封装、继承、多态、接口、抽象类；这些组成了面向对象的基础，如果谈面向对象的程序设计；就要先了解它们。\n\n\n# 抽象、对象、类\n\n抽象 是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程，是编程的基础。编程的本质就是对世界的近似描述，抽象的方向维度取决于实现的目的。\n\n对象 抽取一个特定事物的属性和行为的结果，就是一个对象。它携带者一个特定事物的特征抽象。\n\n类 抽取一类事物的属性和行为的结果，就是一个类。它携带者这类事物的特征，对类特化（给具体值）就是形成一个对象。\n\n\n# 封装、继承、多态\n\n封装 将抽象出的数据、行为进行有机结合；隐藏细节，指对外提供特定功能的接口；封装可以分级向外提供接口：public、protected、private。\n\n继承 描述父子类的关系，子类继承于父类；子类就是父类的一种特例，子类拥有父类的所有信息。继承的方式一般有：public、protected、private。\n\n多态指为不同数据类型的实体提供统一接口，并表现出不同的行为。\n\n可以分为：\n\n变量多态：基础类型变量可以被赋值基础类型对象，也可以被赋值派生类型对象。\n\n函数多态：给相同函数调用（函数名和实参数表），传递同一个对象，可以有不同的行为。行为有接受对象类型决定。\n\n也可以分为：\n\n动态多态：在运行期决定的多态，主要为通过虚继承的方式，实现父类，不同子类的实现不同；即override。\n\n静态多态：在编译期决定的多态\n\n> 静态多态分为：非参数化多态和参数化多态\n> \n> 非参数化多态：函数重载，运算符重载；即overload。\n> \n> 参数化多态：把类型做出参数的多态，泛型编程。\n\n\n# 抽象类和接口\n\n抽象类是用来捕捉子类的通用特性的，不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板；\n\n接口则是抽象方法的集合，只是一种形式，接口自身不能做任何事情。",normalizedContent:"# 面向对象的核心概念\n\n抽象、对象，类、封装、继承、多态、接口、抽象类；这些组成了面向对象的基础，如果谈面向对象的程序设计；就要先了解它们。\n\n\n# 抽象、对象、类\n\n抽象 是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征的过程，是编程的基础。编程的本质就是对世界的近似描述，抽象的方向维度取决于实现的目的。\n\n对象 抽取一个特定事物的属性和行为的结果，就是一个对象。它携带者一个特定事物的特征抽象。\n\n类 抽取一类事物的属性和行为的结果，就是一个类。它携带者这类事物的特征，对类特化（给具体值）就是形成一个对象。\n\n\n# 封装、继承、多态\n\n封装 将抽象出的数据、行为进行有机结合；隐藏细节，指对外提供特定功能的接口；封装可以分级向外提供接口：public、protected、private。\n\n继承 描述父子类的关系，子类继承于父类；子类就是父类的一种特例，子类拥有父类的所有信息。继承的方式一般有：public、protected、private。\n\n多态指为不同数据类型的实体提供统一接口，并表现出不同的行为。\n\n可以分为：\n\n变量多态：基础类型变量可以被赋值基础类型对象，也可以被赋值派生类型对象。\n\n函数多态：给相同函数调用（函数名和实参数表），传递同一个对象，可以有不同的行为。行为有接受对象类型决定。\n\n也可以分为：\n\n动态多态：在运行期决定的多态，主要为通过虚继承的方式，实现父类，不同子类的实现不同；即override。\n\n静态多态：在编译期决定的多态\n\n> 静态多态分为：非参数化多态和参数化多态\n> \n> 非参数化多态：函数重载，运算符重载；即overload。\n> \n> 参数化多态：把类型做出参数的多态，泛型编程。\n\n\n# 抽象类和接口\n\n抽象类是用来捕捉子类的通用特性的，不能被实例化，只能被用作子类的超类，是被用来创建继承层级里子类的模板；\n\n接口则是抽象方法的集合，只是一种形式，接口自身不能做任何事情。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"认知DDD",frontmatter:{title:"认知DDD",date:"2022-05-26T19:59:06.000Z",permalink:"/pages/34e57a/",categories:["领域驱动设计"],tags:[null]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/10.%E5%88%9D%E8%AF%86DDD.html",relativePath:"软件设计--领域驱动设计/10.初识DDD.md",key:"v-594dd699",path:"/pages/34e57a/",headers:[{level:2,title:"DDD来源介绍",slug:"ddd来源介绍",normalizedTitle:"ddd来源介绍",charIndex:2},{level:2,title:"DDD架构的核心",slug:"ddd架构的核心",normalizedTitle:"ddd架构的核心",charIndex:145},{level:2,title:"DDD适用场景",slug:"ddd适用场景",normalizedTitle:"ddd适用场景",charIndex:190},{level:2,title:"阅读前提",slug:"阅读前提",normalizedTitle:"阅读前提",charIndex:549},{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:566},{level:3,title:"第一部分：",slug:"第一部分",normalizedTitle:"第一部分：",charIndex:573},{level:3,title:"第二部分：",slug:"第二部分",normalizedTitle:"第二部分：",charIndex:619},{level:2,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:733}],headersStr:"DDD来源介绍 DDD架构的核心 DDD适用场景 阅读前提 目录 第一部分： 第二部分： 引用",content:"# DDD来源介绍\n\n领域建模和设计的重要性在很早之前就被一些软件开发人员所发现 ，Eric Evans将其定义为领域驱动设计（Domain-Driven Design，简称DDD）；近些年来这种自顶而下的设计方式越发被推崇。\n\n本文以代码为引，从小处入手；同大家一起学习DDD。\n\n\n# DDD架构的核心\n\n提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。\n\n\n# DDD适用场景\n\nDDD虽好，但不要贪杯。在实践DDD时，有两个点需要明确。\n\n1、领域模型对设计能力要求很高，没把握用好，一个错误的抽象还不如不抽象，宁可不要用，也不要滥用，不要为了DDD而DDD。\n\n理解：DDD的学习和使用是有代价的，一个零DDD基础的团队，不要期望在一个项目中完美的使用DDD；应该是一步一步的引入DDD的思想。\n\n2、只有复杂的系统才需要系统DDD。\n\n理解：DDD是为了治理业务而生的。\n\n这里的复杂分为三个层次：\n\n 1. 业务间有复杂的联动关系。\n\n 2. 系统需要持续维护，业务不断演化\n\n 3. 需要隔离技术复杂度的场景。\n\nddd的便捷，是基于业务抽象被不断复用的。如果业务抽象没有复用的必要，也没有系统引入ddd的必要。\n\n只需要使用一次的工具，不需要系统引入ddd。\n\n\n# 阅读前提\n\n了解面向对象\n\n\n# 目录\n\n\n# 第一部分：\n\n文章：\n\n1、DDD概览\n\n目标：\n\n1、简单了解DDD的知识范围。\n\n\n# 第二部分：\n\n文章：\n\n1、值对象、DP\n\n2、实体、领域服务、应用服务\n\n3、基于Cola的初步实践\n\n目标：\n\n1、对不了解DDD的同学，引导认知DDD。\n\n2、对在设计时DDD的同学，了解如何在编码中如何DDD。\n\n\n# 引用\n\n《领域驱动设计：软件核心复杂性应对之道》 作者： Eric Evans\n\n《实现领域驱动设计》 作者：Vaughn Vernon（沃恩.弗农）\n\n部分网络文章",normalizedContent:"# ddd来源介绍\n\n领域建模和设计的重要性在很早之前就被一些软件开发人员所发现 ，eric evans将其定义为领域驱动设计（domain-driven design，简称ddd）；近些年来这种自顶而下的设计方式越发被推崇。\n\n本文以代码为引，从小处入手；同大家一起学习ddd。\n\n\n# ddd架构的核心\n\n提倡以业务为核心，解耦外部依赖，分离业务复杂度和技术复杂度。\n\n\n# ddd适用场景\n\nddd虽好，但不要贪杯。在实践ddd时，有两个点需要明确。\n\n1、领域模型对设计能力要求很高，没把握用好，一个错误的抽象还不如不抽象，宁可不要用，也不要滥用，不要为了ddd而ddd。\n\n理解：ddd的学习和使用是有代价的，一个零ddd基础的团队，不要期望在一个项目中完美的使用ddd；应该是一步一步的引入ddd的思想。\n\n2、只有复杂的系统才需要系统ddd。\n\n理解：ddd是为了治理业务而生的。\n\n这里的复杂分为三个层次：\n\n 1. 业务间有复杂的联动关系。\n\n 2. 系统需要持续维护，业务不断演化\n\n 3. 需要隔离技术复杂度的场景。\n\nddd的便捷，是基于业务抽象被不断复用的。如果业务抽象没有复用的必要，也没有系统引入ddd的必要。\n\n只需要使用一次的工具，不需要系统引入ddd。\n\n\n# 阅读前提\n\n了解面向对象\n\n\n# 目录\n\n\n# 第一部分：\n\n文章：\n\n1、ddd概览\n\n目标：\n\n1、简单了解ddd的知识范围。\n\n\n# 第二部分：\n\n文章：\n\n1、值对象、dp\n\n2、实体、领域服务、应用服务\n\n3、基于cola的初步实践\n\n目标：\n\n1、对不了解ddd的同学，引导认知ddd。\n\n2、对在设计时ddd的同学，了解如何在编码中如何ddd。\n\n\n# 引用\n\n《领域驱动设计：软件核心复杂性应对之道》 作者： eric evans\n\n《实现领域驱动设计》 作者：vaughn vernon（沃恩.弗农）\n\n部分网络文章",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"DDD概览",frontmatter:{title:"DDD概览",date:"2022-05-29T20:51:30.000Z",permalink:"/pages/210a5b/",categories:["领域驱动设计"],tags:[null]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/20.DDD%E6%A6%82%E8%A7%88.html",relativePath:"软件设计--领域驱动设计/20.DDD概览.md",key:"v-bb5e48a0",path:"/pages/210a5b/",headers:[{level:2,title:"DDD基础概念概览",slug:"ddd基础概念概览",normalizedTitle:"ddd基础概念概览",charIndex:2}],headersStr:"DDD基础概念概览",content:"# DDD基础概念概览",normalizedContent:"# ddd基础概念概览",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"值对象、DP",frontmatter:{title:"值对象、DP",date:"2022-05-04T10:39:02.000Z",permalink:"/pages/e880da/",categories:["领域驱动设计"],tags:["DDD"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/30.%E5%80%BC%E5%AF%B9%E8%B1%A1%E3%80%81DP.html",relativePath:"软件设计--领域驱动设计/30.值对象、DP.md",key:"v-1df84aee",path:"/pages/e880da/",headers:[{level:2,title:"值对象",slug:"值对象",normalizedTitle:"值对象",charIndex:7},{level:2,title:"DP（Domain Primitive）",slug:"dp-domain-primitive",normalizedTitle:"dp（domain primitive）",charIndex:461},{level:2,title:"实例要求",slug:"实例要求",normalizedTitle:"实例要求",charIndex:618},{level:2,title:"常见代码",slug:"常见代码",normalizedTitle:"常见代码",charIndex:766},{level:2,title:"认知问题",slug:"认知问题",normalizedTitle:"认知问题",charIndex:2324},{level:3,title:"1、接口调用错误不能在前期识别",slug:"_1、接口调用错误不能在前期识别",normalizedTitle:"1、接口调用错误不能在前期识别",charIndex:2333},{level:3,title:"2、大量的数据校验逻辑，导致的不稳定性",slug:"_2、大量的数据校验逻辑-导致的不稳定性",normalizedTitle:"2、大量的数据校验逻辑，导致的不稳定性",charIndex:2493},{level:3,title:"3、胶水代码的存在，导致业务代码不清晰",slug:"_3、胶水代码的存在-导致业务代码不清晰",normalizedTitle:"3、胶水代码的存在，导致业务代码不清晰",charIndex:2893},{level:2,title:"代码优化实例",slug:"代码优化实例",normalizedTitle:"代码优化实例",charIndex:3971},{level:3,title:"让隐性的概念显性化",slug:"让隐性的概念显性化",normalizedTitle:"让隐性的概念显性化",charIndex:554},{level:3,title:"让隐性的上下文显性化",slug:"让隐性的上下文显性化",normalizedTitle:"让隐性的上下文显性化",charIndex:567},{level:3,title:"封装多对象行为",slug:"封装多对象行为",normalizedTitle:"封装多对象行为",charIndex:581},{level:2,title:"最终代码比较",slug:"最终代码比较",normalizedTitle:"最终代码比较",charIndex:5179},{level:2,title:"git代码",slug:"git代码",normalizedTitle:"git代码",charIndex:5192}],headersStr:"值对象 DP（Domain Primitive） 实例要求 常见代码 认知问题 1、接口调用错误不能在前期识别 2、大量的数据校验逻辑，导致的不稳定性 3、胶水代码的存在，导致业务代码不清晰 代码优化实例 让隐性的概念显性化 让隐性的上下文显性化 封装多对象行为 最终代码比较 git代码",content:'这篇详细介绍 值对象、DP 的含义，以及如何使用DP优化现有代码。\n\n\n# 值对象\n\n首先了解第一个概念：值对象\n\n《实现领域驱动设计》定义：\n\n> 描述了领域中的一件东西\n> \n> 不可变的\n> \n> 将不同的相关属性组合成了一个概念整体\n> \n> 当度量和描述改变时，可以用另外一个值对象予以替换\n> \n> 可以和其他值对象进行相等性比较\n> \n> 不会对协作对象造成副作用\n\n简单来说：以对象的形式，在DDD中起到值的作用。\n\n这里做一个类比的理解, 如果将一个复杂系统比做一个简单的程序。\n\n#include <iostream>\nusing namespace std;\nint main()\n{\n    ***\n\n    int a = 3;\n    int b = 4;\n    cout << a+b << endl;\n\n    ***\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上述代码中的int类型的a、b，就可以近似的理解为值对象。\n\n\n# DP（Domain Primitive）\n\nDP是在特定领域、拥有精准定义、可以自我验证、拥有行为的值对象（ValueObject）。 它是领域的最小组成部分。\n\nDP三原则：\n\n * 让隐性的概念显性化\n * 让隐性的上下文显性化\n * 封装多对象行为\n\nDP比较抽象，下面以实例的方式具体的介绍DP。\n\n\n# 实例要求\n\n一个简单的注册业务要求：\n\n> 1、参数为 客户姓名、手机号、地区；需要 校验姓名、手机号、地区信息的有效性。\n> \n> 2、根据手机号的归属地和所属运营商，查询得到关联的销售组信息，该销售组ID将作为用户的一个属性。\n> \n> 3、据用户信息，构建用户对象；并存入数据库；\n\n\n# 常见代码\n\npublic class User {\n    String name;\n    String phone;\n    String address;\n    Long repId;\n}\n\npublic class UserServiceImpl implements UserService {\n\n    public User register(String name, String phone, String address) \n      throws ValidationException {\n        // 校验逻辑\n        if (name == null || name.length() == 0) {\n            throw new ValidationException("name");\n        }\n        if (phone == null || !isValidPhoneNumber(phone)) {\n            throw new ValidationException("phone");\n        }\n        // 此处省略address的校验逻辑\n\n        // 取电话号里的区号，然后通过区号找到区域内的SalesRep\n        String areaCode = null;\n        String[] areas = new String[]{"0571", "021", "010"};\n        for (int i = 0; i < phone.length(); i++) {\n            String prefix = phone.substring(0, i);\n            if (Arrays.asList(areas).contains(prefix)) {\n                areaCode = prefix;\n                break;\n            }\n        }\n        //找到销售负责人（SalesRep）\n        SalesRep rep = salesRepRepo.findRep(areaCode);\n\n        // 最后创建用户，落盘，然后返回\n        User user = new User();\n        user.name = name;\n        user.phone = phone;\n        user.address = address;\n        if (null != rep) {\n          user.repId = rep.id;\n        }\n\n        return userRepo.save(user);\n    }\n\n    private boolean isValidPhoneNumber(String phone) {\n        String pattern = "^0[1-9]{2,3}-?\\\\d{8}$";\n        return phone.matches(pattern);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n找找问题？\n\n\n# 认知问题\n\n\n# 1、接口调用错误不能在前期识别\n\n具体来说调用函数：\n\npublic User register(String name, String phone, String address) \n\n\n1\n\n\n传参的错误,我们无法在编译前期知道,只能在业务运行到这来时，通过调试发现。\n\n常见错误有：\n\n * 参数顺序搞错\n\n\n# 2、大量的数据校验逻辑，导致的不稳定性\n\n// 校验逻辑\nif (name == null || name.length() == 0) {\n    throw new ValidationException("name");\n}\nif (phone == null || !isValidPhoneNumber(phone)) {\n    throw new ValidationException("phone");\n}\n// 此处省略address的校验逻辑\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n代码这里已经有三个逻辑判断，这里存在如下问题：\n\n 1. 代码的位置不合适，当业务判断发生变化时，需要【修改】、【测试】注册逻辑。\n 2. 代码复用不方便。例：号码可能被多个阶段使用，这里需要多份代码。\n 3. 多个判断，测试用例条件翻倍。\n 4. 业务异常和校验异常不能被合理区分。\n\n\n# 3、胶水代码的存在，导致业务代码不清晰\n\n> 从一些入参里抽取一部分数据，然后调用一个外部依赖获取更多的数据，然后从新的数据中再抽取部分数据用作其他的作用\n\n// 取电话号里的区号，然后通过区号找到区域内的SalesRep\nString areaCode = null;\nString[] areas = new String[]{"0571", "021", "010"};\nfor (int i = 0; i < phone.length(); i++) {\n    String prefix = phone.substring(0, i);\n    if (Arrays.asList(areas).contains(prefix)) {\n        areaCode = prefix;\n        break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段代码，就是一段截取区号的代码。本质上不应是独属于属于注册用户业务。对于这样的代码就需要被封装起来。\n\n//从号码中获取区号\nprivate static String findAreaCode(String phone) {\n    for (int i = 0; i < phone.length(); i++) {\n        String prefix = phone.substring(0, i);\n        if (isAreaCode(prefix)) {\n            return prefix;\n        }\n    }\n    return null;\n}\n//判断该区号是否存在\nprivate static boolean isAreaCode(String prefix) {\n    String[] areas = new String[]{"0571", "021"};\n    return Arrays.asList(areas).contains(prefix);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n原代码的调用：\n\n//获取区号\nString areaCode = findAreaCode(phone);\n//找到区号负责人\nSalesRep rep = salesRepRepo.findRep(areaCode);\n\n\n1\n2\n3\n4\n\n\n但即便这样，胶水痕迹依然存在；获取区号的能力，不应属于注册用户的service。\n\n\n# 代码优化实例\n\n这里我们使用DP的思想来，优化源代码。\n\n\n# 让隐性的概念显性化\n\n首先是【让隐性的概念显性化】；从代码上看，不难发现这段代码隐藏三个概念：name，phone，address\n\npublic User register(String name, String phone, String address) \n\n\n1\n\n\n以phone举例，对phone进行概念显性化。就是对phone进行封装。\n\n接口改为:\n\npublic User register(Name name, PhoneNum phone, Address address) \n\n// 调用：\nregister(new Name("小张"), new PhoneNum("123**1"), new Address("上海市 黄浦区 南京路 110号")) \n\n\n1\n2\n3\n4\n\n\n解决了第一个问题【接口调用错误不能在前期识别】， 同时可以在构造函数中添加有效性判断，以简化和解决第二个问题【大量的数据校验逻辑】 区号为电话号码的属性，应该封装到【PhoneNumber】中，这时就解决了第三个问题【业务代码不清晰】\n\n\n\n原代码的调用：\n\n//找到区号负责人\nSalesRep rep = salesRepRepo.findRep(phone.getAreaCode());\n\n\n1\n2\n\n\n\n# 让隐性的上下文显性化\n\n> 什么是：上下文？ 限界上下文是一个边界，领域模型便存在在这个边界之内。当模型被一个显示的边界所包围时，其中每个概念的含义便是确定的了。因此，限界上下文主要是一个语义上的边界。\n\n这句话表示的比较抽象，给一个简单的解释：前提，基础。\n\n举个例子：比较下两个地址\n\nnew Address("上海市 黄浦区 南京路 110号");\nnew Address("南京路 110号");\n\n\n1\n2\n\n\n地址一，我们很容易找到； 地址二，如果对于上海容易找到，但对于全国就难以确定了。\n\n这里 【上海市，黄浦区】就是 【南京路 110号】 的前提。\n\n同理，如果存在两个上海市，那么我们就需要【中国】这样的前提。\n\n因此我们需要将这些上下文显现的定义下来：\n\npublic class Address {\n  private final String country;\n  private final String province;\n  private final String city;\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 封装多对象行为\n\n这里指，一个DP可以封装多个DP的行为；及鼓励DP的重用。 希望Address和PhoneNumber，可以被重用；以减少重复代码。\n\n如Address和PhoneNumber，现在用于注册。如果这是一个电商系统，也可以用于商品的寄送。\n\n\n# 最终代码比较\n\n\n\n\n# git代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：领域模型/05Demo\n\n实例参考：https://blog.csdn.net/weixin_42596778/article/details/118938934',normalizedContent:'这篇详细介绍 值对象、dp 的含义，以及如何使用dp优化现有代码。\n\n\n# 值对象\n\n首先了解第一个概念：值对象\n\n《实现领域驱动设计》定义：\n\n> 描述了领域中的一件东西\n> \n> 不可变的\n> \n> 将不同的相关属性组合成了一个概念整体\n> \n> 当度量和描述改变时，可以用另外一个值对象予以替换\n> \n> 可以和其他值对象进行相等性比较\n> \n> 不会对协作对象造成副作用\n\n简单来说：以对象的形式，在ddd中起到值的作用。\n\n这里做一个类比的理解, 如果将一个复杂系统比做一个简单的程序。\n\n#include <iostream>\nusing namespace std;\nint main()\n{\n    ***\n\n    int a = 3;\n    int b = 4;\n    cout << a+b << endl;\n\n    ***\n    return 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上述代码中的int类型的a、b，就可以近似的理解为值对象。\n\n\n# dp（domain primitive）\n\ndp是在特定领域、拥有精准定义、可以自我验证、拥有行为的值对象（valueobject）。 它是领域的最小组成部分。\n\ndp三原则：\n\n * 让隐性的概念显性化\n * 让隐性的上下文显性化\n * 封装多对象行为\n\ndp比较抽象，下面以实例的方式具体的介绍dp。\n\n\n# 实例要求\n\n一个简单的注册业务要求：\n\n> 1、参数为 客户姓名、手机号、地区；需要 校验姓名、手机号、地区信息的有效性。\n> \n> 2、根据手机号的归属地和所属运营商，查询得到关联的销售组信息，该销售组id将作为用户的一个属性。\n> \n> 3、据用户信息，构建用户对象；并存入数据库；\n\n\n# 常见代码\n\npublic class user {\n    string name;\n    string phone;\n    string address;\n    long repid;\n}\n\npublic class userserviceimpl implements userservice {\n\n    public user register(string name, string phone, string address) \n      throws validationexception {\n        // 校验逻辑\n        if (name == null || name.length() == 0) {\n            throw new validationexception("name");\n        }\n        if (phone == null || !isvalidphonenumber(phone)) {\n            throw new validationexception("phone");\n        }\n        // 此处省略address的校验逻辑\n\n        // 取电话号里的区号，然后通过区号找到区域内的salesrep\n        string areacode = null;\n        string[] areas = new string[]{"0571", "021", "010"};\n        for (int i = 0; i < phone.length(); i++) {\n            string prefix = phone.substring(0, i);\n            if (arrays.aslist(areas).contains(prefix)) {\n                areacode = prefix;\n                break;\n            }\n        }\n        //找到销售负责人（salesrep）\n        salesrep rep = salesreprepo.findrep(areacode);\n\n        // 最后创建用户，落盘，然后返回\n        user user = new user();\n        user.name = name;\n        user.phone = phone;\n        user.address = address;\n        if (null != rep) {\n          user.repid = rep.id;\n        }\n\n        return userrepo.save(user);\n    }\n\n    private boolean isvalidphonenumber(string phone) {\n        string pattern = "^0[1-9]{2,3}-?\\\\d{8}$";\n        return phone.matches(pattern);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n找找问题？\n\n\n# 认知问题\n\n\n# 1、接口调用错误不能在前期识别\n\n具体来说调用函数：\n\npublic user register(string name, string phone, string address) \n\n\n1\n\n\n传参的错误,我们无法在编译前期知道,只能在业务运行到这来时，通过调试发现。\n\n常见错误有：\n\n * 参数顺序搞错\n\n\n# 2、大量的数据校验逻辑，导致的不稳定性\n\n// 校验逻辑\nif (name == null || name.length() == 0) {\n    throw new validationexception("name");\n}\nif (phone == null || !isvalidphonenumber(phone)) {\n    throw new validationexception("phone");\n}\n// 此处省略address的校验逻辑\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n代码这里已经有三个逻辑判断，这里存在如下问题：\n\n 1. 代码的位置不合适，当业务判断发生变化时，需要【修改】、【测试】注册逻辑。\n 2. 代码复用不方便。例：号码可能被多个阶段使用，这里需要多份代码。\n 3. 多个判断，测试用例条件翻倍。\n 4. 业务异常和校验异常不能被合理区分。\n\n\n# 3、胶水代码的存在，导致业务代码不清晰\n\n> 从一些入参里抽取一部分数据，然后调用一个外部依赖获取更多的数据，然后从新的数据中再抽取部分数据用作其他的作用\n\n// 取电话号里的区号，然后通过区号找到区域内的salesrep\nstring areacode = null;\nstring[] areas = new string[]{"0571", "021", "010"};\nfor (int i = 0; i < phone.length(); i++) {\n    string prefix = phone.substring(0, i);\n    if (arrays.aslist(areas).contains(prefix)) {\n        areacode = prefix;\n        break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段代码，就是一段截取区号的代码。本质上不应是独属于属于注册用户业务。对于这样的代码就需要被封装起来。\n\n//从号码中获取区号\nprivate static string findareacode(string phone) {\n    for (int i = 0; i < phone.length(); i++) {\n        string prefix = phone.substring(0, i);\n        if (isareacode(prefix)) {\n            return prefix;\n        }\n    }\n    return null;\n}\n//判断该区号是否存在\nprivate static boolean isareacode(string prefix) {\n    string[] areas = new string[]{"0571", "021"};\n    return arrays.aslist(areas).contains(prefix);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n原代码的调用：\n\n//获取区号\nstring areacode = findareacode(phone);\n//找到区号负责人\nsalesrep rep = salesreprepo.findrep(areacode);\n\n\n1\n2\n3\n4\n\n\n但即便这样，胶水痕迹依然存在；获取区号的能力，不应属于注册用户的service。\n\n\n# 代码优化实例\n\n这里我们使用dp的思想来，优化源代码。\n\n\n# 让隐性的概念显性化\n\n首先是【让隐性的概念显性化】；从代码上看，不难发现这段代码隐藏三个概念：name，phone，address\n\npublic user register(string name, string phone, string address) \n\n\n1\n\n\n以phone举例，对phone进行概念显性化。就是对phone进行封装。\n\n接口改为:\n\npublic user register(name name, phonenum phone, address address) \n\n// 调用：\nregister(new name("小张"), new phonenum("123**1"), new address("上海市 黄浦区 南京路 110号")) \n\n\n1\n2\n3\n4\n\n\n解决了第一个问题【接口调用错误不能在前期识别】， 同时可以在构造函数中添加有效性判断，以简化和解决第二个问题【大量的数据校验逻辑】 区号为电话号码的属性，应该封装到【phonenumber】中，这时就解决了第三个问题【业务代码不清晰】\n\n\n\n原代码的调用：\n\n//找到区号负责人\nsalesrep rep = salesreprepo.findrep(phone.getareacode());\n\n\n1\n2\n\n\n\n# 让隐性的上下文显性化\n\n> 什么是：上下文？ 限界上下文是一个边界，领域模型便存在在这个边界之内。当模型被一个显示的边界所包围时，其中每个概念的含义便是确定的了。因此，限界上下文主要是一个语义上的边界。\n\n这句话表示的比较抽象，给一个简单的解释：前提，基础。\n\n举个例子：比较下两个地址\n\nnew address("上海市 黄浦区 南京路 110号");\nnew address("南京路 110号");\n\n\n1\n2\n\n\n地址一，我们很容易找到； 地址二，如果对于上海容易找到，但对于全国就难以确定了。\n\n这里 【上海市，黄浦区】就是 【南京路 110号】 的前提。\n\n同理，如果存在两个上海市，那么我们就需要【中国】这样的前提。\n\n因此我们需要将这些上下文显现的定义下来：\n\npublic class address {\n  private final string country;\n  private final string province;\n  private final string city;\n  ...\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 封装多对象行为\n\n这里指，一个dp可以封装多个dp的行为；及鼓励dp的重用。 希望address和phonenumber，可以被重用；以减少重复代码。\n\n如address和phonenumber，现在用于注册。如果这是一个电商系统，也可以用于商品的寄送。\n\n\n# 最终代码比较\n\n\n\n\n# git代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：领域模型/05demo\n\n实例参考：https://blog.csdn.net/weixin_42596778/article/details/118938934',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"实体、领域服务、应用服务",frontmatter:{title:"实体、领域服务、应用服务",date:"2O22-05-05 1O:39:O2",permalink:"/pages/e88Odc/",categories:["领域驱动设计"],tags:["DDD"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/40.%E5%AE%9E%E4%BD%93%E3%80%81%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1.html",relativePath:"软件设计--领域驱动设计/40.实体、领域服务、应用服务.md",key:"v-69d20cf3",path:"/pages/e88Odc/",headers:[{level:2,title:"实例要求",slug:"实例要求",normalizedTitle:"实例要求",charIndex:35},{level:2,title:"常见代码",slug:"常见代码",normalizedTitle:"常见代码",charIndex:300},{level:2,title:"认识问题",slug:"认识问题",normalizedTitle:"认识问题",charIndex:2321},{level:3,title:"1、 数据库相关",slug:"_1、-数据库相关",normalizedTitle:"1、 数据库相关",charIndex:2475},{level:3,title:"2、外部系统提供的功能",slug:"_2、外部系统提供的功能",normalizedTitle:"2、外部系统提供的功能",charIndex:2691},{level:3,title:"3、其他业务",slug:"_3、其他业务",normalizedTitle:"3、其他业务",charIndex:2772},{level:2,title:"代码优化",slug:"代码优化",normalizedTitle:"代码优化",charIndex:2872},{level:3,title:"1、将实名验证部分抽离",slug:"_1、将实名验证部分抽离",normalizedTitle:"1、将实名验证部分抽离",charIndex:3002},{level:3,title:"2、将数据相关的进行抽提",slug:"_2、将数据相关的进行抽提",normalizedTitle:"2、将数据相关的进行抽提",charIndex:3452},{level:3,title:"3、抽离其他业务",slug:"_3、抽离其他业务",normalizedTitle:"3、抽离其他业务",charIndex:4798},{level:3,title:"4、最终的调用代码",slug:"_4、最终的调用代码",normalizedTitle:"4、最终的调用代码",charIndex:4990},{level:2,title:"git代码",slug:"git代码",normalizedTitle:"git代码",charIndex:5861}],headersStr:"实例要求 常见代码 认识问题 1、 数据库相关 2、外部系统提供的功能 3、其他业务 代码优化 1、将实名验证部分抽离 2、将数据相关的进行抽提 3、抽离其他业务 4、最终的调用代码 git代码",content:'这一节，主要通过实例的方式；解读：实体、领域服务、应用服务。\n\n\n# 实例要求\n\n> 1、参数为 客户姓名、手机号；需要 校验姓名、手机号、地区信息的有效性；并且需要做实名认证。\n> \n> 2、根据得到的实名信息，按照一定逻辑计算得出该用户的标签，该标签将作为用户的一个属性\n> \n> 3、根据手机号的归属地和所属运营商，查询得到关联的销售组信息，该销售组ID将作为用户的一个属性。\n> \n> 4、根据用户信息，构建用户对象和福利对象，并查询风控是否通过。\n> \n> 5、若通过，用户失去新客身份，且可以查询到福利信息，数据落库。 若不通过，用户保持新客身份，但查询不到福利信息，数据落库。\n\n\n# 常见代码\n\npublic class UserServiceImpl implements UserService {\n    @Resource\n    private UserMapper userMapper;\n    @Resource\n    private SalesMapper salesMapper;\n    @Resource\n    private RewardMapper rewardMapper;\n    @Autowired\n    private TelecomRealnameService telecomRealnameService;\n    @Autowired\n    private RiskControlService riskControlService;\n    @Override\n    public UserDO register(Name name, PhoneNumber phone) throws ValidationException {\n        //参数合法性校验已在PhoneNumber中处理\n        //参数一致性校验\n        TelecomInfoDTO telecomInfoDTO = telecomRealnameService.getRealnameInfo(phone.getPhone());\n        if (!name.getName().equals(telecomInfoDTO.getName())) {\n            throw new ValidationException("phone : " + phone.getPhone());\n        }\n        //计算用户标签\n        String label = getLabel(telecomInfoDTO);\n        //计算销售组\n        String salesId = getSalesId(phone);\n        //返回身份证\n        String idCard = telecomInfoDTO.getIdCard();\n        // 用户\n        UserDO userDO = new UserDO(idCard, name.getName(), phone.getPhone(), label, salesId);\n        // 对应新客奖励\n        RewardDO rewardDO = new RewardDO(idCard,label);\n        // 检查风控（查看库存等）\n        if( !riskControlService.check(idCard, label)) {\n            userDO.setNew(true);\n            rewardDO.setAvailable(false);\n        } else {\n            userDO.setNew(false);\n            rewardDO.setAvailable(true) ;\n        }\n        //存储信息\n        rewardMapper.insert(rewardDO) ;\n        return userMapper.insert(userDO);\n    }\n\n    private String getLabel(TelecomInfoDTO dto){\n        //本地逻辑处理\n        return "";\n    }\n\n    // 销售组ID\n    private String getSalesId(PhoneNumber phone) {\n        SalesDO salesDO = salesMapper.select(phone.getAreaCode(), phone.getOperatorCode());\n        if (salesDO != null){\n            return salesDO.getSalesId();\n        }\n        return null;\n    }\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n找找问题？\n\n\n# 认识问题\n\n核心问题：大量的外部依赖\n\n这里可能要问：什么叫外部依赖？\n\n内部： 当前业务范围\n\n特征：\n\n1、由当前业务自行控制。\n\n2、业务不变的情况下，是基本不会变动的，不可变动的。\n\n外部： 当前业务范围外\n\n特征：\n\n1、不受当前业务控制。\n\n2、业务不变的情况下，是可变动的，易变动的。\n\n\n# 1、 数据库相关\n\n数据库、数据表Scheme、ORM都属于外部依赖，都是外部依赖。\n\n如:\n\n当前使用是: MySql，后随业务发展，公司环境等等，换成：MongoDB。\n\n当前是：user表 和 reward表 是拆分的，后面由于别的业务存储的影响，需要改为一张表存储；或者需要增加字段。\n\n当前使用是: MyBatis，后面为了安全等原因，需要换位公司内统一使用的ORM，或者改为 JPA，或者 Hibernate。\n\n\n# 2、外部系统提供的功能\n\n外部系统提供的功能，大多的表现方式为RPC；\n\n如：当前的实名制验证，是依赖电信提供的服务。\n\n后面可能是换成移动，或者联通。\n\n\n# 3、其他业务\n\n顾名思义，就是不属于当前业务的；同时属于当前系统的部分。\n\n如: 新客奖励相关 和 注册业务没有比如关系。\n\n新客奖励，可能是指当前的一种优惠，后期可能就取消了，或者更换了。\n\n\n# 代码优化\n\n代码优化的思路也很简单。现在的代码，本质上是面向数据对象编程；而要做的是面向接口编程，也就是大家习以为常的提接口。\n\n接口的可以理解为是规则、协议；将接口以业务需要的方式做定义；由于业务的稳定，也就达到了接口稳定的目的。\n\n优化后的代码：\n\n\n# 1、将实名验证部分抽离\n\n\n\n这里的RealnameInfo，上篇学的DP。整个实名认证封装为一个接口：\n\npublic interface RealnameService {\n    RealnameInfo get(Name name, PhoneNumber phoneNumber) throws ValidationException;\n}\n\n@Service\npublic class RealnameServiceImpl implements RealnameService {\n\n    @Override\n    public RealnameInfo get(Name name, PhoneNumber phoneNumber) throws ValidationException {\n        return new RealnameInfo(name, phoneNumber);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2、将数据相关的进行抽提\n\n\n\na、创建数据库相关操作的接口\n\n// 接口\npublic interface UserRepo {\n    User save(User user);\n}\n\n// 实现\n@Component\npublic class UserRepoImpl implements UserRepo {\n    @Resource\n    UserMapper userMapper;\n    @Override\n    public User save(User user) {\n        UserDO userDO = UserBuilder.toDO(user);\n        userMapper.save(userDO);\n        return UserBuilder.toEntity(userDO);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nb、抽离User相关业务，填充到User User业务抽提出来\n\npublic class User {\n    // 用户id\n    private String userId;\n    // 用户名称\n    private Name name;\n    // 用户手机，DP\n    private PhoneNumber phone;\n    //用户标签，DP\n    private Label label;\n    //绑定销售id,DP\n    private Sales sales;\n    // 标志是否为新用户，默认为false\n    private Boolean fresh = false;\n    // 销售查询接口\n    private SalesRepo salesRepo;\n    //构造方法\n    public User(RealnameInfo info, PhoneNumber phone) throws ValidationException {\n        this.name = info.getName();\n        this.phone = phone;\n        this.label = info.getLabel();\n\n        this.salesRepo = SpringContextUtil.getBean(com.demo20.case2.repository.SalesRepo.class);\n        this.sales = salesRepo.find(phone);\n    }\n\n    public void fresh() {\n        this.fresh = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n这里的User就是实体；\n\n实体是有状态，在领域模型中具有唯一性；\n\n为了在它的连续变化中，有效的追踪它，它必须有一个唯一标志。\n\n\n# 3、抽离其他业务\n\n这里的新客礼物，本质上是对现有的User做检查，并同时更新其他的系统状态。\n\n这里就不好放在User实体内，如果强行放在User实体内，就会引起User的业务不稳定。\n\n这里抽提出一个用于User检查的service。\n\n\n\n这里的 CheckUserService 就是领域服务。\n\n领域服务：为了解决不好在一个实体内解决的业务问题，它一定是无状态的。\n\n\n# 4、最终的调用代码\n\n发现最终的调用代码是没有业务实现的。\n\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepo userRepo;\n    @Autowired\n    private CheckUserService checkUserService;\n    @Autowired\n    private RealnameService realnameService;\n\n    @Override\n    public User register(Name name, PhoneNumber phone) throws ValidationException {\n        // 查询实名信息(实名信息验证)\n        RealnameInfo realnameInfo = realnameService.get(name, phone);\n        // 构造对象\n        User user = new User(realnameInfo, phone);\n        // 检查User对象\n        checkUserService.check(user);\n        return userRepo.save(user);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这里的UserService, 就是应用服务。\n\n应用服务：是用来表达用例和用户故事（User Story)的主要手段。\n\n应用层经过应用服务接口来暴露系统的所有功能。在应用服务的实现中，它负责编排和转发，它将要实现的功能委托给一个或多个领域对象来实现，它自己只负责处理业务用例的执行顺序以及结果的拼装。经过这样一种方式，它隐藏了领域层的复杂性及其内部实现机制。\n\n应用服务：应该是很薄的一层。\n\n\n# git代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：领域模型/20Demo\n\n本文案例参照：https://www.bilibili.com/video/BV1Ci4y1978C?spm_id_from=333.88O.my_history.page.click',normalizedContent:'这一节，主要通过实例的方式；解读：实体、领域服务、应用服务。\n\n\n# 实例要求\n\n> 1、参数为 客户姓名、手机号；需要 校验姓名、手机号、地区信息的有效性；并且需要做实名认证。\n> \n> 2、根据得到的实名信息，按照一定逻辑计算得出该用户的标签，该标签将作为用户的一个属性\n> \n> 3、根据手机号的归属地和所属运营商，查询得到关联的销售组信息，该销售组id将作为用户的一个属性。\n> \n> 4、根据用户信息，构建用户对象和福利对象，并查询风控是否通过。\n> \n> 5、若通过，用户失去新客身份，且可以查询到福利信息，数据落库。 若不通过，用户保持新客身份，但查询不到福利信息，数据落库。\n\n\n# 常见代码\n\npublic class userserviceimpl implements userservice {\n    @resource\n    private usermapper usermapper;\n    @resource\n    private salesmapper salesmapper;\n    @resource\n    private rewardmapper rewardmapper;\n    @autowired\n    private telecomrealnameservice telecomrealnameservice;\n    @autowired\n    private riskcontrolservice riskcontrolservice;\n    @override\n    public userdo register(name name, phonenumber phone) throws validationexception {\n        //参数合法性校验已在phonenumber中处理\n        //参数一致性校验\n        telecominfodto telecominfodto = telecomrealnameservice.getrealnameinfo(phone.getphone());\n        if (!name.getname().equals(telecominfodto.getname())) {\n            throw new validationexception("phone : " + phone.getphone());\n        }\n        //计算用户标签\n        string label = getlabel(telecominfodto);\n        //计算销售组\n        string salesid = getsalesid(phone);\n        //返回身份证\n        string idcard = telecominfodto.getidcard();\n        // 用户\n        userdo userdo = new userdo(idcard, name.getname(), phone.getphone(), label, salesid);\n        // 对应新客奖励\n        rewarddo rewarddo = new rewarddo(idcard,label);\n        // 检查风控（查看库存等）\n        if( !riskcontrolservice.check(idcard, label)) {\n            userdo.setnew(true);\n            rewarddo.setavailable(false);\n        } else {\n            userdo.setnew(false);\n            rewarddo.setavailable(true) ;\n        }\n        //存储信息\n        rewardmapper.insert(rewarddo) ;\n        return usermapper.insert(userdo);\n    }\n\n    private string getlabel(telecominfodto dto){\n        //本地逻辑处理\n        return "";\n    }\n\n    // 销售组id\n    private string getsalesid(phonenumber phone) {\n        salesdo salesdo = salesmapper.select(phone.getareacode(), phone.getoperatorcode());\n        if (salesdo != null){\n            return salesdo.getsalesid();\n        }\n        return null;\n    }\n}  \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n找找问题？\n\n\n# 认识问题\n\n核心问题：大量的外部依赖\n\n这里可能要问：什么叫外部依赖？\n\n内部： 当前业务范围\n\n特征：\n\n1、由当前业务自行控制。\n\n2、业务不变的情况下，是基本不会变动的，不可变动的。\n\n外部： 当前业务范围外\n\n特征：\n\n1、不受当前业务控制。\n\n2、业务不变的情况下，是可变动的，易变动的。\n\n\n# 1、 数据库相关\n\n数据库、数据表scheme、orm都属于外部依赖，都是外部依赖。\n\n如:\n\n当前使用是: mysql，后随业务发展，公司环境等等，换成：mongodb。\n\n当前是：user表 和 reward表 是拆分的，后面由于别的业务存储的影响，需要改为一张表存储；或者需要增加字段。\n\n当前使用是: mybatis，后面为了安全等原因，需要换位公司内统一使用的orm，或者改为 jpa，或者 hibernate。\n\n\n# 2、外部系统提供的功能\n\n外部系统提供的功能，大多的表现方式为rpc；\n\n如：当前的实名制验证，是依赖电信提供的服务。\n\n后面可能是换成移动，或者联通。\n\n\n# 3、其他业务\n\n顾名思义，就是不属于当前业务的；同时属于当前系统的部分。\n\n如: 新客奖励相关 和 注册业务没有比如关系。\n\n新客奖励，可能是指当前的一种优惠，后期可能就取消了，或者更换了。\n\n\n# 代码优化\n\n代码优化的思路也很简单。现在的代码，本质上是面向数据对象编程；而要做的是面向接口编程，也就是大家习以为常的提接口。\n\n接口的可以理解为是规则、协议；将接口以业务需要的方式做定义；由于业务的稳定，也就达到了接口稳定的目的。\n\n优化后的代码：\n\n\n# 1、将实名验证部分抽离\n\n\n\n这里的realnameinfo，上篇学的dp。整个实名认证封装为一个接口：\n\npublic interface realnameservice {\n    realnameinfo get(name name, phonenumber phonenumber) throws validationexception;\n}\n\n@service\npublic class realnameserviceimpl implements realnameservice {\n\n    @override\n    public realnameinfo get(name name, phonenumber phonenumber) throws validationexception {\n        return new realnameinfo(name, phonenumber);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2、将数据相关的进行抽提\n\n\n\na、创建数据库相关操作的接口\n\n// 接口\npublic interface userrepo {\n    user save(user user);\n}\n\n// 实现\n@component\npublic class userrepoimpl implements userrepo {\n    @resource\n    usermapper usermapper;\n    @override\n    public user save(user user) {\n        userdo userdo = userbuilder.todo(user);\n        usermapper.save(userdo);\n        return userbuilder.toentity(userdo);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nb、抽离user相关业务，填充到user user业务抽提出来\n\npublic class user {\n    // 用户id\n    private string userid;\n    // 用户名称\n    private name name;\n    // 用户手机，dp\n    private phonenumber phone;\n    //用户标签，dp\n    private label label;\n    //绑定销售id,dp\n    private sales sales;\n    // 标志是否为新用户，默认为false\n    private boolean fresh = false;\n    // 销售查询接口\n    private salesrepo salesrepo;\n    //构造方法\n    public user(realnameinfo info, phonenumber phone) throws validationexception {\n        this.name = info.getname();\n        this.phone = phone;\n        this.label = info.getlabel();\n\n        this.salesrepo = springcontextutil.getbean(com.demo20.case2.repository.salesrepo.class);\n        this.sales = salesrepo.find(phone);\n    }\n\n    public void fresh() {\n        this.fresh = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n这里的user就是实体；\n\n实体是有状态，在领域模型中具有唯一性；\n\n为了在它的连续变化中，有效的追踪它，它必须有一个唯一标志。\n\n\n# 3、抽离其他业务\n\n这里的新客礼物，本质上是对现有的user做检查，并同时更新其他的系统状态。\n\n这里就不好放在user实体内，如果强行放在user实体内，就会引起user的业务不稳定。\n\n这里抽提出一个用于user检查的service。\n\n\n\n这里的 checkuserservice 就是领域服务。\n\n领域服务：为了解决不好在一个实体内解决的业务问题，它一定是无状态的。\n\n\n# 4、最终的调用代码\n\n发现最终的调用代码是没有业务实现的。\n\npublic class userserviceimpl implements userservice {\n    @autowired\n    private userrepo userrepo;\n    @autowired\n    private checkuserservice checkuserservice;\n    @autowired\n    private realnameservice realnameservice;\n\n    @override\n    public user register(name name, phonenumber phone) throws validationexception {\n        // 查询实名信息(实名信息验证)\n        realnameinfo realnameinfo = realnameservice.get(name, phone);\n        // 构造对象\n        user user = new user(realnameinfo, phone);\n        // 检查user对象\n        checkuserservice.check(user);\n        return userrepo.save(user);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这里的userservice, 就是应用服务。\n\n应用服务：是用来表达用例和用户故事（user story)的主要手段。\n\n应用层经过应用服务接口来暴露系统的所有功能。在应用服务的实现中，它负责编排和转发，它将要实现的功能委托给一个或多个领域对象来实现，它自己只负责处理业务用例的执行顺序以及结果的拼装。经过这样一种方式，它隐藏了领域层的复杂性及其内部实现机制。\n\n应用服务：应该是很薄的一层。\n\n\n# git代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：领域模型/20demo\n\n本文案例参照：https://www.bilibili.com/video/bv1ci4y1978c?spm_id_from=333.88o.my_history.page.click',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"基于Cola的初步实践",frontmatter:{title:"基于Cola的初步实践",date:"2022-05-05T13:39:02.000Z",permalink:"/pages/e880df/",categories:["领域驱动设计"],tags:["DDD","COLA"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/50.%E5%9F%BA%E4%BA%8ECola%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AE%9E%E8%B7%B5.html",relativePath:"软件设计--领域驱动设计/50.基于Cola的初步实践.md",key:"v-5d4c8520",path:"/pages/e880df/",headers:[{level:2,title:"业务要求",slug:"业务要求",normalizedTitle:"业务要求",charIndex:85},{level:2,title:"常见代码",slug:"常见代码",normalizedTitle:"常见代码",charIndex:225},{level:2,title:"认识问题",slug:"认识问题",normalizedTitle:"认识问题",charIndex:2488},{level:2,title:"1、解决分包不清晰",slug:"_1、解决分包不清晰",normalizedTitle:"1、解决分包不清晰",charIndex:3005},{level:3,title:"Cola 4.0 架构/框架",slug:"cola-4-0-架构-框架",normalizedTitle:"cola 4.0 架构/框架",charIndex:3195},{level:3,title:"分包后工程结构",slug:"分包后工程结构",normalizedTitle:"分包后工程结构",charIndex:4202},{level:2,title:"2、解决DTO臃肿问题",slug:"_2、解决dto臃肿问题",normalizedTitle:"2、解决dto臃肿问题",charIndex:4263},{level:2,title:"Git代码",slug:"git代码",normalizedTitle:"git代码",charIndex:7714},{level:2,title:"Cola组件介绍",slug:"cola组件介绍",normalizedTitle:"cola组件介绍",charIndex:7782}],headersStr:"业务要求 常见代码 认识问题 1、解决分包不清晰 Cola 4.0 架构/框架 分包后工程结构 2、解决DTO臃肿问题 Git代码 Cola组件介绍",content:'这一节，主要是介绍CQRS、基于COLA的分包方式。\n\n希望将领域模型的理论，应用到实战。\n\n既然要应用到实战，这里不经要问一个问题： 距离实战，还有多少差距？\n\n\n# 业务要求\n\n> 1、活动策划可以查看所有用户信息，并可以通过，手机号码、姓名、销售信息 里的一个或多个来查找用户，显示姓名，号码。\n> \n> 2、活动策划可以查看用户的详细信息，显示：姓名，号码，新手福利信息；并修改用户的新手福利。\n> \n> 3、用户可以自行注销账号。\n\n\n# 常见代码\n\n应用服务：\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepo userRepo;\n    @Autowired\n    private CheckUserService checkUserService;\n    @Autowired\n    private RealnameService realnameService;\n\n    @Override\n    public UserDTO register(Name name, PhoneNumber phone) throws ValidationException {\n        // 查询实名信息(实名信息验证)\n        RealnameInfo realnameInfo = realnameService.get(name, phone);\n        // 构造对象\n        User user = new User(realnameInfo, phone);\n        // 检查User对象\n        checkUserService.check(user);\n        return new UserDTO(userRepo.save(user));\n    }\n\n    @Override\n    public List<UserDTO> findList(UserParamDTO userParamDTO) {\n        List<User> userList = userRepo.find(userParamDTO);\n        List<UserDTO> userDTOList = new ArrayList<>();\n        userList.forEach(user -> {\n            userDTOList.add(new UserDTO(user));\n        });\n        return userDTOList;\n    }\n\n    @Override\n    public UserDTO find(UserParamDTO userParamDTO) {\n        if (null == userParamDTO.getUserId() || userParamDTO.getUserId().length() == 0) {\n            return null;\n        }\n        User user = userRepo.findById(userParamDTO.getUserId());\n        if (null != user) {\n            return new UserDTO(user);\n        }\n        return null;\n    }\n\n    @Override\n    public UserDTO setFresh(UserParamDTO userParamDTO) {\n        if (null == userParamDTO.getUserId() || userParamDTO.getUserId().length() == 0) {\n            return null;\n        }\n        User user = userRepo.findById(userParamDTO.getUserId());\n        if (null != user) {\n            // 设置用户为新客身份，以便发送新手礼包\n            user.setFresh(true);\n            // 检查User对象\n            checkUserService.check(user);\n            return new UserDTO(user);\n        }\n        return null;\n    }\n\n    @Override\n    public Boolean deleteOne(UserParamDTO userParamDTO) {\n        if (null == userParamDTO.getUserId() || userParamDTO.getUserId().length() == 0) {\n            return false;\n        }\n        return userRepo.delete(userParamDTO.getUserId());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# 认识问题\n\n1、前两章的问题，这里再次出现\n\n解决办法，回顾前两篇内容。\n\n2、随着不断的提取概念，经典的3层结构不能很好的容纳这些概念。\n\n\n\n3、多个请求使用一个DTO，导致DTO臃肿\n\n现在的UserParamDTO，被多个业务使用。导致DTO的臃肿，在传输中需要填充并不需要的字段。\n\n后续维护者，不知道DTO的成员变量有几重业务意义；只能不断膨胀。\n\n同时应用服务不断被修改，有业务外流的风险；也不符合开闭原则。\n\n@Data\npublic class UserParamDTO implements Serializable {\n    // 用户id\n    private String userId;\n    // 用户名称\n    private String name;\n    // 用户手机\n    private String phone;\n    //绑定销售id\n    private String salesId;\n    // 标志是否为新用户，默认为false\n    private Boolean fresh;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 1、解决分包不清晰\n\n相对经典的3层架构而言，DDD也有自己的分层架构方式。\n\nDDD的经典4层架构：用户接口层，应用层，领域层，基础设施层\n\n与原3层架构，对照如下。\n\n\n\n用于DDD分层的复杂性比较高，如： 具体代码如何划分，如何归属。\n\n这里推荐使用Cola的分层方式。\n\n目前Cola已经到4.0时代，经过4个版本的沉淀；笔者认为它已经是一个非常完善的架构方式。\n\n\n# Cola 4.0 架构/框架\n\nCOLA 4.0 架构分成COLA架构和COLA组件两个部分：\n\n 1. COLA架构：关注应用架构的定义和构建，提升应用质量。\n\n 2. COLA组件：提供应用开发所需要的可复用组件，提升研发效率。\n\n\n\nCOLA架构各个包结构的简要功能描述，如下表所示：\n\n层次           包名            功能                          必选\nAdapter层     web           处理页面请求的Controller           否\nAdapter层     wireless      处理无线端的适配                    否\nAdapter层     wap           处理wap端的适配                   否\nApp层         executor      处理request，包括command和query   是\nApp层         consumer      处理外部message                 否\nApp层         scheduler     处理定时任务                      否\nDomain层      model         领域模型                        否\nDomain层      ability       领域能力，包括DomainService        否\nDomain层      gateway       领域网关，解耦利器                   是\nInfra层       gatewayimpl   网关实现                        是\nInfra层       mapper        ibatis数据库映射                 否\nInfra层       config        配置信息                        否\nClient SDK   api           服务对外透出的API                  是\nClient SDK   dto           服务对外的DTO                    是\n\n\n# 分包后工程结构\n\n1、首先是用户接口层和应用层的填充。\n\n\n\n2、领域层的填充\n\n\n\n3、基础设施层 的填充\n\n\n\n\n# 2、解决DTO臃肿问题\n\n当前的DTO运行方式为：\n\n\n\n单一的DTO，在DDD中适配多个业务。DTO不断的被复杂化。\n\n为了解决这个问题，这里引入一个概念：\n\nCQRS（Command and Query Responsibility Segregation）命令和查询责任隔离\n\n为了解决传统DTO在DDD中的问题，提出了根据读写职责不同，把领域模型切分为command和query两个部分：\n\n\n\nCommand端与Query端都通过Application Service 进入系统，共享同一个数据库，但Command端只写入状态，Query端只读取状态。\n\n代码分包方式：\n\n\n\n定义和执行体：\n\n// 参数\n@Data\npublic class RegisterUserCmd extends Command {\n    // 用户名称\n    private String name;\n    // 用户手机\n    private String phone;\n}\n\n// 执行\n@Component\npublic class RegisterUserCmdExe {\n    @Autowired\n    private UserGateWay userGateWay;\n    @Autowired\n    private CheckUserService checkUserService;\n    @Autowired\n    private RealnameService realnameService;\n\n    public SingleResponse<UserDetailCO> execute(RegisterUserCmd registerUserCmd) {\n        try {\n            // 查询实名信息(实名信息验证)\n            RealnameInfo realnameInfo = realnameService.get(new Name(registerUserCmd.getName()), new PhoneNumber(registerUserCmd.getPhone()));\n            // 构造对象\n            User user = new User(realnameInfo, new PhoneNumber(registerUserCmd.getPhone()));\n            // 检查User对象\n            checkUserService.check(user);\n            return SingleResponse.of(new UserDetailCO(userGateWay.save(user)));\n        } catch (ValidationException e) {\n            e.printStackTrace();\n            return SingleResponse.buildFailure("401", e.getMessage());\n        }\n    }\n}\n\n// 返回值\n@Data\npublic class UserDetailCO implements Serializable {\n    // 用户id\n    private String userId;\n    // 用户名称\n    private String name;\n    // 用户手机\n    private String phone;\n    //用户标签\n    private String label;\n    //绑定销售id\n    private String salesId;\n    // 标志是否为新用户，默认为false\n    private Boolean fresh;\n\n    public UserDetailCO(User user) {\n        this.userId = user.getUserId();\n        this.name = user.getName().getName();\n        this.phone = user.getPhone().getPhone();\n        this.label = user.getLabel().toString();\n        this.salesId = user.getSales().getSalesId();\n        this.fresh = user.getFresh();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n调用代码：\n\n@Service\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    RegisterUserCmdExe registerUserCmdExe;\n    @Autowired\n    FindUsersQryExe findUsersQryExe;\n    @Autowired\n    FindUserQryExe findUserQryExe;\n    @Autowired\n    FreshUserCmdExe freshUserCmdExe;\n    @Autowired\n    DeleteUserCmdExe deleteUserCmdExe;\n\n    @Override\n    public SingleResponse<UserDetailCO> register(RegisterUserCmd registerUserCmd)  {\n        return registerUserCmdExe.execute(registerUserCmd);\n    }\n\n    @Override\n    public MultiResponse<UserSimpleCO> findList(FindUsersQry findUsersQry) {\n        return findUsersQryExe.execute(findUsersQry);\n    }\n\n    @Override\n    public SingleResponse<UserDetailCO> find(FindUserQry findUserQry) {\n        return findUserQryExe.execute(findUserQry);\n    }\n\n    @Override\n    public SingleResponse<UserDetailCO> setFresh(FreshUserCmd freshUserCmd) {\n        return freshUserCmdExe.execute(freshUserCmd);\n    }\n\n    @Override\n    public Response deleteOne(DeleteUserCmd deleteUserCmd) {\n        return deleteUserCmdExe.execute(deleteUserCmd);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n封装完成后，任何一个业务的参数变化，只会影响自己的业务情况。\n\n应用服务不会因为业务的变化而变化，具体的业务组织交个每个业务执行体做； 更符合单一职责。\n\n\n# Git代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：领域模型/30Demo\n\n\n# Cola组件介绍\n\nCOLA 组件：提供了一些框架级别的功能，提供应用开发所需要的可复用组件，提升研发效率。\n\n组件名称                               功能                                     版本      依赖\ncola-component-dto                 定义了DTO格式，包括分页                          1.0.0   无\ncola-component-exception           定义了异常格式，主要有BizException和SysException   1.0.0   无\ncola-component-statemachine        状态机组件                                  1.0.0   无\ncola-component-domain-starter      Spring托管的领域实体组件                        1.0.0   无\ncola-component-catchlog-starter    异常处理和日志组件                              1.0.0   exception,dto组件\ncola-component-extension-starter   扩展点组件                                  1.0.0   无\ncola-component-test-container      测试容器组件                                 1.0.0   无\n\n参考：《 COLA 4.0：应用架构的最佳实践》\n\n梳理文档时，借用了多篇文档的内容，目前以记不清晰；未能详细标记，望海涵。',normalizedContent:'这一节，主要是介绍cqrs、基于cola的分包方式。\n\n希望将领域模型的理论，应用到实战。\n\n既然要应用到实战，这里不经要问一个问题： 距离实战，还有多少差距？\n\n\n# 业务要求\n\n> 1、活动策划可以查看所有用户信息，并可以通过，手机号码、姓名、销售信息 里的一个或多个来查找用户，显示姓名，号码。\n> \n> 2、活动策划可以查看用户的详细信息，显示：姓名，号码，新手福利信息；并修改用户的新手福利。\n> \n> 3、用户可以自行注销账号。\n\n\n# 常见代码\n\n应用服务：\n\n@service\npublic class userserviceimpl implements userservice {\n    @autowired\n    private userrepo userrepo;\n    @autowired\n    private checkuserservice checkuserservice;\n    @autowired\n    private realnameservice realnameservice;\n\n    @override\n    public userdto register(name name, phonenumber phone) throws validationexception {\n        // 查询实名信息(实名信息验证)\n        realnameinfo realnameinfo = realnameservice.get(name, phone);\n        // 构造对象\n        user user = new user(realnameinfo, phone);\n        // 检查user对象\n        checkuserservice.check(user);\n        return new userdto(userrepo.save(user));\n    }\n\n    @override\n    public list<userdto> findlist(userparamdto userparamdto) {\n        list<user> userlist = userrepo.find(userparamdto);\n        list<userdto> userdtolist = new arraylist<>();\n        userlist.foreach(user -> {\n            userdtolist.add(new userdto(user));\n        });\n        return userdtolist;\n    }\n\n    @override\n    public userdto find(userparamdto userparamdto) {\n        if (null == userparamdto.getuserid() || userparamdto.getuserid().length() == 0) {\n            return null;\n        }\n        user user = userrepo.findbyid(userparamdto.getuserid());\n        if (null != user) {\n            return new userdto(user);\n        }\n        return null;\n    }\n\n    @override\n    public userdto setfresh(userparamdto userparamdto) {\n        if (null == userparamdto.getuserid() || userparamdto.getuserid().length() == 0) {\n            return null;\n        }\n        user user = userrepo.findbyid(userparamdto.getuserid());\n        if (null != user) {\n            // 设置用户为新客身份，以便发送新手礼包\n            user.setfresh(true);\n            // 检查user对象\n            checkuserservice.check(user);\n            return new userdto(user);\n        }\n        return null;\n    }\n\n    @override\n    public boolean deleteone(userparamdto userparamdto) {\n        if (null == userparamdto.getuserid() || userparamdto.getuserid().length() == 0) {\n            return false;\n        }\n        return userrepo.delete(userparamdto.getuserid());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n\n# 认识问题\n\n1、前两章的问题，这里再次出现\n\n解决办法，回顾前两篇内容。\n\n2、随着不断的提取概念，经典的3层结构不能很好的容纳这些概念。\n\n\n\n3、多个请求使用一个dto，导致dto臃肿\n\n现在的userparamdto，被多个业务使用。导致dto的臃肿，在传输中需要填充并不需要的字段。\n\n后续维护者，不知道dto的成员变量有几重业务意义；只能不断膨胀。\n\n同时应用服务不断被修改，有业务外流的风险；也不符合开闭原则。\n\n@data\npublic class userparamdto implements serializable {\n    // 用户id\n    private string userid;\n    // 用户名称\n    private string name;\n    // 用户手机\n    private string phone;\n    //绑定销售id\n    private string salesid;\n    // 标志是否为新用户，默认为false\n    private boolean fresh;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 1、解决分包不清晰\n\n相对经典的3层架构而言，ddd也有自己的分层架构方式。\n\nddd的经典4层架构：用户接口层，应用层，领域层，基础设施层\n\n与原3层架构，对照如下。\n\n\n\n用于ddd分层的复杂性比较高，如： 具体代码如何划分，如何归属。\n\n这里推荐使用cola的分层方式。\n\n目前cola已经到4.0时代，经过4个版本的沉淀；笔者认为它已经是一个非常完善的架构方式。\n\n\n# cola 4.0 架构/框架\n\ncola 4.0 架构分成cola架构和cola组件两个部分：\n\n 1. cola架构：关注应用架构的定义和构建，提升应用质量。\n\n 2. cola组件：提供应用开发所需要的可复用组件，提升研发效率。\n\n\n\ncola架构各个包结构的简要功能描述，如下表所示：\n\n层次           包名            功能                          必选\nadapter层     web           处理页面请求的controller           否\nadapter层     wireless      处理无线端的适配                    否\nadapter层     wap           处理wap端的适配                   否\napp层         executor      处理request，包括command和query   是\napp层         consumer      处理外部message                 否\napp层         scheduler     处理定时任务                      否\ndomain层      model         领域模型                        否\ndomain层      ability       领域能力，包括domainservice        否\ndomain层      gateway       领域网关，解耦利器                   是\ninfra层       gatewayimpl   网关实现                        是\ninfra层       mapper        ibatis数据库映射                 否\ninfra层       config        配置信息                        否\nclient sdk   api           服务对外透出的api                  是\nclient sdk   dto           服务对外的dto                    是\n\n\n# 分包后工程结构\n\n1、首先是用户接口层和应用层的填充。\n\n\n\n2、领域层的填充\n\n\n\n3、基础设施层 的填充\n\n\n\n\n# 2、解决dto臃肿问题\n\n当前的dto运行方式为：\n\n\n\n单一的dto，在ddd中适配多个业务。dto不断的被复杂化。\n\n为了解决这个问题，这里引入一个概念：\n\ncqrs（command and query responsibility segregation）命令和查询责任隔离\n\n为了解决传统dto在ddd中的问题，提出了根据读写职责不同，把领域模型切分为command和query两个部分：\n\n\n\ncommand端与query端都通过application service 进入系统，共享同一个数据库，但command端只写入状态，query端只读取状态。\n\n代码分包方式：\n\n\n\n定义和执行体：\n\n// 参数\n@data\npublic class registerusercmd extends command {\n    // 用户名称\n    private string name;\n    // 用户手机\n    private string phone;\n}\n\n// 执行\n@component\npublic class registerusercmdexe {\n    @autowired\n    private usergateway usergateway;\n    @autowired\n    private checkuserservice checkuserservice;\n    @autowired\n    private realnameservice realnameservice;\n\n    public singleresponse<userdetailco> execute(registerusercmd registerusercmd) {\n        try {\n            // 查询实名信息(实名信息验证)\n            realnameinfo realnameinfo = realnameservice.get(new name(registerusercmd.getname()), new phonenumber(registerusercmd.getphone()));\n            // 构造对象\n            user user = new user(realnameinfo, new phonenumber(registerusercmd.getphone()));\n            // 检查user对象\n            checkuserservice.check(user);\n            return singleresponse.of(new userdetailco(usergateway.save(user)));\n        } catch (validationexception e) {\n            e.printstacktrace();\n            return singleresponse.buildfailure("401", e.getmessage());\n        }\n    }\n}\n\n// 返回值\n@data\npublic class userdetailco implements serializable {\n    // 用户id\n    private string userid;\n    // 用户名称\n    private string name;\n    // 用户手机\n    private string phone;\n    //用户标签\n    private string label;\n    //绑定销售id\n    private string salesid;\n    // 标志是否为新用户，默认为false\n    private boolean fresh;\n\n    public userdetailco(user user) {\n        this.userid = user.getuserid();\n        this.name = user.getname().getname();\n        this.phone = user.getphone().getphone();\n        this.label = user.getlabel().tostring();\n        this.salesid = user.getsales().getsalesid();\n        this.fresh = user.getfresh();\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n调用代码：\n\n@service\npublic class userserviceimpl implements userservice {\n    @autowired\n    registerusercmdexe registerusercmdexe;\n    @autowired\n    findusersqryexe findusersqryexe;\n    @autowired\n    finduserqryexe finduserqryexe;\n    @autowired\n    freshusercmdexe freshusercmdexe;\n    @autowired\n    deleteusercmdexe deleteusercmdexe;\n\n    @override\n    public singleresponse<userdetailco> register(registerusercmd registerusercmd)  {\n        return registerusercmdexe.execute(registerusercmd);\n    }\n\n    @override\n    public multiresponse<usersimpleco> findlist(findusersqry findusersqry) {\n        return findusersqryexe.execute(findusersqry);\n    }\n\n    @override\n    public singleresponse<userdetailco> find(finduserqry finduserqry) {\n        return finduserqryexe.execute(finduserqry);\n    }\n\n    @override\n    public singleresponse<userdetailco> setfresh(freshusercmd freshusercmd) {\n        return freshusercmdexe.execute(freshusercmd);\n    }\n\n    @override\n    public response deleteone(deleteusercmd deleteusercmd) {\n        return deleteusercmdexe.execute(deleteusercmd);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n封装完成后，任何一个业务的参数变化，只会影响自己的业务情况。\n\n应用服务不会因为业务的变化而变化，具体的业务组织交个每个业务执行体做； 更符合单一职责。\n\n\n# git代码\n\n仓库位置：https://github.com/su-dd/demo.git\n\n代码位置：领域模型/30demo\n\n\n# cola组件介绍\n\ncola 组件：提供了一些框架级别的功能，提供应用开发所需要的可复用组件，提升研发效率。\n\n组件名称                               功能                                     版本      依赖\ncola-component-dto                 定义了dto格式，包括分页                          1.0.0   无\ncola-component-exception           定义了异常格式，主要有bizexception和sysexception   1.0.0   无\ncola-component-statemachine        状态机组件                                  1.0.0   无\ncola-component-domain-starter      spring托管的领域实体组件                        1.0.0   无\ncola-component-catchlog-starter    异常处理和日志组件                              1.0.0   exception,dto组件\ncola-component-extension-starter   扩展点组件                                  1.0.0   无\ncola-component-test-container      测试容器组件                                 1.0.0   无\n\n参考：《 cola 4.0：应用架构的最佳实践》\n\n梳理文档时，借用了多篇文档的内容，目前以记不清晰；未能详细标记，望海涵。',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"贫血模型和充血模型",frontmatter:{title:"贫血模型和充血模型",date:"2022-05-04T10:39:02.000Z",permalink:"/pages/e880db/",categories:["领域模型"],tags:["领域模型","DDD"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/60.%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B.html",relativePath:"软件设计--领域驱动设计/60.贫血模型和充血模型.md",key:"v-4c7328ea",path:"/pages/e880db/",headers:[{level:2,title:"贫血模型vs充血模型",slug:"贫血模型vs充血模型",normalizedTitle:"贫血模型vs充血模型",charIndex:135},{level:2,title:"举例说明",slug:"举例说明",normalizedTitle:"举例说明",charIndex:281},{level:2,title:"面向对象的角度",slug:"面向对象的角度",normalizedTitle:"面向对象的角度",charIndex:897},{level:2,title:"如何选择",slug:"如何选择",normalizedTitle:"如何选择",charIndex:1e3}],headersStr:"贫血模型vs充血模型 举例说明 面向对象的角度 如何选择",content:"在领域模型的概念里，两种定义方式。\n\n方式1 ： 失血模型、贫血模型、充血模型、涨血模型 四种概念。\n\n方式2：贫血模型、充血模型 两个概念。\n\n这里以 方式2做阐述。 这里认为：过多的概念并不能支持好的代码的产出，从简单的概念里阐述好的行为和不好的行为即可。\n\n\n# 贫血模型vs充血模型\n\n贫血模型：也称贫血领域对象，指仅用作数据载体，而没有行为和动作的领域对象。\n\n充血模型：也称充血领域对象，同时定义数据和行为的领域对象。\n\n个人理解：\n\n贫血模型：提供基本的数据支持，不包含实际业务逻辑。\n\n充血模型：提供数据支持，同时提供具体业务逻辑支持。\n\n\n# 举例说明\n\n如：计算学生的BMI。\n\n贫血模型：\n\nclass Student {\n    Long id;\n    double height;\n    double weight;\n\n    public double getHeight() {...}\n\tpublic double getWeight() {...}\n};\n\nclass ClassService {\n    public double getBMIByStudentId(long id) {...}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n充血模型：\n\nclass Student {\n    Long id;\n    double height;\n    double weight;\n\n    public double getHeight() {...}\n\tpublic double getWeight() {...}\n    public double getBMI() {...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对比两者代码，容易发现：\n\n 1. 贫血模型的业务，放在Service中。\n 2. 充血模型的业务，放在DP中。\n\n从业务重用上看：\n\n充血模型，业务重用的最小个体是DP。\n\n贫血模型，业务重用的最小个体为Service。如果Service包含其他业务就会导致不必要的依赖。\n\n\n# 面向对象的角度\n\n从OO的角度去审视贫血模型和充血模型，会发现：\n\n贫血模型的本质是在一堆数据上建立一个一个业务流程，是一个面向过程的实现方式。\n\n充血模型既有数据也有对应的行为，这是面向对象的。\n\n\n# 如何选择\n\n我们知道充血模型即要抽象属性，也要抽象行为；会比贫血模型更难设计。所以在选用时也有相应的偏好，或者有结合使用的情况。\n\n如果业务只是简单的CRUD，或者CRUD可以解决90%的业务情况。推荐使用贫血模型。其实大量的项目都是这样的简单项目。\n\n但是如果在做复杂的项目，拥有复杂的业务时，我们就需要使用充血模型；\n\nDDD是基于好的抽象，宁愿不抽象，也不要固执的做出不合理的抽象。",normalizedContent:"在领域模型的概念里，两种定义方式。\n\n方式1 ： 失血模型、贫血模型、充血模型、涨血模型 四种概念。\n\n方式2：贫血模型、充血模型 两个概念。\n\n这里以 方式2做阐述。 这里认为：过多的概念并不能支持好的代码的产出，从简单的概念里阐述好的行为和不好的行为即可。\n\n\n# 贫血模型vs充血模型\n\n贫血模型：也称贫血领域对象，指仅用作数据载体，而没有行为和动作的领域对象。\n\n充血模型：也称充血领域对象，同时定义数据和行为的领域对象。\n\n个人理解：\n\n贫血模型：提供基本的数据支持，不包含实际业务逻辑。\n\n充血模型：提供数据支持，同时提供具体业务逻辑支持。\n\n\n# 举例说明\n\n如：计算学生的bmi。\n\n贫血模型：\n\nclass student {\n    long id;\n    double height;\n    double weight;\n\n    public double getheight() {...}\n\tpublic double getweight() {...}\n};\n\nclass classservice {\n    public double getbmibystudentid(long id) {...}\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n充血模型：\n\nclass student {\n    long id;\n    double height;\n    double weight;\n\n    public double getheight() {...}\n\tpublic double getweight() {...}\n    public double getbmi() {...}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n对比两者代码，容易发现：\n\n 1. 贫血模型的业务，放在service中。\n 2. 充血模型的业务，放在dp中。\n\n从业务重用上看：\n\n充血模型，业务重用的最小个体是dp。\n\n贫血模型，业务重用的最小个体为service。如果service包含其他业务就会导致不必要的依赖。\n\n\n# 面向对象的角度\n\n从oo的角度去审视贫血模型和充血模型，会发现：\n\n贫血模型的本质是在一堆数据上建立一个一个业务流程，是一个面向过程的实现方式。\n\n充血模型既有数据也有对应的行为，这是面向对象的。\n\n\n# 如何选择\n\n我们知道充血模型即要抽象属性，也要抽象行为；会比贫血模型更难设计。所以在选用时也有相应的偏好，或者有结合使用的情况。\n\n如果业务只是简单的crud，或者crud可以解决90%的业务情况。推荐使用贫血模型。其实大量的项目都是这样的简单项目。\n\n但是如果在做复杂的项目，拥有复杂的业务时，我们就需要使用充血模型；\n\nddd是基于好的抽象，宁愿不抽象，也不要固执的做出不合理的抽象。",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"统一语言",frontmatter:{title:"统一语言",date:"2022-05-05T10:39:02.000Z",permalink:"/pages/e880dd/",categories:["领域驱动设计",null],tags:["DDD"]},regularPath:"/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1--%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/70.%E7%BB%9F%E4%B8%80%E8%AF%AD%E8%A8%80.html",relativePath:"软件设计--领域驱动设计/70.统一语言.md",key:"v-0624a254",path:"/pages/e880dd/",headers:[{level:2,title:"生长出来的概念",slug:"生长出来的概念",normalizedTitle:"生长出来的概念",charIndex:55},{level:2,title:"统一语言（UBIQUITOUS LANGUAGE）",slug:"统一语言-ubiquitous-language",normalizedTitle:"统一语言（ubiquitous language）",charIndex:448}],excerpt:"<p>领域模型的战略部分：</p>\n<p>概念: 统一语言、子域划分、限界上下文</p>\n<p>方法：原文分析、四色模型、事件风暴</p>\n",headersStr:"生长出来的概念 统一语言（UBIQUITOUS LANGUAGE）",content:"领域模型的战略部分：\n\n概念: 统一语言、子域划分、限界上下文\n\n方法：原文分析、四色模型、事件风暴\n\n\n# 生长出来的概念\n\n1948年6月21日上午11点，在曼彻斯特大学，存储程序的计算机第一次在电子内存中存储了一段软件并成功执行了该软件。\n\n软件的复杂度已经超出很多人的想想。WinXP,Win7代码月4千万行，win11代码已经为5千万行。\n\n为了可以更好的治理代码，我们管理的代码的思想也在不断变化。\n\n从【字节码】--\x3e 【汇编】--\x3e【面向过程】--\x3e【面向对象】\n\n领域模型本质上是面向对象方法的更为深入的使用。\n\n这里先回顾什么是面向对象：\n\n面向对象的基本逻辑就是将现实事务映射到代码中，在此基础上提出了封装、继承、多态。符合面向对象的代码会以更亲近软件开发者思考认知的方式运行，以更接近人类认知事物的方式进行生长。\n\n随着软件行业的不断细分，软件需求一般不是开发者自行发现；而是由客户，产品经理等角色去提出。\n\n领域模型解决的是让软件以更符合业务需求的方式去产生。\n\n\n# 统一语言（UBIQUITOUS LANGUAGE）\n\n统一语言是领域模型的第一步，也是会一直贯彻在整个过程中。\n\n由于语言上存在鸿沟，领域专家们只能模糊地描述他们想要的东西，开发人员虽然努力去理解一个自己不熟悉的领域但也只能形成模糊的认识，结果就是各说各的话，或者都是一知半解，最后到上线前才会发现漏了这个漏了那个。\n\n统一语言是指统一 产品、开发、测试等参与者，对业务认知统一。它是指通过浓缩后的领域语言。可表现为图，可以使用UML等方式；\n\n例：",normalizedContent:"领域模型的战略部分：\n\n概念: 统一语言、子域划分、限界上下文\n\n方法：原文分析、四色模型、事件风暴\n\n\n# 生长出来的概念\n\n1948年6月21日上午11点，在曼彻斯特大学，存储程序的计算机第一次在电子内存中存储了一段软件并成功执行了该软件。\n\n软件的复杂度已经超出很多人的想想。winxp,win7代码月4千万行，win11代码已经为5千万行。\n\n为了可以更好的治理代码，我们管理的代码的思想也在不断变化。\n\n从【字节码】--\x3e 【汇编】--\x3e【面向过程】--\x3e【面向对象】\n\n领域模型本质上是面向对象方法的更为深入的使用。\n\n这里先回顾什么是面向对象：\n\n面向对象的基本逻辑就是将现实事务映射到代码中，在此基础上提出了封装、继承、多态。符合面向对象的代码会以更亲近软件开发者思考认知的方式运行，以更接近人类认知事物的方式进行生长。\n\n随着软件行业的不断细分，软件需求一般不是开发者自行发现；而是由客户，产品经理等角色去提出。\n\n领域模型解决的是让软件以更符合业务需求的方式去产生。\n\n\n# 统一语言（ubiquitous language）\n\n统一语言是领域模型的第一步，也是会一直贯彻在整个过程中。\n\n由于语言上存在鸿沟，领域专家们只能模糊地描述他们想要的东西，开发人员虽然努力去理解一个自己不熟悉的领域但也只能形成模糊的认识，结果就是各说各的话，或者都是一知半解，最后到上线前才会发现漏了这个漏了那个。\n\n统一语言是指统一 产品、开发、测试等参与者，对业务认知统一。它是指通过浓缩后的领域语言。可表现为图，可以使用uml等方式；\n\n例：",charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"List列表",frontmatter:{title:"List列表",date:"2022-05-15T01:13:38.000Z",permalink:"/pages/311ce3/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/21.%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/1.List.html",relativePath:"编程语言--Java/21.容器类型/1.List.md",key:"v-4b089667",path:"/pages/311ce3/",headers:[{level:2,title:"1 List集合概述和特点",slug:"_1-list集合概述和特点",normalizedTitle:"1 list集合概述和特点",charIndex:2},{level:2,title:"2 List集合的特有方法",slug:"_2-list集合的特有方法",normalizedTitle:"2 list集合的特有方法",charIndex:177},{level:2,title:"3 List集合子类的特点",slug:"_3-list集合子类的特点",normalizedTitle:"3 list集合子类的特点",charIndex:435},{level:2,title:"4 集合的案例-List集合存储学生对象并遍历",slug:"_4-集合的案例-list集合存储学生对象并遍历",normalizedTitle:"4 集合的案例-list集合存储学生对象并遍历",charIndex:838},{level:2,title:"5 并发修改异常",slug:"_5-并发修改异常",normalizedTitle:"5 并发修改异常",charIndex:2312},{level:2,title:"6 增强for循环",slug:"_6-增强for循环",normalizedTitle:"6 增强for循环",charIndex:3691}],headersStr:"1 List集合概述和特点 2 List集合的特有方法 3 List集合子类的特点 4 集合的案例-List集合存储学生对象并遍历 5 并发修改异常 6 增强for循环",content:'# 1 List集合概述和特点\n\n * List集合概述\n   \n   * 有序集合（也称为序列），用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元 素,并搜索列表中的元素\n   * 与Set集合不同，列表通常允许重复的元素\n\n * List集合特点\n   \n   * 有索引\n   * 可以存储重素\n   * 元素存取有序\n\n\n# 2 List集合的特有方法\n\n方法名                              描述\nvoid add(int index, E element)   在此集合中的指定位置插/M旨定的元素\nE remove(int index)              删除指定索引处的元素,返回被删除的元素\nE set(int index, E element)      修改J旨定索引处的元素,返回被修改的元素\nE get(int index)                 返回指定索引处的元素\n\n\n# 3 List集合子类的特点\n\n * ArrayList 集合\n   \n   * 底层是数组结构实现,查询快、增删慢\n\n * LinkedList集合\n   \n   * 底层是链表结构实现,查询慢、增删快\n   * 特有方法\n\nLINKEDLIST 特有方法 方法名         说明\npublic void addFirst(E e)   在该列券头插涌定的元素\npublic void addLast(E e)    樹旨定的元素斷到此列表的末尾\npublic E getFirst()         返回此列表中的第一个元素\npublic E getLast()          返回此列表中的最后一个元素\npublic E removeFirst()      从此列表中删除并返回第一个元素\npublic E removeLast()       从此列表中删除并返回最后一个元素\n\n\n# 4 集合的案例-List集合存储学生对象并遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合,存储3个学生对象,使用程序实现在控制台遍历该集合\n\n * 代码实现\n\npublic class Student {\n    private String name;\n    private int age;\n    public Student(){\n\n    }\n    public Student(String name,int age){\n        this.name=name;this.age=age;\n    }\n    public String getName(){\n        return name;\n    }\n    public void setName(String name){\n        this.name=name;\n    }\n    public int getAge(){\n        return age;\n    }\n    public void setAge(int age){\n        this.age=age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 测试类\n\npublic class ListDemo {\n    public static void main(String[] args) {\n\n        //创建List集合对象\n        List<Student> list=new ArrayList<Student>();\n\n        //创建学生对象\n        Student s1 = new Student("林青霞",30);\n        Student s2 = new Student("张曼玉",35);\n        Student s3 = new Student("王祖贤",33);\n\n        //把学生添加到集合\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n\n        //迭代器方式\n        Iterator<Student> it=list.iterator();\n        while (it.hasNext()) {\n            Student s = it.next();\n            System.out.println(s.getName()+","+s.getAge());\n        }\n\n        System.out.println("--------");\n\n        //for循环方式\n        for(int i=0; i < list.size(); i++) {\n            Student s = list.get(i);\n            System.out.println(s.getName()+","+s.getAge());\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 5 并发修改异常\n\n * 出现的原因\n   \n   * 迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：ConcurrentModificationException\n\n * 解决的方案\n   \n   * 用for循环遍历,然后用集合对象做对应的操作即可\n   * 使用列表迭代器ListIterator\n     * 通过List集合的listlterator()方法得到,所以说它是Li st集合特有的迭代器\n     * 用于允许程序员沿任一方向遍历的列表迭代器,在迭代期间修改列表,并获取列表中迭代器的当前位置\n\n * 示例代码\n\npublic class ListDemo2 {\n    public static void main(String[] args) {\n        // 创建集合对象\n        List<String> list = new ArrayList<>();\n\n        // 添加元素\n        list.add("hello");\n        list.add("world");\n\n        //迭代器方式\n        Iterator<String> it=list.iterator();\n        while (it.hasNext()) {\n            String s = it.next();\n            if (s.equals("world")) {\n                //list.add("java");  //ConcurrentModificationException\n            }\n        }\n\n        // for循环方式\n        for(int i=0; i < list.size(); i++) {\n            String s = list.get(i);\n            if (s.equals("world")) {\n                list.add("java");\n            }\n        }\n\n        //获取列表迭代器\n        ListIterator<String> lit = list.listIterator();\n        while (lit.hasNext()) {\n            String s = lit.next();\n            if(s.equals("world")) {\n                lit.add("javaee");\n            }\n        }\n\n        // 输出集合对象\n        System.out.println(list);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 6 增强for循环\n\n * 定义格式\n\nfor(元素数据类型变量名:数组/集合对象名){\n循环体;\n}\n\n\n1\n2\n3\n\n * 示例代码\n\npublic class ForDemo {\n    public static void main(String[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        for (int i : arr) {\n            System.out.println(i);\n        }\n        System.out.println("--------");\n        String[] strArray = {"hello", "world", "java"};\n        for (String s : strArray) {\n            System.out.println(s);\n        }\n        System.out.println("--------");\n        List<String> list = new ArrayList<String>();\n        list.add("hello");\n        list.add("world");\n        list.add("java");\n        for (String s : list) {\n            System.out.println(s);\n        }\n        System.out.println("--------");\n        // 内部原理是一个Iterator迭代器\n        for(String s : list) {\n            if(s.equals("world")) {\n        //        list.add("javaee"); //ConcurrentModificationException\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',normalizedContent:'# 1 list集合概述和特点\n\n * list集合概述\n   \n   * 有序集合（也称为序列），用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元 素,并搜索列表中的元素\n   * 与set集合不同，列表通常允许重复的元素\n\n * list集合特点\n   \n   * 有索引\n   * 可以存储重素\n   * 元素存取有序\n\n\n# 2 list集合的特有方法\n\n方法名                              描述\nvoid add(int index, e element)   在此集合中的指定位置插/m旨定的元素\ne remove(int index)              删除指定索引处的元素,返回被删除的元素\ne set(int index, e element)      修改j旨定索引处的元素,返回被修改的元素\ne get(int index)                 返回指定索引处的元素\n\n\n# 3 list集合子类的特点\n\n * arraylist 集合\n   \n   * 底层是数组结构实现,查询快、增删慢\n\n * linkedlist集合\n   \n   * 底层是链表结构实现,查询慢、增删快\n   * 特有方法\n\nlinkedlist 特有方法 方法名         说明\npublic void addfirst(e e)   在该列券头插涌定的元素\npublic void addlast(e e)    樹旨定的元素斷到此列表的末尾\npublic e getfirst()         返回此列表中的第一个元素\npublic e getlast()          返回此列表中的最后一个元素\npublic e removefirst()      从此列表中删除并返回第一个元素\npublic e removelast()       从此列表中删除并返回最后一个元素\n\n\n# 4 集合的案例-list集合存储学生对象并遍历\n\n * 案例需求\n   \n   创建一个存储学生对象的集合,存储3个学生对象,使用程序实现在控制台遍历该集合\n\n * 代码实现\n\npublic class student {\n    private string name;\n    private int age;\n    public student(){\n\n    }\n    public student(string name,int age){\n        this.name=name;this.age=age;\n    }\n    public string getname(){\n        return name;\n    }\n    public void setname(string name){\n        this.name=name;\n    }\n    public int getage(){\n        return age;\n    }\n    public void setage(int age){\n        this.age=age;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n * 测试类\n\npublic class listdemo {\n    public static void main(string[] args) {\n\n        //创建list集合对象\n        list<student> list=new arraylist<student>();\n\n        //创建学生对象\n        student s1 = new student("林青霞",30);\n        student s2 = new student("张曼玉",35);\n        student s3 = new student("王祖贤",33);\n\n        //把学生添加到集合\n        list.add(s1);\n        list.add(s2);\n        list.add(s3);\n\n        //迭代器方式\n        iterator<student> it=list.iterator();\n        while (it.hasnext()) {\n            student s = it.next();\n            system.out.println(s.getname()+","+s.getage());\n        }\n\n        system.out.println("--------");\n\n        //for循环方式\n        for(int i=0; i < list.size(); i++) {\n            student s = list.get(i);\n            system.out.println(s.getname()+","+s.getage());\n        }\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 5 并发修改异常\n\n * 出现的原因\n   \n   * 迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际修改值不一致，则会出现：concurrentmodificationexception\n\n * 解决的方案\n   \n   * 用for循环遍历,然后用集合对象做对应的操作即可\n   * 使用列表迭代器listiterator\n     * 通过list集合的listlterator()方法得到,所以说它是li st集合特有的迭代器\n     * 用于允许程序员沿任一方向遍历的列表迭代器,在迭代期间修改列表,并获取列表中迭代器的当前位置\n\n * 示例代码\n\npublic class listdemo2 {\n    public static void main(string[] args) {\n        // 创建集合对象\n        list<string> list = new arraylist<>();\n\n        // 添加元素\n        list.add("hello");\n        list.add("world");\n\n        //迭代器方式\n        iterator<string> it=list.iterator();\n        while (it.hasnext()) {\n            string s = it.next();\n            if (s.equals("world")) {\n                //list.add("java");  //concurrentmodificationexception\n            }\n        }\n\n        // for循环方式\n        for(int i=0; i < list.size(); i++) {\n            string s = list.get(i);\n            if (s.equals("world")) {\n                list.add("java");\n            }\n        }\n\n        //获取列表迭代器\n        listiterator<string> lit = list.listiterator();\n        while (lit.hasnext()) {\n            string s = lit.next();\n            if(s.equals("world")) {\n                lit.add("javaee");\n            }\n        }\n\n        // 输出集合对象\n        system.out.println(list);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 6 增强for循环\n\n * 定义格式\n\nfor(元素数据类型变量名:数组/集合对象名){\n循环体;\n}\n\n\n1\n2\n3\n\n * 示例代码\n\npublic class fordemo {\n    public static void main(string[] args) {\n        int[] arr = {1, 2, 3, 4, 5};\n        for (int i : arr) {\n            system.out.println(i);\n        }\n        system.out.println("--------");\n        string[] strarray = {"hello", "world", "java"};\n        for (string s : strarray) {\n            system.out.println(s);\n        }\n        system.out.println("--------");\n        list<string> list = new arraylist<string>();\n        list.add("hello");\n        list.add("world");\n        list.add("java");\n        for (string s : list) {\n            system.out.println(s);\n        }\n        system.out.println("--------");\n        // 内部原理是一个iterator迭代器\n        for(string s : list) {\n            if(s.equals("world")) {\n        //        list.add("javaee"); //concurrentmodificationexception\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"编程语言",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"10.编程语言",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:null}},title:"编程语言",date:"2022-05-01T23:03:14.000Z",permalink:"/language",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95/10.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80.html",relativePath:"00.目录/10.编程语言.md",key:"v-cb850cc6",path:"/language/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3},{title:"map表",frontmatter:{title:"map表",date:"2022-05-15T01:16:45.000Z",permalink:"/pages/9e1298/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/21.%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/3.map.html",relativePath:"编程语言--Java/21.容器类型/3.map.md",key:"v-07521cf9",path:"/pages/9e1298/",headers:[{level:2,title:"1 Map集合概述和特点",slug:"_1-map集合概述和特点",normalizedTitle:"1 map集合概述和特点",charIndex:2},{level:2,title:"2  遍历Map",slug:"_2-遍历map",normalizedTitle:"2  遍历map",charIndex:null},{level:2,title:"3 Properties特点",slug:"_3-properties特点",normalizedTitle:"3 properties特点",charIndex:1983},{level:4,title:"3.1 Properties和IO流相结合的方法",slug:"_3-1-properties和io流相结合的方法",normalizedTitle:"3.1 properties和io流相结合的方法",charIndex:2948}],headersStr:"1 Map集合概述和特点 2  遍历Map 3 Properties特点 3.1 Properties和IO流相结合的方法",content:'# 1 Map集合概述和特点\n\n * Map集合概述\n   \n    interface Map<K,V> K：键的类型；V：值的类型\n   \n   \n   1\n   \n\n * Map集合的特点\n   \n   * 键值对映射关系\n   * 一个键对应一个值\n   * 键不能重复，值可以重复\n   * 元素存取无序\n\n * 基本方法介绍\n   \n   方法名                                   说明\n   V put(K key,V value)                  添加元素\n   V remove(Object key)                  根据键删除键值对元素\n   void clear()                          移除所有的键值对元素\n   boolean containsKey(Object key)       判断集合是否包含指定的键\n   boolean containsValue(Object value)   判断集合是否包含指定的值\n   boolean isEmpty()                     判断集合是否为空\n   int size()                            集合的长度，也就是集合中键值对的个数\n\n * 获取方法\n   \n   方法名                              说明\n   V get(Object key)                根据键获取值\n   Set keySet()                     获取所有键的集合\n   Collection values()              获取所有值的集合\n   Set<Map.Entry<K,V>> entrySet()   获取所有键值对对象的集合\n\n\n# 2 遍历Map\n\n * Set< K > keySet()，获取所有键的集合。\n * Set<Map.Entry<K,V>> entrySet()，获取所有键值对对象的集合 。\n\npublic class MapDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        Map<String, String> map = new HashMap<String, String>();\n\n        //添加元素\n        map.put("张无忌", "赵敏");\n        map.put("郭靖", "黄蓉");\n        map.put("杨过", "小龙女");\n\n        //获取所有键的集合。用keySet()方法实现\n        Set<String> keySet = map.keySet();\n\n        //遍历键的集合，获取到每一个键。用增强for实现\n        for (String key : keySet) {\n            //根据键去找值。用get(Object key)方法实现\n            String value = map.get(key);\n            System.out.println(key + "," + value);\n        }\n\n        System.out.println("-----------------------------");\n        \n        //获取所有键值对对象的集合\n        Set<Map.Entry<String, String>> entries = map.entrySet();\n\n        //遍历键值对对象的集合，得到每一个键值对对象\n        for (Map.Entry<String, String> me : entries) {\n            //根据键值对对象获取键和值\n            String key = me.getKey();\n            String value = me.getValue();\n            System.out.println(key + "," + value);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 3 Properties特点\n\n * Properties介绍\n   \n   * 是一个Map体系的集合类\n   * Properties可以保存到流中或从流中加载\n   * 属性列表中的每个键及其对应的值都是一个字符串\n\n * 特有方法\n   \n   方法名                                            说明\n   Object setProperty(String key, String value)   设置集合的键和值，都是String类型，底层调用 Hashtable方法 put\n   String getProperty(String key)                 使用此属性列表中指定的键搜索属性\n   Set stringPropertyNames()                      从该属性列表中返回一个不可修改的键集，其中键及其对应的 值是字符串\n\n * 示例代码\n\npublic class PropertiesDemo1 {\n    public static void main(String[] args) {\n        //创建集合对象\n        Properties prop = new Properties();\n\n        //存储元素\n        prop.put("001", "林青霞");\n        prop.put("002", "张曼玉");\n        prop.setProperty("003", "王祖贤");\n\n        //遍历集合\n        Set<String> keySet = prop.stringPropertyNames();\n        for (String key : keySet) {\n            String value = prop.getProperty(key);\n            System.out.println(key + "," + value);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3.1 Properties和IO流相结合的方法\n\n * 和IO流结合的方法\n\n方法名                                             说明\nvoid load(InputStream inStream)                 从输入字节流读取属性列表（键和元素对）\nvoid load(Reader reader)                        从输入字符流读取属性列表（键和元素对）\nvoid store(OutputStream out, String comments)   将此属性列表（键和元素对）写入此 Properties表中，以适合于使用\n                                                load(InputStream)方法的格式写入输出字节流\nvoid store(Writer writer, String comments)      将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)\n\n * 示例代码\n\n\npublic class PropertiesDemo2 {\n    public static void main(String[] args) throws IOException {\n        PropertiesDemo2 demo = new PropertiesDemo2();\n        //把集合中的数据保存到文件\n        demo.myStore();\n        //把文件中的数据加载到集合\n        demo.myLoad();\n    }\n\n    private void myLoad() throws IOException {\n        Properties prop = new Properties();\n        FileReader fr = new FileReader(this.getClass().getResource("/Stream/fw.txt").getPath());\n        prop.load(fr);\n        // 也可以\n        //prop.load(this.getClass().getResourceAsStream("/Stream/fw.txt"));\n        fr.close();\n        System.out.println(prop);\n    }\n\n    private void myStore() throws IOException {\n        Properties prop = new Properties();\n        prop.setProperty("001", "林青霞");\n        prop.setProperty("002", "张曼玉");\n        prop.setProperty("003", "王祖贤");\n\n        FileWriter fw = new FileWriter(this.getClass().getResource("/Stream/fw.txt").getPath());\n        prop.store(fw, null);\n        fw.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',normalizedContent:'# 1 map集合概述和特点\n\n * map集合概述\n   \n    interface map<k,v> k：键的类型；v：值的类型\n   \n   \n   1\n   \n\n * map集合的特点\n   \n   * 键值对映射关系\n   * 一个键对应一个值\n   * 键不能重复，值可以重复\n   * 元素存取无序\n\n * 基本方法介绍\n   \n   方法名                                   说明\n   v put(k key,v value)                  添加元素\n   v remove(object key)                  根据键删除键值对元素\n   void clear()                          移除所有的键值对元素\n   boolean containskey(object key)       判断集合是否包含指定的键\n   boolean containsvalue(object value)   判断集合是否包含指定的值\n   boolean isempty()                     判断集合是否为空\n   int size()                            集合的长度，也就是集合中键值对的个数\n\n * 获取方法\n   \n   方法名                              说明\n   v get(object key)                根据键获取值\n   set keyset()                     获取所有键的集合\n   collection values()              获取所有值的集合\n   set<map.entry<k,v>> entryset()   获取所有键值对对象的集合\n\n\n# 2 遍历map\n\n * set< k > keyset()，获取所有键的集合。\n * set<map.entry<k,v>> entryset()，获取所有键值对对象的集合 。\n\npublic class mapdemo {\n    public static void main(string[] args) {\n        //创建集合对象\n        map<string, string> map = new hashmap<string, string>();\n\n        //添加元素\n        map.put("张无忌", "赵敏");\n        map.put("郭靖", "黄蓉");\n        map.put("杨过", "小龙女");\n\n        //获取所有键的集合。用keyset()方法实现\n        set<string> keyset = map.keyset();\n\n        //遍历键的集合，获取到每一个键。用增强for实现\n        for (string key : keyset) {\n            //根据键去找值。用get(object key)方法实现\n            string value = map.get(key);\n            system.out.println(key + "," + value);\n        }\n\n        system.out.println("-----------------------------");\n        \n        //获取所有键值对对象的集合\n        set<map.entry<string, string>> entries = map.entryset();\n\n        //遍历键值对对象的集合，得到每一个键值对对象\n        for (map.entry<string, string> me : entries) {\n            //根据键值对对象获取键和值\n            string key = me.getkey();\n            string value = me.getvalue();\n            system.out.println(key + "," + value);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 3 properties特点\n\n * properties介绍\n   \n   * 是一个map体系的集合类\n   * properties可以保存到流中或从流中加载\n   * 属性列表中的每个键及其对应的值都是一个字符串\n\n * 特有方法\n   \n   方法名                                            说明\n   object setproperty(string key, string value)   设置集合的键和值，都是string类型，底层调用 hashtable方法 put\n   string getproperty(string key)                 使用此属性列表中指定的键搜索属性\n   set stringpropertynames()                      从该属性列表中返回一个不可修改的键集，其中键及其对应的 值是字符串\n\n * 示例代码\n\npublic class propertiesdemo1 {\n    public static void main(string[] args) {\n        //创建集合对象\n        properties prop = new properties();\n\n        //存储元素\n        prop.put("001", "林青霞");\n        prop.put("002", "张曼玉");\n        prop.setproperty("003", "王祖贤");\n\n        //遍历集合\n        set<string> keyset = prop.stringpropertynames();\n        for (string key : keyset) {\n            string value = prop.getproperty(key);\n            system.out.println(key + "," + value);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3.1 properties和io流相结合的方法\n\n * 和io流结合的方法\n\n方法名                                             说明\nvoid load(inputstream instream)                 从输入字节流读取属性列表（键和元素对）\nvoid load(reader reader)                        从输入字符流读取属性列表（键和元素对）\nvoid store(outputstream out, string comments)   将此属性列表（键和元素对）写入此 properties表中，以适合于使用\n                                                load(inputstream)方法的格式写入输出字节流\nvoid store(writer writer, string comments)      将此属性列表（键和元素对）写入此 properties表中，以适合使用 load(reader)\n\n * 示例代码\n\n\npublic class propertiesdemo2 {\n    public static void main(string[] args) throws ioexception {\n        propertiesdemo2 demo = new propertiesdemo2();\n        //把集合中的数据保存到文件\n        demo.mystore();\n        //把文件中的数据加载到集合\n        demo.myload();\n    }\n\n    private void myload() throws ioexception {\n        properties prop = new properties();\n        filereader fr = new filereader(this.getclass().getresource("/stream/fw.txt").getpath());\n        prop.load(fr);\n        // 也可以\n        //prop.load(this.getclass().getresourceasstream("/stream/fw.txt"));\n        fr.close();\n        system.out.println(prop);\n    }\n\n    private void mystore() throws ioexception {\n        properties prop = new properties();\n        prop.setproperty("001", "林青霞");\n        prop.setproperty("002", "张曼玉");\n        prop.setproperty("003", "王祖贤");\n\n        filewriter fw = new filewriter(this.getclass().getresource("/stream/fw.txt").getpath());\n        prop.store(fw, null);\n        fw.close();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',charsets:{cjk:!0},lastUpdated:"2023/03/08, 18:38:33",lastUpdatedTimestamp:1678271913e3},{title:"set集合",frontmatter:{title:"set集合",date:"2022-05-15T01:16:34.000Z",permalink:"/pages/df5401/",categories:["Java基础知识"],tags:[null]},regularPath:"/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80--Java/21.%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B/2.set.html",relativePath:"编程语言--Java/21.容器类型/2.set.md",key:"v-7f5075af",path:"/pages/df5401/",headers:[{level:2,title:"1 Set集合概述和特点",slug:"_1-set集合概述和特点",normalizedTitle:"1 set集合概述和特点",charIndex:2},{level:2,title:"2 Java哈希值",slug:"_2-java哈希值",normalizedTitle:"2 java哈希值",charIndex:86},{level:2,title:"3 HashSet集合概述和特点",slug:"_3-hashset集合概述和特点",normalizedTitle:"3 hashset集合概述和特点",charIndex:312},{level:2,title:"4 LinkedHashSet集合概述和特点",slug:"_4-linkedhashset集合概述和特点",normalizedTitle:"4 linkedhashset集合概述和特点",charIndex:2541},{level:2,title:"5 TreeSet集合概述和特点",slug:"_5-treeset集合概述和特点",normalizedTitle:"5 treeset集合概述和特点",charIndex:3171},{level:3,title:"5.1 比较器排序Comparator",slug:"_5-1-比较器排序comparator",normalizedTitle:"5.1 比较器排序comparator",charIndex:3456},{level:3,title:"5.2 自然排序Comparable",slug:"_5-2-自然排序comparable",normalizedTitle:"5.2 自然排序comparable",charIndex:4414}],headersStr:"1 Set集合概述和特点 2 Java哈希值 3 HashSet集合概述和特点 4 LinkedHashSet集合概述和特点 5 TreeSet集合概述和特点 5.1 比较器排序Comparator 5.2 自然排序Comparable",content:'# 1 Set集合概述和特点\n\n * Set集合的特点\n   * 元素存取无序\n   * 没有索引、只能通过迭代器或增强for循环遍历\n   * 不能存储重复元素\n\n\n# 2 Java哈希值\n\n * 哈希值简介\n   * 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值\n * 如何获取哈希值\n   * Object类中的 public int hashCode()：返回对象的哈希码值\n * 哈希值的特点\n   * 同一个对象多次调用 hashCode() 方法，返回的哈希值是相同的\n   * 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n\n\n# 3 HashSet集合概述和特点\n\n * HashSet集合的特点\n   \n   * 底层数据结构是哈希表\n   \n   * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n   \n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   \n   * 由于是Set集合，所以是不包含重复元素的集合\n   \n   * HashSet存储逻辑：\n     \n     \n\n * 案例需求\n   \n   * 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n   * 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n * 学生类：\n\npublic class Student {\n    private String name;\n    private int age;\n    public Student() {\n    }\n    public Student(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Student student = (Student) o;\n        if (age != student.age)\n            return false;\n        return name != null ? name.equals(student.name) : student.name == null;\n    }\n    @Override\n    public int hashCode() {\n        int result = name != null ? name.hashCode() : 0;\n        result = 31 * result + age;\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * 测试类\n\npublic class HashSetDemo {\n    public static void main(String[] args) {\n        //创建HashSet集合对象\n        HashSet<Student> hs = new HashSet<Student>();\n        //创建学生对象\n        Student s1 = new Student("林青霞", 30);\n        Student s2 = new Student("张曼玉", 35);\n        Student s3 = new Student("王祖贤", 33);\n        Student s4 = new Student("王祖贤", 33);\n        Student s5 = new Student("", 33);\n        Student s6 = new Student("", 33);\n        //把学生添加到集合\n        hs.add(s1);\n        hs.add(s2);\n        hs.add(s3);\n        hs.add(s4);\n        hs.add(s5);\n        hs.add(s6);\n        hs.add(new Student());\n        hs.add(new Student());\n        //遍历集合(增强for)\n        for (Student s : hs) {\n            System.out.println(s.getName() + "," + s.getAge());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4 LinkedHashSet集合概述和特点\n\n * LinkedHashSet集合特点\n   \n   * 哈希表和链表实现的Set接口，具有可预测的迭代次序\n   * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n   * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n * 测试类\n\npublic class LinkedHashSetDemo {\n    public static void main(String[] args) {\n        //创建集合对象\n        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<String>();\n        //添加元素\n        linkedHashSet.add("hello");\n        linkedHashSet.add("world");\n        linkedHashSet.add("java");\n        linkedHashSet.add("world");\n        //遍历集合\n        for(String s : linkedHashSet) {\n            System.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5 TreeSet集合概述和特点\n\n * TreeSet集合概述\n   \n   * 元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法\n     * TreeSet(Comparator comparator) ：根据指定的比较器进行排序\n     * TreeSet()：根据其元素的自然排序进行排序\n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   * 由于是Set集合，所以不包含重复元素的集合\n\n * 案例需求\n   \n   * 存储学生对象并遍历\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n\n# 5.1 比较器排序Comparator\n\npublic class TreeSetDemo {\n    public static void main(String[] args) {\n        // 创建集合对象\n        TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() {\n            @Override\n            public int compare(Student o1, Student o2) {\n                int num = o1.getAge() - o2.getAge();\n                int num2 = num == 0 ? o1.getName().compareTo(o2.getName()) : num;\n                return num2;\n            }\n        });\n\n        //把学生添加到集合\n        ts.add(new Student("xishi", 29));\n        ts.add(new Student("wangzhaojun", 28));\n        ts.add(new Student("diaochan", 30));\n        ts.add(new Student("yangyuhuan", 33));\n        ts.add(new Student("linqingxia",33));\n        ts.add(new Student("linqingxia",33));\n\n        //遍历集合\n        for (Student s : ts) {\n            System.out.println(s.getName() + "," + s.getAge());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.2 自然排序Comparable\n\n * 学生类\n\npublic class Student2 implements Comparable<Student2> {\n    private String name;\n    private int age;\n    public Student2() {\n    }\n    public Student2(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Override\n    public int compareTo(Student2 student2) {\n        int num = this.getAge() - student2.getAge();\n        int num2 = num == 0 ? this.getName().compareTo(student2.getName()): num;\n        return num2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 测试类\n\npublic class TreeSetDemo2 {\n    public static void main(String[] args) {\n        //创建集合对象\n        TreeSet<Student2> ts = new TreeSet<Student2>();\n        //把学生添加到集合\n        ts.add(new Student2("xishi", 29));\n        ts.add(new Student2("wangzhaojun", 28));\n        ts.add(new Student2("diaochan", 30));\n        ts.add(new Student2("yangyuhuan", 33));\n        ts.add(new Student2("linqingxia",33));\n        ts.add(new Student2("linqingxia",33));\n        //遍历集合\n        for (Student2 s : ts) {\n            System.out.println(s.getName() + "," + s.getAge());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',normalizedContent:'# 1 set集合概述和特点\n\n * set集合的特点\n   * 元素存取无序\n   * 没有索引、只能通过迭代器或增强for循环遍历\n   * 不能存储重复元素\n\n\n# 2 java哈希值\n\n * 哈希值简介\n   * 是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值\n * 如何获取哈希值\n   * object类中的 public int hashcode()：返回对象的哈希码值\n * 哈希值的特点\n   * 同一个对象多次调用 hashcode() 方法，返回的哈希值是相同的\n   * 默认情况下，不同对象的哈希值是不同的。而重写hashcode()方法，可以实现让不同对象的哈希值相同\n\n\n# 3 hashset集合概述和特点\n\n * hashset集合的特点\n   \n   * 底层数据结构是哈希表\n   \n   * 对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n   \n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   \n   * 由于是set集合，所以是不包含重复元素的集合\n   \n   * hashset存储逻辑：\n     \n     \n\n * 案例需求\n   \n   * 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合\n   * 要求：学生对象的成员变量值相同，我们就认为是同一个对象\n\n * 学生类：\n\npublic class student {\n    private string name;\n    private int age;\n    public student() {\n    }\n    public student(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public int getage() {\n        return age;\n    }\n    public void setage(int age) {\n        this.age = age;\n    }\n    @override\n    public boolean equals(object o) {\n        if (this == o)\n            return true;\n        if (o == null || getclass() != o.getclass())\n            return false;\n        student student = (student) o;\n        if (age != student.age)\n            return false;\n        return name != null ? name.equals(student.name) : student.name == null;\n    }\n    @override\n    public int hashcode() {\n        int result = name != null ? name.hashcode() : 0;\n        result = 31 * result + age;\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n * 测试类\n\npublic class hashsetdemo {\n    public static void main(string[] args) {\n        //创建hashset集合对象\n        hashset<student> hs = new hashset<student>();\n        //创建学生对象\n        student s1 = new student("林青霞", 30);\n        student s2 = new student("张曼玉", 35);\n        student s3 = new student("王祖贤", 33);\n        student s4 = new student("王祖贤", 33);\n        student s5 = new student("", 33);\n        student s6 = new student("", 33);\n        //把学生添加到集合\n        hs.add(s1);\n        hs.add(s2);\n        hs.add(s3);\n        hs.add(s4);\n        hs.add(s5);\n        hs.add(s6);\n        hs.add(new student());\n        hs.add(new student());\n        //遍历集合(增强for)\n        for (student s : hs) {\n            system.out.println(s.getname() + "," + s.getage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 4 linkedhashset集合概述和特点\n\n * linkedhashset集合特点\n   \n   * 哈希表和链表实现的set接口，具有可预测的迭代次序\n   * 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n   * 由哈希表保证元素唯一，也就是说没有重复的元素\n\n * 测试类\n\npublic class linkedhashsetdemo {\n    public static void main(string[] args) {\n        //创建集合对象\n        linkedhashset<string> linkedhashset = new linkedhashset<string>();\n        //添加元素\n        linkedhashset.add("hello");\n        linkedhashset.add("world");\n        linkedhashset.add("java");\n        linkedhashset.add("world");\n        //遍历集合\n        for(string s : linkedhashset) {\n            system.out.println(s);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 5 treeset集合概述和特点\n\n * treeset集合概述\n   \n   * 元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法\n     * treeset(comparator comparator) ：根据指定的比较器进行排序\n     * treeset()：根据其元素的自然排序进行排序\n   * 没有带索引的方法，所以不能使用普通for循环遍历\n   * 由于是set集合，所以不包含重复元素的集合\n\n * 案例需求\n   \n   * 存储学生对象并遍历\n   * 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n\n\n# 5.1 比较器排序comparator\n\npublic class treesetdemo {\n    public static void main(string[] args) {\n        // 创建集合对象\n        treeset<student> ts = new treeset<student>(new comparator<student>() {\n            @override\n            public int compare(student o1, student o2) {\n                int num = o1.getage() - o2.getage();\n                int num2 = num == 0 ? o1.getname().compareto(o2.getname()) : num;\n                return num2;\n            }\n        });\n\n        //把学生添加到集合\n        ts.add(new student("xishi", 29));\n        ts.add(new student("wangzhaojun", 28));\n        ts.add(new student("diaochan", 30));\n        ts.add(new student("yangyuhuan", 33));\n        ts.add(new student("linqingxia",33));\n        ts.add(new student("linqingxia",33));\n\n        //遍历集合\n        for (student s : ts) {\n            system.out.println(s.getname() + "," + s.getage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 5.2 自然排序comparable\n\n * 学生类\n\npublic class student2 implements comparable<student2> {\n    private string name;\n    private int age;\n    public student2() {\n    }\n    public student2(string name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    public string getname() {\n        return name;\n    }\n    public void setname(string name) {\n        this.name = name;\n    }\n    public int getage() {\n        return age;\n    }\n    public void setage(int age) {\n        this.age = age;\n    }\n    @override\n    public int compareto(student2 student2) {\n        int num = this.getage() - student2.getage();\n        int num2 = num == 0 ? this.getname().compareto(student2.getname()): num;\n        return num2;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n * 测试类\n\npublic class treesetdemo2 {\n    public static void main(string[] args) {\n        //创建集合对象\n        treeset<student2> ts = new treeset<student2>();\n        //把学生添加到集合\n        ts.add(new student2("xishi", 29));\n        ts.add(new student2("wangzhaojun", 28));\n        ts.add(new student2("diaochan", 30));\n        ts.add(new student2("yangyuhuan", 33));\n        ts.add(new student2("linqingxia",33));\n        ts.add(new student2("linqingxia",33));\n        //遍历集合\n        for (student2 s : ts) {\n            system.out.println(s.getname() + "," + s.getage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n',charsets:{cjk:!0},lastUpdated:"2023/04/09, 19:59:04",lastUpdatedTimestamp:1681041544e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"编程语言",link:"/language/",items:[{text:"C++",link:"/language/c++/"},{text:"Java",link:"/language/java/"},{text:"Go",link:"/language/go/"}]},{text:"软件设计",link:"/design/",items:[{text:"面向对象",link:"/design/oo/"},{text:"设计模式",link:"/design/GoF/"},{text:"领域驱动设计",link:"/design/ddd/"}]},{text:"常用框架",link:"/frame/",items:[{text:"Spring",link:"/frame/spring/"}]},{text:"常用工具",link:"/tools/"},{text:"更多",link:"/archives/",items:[{text:"本站",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]},{text:"我的",items:[{text:"关于",link:"/about/"},{text:"收藏",link:"/pages/beb6c0bd8a66cea6/"}]}]}],sidebarDepth:2,logo:"/img/logo.png",repo:"su-dd/blogwriter",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",categoryText:"随笔",bodyBgImg:["https://cdn.addai.cn/blog/网站使用/bg3.png"],bodyBgImgOpacity:.5,sidebar:{"/00.目录/":[["10.编程语言.md","编程语言","/language"],["20.软件设计.md","软件设计","/design"],["40.常用框架.md","常用框架","/frame"],["50.常用工具.md","常用工具","/tools"]],catalogue:{"编程语言":"/language","软件设计":"/design","常用框架":"/frame","常用工具":"/tools","C++":"/language/c++",JAVA:"/language/java",Go:"/language/go","面向对象":"/design/oo","设计模式":"/design/GoF","领域驱动设计":"/design/ddd",Spring:"/frame/spring"},"/10.编程语言/":[["10.C++.md","C++","/language/c++"],["20.JAVA.md","Java","/language/java"],["30.Go.md","Go","/language/go"]],"/11.算法/":[["1.名词收集.md","名词收集","/pages/21eaf0/"]],"/12.操作系统/":[["10.系统的概念.md","系统的概念","/pages/e184a5/"],["20.系统的进程.md","进程","/pages/360dfa/"],["30.系统的线程.md","线程","/pages/aac1ac/"],["40.存储.md","内存","/pages/295c69/"]],"/20.软件设计/":[["10.面向对象.md","面向对象","/design/oo"],["20.设计模式.md","设计模式","/design/GoF"],["30.领域驱动设计.md","领域驱动设计","/design/ddd"]],"/40.常用框架/":[{title:"后端框架",collapsable:!0,children:[["10.后端框架/10.Spring.md","Spring相关","/frame/spring"]]}],"/50.常用工具/":[{title:"Git",collapsable:!0,children:[{title:"手册",collapsable:!0,children:[["10.Git/10.手册/00.常用Git命令清单.md","常用Git命令清单","/pages/8292d8/"],["10.Git/10.手册/03.Git变基合并.md","Git变基合并","/pages/c10281/"],["10.Git/10.手册/06.Git命令思维导图.md","Git命令思维导图","/pages/4cbc21/"]]},{title:"文档笔记",collapsable:!0,children:[["10.Git/20.文档笔记/10.Git基础与命令.md","Git基础与命令","/pages/635088/"],["10.Git/20.文档笔记/20.Git分支-分支原理.md","Git分支-分支原理","/pages/4bef1a/"],["10.Git/20.文档笔记/30.Git分支的新建与合并-分支操作.md","Git分支的新建与合并-分支操作","/pages/ea5a8c/"],["10.Git/20.文档笔记/40.Git分支管理-查看分支.md","Git分支管理-查看分支","/pages/a399b3/"],["10.Git/20.文档笔记/50.Git分支开发工作流.md","Git分支开发工作流","/pages/49ee30/"],["10.Git/20.文档笔记/60.Git分支-远程分支.md","Git分支-远程分支","/pages/574d62/"],["10.Git/20.文档笔记/70.Git分支-变基.md","Git分支-变基","/pages/3a3247/"],["10.Git/20.文档笔记/80.Git工具-查看修订版本.md","Git工具-查看修订版本","/pages/c984d1/"],["10.Git/20.文档笔记/90.Git工具-交互式暂存.md","Git工具-交互式暂存","/pages/76d859/"],["10.Git/20.文档笔记/100.Git工具-重写历史.md","Git工具-重写历史","/pages/1832fe/"],["10.Git/20.文档笔记/110.Git工具-重置揭密.md","Git工具-重置揭密","/pages/d9e9c6/"]]}]},{title:"CMake",collapsable:!0,children:[["20.CMake/1.CMake简述.md","CMake简述","/pages/6a3b4c/"],["20.CMake/2.CMake详解.md","CMake详解","/pages/44f8a2/"]]},{title:"NVM",collapsable:!0,children:[["30.NVM/1.NVM使用.md","NVM使用","/pages/a038dc/"]]},{title:"部署",collapsable:!0,children:[["60.部署/10.认知nginx.md","认知nginx","/pages/dafb6a/"],["60.部署/20.阿里云存储容器选择.md","存储容器选择","/pages/e8f440/"]]}],"/60.关于/":[["1.介绍.md","介绍","/about"],["2.列表.md","列表","/pages/83ed2b/","原创"],["3.资料收集.md","资料收集","/pages/0a2075/","原创"],{title:"指南",collapsable:!0,children:[{title:"指南",collapsable:!0,children:[["10.指南/01.指南/02.介绍.md","介绍","/pages/a2f161"],["10.指南/01.指南/03.快速上手.md","快速上手","/pages/793dcb"],["10.指南/01.指南/04.目录结构.md","目录结构","/pages/2f674a"],["10.指南/01.指南/05.核心配置和约定.md","构建结构化站点的核心配置和约定","/pages/33d574"],["10.指南/01.指南/06.自动生成front matter.md","自动生成front matter","/pages/088c16"],["10.指南/01.指南/07.Markdown 容器.md","Markdown 容器","/pages/d0d7eb/"],["10.指南/01.指南/08.Markdown 中使用组件.md","Markdown 中使用组件","/pages/197691/"]]},{title:"相关文章",collapsable:!0,children:[["10.指南/02.相关文章/03.使目录栏支持h2~h6标题.md","使目录栏支持h2~h6标题","/pages/8dfab5/"],["10.指南/02.相关文章/06.如何让你的笔记更有表现力.md","如何让你的笔记更有表现力","/pages/dd027d/"],["10.指南/02.相关文章/07.批量操作front matter工具.md","批量操作front matter工具","/pages/2b8e22"],["10.指南/02.相关文章/08.部署.md","部署","/pages/0fc1d2"],["10.指南/02.相关文章/09.关于写文章和一级标题.md","关于写文章和一级标题","/pages/9ae0bd"],["10.指南/02.相关文章/10.关于博客搭建与管理.md","关于博客搭建与管理","/pages/26997d"],["10.指南/02.相关文章/11.在线编辑和新增文章的方法.md","在线编辑和新增文章的方法","/pages/c5a54d"]]}]},{title:"配置",collapsable:!0,children:[{title:"配置",collapsable:!0,children:[["20.配置/01.配置/01.主题配置.md","主题配置","/pages/a20ce8"],["20.配置/01.配置/02.首页配置.md","首页配置","/pages/f14bdb"],["20.配置/01.配置/03.front matter配置.md","front matter配置","/pages/3216b0"],["20.配置/01.配置/04.目录页配置.md","目录页配置","/pages/54651a"],["20.配置/01.配置/05.添加摘要.md","添加摘要","/pages/1cc523"],["20.配置/01.配置/06.修改主题颜色和样式.md","修改主题颜色和样式","/pages/f51918"],["20.配置/01.配置/07.评论栏.md","评论栏","/pages/ce175c"]]}]}],"/70.收藏/":[["01.网站.md","网站","/pages/beb6c0bd8a66cea6"],["02.常用的前端轮子.md","常用的前端轮子","/pages/47cf96/"]],"/后端框架--Spring/":[{title:"Spring基础",collapsable:!0,children:[["5.Spring基础/10.Spring初识.md","Spring初识","/pages/d62e19/"],["5.Spring基础/20.Spring_Xml配置.md","Spring_Xml配置","/pages/2c89d0/"],["5.Spring基础/30.Spring_IOC的XML实现.md","Spring_IOC的XML实现","/pages/c35ea5/"],["5.Spring基础/40.Spring_AOP的XML实现.md","Spring_AOP的XML实现","/pages/af24c9/"],["5.Spring基础/50.Spring_IOC的注解实现.md","Spring_IOC的注解实现","/pages/4ea055/"],["5.Spring基础/60.Spring_AOP的注解实现.md","Spring_AOP的注解实现","/pages/4ea056/"]]},["10.spring_restful注解.md","spring_restful注解","/pages/185350/"],["20.Spring定时任务.md","Spring定时任务","/pages/a5092c/"],["30.Spring动态定时任务.md","Spring动态定时任务","/pages/ab0f00/"],["40.Spring注册失败.md","Spring注册失败","/pages/0c8435/"],["50.SpringAPI文档knife4j.md","SpringAPI文档knife4j","/pages/30c07c/"]],"/数据库-MySQL/":[["10.SQL基本语法.md","SQL基本语法","/pages/08040d/"]],"/编程语言--C++/":[{title:"基础",collapsable:!0,children:[["10.基础/1.C++简介.md","C++简介","/pages/74c8e0/"],["10.基础/2.HelloWorld.md","C++ HelloWorld","/pages/5805d0/"],["10.基础/3.C++基础概念.md","C++基础概念","/pages/29b4c6/"],["10.基础/4.C++基础语法.md","C++基础语法","/pages/8498db/"],["10.基础/5.C++结构体联合体.md","C++结构体联合体","/pages/25293e/"],["10.基础/6.C++类基础概念.md","C++类的基础概念:封装、继承、多态","/pages/a8b12f/"],["10.基础/7.C++抽象类接口.md","C++抽象类接口","/pages/269843/"],["10.基础/8.C++头文件.md","C++头文件","/pages/a79d76/"],["10.基础/9.C++枚举和枚举类.md","C++枚举和枚举类","/pages/8d1751/"]]},{title:"深入理解",collapsable:!0,children:[["20.深入理解/10.详解：C++内存分配.md","深入理解：C++内存分配","/pages/f2ea1e/"],["20.深入理解/20.详解：变量、引用、指针.md","深入理解：变量、引用、指针","/pages/f95db2/"],["20.深入理解/30.详解：C++类的默认函数.md","C++类的默认函数","/pages/f2ea1f/"],["20.深入理解/50.详解：继承和虚表.md","深入理解：继承和虚表","/pages/9516e1/"]]}],"/编程语言--Java/":[["10.Java基础.md","Java基础语法","/pages/740f83/"],["15.JavaBean.md","JavaBean","/pages/e5b6fe/"],["20.Java容器.md","Java容器","/pages/9a5df1/"],{title:"容器类型",collapsable:!0,children:[["21.容器类型/1.List.md","List列表","/pages/311ce3/"],["21.容器类型/2.set.md","set集合","/pages/df5401/"],["21.容器类型/3.map.md","map表","/pages/9e1298/"]]},["30.泛型和数据结构.md","泛型和数据结构","/pages/5fcd9c/"],["40.JAVA反射.md","反射：框架设计的灵魂","/pages/e9f877/"],["50.JUnit单元测试.md","JUnit单元测试","/pages/be8065/"],["60.JAVA内存.md","JAVA内存","/pages/8388fc/"]],"/编程语言--golang/":[["1.HelloWorld.md","Go-HelloWorld","/pages/72b069/"],["2.基础.md","Go-基础","/pages/10f9a7/"],["3.控制流.md","Go-控制流","/pages/7f78ce/"],["4.更多类型.md","Go-更多类型","/pages/600b2c/"],["5.方法.md","Go-方法","/pages/7a5364/"],["6.并发.md","Go-并发","/pages/0466ae/"]],"/软件设计--设计模式/":[["0.设计模式总览.md","设计模式-总览","/pages/eb366e/"],["1.简单工厂模式.md","简单工厂","/pages/715e9b/"],["2.工厂模式.md","工厂模式","/pages/3726e2/"],["3.外观（面板）模式.md","外观（面板）模式","/pages/8f3579/"],["4.单例模式.md","单例模式","/pages/8bab8c/"],["5.原型模式.md","原型模式","/pages/e4eef8/"],["6.抽象工厂模式.md","抽象工厂","/pages/b0b3d1/"],["7.模板方法模式.md","模板方法","/pages/dfc73d/"],["8.策略模式.md","策略模式","/pages/37ea50/"],["9.享元模式.md","享元模式","/pages/fc67c3/"],["10.装饰模式.md","装饰模式","/pages/c938fe/"],["11.代理模式.md","代理模式","/pages/4d70d2/"],["12.桥模式.md","桥模式","/pages/51f3ea/"],["13.适配器模式.md","适配器模型","/pages/54282c/"],["14.迭代器模式.md","迭代器模型","/pages/d6c716/"],["15.备忘录模式.md","备忘录模型","/pages/918f6b/"],["16.命令模式.md","命令模式","/pages/b2b690/"],["17.组合模式.md","组合模型","/pages/135e7e/"],["18.职责链模式.md","职责链模式","/pages/88b3b0/"],["19.访问者模式.md","访问者模式","/pages/d342b4/"],["20.解释器模式.md","解释器模式","/pages/ff0ba9/"],["21.中介者模式.md","中介者模式","/pages/37df0f/"],["22.观察者模式.md","观察者模式","/pages/7cdad8/"],["23.状态模式.md","状态模式","/pages/d841b1/"],["24.建造者模式.md","建造者模式","/pages/d741b1/"],["25.设计模式回顾.md","设计模式整体回顾","/pages/d731b1/"]],"/软件设计--面向对象/":[["1.OO的世界.md","OO的世界","/pages/3ea3c4/"],["2.面向对象的核心概念.md","面向对象的核心概念","/pages/9ac8f7/"]],"/软件设计--领域驱动设计/":[["10.初识DDD.md","认知DDD","/pages/34e57a/"],["20.DDD概览.md","DDD概览","/pages/210a5b/"],["30.值对象、DP.md","值对象、DP","/pages/e880da/"],["40.实体、领域服务、应用服务.md","实体、领域服务、应用服务","/pages/e88Odc/"],["50.基于Cola的初步实践.md","基于Cola的初步实践","/pages/e880df/"],["60.贫血模型和充血模型.md","贫血模型和充血模型","/pages/e880db/"],["70.统一语言.md","统一语言","/pages/e880dd/"]]},indexImg:{navColor:2,switchNavColor:!0,bgTimeColor:!0,bgTimeColorArray:["transparent","rgba(255, 148, 48, .2)","rgba(0, 0, 0, .3)","rgba(0, 0, 0, .5)"],descFade:!0,desc:["我不聪明，但是也没有关系 —— 来自 苏呆呆"],descFontSize:"1.4rem",descFadeInTime:200,descFadeOutTime:100,descNextTime:800,bubble:!1,bubblePosition:0,bubbleNum:200},blogInfo:{blogCreate:"2022-10-1",indexView:!0,pageView:!0,readingTime:!0,eachFileWords:[{name:"编程语言",filePath:"/home/runner/work/blogwriter/blogwriter/docs/00.目录/10.编程语言.md",wordsCount:45,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"10.编程语言",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:null}},title:"编程语言",date:"2022-05-01T23:03:14.000Z",permalink:"/language",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"软件设计",filePath:"/home/runner/work/blogwriter/blogwriter/docs/00.目录/20.软件设计.md",wordsCount:60,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"20.软件设计",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"软件设计相关知识的收集、学习、整理"}},title:"软件设计",date:"2022-05-01T22:58:59.000Z",permalink:"/design",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"常用框架",filePath:"/home/runner/work/blogwriter/blogwriter/docs/00.目录/40.常用框架.md",wordsCount:49,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"40.常用框架",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"常用框架"}},title:"常用框架",date:"2022-06--7 23:03:25",permalink:"/frame",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"常用工具",filePath:"/home/runner/work/blogwriter/blogwriter/docs/00.目录/50.常用工具.md",wordsCount:53,readingTime:"1",pageComponent:{name:"Catalogue",data:{key:"50.常用工具",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"工具使用方式记录"}},title:"常用工具",date:"2022-05-01T23:03:25.000Z",permalink:"/tools",sidebar:!1,article:!1,comment:!1,editLink:!1},{name:"C++",filePath:"/home/runner/work/blogwriter/blogwriter/docs/10.编程语言/10.C++.md",wordsCount:113,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"编程语言--C++",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"C++是一种被广泛使用的计算机程序设计语言。它是一种通用程序设计语言，支持多重编程范式，例如过程化程序设计、数据抽象、面向对象程序设计、泛型程序设计和设计模式等。"}},title:"C++",date:"2022-05-15T22:09:17.000Z",permalink:"/language/c++",article:!1,comment:!1,editLink:!1},{name:"JAVA",filePath:"/home/runner/work/blogwriter/blogwriter/docs/10.编程语言/20.JAVA.md",wordsCount:60,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"编程语言--Java",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对Java相关内容的收集和记录"}},title:"Java",date:"2022-05-15T22:09:17.000Z",permalink:"/language/java",article:!1,comment:!1,editLink:!1},{name:"Go",filePath:"/home/runner/work/blogwriter/blogwriter/docs/10.编程语言/30.Go.md",wordsCount:54,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"编程语言--golang",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"目前所有内容来着：https://tour.go-zh.org/"}},title:"Go",date:"2022-05-15T22:09:17.000Z",permalink:"/language/go",article:!1,comment:!1,editLink:!1},{name:"名词收集",filePath:"/home/runner/work/blogwriter/blogwriter/docs/11.算法/1.名词收集.md",wordsCount:131,readingTime:"1",title:"名词收集",date:"2022-06-10T23:36:34.000Z",permalink:"/pages/21eaf0/",categories:["知识积累","常见知识"],tags:[null]},{name:"系统的概念",filePath:"/home/runner/work/blogwriter/blogwriter/docs/12.操作系统/10.系统的概念.md",wordsCount:24,readingTime:"1",title:"系统的概念",date:"2022-06-10T23:46:02.000Z",permalink:"/pages/e184a5/",categories:["知识积累","系统"],tags:[null]},{name:"系统的进程",filePath:"/home/runner/work/blogwriter/blogwriter/docs/12.操作系统/20.系统的进程.md",wordsCount:21,readingTime:"1",title:"进程",date:"2022-06-10T23:46:49.000Z",permalink:"/pages/360dfa/",categories:["知识积累","系统"],tags:[null]},{name:"系统的线程",filePath:"/home/runner/work/blogwriter/blogwriter/docs/12.操作系统/30.系统的线程.md",wordsCount:21,readingTime:"1",title:"线程",date:"2022-06-10T23:47:16.000Z",permalink:"/pages/aac1ac/",categories:["知识积累","系统"],tags:[null]},{name:"存储",filePath:"/home/runner/work/blogwriter/blogwriter/docs/12.操作系统/40.存储.md",wordsCount:21,readingTime:"1",title:"内存",date:"2022-06-10T23:47:45.000Z",permalink:"/pages/295c69/",categories:["知识积累","系统"],tags:[null]},{name:"面向对象",filePath:"/home/runner/work/blogwriter/blogwriter/docs/20.软件设计/10.面向对象.md",wordsCount:69,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"软件设计--面向对象",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对《面向对象》相关内容的收集和记录"}},title:"面向对象",date:"2022-05-15T22:09:17.000Z",permalink:"/design/oo",article:!1,comment:!1,editLink:!1},{name:"设计模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/20.软件设计/20.设计模式.md",wordsCount:69,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"软件设计--设计模式",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对《设计模式》相关内容的收集和记录"}},title:"设计模式",date:"2022-05-15T22:09:17.000Z",permalink:"/design/GoF",article:!1,comment:!1,editLink:!1},{name:"领域驱动设计",filePath:"/home/runner/work/blogwriter/blogwriter/docs/20.软件设计/30.领域驱动设计.md",wordsCount:96,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"软件设计--领域驱动设计",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对《领域驱动设计》相关内容的收集和记录；文章从面向对象，代码优化入手，同大家一起了解DDD。"}},title:"领域驱动设计",date:"2022-05-15T22:09:17.000Z",permalink:"/design/ddd",article:!1,comment:!1,editLink:!1},{name:"Spring",filePath:"/home/runner/work/blogwriter/blogwriter/docs/40.常用框架/10.后端框架/10.Spring.md",wordsCount:62,readingTime:"1",pageComponent:{name:"Catalogue",data:{path:"后端框架--Spring",imgUrl:"https://cdn.addai.cn/blog/网站使用/books.png",description:"本章内容为博主对Spring相关内容的收集和记录"}},title:"Spring相关",date:"2022-05-15T22:09:17.000Z",permalink:"/frame/spring",article:!1,comment:!1,editLink:!1},{name:"常用Git命令清单",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/10.手册/00.常用Git命令清单.md",wordsCount:"1.8k",readingTime:"7.4m",title:"常用Git命令清单",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/8292d8/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git变基合并",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/10.手册/03.Git变基合并.md",wordsCount:"1.3k",readingTime:"5.3m",title:"Git变基合并",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c10281/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git命令思维导图",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/10.手册/06.Git命令思维导图.md",wordsCount:61,readingTime:"1",title:"Git命令思维导图",date:"2020-11-18T17:46:22.000Z",permalink:"/pages/4cbc21/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git基础与命令",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/10.Git基础与命令.md",wordsCount:"4k",readingTime:"15.6m",title:"Git基础与命令",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/635088/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git工具-重写历史",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/100.Git工具-重写历史.md",wordsCount:"3.9k",readingTime:"15.5m",title:"Git工具-重写历史",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/1832fe/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git工具-重置揭密",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/110.Git工具-重置揭密.md",wordsCount:"4.1k",readingTime:"15.7m",title:"Git工具-重置揭密",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/d9e9c6/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git分支-分支原理",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/20.Git分支-分支原理.md",wordsCount:"2k",readingTime:"7.8m",title:"Git分支-分支原理",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/4bef1a/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git分支的新建与合并-分支操作",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/30.Git分支的新建与合并-分支操作.md",wordsCount:950,readingTime:"3.6m",title:"Git分支的新建与合并-分支操作",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/ea5a8c/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git分支管理-查看分支",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/40.Git分支管理-查看分支.md",wordsCount:409,readingTime:"1.6m",title:"Git分支管理-查看分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/a399b3/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git分支开发工作流",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/50.Git分支开发工作流.md",wordsCount:"1.3k",readingTime:"4.6m",title:"Git分支开发工作流",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/49ee30/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git分支-远程分支",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/60.Git分支-远程分支.md",wordsCount:"3.5k",readingTime:"13.4m",title:"Git分支-远程分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/574d62/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git分支-变基",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/70.Git分支-变基.md",wordsCount:"4.7k",readingTime:"17.3m",title:"Git分支-变基",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/3a3247/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git工具-查看修订版本",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/80.Git工具-查看修订版本.md",wordsCount:"3.6k",readingTime:"14.1m",title:"Git工具-查看修订版本",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c984d1/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"Git工具-交互式暂存",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/10.Git/20.文档笔记/90.Git工具-交互式暂存.md",wordsCount:"1.6k",readingTime:"7.3m",title:"Git工具-交互式暂存",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/76d859/",categories:["《Git》学习笔记"],tags:["Git"]},{name:"CMake简述",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/20.CMake/1.CMake简述.md",wordsCount:768,readingTime:"2.7m",title:"CMake简述",date:"2023-04-03T22:29:57.000Z",permalink:"/pages/6a3b4c/",categories:["常用工具","CMake"],tags:["CMake"]},{name:"CMake详解",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/20.CMake/2.CMake详解.md",wordsCount:"5.3k",readingTime:"23.6m",title:"CMake详解",date:"2023-04-03T22:52:32.000Z",permalink:"/pages/44f8a2/",categories:["常用工具","CMake"],tags:["CMake"]},{name:"NVM使用",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/30.NVM/1.NVM使用.md",wordsCount:459,readingTime:"1.9m",title:"NVM使用",date:"2023-04-03T23:57:10.000Z",permalink:"/pages/a038dc/",categories:["常用工具","NVM"],tags:["NVM"]},{name:"认知nginx",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/60.部署/10.认知nginx.md",wordsCount:114,readingTime:"1",title:"认知nginx",date:"2022-05-13T14:47:29.000Z",permalink:"/pages/dafb6a/",categories:["知识积累","部署和运维相关"],tags:["nginx"]},{name:"阿里云存储容器选择",filePath:"/home/runner/work/blogwriter/blogwriter/docs/50.常用工具/60.部署/20.阿里云存储容器选择.md",wordsCount:850,readingTime:"3m",title:"存储容器选择",date:"2022-06-02T10:51:11.000Z",permalink:"/pages/e8f440/",categories:["知识积累","部署"],tags:[null]},{name:"介绍",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/1.介绍.md",wordsCount:256,readingTime:"1.3m",title:"介绍",date:"2022-05-01T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},{name:"介绍",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/02.介绍.md",wordsCount:"1.1k",readingTime:"3.8m",title:"介绍",date:"2020-05-11T13:54:03.000Z",permalink:"/pages/a2f161",article:!1},{name:"快速上手",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/03.快速上手.md",wordsCount:493,readingTime:"2.3m",title:"快速上手",date:"2020-05-11T13:54:40.000Z",permalink:"/pages/793dcb",article:!1},{name:"目录结构",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/04.目录结构.md",wordsCount:587,readingTime:"2.3m",title:"目录结构",date:"2020-05-11T13:54:56.000Z",permalink:"/pages/2f674a",article:!1},{name:"核心配置和约定",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/05.核心配置和约定.md",wordsCount:908,readingTime:"3.5m",title:"构建结构化站点的核心配置和约定",date:"2020-05-12T11:01:21.000Z",permalink:"/pages/33d574",article:!1},{name:"自动生成front matter",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/06.自动生成front matter.md",wordsCount:841,readingTime:"3.2m",title:"自动生成front matter",date:"2020-05-12T11:46:37.000Z",permalink:"/pages/088c16",article:!1},{name:"Markdown 容器",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/07.Markdown 容器.md",wordsCount:"2k",readingTime:"8.7m",title:"Markdown 容器",date:"2020-05-29T11:16:18.000Z",permalink:"/pages/d0d7eb/",article:!1},{name:"Markdown 中使用组件",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/01.指南/08.Markdown 中使用组件.md",wordsCount:363,readingTime:"1.6m",title:"Markdown 中使用组件",date:"2020-11-10T18:56:22.000Z",permalink:"/pages/197691/",article:!1},{name:"使目录栏支持h2~h6标题",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/03.使目录栏支持h2~h6标题.md",wordsCount:167,readingTime:"1",title:"使目录栏支持h2~h6标题",date:"2022-03-18T15:02:52.000Z",permalink:"/pages/8dfab5/",article:!1},{name:"如何让你的笔记更有表现力",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/06.如何让你的笔记更有表现力.md",wordsCount:"1.1k",readingTime:"5.8m",title:"如何让你的笔记更有表现力",date:"2020-09-26T21:13:59.000Z",permalink:"/pages/dd027d/",article:!1},{name:"批量操作front matter工具",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/07.批量操作front matter工具.md",wordsCount:422,readingTime:"1.6m",title:"批量操作front matter工具",date:"2020-05-13T11:52:45.000Z",permalink:"/pages/2b8e22",article:!1},{name:"部署",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/08.部署.md",wordsCount:677,readingTime:"2.9m",title:"部署",date:"2020-05-13T12:10:53.000Z",permalink:"/pages/0fc1d2",article:!1},{name:"关于写文章和一级标题",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/09.关于写文章和一级标题.md",wordsCount:361,readingTime:"1.3m",title:"关于写文章和一级标题",date:"2020-05-13T12:07:32.000Z",permalink:"/pages/9ae0bd",article:!1},{name:"关于博客搭建与管理",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/10.关于博客搭建与管理.md",wordsCount:213,readingTime:"1",title:"关于博客搭建与管理",date:"2020-05-13T12:12:33.000Z",permalink:"/pages/26997d",article:!1},{name:"在线编辑和新增文章的方法",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/10.指南/02.相关文章/11.在线编辑和新增文章的方法.md",wordsCount:307,readingTime:"1.2m",title:"在线编辑和新增文章的方法",date:"2020-05-19T11:17:58.000Z",permalink:"/pages/c5a54d",article:!1},{name:"列表",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/2.列表.md",wordsCount:"2.1k",readingTime:"9.8m",title:"列表",date:"2023-03-08T11:39:00.000Z",permalink:"/pages/83ed2b/",titleTag:"原创",categories:"+ 关于",tags:"+ 关于",sticky:1},{name:"主题配置",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/01.主题配置.md",wordsCount:"2.6k",readingTime:"11.5m",title:"主题配置",date:"2020-05-12T14:57:21.000Z",permalink:"/pages/a20ce8",article:!1},{name:"首页配置",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/02.首页配置.md",wordsCount:653,readingTime:"2.6m",title:"首页配置",date:"2020-05-12T15:36:50.000Z",permalink:"/pages/f14bdb",article:!1},{name:"front matter配置",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/03.front matter配置.md",wordsCount:439,readingTime:"1.7m",title:"front matter配置",date:"2020-05-12T15:37:00.000Z",permalink:"/pages/3216b0",article:!1},{name:"目录页配置",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/04.目录页配置.md",wordsCount:754,readingTime:"2.9m",title:"目录页配置",date:"2020-05-13T10:58:07.000Z",permalink:"/pages/54651a",article:!1},{name:"添加摘要",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/05.添加摘要.md",wordsCount:290,readingTime:"1.1m",title:"添加摘要",date:"2020-05-13T11:47:49.000Z",permalink:"/pages/1cc523",article:!1},{name:"修改主题颜色和样式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/06.修改主题颜色和样式.md",wordsCount:454,readingTime:"2m",title:"修改主题颜色和样式",date:"2020-05-13T11:48:50.000Z",permalink:"/pages/f51918",article:!1},{name:"评论栏",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/20.配置/01.配置/07.评论栏.md",wordsCount:101,readingTime:"1",title:"评论栏",date:"2020-05-13T12:00:39.000Z",permalink:"/pages/ce175c",article:!1},{name:"资料收集",filePath:"/home/runner/work/blogwriter/blogwriter/docs/60.关于/3.资料收集.md",wordsCount:26,readingTime:"1",title:"资料收集",date:"2023-03-08T11:45:14.000Z",permalink:"/pages/0a2075/",titleTag:"原创",categories:["关于"],tags:["关于"],sticky:2},{name:"网站",filePath:"/home/runner/work/blogwriter/blogwriter/docs/70.收藏/01.网站.md",wordsCount:"3.5k",readingTime:"15.2m",title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2020-04-19T11:33:04.000Z",article:!1},{name:"常用的前端轮子",filePath:"/home/runner/work/blogwriter/blogwriter/docs/70.收藏/02.常用的前端轮子.md",wordsCount:299,readingTime:"1.5m",title:"常用的前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/pages/47cf96/",article:!1},{name:"水平扩展和垂直扩展",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/1.水平扩展和垂直扩展.md",wordsCount:161,readingTime:"1",title:"水平扩展和垂直扩展",date:"2022-06-09T22:26:59.000Z",permalink:"/pages/560a28/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"后向纠错",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/10.后向纠错.md",wordsCount:22,readingTime:"1",title:"后向纠错",date:"2022-06-10T20:13:11.000Z",permalink:"/pages/7cdb84/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"教育的意义",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/100.教育的意义.md",wordsCount:738,readingTime:"2.5m",title:"教育的意义",date:"2022-05-04T19:59:18.000Z",permalink:"/pages/5ce909/",categories:["生活记杂"],tags:["教育"],sidebar:"auto"},{name:"HelloWord的执行过程",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/11.HelloWord的执行过程.md",wordsCount:24,readingTime:"1",title:"HelloWord的执行过程",date:"2022-06-10T23:14:46.000Z",permalink:"/pages/f96e78/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"DNS是怎么工作的",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/12.DNS是怎么工作的.md",wordsCount:25,readingTime:"1",title:"DNS是怎么工作的",date:"2022-06-10T23:33:47.000Z",permalink:"/pages/876d21/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"http和https有什么区别",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/13.http和https有什么区别.md",wordsCount:25,readingTime:"1",title:"http和https有什么区别",date:"2022-06-10T23:30:07.000Z",permalink:"/pages/6a8491/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"ipv4和ipv6有什么区别",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/14.ipv4和ipv6有什么区别.md",wordsCount:25,readingTime:"1",title:"ipv4和ipv6有什么区别",date:"2022-06-10T23:35:05.000Z",permalink:"/pages/0ad58c/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"一个网页的执行过程",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/20.一个网页的执行过程.md",wordsCount:27,readingTime:"1",title:"一个网页的执行过程",date:"2022-06-10T23:15:04.000Z",permalink:"/pages/fe33e1/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"如何稳定占用一半的CPU",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/30.如何稳定占用一半的CPU.md",wordsCount:28,readingTime:"1",title:"如何稳定占用一半的CPU",date:"2022-06-10T23:22:08.000Z",permalink:"/pages/71575b/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"如何稳定的占用一半的内存",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/40.如何稳定的占用一半的内存.md",wordsCount:30,readingTime:"1",title:"如何稳定的占用一半的内存",date:"2022-06-10T23:22:30.000Z",permalink:"/pages/b9419f/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"如何使用udp做一个安全的传输",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/50.如何使用udp做一个安全的传输.md",wordsCount:40,readingTime:"1",title:"如何使用udp做一个安全的传输",date:"2022-06-10T23:30:57.000Z",permalink:"/pages/2e9782/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"TCP下载一个大文件的过程",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/70.TCP下载一个大文件的过程.md",wordsCount:44,readingTime:"1",title:"TCP下载一个大文件的过程",date:"2022-06-10T23:31:28.000Z",permalink:"/pages/35cb80/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"Qt原子操作",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/71.Qt原子操作.md",wordsCount:"1.6k",readingTime:"7.1m",title:"Qt原子操作",date:"2023-03-15T17:53:39.000Z",permalink:"/pages/1eec76/",sidebar:"auto",categories:["随笔"],tags:["QAtomicInt"]},{name:"前向纠错",filePath:"/home/runner/work/blogwriter/blogwriter/docs/_posts/随笔/9.前向纠错.md",wordsCount:22,readingTime:"1",title:"前向纠错",date:"2022-06-10T20:12:46.000Z",permalink:"/pages/7d6e5c/",categories:["随笔"],tags:[null],sidebar:"auto"},{name:"spring_restful注解",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/10.spring_restful注解.md",wordsCount:"2k",readingTime:"8.3m",title:"spring_restful注解",date:"2022-05-04T19:29:07.000Z",permalink:"/pages/185350/",categories:["Spring相关"],tags:["RESTFUL"]},{name:"Spring定时任务",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/20.Spring定时任务.md",wordsCount:"1.2k",readingTime:"4.8m",title:"Spring定时任务",date:"2022-05-10T11:29:07.000Z",permalink:"/pages/a5092c/",categories:["Spring相关"],tags:[null]},{name:"Spring动态定时任务",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/30.Spring动态定时任务.md",wordsCount:639,readingTime:"2.8m",title:"Spring动态定时任务",date:"2022-05-10T14:35:45.000Z",permalink:"/pages/ab0f00/",categories:["Spring相关"],tags:[null]},{name:"Spring注册失败",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/40.Spring注册失败.md",wordsCount:722,readingTime:"3.2m",title:"Spring注册失败",date:"2022-05-13T14:27:55.000Z",permalink:"/pages/0c8435/",categories:["Spring相关"],tags:[null]},{name:"Spring初识",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/5.Spring基础/10.Spring初识.md",wordsCount:227,readingTime:"1",title:"Spring初识",date:"2022-05-25T21:31:40.000Z",permalink:"/pages/d62e19/",categories:["Spring相关"],tags:[null]},{name:"Spring_Xml配置",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/5.Spring基础/20.Spring_Xml配置.md",wordsCount:594,readingTime:"3m",title:"Spring_Xml配置",date:"2022-05-25T21:36:16.000Z",permalink:"/pages/2c89d0/",categories:["Spring相关"],tags:[null]},{name:"Spring_IOC的XML实现",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/5.Spring基础/30.Spring_IOC的XML实现.md",wordsCount:"1.4k",readingTime:"5.9m",title:"Spring_IOC的XML实现",date:"2022-05-14T11:54:22.000Z",permalink:"/pages/c35ea5/",categories:["Spring相关"],tags:[null]},{name:"Spring_AOP的XML实现",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/5.Spring基础/40.Spring_AOP的XML实现.md",wordsCount:"1.5k",readingTime:"6.4m",title:"Spring_AOP的XML实现",date:"2022-05-25T22:06:28.000Z",permalink:"/pages/af24c9/",categories:["Spring相关"],tags:[null]},{name:"Spring_IOC的注解实现",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/5.Spring基础/50.Spring_IOC的注解实现.md",wordsCount:"1.5k",readingTime:"7.1m",title:"Spring_IOC的注解实现",date:"2022-05-14T11:53:39.000Z",permalink:"/pages/4ea055/",categories:["Spring相关"],tags:[null]},{name:"Spring_AOP的注解实现",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/5.Spring基础/60.Spring_AOP的注解实现.md",wordsCount:490,readingTime:"2.4m",title:"Spring_AOP的注解实现",date:"2022-05-14T11:53:39.000Z",permalink:"/pages/4ea056/",categories:["Spring相关"],tags:[null]},{name:"SpringAPI文档knife4j",filePath:"/home/runner/work/blogwriter/blogwriter/docs/后端框架--Spring/50.SpringAPI文档knife4j.md",wordsCount:528,readingTime:"2.5m",title:"SpringAPI文档knife4j",date:"2022-05-30T14:30:42.000Z",permalink:"/pages/30c07c/",categories:["Spring相关"],tags:["knife4j"]},{name:"SQL基本语法",filePath:"/home/runner/work/blogwriter/blogwriter/docs/数据库-MySQL/10.SQL基本语法.md",wordsCount:319,readingTime:"1.2m",title:"SQL基本语法",date:"2022-05-14T23:45:15.000Z",permalink:"/pages/08040d/",categories:["知识积累","SQL"],tags:[null]},{name:"C++简介",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/1.C++简介.md",wordsCount:"1.4k",readingTime:"5.4m",title:"C++简介",date:"2022-09-25T20:04:36.000Z",permalink:"/pages/74c8e0/",categories:["C++"],tags:["C++"]},{name:"HelloWorld",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/2.HelloWorld.md",wordsCount:385,readingTime:"1.6m",title:"C++ HelloWorld",date:"2022-09-26T19:49:53.000Z",permalink:"/pages/5805d0/",categories:["C++"],tags:[null]},{name:"C++基础概念",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/3.C++基础概念.md",wordsCount:516,readingTime:"2.1m",title:"C++基础概念",date:"2023-01-29T17:32:05.000Z",permalink:"/pages/29b4c6/",categories:["C++","基础语法"],tags:["函数","参数","返回值","变量","作用域","全局变量","局部变量","形参"]},{name:"C++基础语法",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/4.C++基础语法.md",wordsCount:"3.9k",readingTime:"16.8m",title:"C++基础语法",date:"2022-09-26T21:14:43.000Z",permalink:"/pages/8498db/",categories:["C++"],tags:["基础类型","修饰符","运算符","new","delete","malloc","free","数组","指针","数组","赋值语句","条件语句","循环语句","try","catch","throw"]},{name:"C++结构体联合体",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/5.C++结构体联合体.md",wordsCount:633,readingTime:"2.6m",title:"C++结构体联合体",date:"2023-02-01T16:31:17.000Z",permalink:"/pages/25293e/",categories:["C++","基础语法"],tags:["结构体","联合体"]},{name:"C++类基础概念",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/6.C++类基础概念.md",wordsCount:"3k",readingTime:"12.1m",title:"C++类的基础概念:封装、继承、多态",date:"2023-01-29T16:28:38.000Z",permalink:"/pages/a8b12f/",categories:["C++","基础语法"],tags:["Class","封装","继承","多态","抽象","类","对象","this指针","构造函数","析构函数"]},{name:"C++抽象类接口",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/7.C++抽象类接口.md",wordsCount:733,readingTime:"2.7m",title:"C++抽象类接口",date:"2023-02-02T15:51:42.000Z",permalink:"/pages/269843/",categories:["C++","基础语法"],tags:["接口","纯虚函数","C++接口"]},{name:"C++头文件",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/8.C++头文件.md",wordsCount:"2.4k",readingTime:"8.9m",title:"C++头文件",date:"2023-02-14T15:51:59.000Z",permalink:"/pages/a79d76/",categories:["C++","基础语法"],tags:["头文件"]},{name:"C++枚举和枚举类",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/10.基础/9.C++枚举和枚举类.md",wordsCount:701,readingTime:"3m",title:"C++枚举和枚举类",date:"2023-02-01T17:15:08.000Z",permalink:"/pages/8d1751/",categories:["C++","基础语法"],tags:["枚举","枚举类"]},{name:"详解：C++内存分配",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/20.深入理解/10.详解：C++内存分配.md",wordsCount:"3.4k",readingTime:"13.4m",title:"深入理解：C++内存分配",date:"2023-01-08T23:07:46.000Z",permalink:"/pages/f2ea1e/",categories:["C++"],tags:["内存分配"]},{name:"详解：变量、引用、指针",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/20.深入理解/20.详解：变量、引用、指针.md",wordsCount:535,readingTime:"2.3m",title:"深入理解：变量、引用、指针",date:"2022-12-25T19:40:44.000Z",permalink:"/pages/f95db2/",categories:["C++"],tags:["变量"]},{name:"详解：C++类的默认函数",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/20.深入理解/30.详解：C++类的默认函数.md",wordsCount:29,readingTime:"1",title:"C++类的默认函数",date:"2023-01-08T23:07:46.000Z",permalink:"/pages/f2ea1f/",categories:["C++"],tags:["构造","析构","拷贝构造",null]},{name:"详解：继承和虚表",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--C++/20.深入理解/50.详解：继承和虚表.md",wordsCount:31,readingTime:"1",title:"深入理解：继承和虚表",date:"2023-01-30T08:37:43.000Z",permalink:"/pages/9516e1/",categories:["C++","理解和使用"],tags:[null]},{name:"Java基础",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/10.Java基础.md",wordsCount:"2.2k",readingTime:"8.7m",title:"Java基础语法",date:"2022-05-04T19:36:07.000Z",permalink:"/pages/740f83/",categories:["Java基础知识"],tags:[null]},{name:"JavaBean",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/15.JavaBean.md",wordsCount:114,readingTime:"1",title:"JavaBean",date:"2022-05-15T01:11:51.000Z",permalink:"/pages/e5b6fe/",categories:["Java基础知识"],tags:[null]},{name:"Java容器",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/20.Java容器.md",wordsCount:486,readingTime:"2m",title:"Java容器",date:"2022-05-04T19:36:09.000Z",permalink:"/pages/9a5df1/",categories:["Java基础知识"],tags:[null]},{name:"List",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/21.容器类型/1.List.md",wordsCount:"1k",readingTime:"4.5m",title:"List列表",date:"2022-05-15T01:13:38.000Z",permalink:"/pages/311ce3/",categories:["Java基础知识"],tags:[null]},{name:"set",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/21.容器类型/2.set.md",wordsCount:"1.2k",readingTime:"5.5m",title:"set集合",date:"2022-05-15T01:16:34.000Z",permalink:"/pages/df5401/",categories:["Java基础知识"],tags:[null]},{name:"map",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/21.容器类型/3.map.md",wordsCount:955,readingTime:"4.1m",title:"map表",date:"2022-05-15T01:16:45.000Z",permalink:"/pages/9e1298/",categories:["Java基础知识"],tags:[null]},{name:"泛型和数据结构",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/30.泛型和数据结构.md",wordsCount:"1.2k",readingTime:"5m",title:"泛型和数据结构",date:"2022-05-04T19:36:12.000Z",permalink:"/pages/5fcd9c/",categories:["Java基础知识"],tags:[null]},{name:"JAVA反射",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/40.JAVA反射.md",wordsCount:490,readingTime:"1.9m",title:"反射：框架设计的灵魂",date:"2022-05-15T00:07:31.000Z",permalink:"/pages/e9f877/",categories:["Java基础知识"],tags:[null]},{name:"JUnit单元测试",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/50.JUnit单元测试.md",wordsCount:253,readingTime:"1",title:"JUnit单元测试",date:"2022-05-15T01:07:39.000Z",permalink:"/pages/be8065/",categories:["Java基础知识"],tags:[null]},{name:"JAVA内存",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--Java/60.JAVA内存.md",wordsCount:250,readingTime:"1",title:"JAVA内存",date:"2022-05-15T01:06:35.000Z",permalink:"/pages/8388fc/",categories:["Java基础知识"],tags:[null]},{name:"HelloWorld",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--golang/1.HelloWorld.md",wordsCount:33,readingTime:"1",title:"Go-HelloWorld",date:"2023-03-13T09:09:21.000Z",permalink:"/pages/72b069/",categories:["编程语言-golang"],tags:[null]},{name:"基础",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--golang/2.基础.md",wordsCount:"1.9k",readingTime:"8m",title:"Go-基础",date:"2023-03-13T09:04:50.000Z",permalink:"/pages/10f9a7/",categories:["编程语言-golang"],tags:[null]},{name:"控制流",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--golang/3.控制流.md",wordsCount:"1.6k",readingTime:"6.8m",title:"Go-控制流",date:"2023-03-13T09:05:24.000Z",permalink:"/pages/7f78ce/",categories:["编程语言-golang"],tags:[null]},{name:"更多类型",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--golang/4.更多类型.md",wordsCount:"3.5k",readingTime:"16.1m",title:"Go-更多类型",date:"2023-03-13T09:05:53.000Z",permalink:"/pages/600b2c/",categories:["编程语言-golang"],tags:[null]},{name:"方法",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--golang/5.方法.md",wordsCount:"4.3k",readingTime:"19.5m",title:"Go-方法",date:"2023-03-13T16:29:20.000Z",permalink:"/pages/7a5364/",categories:["编程语言-golang"],tags:[null]},{name:"并发",filePath:"/home/runner/work/blogwriter/blogwriter/docs/编程语言--golang/6.并发.md",wordsCount:"2.1k",readingTime:"9.4m",title:"Go-并发",date:"2023-03-16T23:34:29.000Z",permalink:"/pages/0466ae/",categories:["编程语言--golang"],tags:[null]},{name:"设计模式总览",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/0.设计模式总览.md",wordsCount:"1.1k",readingTime:"3.8m",title:"设计模式-总览",date:"2022-05-01T22:52:02.000Z",permalink:"/pages/eb366e/",categories:["设计模式"],tags:["设计模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"简单工厂模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/1.简单工厂模式.md",wordsCount:683,readingTime:"2.7m",title:"简单工厂",date:"2022-05-03T18:13:02.000Z",permalink:"/pages/715e9b/",categories:["设计模式"],tags:["简单工厂"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"装饰模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/10.装饰模式.md",wordsCount:672,readingTime:"2.5m",title:"装饰模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/c938fe/",categories:["设计模式"],tags:["装饰模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"代理模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/11.代理模式.md",wordsCount:567,readingTime:"2.1m",title:"代理模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/4d70d2/",categories:["设计模式"],tags:["代理模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"桥模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/12.桥模式.md",wordsCount:658,readingTime:"2.6m",title:"桥模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/51f3ea/",categories:["设计模式"],tags:["桥模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"适配器模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/13.适配器模式.md",wordsCount:859,readingTime:"3.4m",title:"适配器模型",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/54282c/",categories:["设计模式"],tags:["适配器模式"]},{name:"迭代器模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/14.迭代器模式.md",wordsCount:746,readingTime:"3.5m",title:"迭代器模型",date:"2022-06-11T21:22:38.000Z",permalink:"/pages/d6c716/",categories:["设计模式"],tags:["迭代器模式"]},{name:"备忘录模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/15.备忘录模式.md",wordsCount:561,readingTime:"2.3m",title:"备忘录模型",date:"2022-06-11T21:22:58.000Z",permalink:"/pages/918f6b/",categories:["设计模式"],tags:["备忘录模式"]},{name:"命令模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/16.命令模式.md",wordsCount:"1.1k",readingTime:"4.2m",title:"命令模式",date:"2022-07-21T21:23:14.000Z",permalink:"/pages/b2b690/",categories:["设计模式"],tags:["命令模式"]},{name:"组合模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/17.组合模式.md",wordsCount:"1k",readingTime:"4.4m",title:"组合模型",date:"2022-07-23T21:23:44.000Z",permalink:"/pages/135e7e/",categories:["设计模式"],tags:["组合模式"]},{name:"职责链模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/18.职责链模式.md",wordsCount:"1.1k",readingTime:"4.3m",title:"职责链模式",date:"2022-07-28T21:24:12.000Z",permalink:"/pages/88b3b0/",categories:["设计模式"],tags:["职责链模式"]},{name:"访问者模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/19.访问者模式.md",wordsCount:"1.1k",readingTime:"4.7m",title:"访问者模式",date:"2022-08-01T21:24:45.000Z",permalink:"/pages/d342b4/",categories:["设计模式"],tags:["访问者模式"]},{name:"工厂模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/2.工厂模式.md",wordsCount:848,readingTime:"3.2m",title:"工厂模式",date:"2022-05-03T18:20:28.000Z",permalink:"/pages/3726e2/",categories:["设计模式"],tags:["设计模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"解释器模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/20.解释器模式.md",wordsCount:"1.1k",readingTime:"4.3m",title:"解释器模式",date:"2022-08-31T21:25:36.000Z",permalink:"/pages/ff0ba9/",categories:["设计模式"],tags:["解释器模式"]},{name:"中介者模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/21.中介者模式.md",wordsCount:704,readingTime:"3.1m",title:"中介者模式",date:"2022-09-02T21:26:14.000Z",permalink:"/pages/37df0f/",categories:["设计模式"],tags:["中介者模式"]},{name:"观察者模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/22.观察者模式.md",wordsCount:782,readingTime:"3m",title:"观察者模式",date:"2022-09-05T21:26:35.000Z",permalink:"/pages/7cdad8/",categories:["设计模式"],tags:["观察者模式"]},{name:"状态模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/23.状态模式.md",wordsCount:692,readingTime:"2.7m",title:"状态模式",date:"2022-09-14T21:27:22.000Z",permalink:"/pages/d841b1/",categories:["设计模式"],tags:["状态模式"]},{name:"建造者模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/24.建造者模式.md",wordsCount:"1.1k",readingTime:"4.7m",title:"建造者模式",date:"2022-09-14T21:27:22.000Z",permalink:"/pages/d741b1/",categories:["设计模式"],tags:["建造者模式"]},{name:"设计模式回顾",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/25.设计模式回顾.md",wordsCount:"3.9k",readingTime:"13.3m",title:"设计模式整体回顾",date:"2022-09-22T21:27:22.000Z",permalink:"/pages/d731b1/",categories:["设计模式"],tags:["设计模式","总结"]},{name:"外观（面板）模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/3.外观（面板）模式.md",wordsCount:542,readingTime:"2.1m",title:"外观（面板）模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/8f3579/",categories:["设计模式"],tags:["外观模式","面板模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"单例模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/4.单例模式.md",wordsCount:910,readingTime:"3.7m",title:"单例模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/8bab8c/",categories:["设计模式"],tags:["单例模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"原型模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/5.原型模式.md",wordsCount:510,readingTime:"1.9m",title:"原型模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/e4eef8/",categories:["设计模式"],tags:["原型模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"抽象工厂模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/6.抽象工厂模式.md",wordsCount:538,readingTime:"2.1m",title:"抽象工厂",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/b0b3d1/",categories:["设计模式"],tags:["抽象工厂"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"模板方法模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/7.模板方法模式.md",wordsCount:442,readingTime:"1.7m",title:"模板方法",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/dfc73d/",categories:["设计模式"],tags:["模板方法"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"策略模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/8.策略模式.md",wordsCount:469,readingTime:"1.8m",title:"策略模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/37ea50/",categories:["设计模式"],tags:["策略模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"享元模式",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--设计模式/9.享元模式.md",wordsCount:745,readingTime:"2.8m",title:"享元模式",date:"2022-05-03T18:27:14.000Z",permalink:"/pages/fc67c3/",categories:["设计模式"],tags:["享元模式"],author:{name:"苏呆呆",link:"https://github.com/su-dd"}},{name:"OO的世界",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--面向对象/1.OO的世界.md",wordsCount:"2.2k",readingTime:"7.4m",title:"OO的世界",date:"2022-05-04T11:45:37.000Z",permalink:"/pages/3ea3c4/",categories:["面向对象"],tags:["面向对象"]},{name:"面向对象的核心概念",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--面向对象/2.面向对象的核心概念.md",wordsCount:658,readingTime:"2.2m",title:"面向对象的核心概念",date:"2022-05-04T12:01:48.000Z",permalink:"/pages/9ac8f7/",categories:["面向对象"],tags:["面向对象"]},{name:"初识DDD",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/10.初识DDD.md",wordsCount:584,readingTime:"2.1m",title:"认知DDD",date:"2022-05-26T19:59:06.000Z",permalink:"/pages/34e57a/",categories:["领域驱动设计"],tags:[null]},{name:"DDD概览",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/20.DDD概览.md",wordsCount:51,readingTime:"1",title:"DDD概览",date:"2022-05-29T20:51:30.000Z",permalink:"/pages/210a5b/",categories:["领域驱动设计"],tags:[null]},{name:"值对象、DP",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/30.值对象、DP.md",wordsCount:"1.8k",readingTime:"7.3m",title:"值对象、DP",date:"2022-05-04T10:39:02.000Z",permalink:"/pages/e880da/",categories:["领域驱动设计"],tags:["DDD"]},{name:"实体、领域服务、应用服务",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/40.实体、领域服务、应用服务.md",wordsCount:"1.7k",readingTime:"7m",title:"实体、领域服务、应用服务",date:"2O22-05-05 1O:39:O2",permalink:"/pages/e88Odc/",categories:["领域驱动设计"],tags:["DDD"]},{name:"基于Cola的初步实践",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/50.基于Cola的初步实践.md",wordsCount:"2k",readingTime:"8.6m",title:"基于Cola的初步实践",date:"2022-05-05T13:39:02.000Z",permalink:"/pages/e880df/",categories:["领域驱动设计"],tags:["DDD","COLA"]},{name:"贫血模型和充血模型",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/60.贫血模型和充血模型.md",wordsCount:646,readingTime:"2.3m",title:"贫血模型和充血模型",date:"2022-05-04T10:39:02.000Z",permalink:"/pages/e880db/",categories:["领域模型"],tags:["领域模型","DDD"]},{name:"统一语言",filePath:"/home/runner/work/blogwriter/blogwriter/docs/软件设计--领域驱动设计/70.统一语言.md",wordsCount:551,readingTime:"1.9m",title:"统一语言",date:"2022-05-05T10:39:02.000Z",permalink:"/pages/e880dd/",categories:["领域驱动设计",null],tags:["DDD"]}],mdFileCountType:"archives",totalWords:"archives",moutedEvent:".tags-wrapper",indexIteration:2500,pageIteration:2500},author:{name:"su-dd",link:"https://github.com/su-dd"},blogger:{avatar:"https://cdn.addai.cn/blog/网站使用/呆呆.webp",name:"苏呆呆",slogan:"一个向往美好生活的笨人。"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:987380454@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/su-dd"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2022,copyrightInfo:'daidai | <a href="https://beian.miit.gov.cn/" target="_blank">皖ICP备2023000523号-1</a>'},htmlModules:{}},locales:{"/":{lang:"zh-CN",title:"苏呆呆的博客",description:"一个向往美好生活的笨人。",path:"/"}}};var kl=t(48),wl=t(98),El=t(99),_l=t(11);var Cl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(_l.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(_l.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(_l.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(_l.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(_l.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Vt.component(wl.default),Vt.component(El.default);function Tl(n){return n.toString().padStart(2,"0")}t(248);Vt.component("Fantasy",()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,354))),Vt.component("IndexBigImg",()=>Promise.all([t.e(0),t.e(5)]).then(t.bind(null,355))),Vt.component("LastReadingPopup",()=>Promise.resolve().then(t.bind(null,48))),Vt.component("PageInfo",()=>t.e(8).then(t.bind(null,356))),Vt.component("WebInfo",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,351))),Vt.component("Badge",()=>Promise.all([t.e(0),t.e(6)]).then(t.bind(null,511))),Vt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,98))),Vt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,99)));t(249),t(250);var Al=t(97),Sl=t.n(Al),Il=t(27);let Bl,Pl;var zl;"valine"===(zl="gitalk")?t.e(166).then(t.t.bind(null,347,7)).then(n=>Pl=n.default):"gitalk"===zl&&Promise.all([t.e(0),t.e(165)]).then(t.t.bind(null,348,7)).then(()=>t.e(164).then(t.t.bind(null,349,7))).then(n=>Bl=n.default);function Dl(n,e){const t={};return Reflect.ownKeys(n).forEach(a=>{if("string"==typeof n[a])try{t[a]=Sl.a.render(n[a],e)}catch(e){console.warn(`Comment config option error at key named "${a}"`),console.warn("More info: "+e.message),t[a]=n[a]}else t[a]=n[a]}),t}console.log(`How to use "gitalk" in ${Il.name}@v${Il.version}:`,Il.homepage);const jl={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new Bl(Dl({clientID:"fbd03da0e3c540784529",clientSecret:"cfe0bfcf694efad463444b1de0216019cac7c299",repo:"blogwriter",owner:"su-dd",admin:["su-dd"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Pl({...Dl({clientID:"fbd03da0e3c540784529",clientSecret:"cfe0bfcf694efad463444b1de0216019cac7c299",repo:"blogwriter",owner:"su-dd",admin:["su-dd"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Ol="vuepress-plugin-comment";let Fl=null;function Ml(n){return jl.gitalk.clear(Ol)}function $l(n){return!1!==n.comment&&!1!==n.comments}function Ll(n){clearTimeout(Fl);if(document.querySelector("main.page"))return jl.gitalk.render(n,Ol);Fl=setTimeout(()=>Ll(n),200)}var Rl={mounted(){Fl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Ml()&&$l(n)&&Ll(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Ml()&&$l(t)&&Ll(t)})}},Ul=Object(vl.a)(Rl,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Gl=[({Vue:n,options:e,router:t,siteData:a,isServer:r})=>{let i=!1;n.component(kl.default.name,kl.default),n.mixin({mounted(){i||(window.addEventListener("unload",this.saveLastReading),i=!0)},methods:{saveLastReading(){localStorage.setItem("lastReading",JSON.stringify({path:this.$route.path,scrollTop:document.documentElement.scrollTop,timestamp:(new Date).getTime()}))}}})},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Tl(n.getUTCMonth()+1)}-${Tl(n.getUTCDate())} ${Tl(n.getUTCHours())}:${Tl(n.getUTCMinutes())}:${Tl(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(Cl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?3d63e1b0aa607833cafb451888226547";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Ul)}],ql=["Comment","PageInfo","LastReadingPopup"];class Nl extends class{constructor(){this.store=new Vt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Vt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Nl.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Hl={install(n){const e=new Nl;n.$vuepress=e,n.prototype.$vuepress=e}};function Vl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Jl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ms("pageKey",e),Vt.component(e)||Vt.component(e,os(e)),Vt.component(e)?n(e):n("")}},Zl={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Xl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Wl=(t(256),t(257),Object(vl.a)(Xl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ql={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Vt.config.productionTip=!1,Vt.use(No),Vt.use(Hl),Vt.mixin(function(n,e,t=Vt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xl)),Vt.component("Content",Jl),Vt.component("ContentSlotsDistributor",Zl),Vt.component("OutboundLink",Wl),Vt.component("ClientOnly",Ql),Vt.component("Layout",ss("Layout")),Vt.component("NotFound",ss("NotFound")),Vt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"f6b731a"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xl.routerBase||xl.base,t=new No({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!Vt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Vl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Vl(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Vl(n,r)?a(r):Vl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Gl.filter(n=>"function"==typeof n).map(e=>e({Vue:Vt,options:a,router:t,siteData:xl,isServer:n})))}catch(n){console.error(n)}return{app:new Vt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},ql.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);